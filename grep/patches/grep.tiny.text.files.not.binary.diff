From 2f0255e9f4cc5cc8bd619d1f217902eb29b30bc2 Mon Sep 17 00:00:00 2001
From: Paul Eggert <eggert@cs.ucla.edu>
Date: Fri, 27 Jul 2012 19:14:14 +0000
Subject: grep: don't falsely report tiny text files as binary

* NEWS: Document this.
* src/main.c (file_is_binary): When we are already at apparent
EOF, skip the file-size check, as some servers use zero blocks
to store binary files.  Reported by Martin Carroll in
<http://lists.gnu.org/archive/html/bug-grep/2012-07/msg00016.html>.
---
diff --git a/NEWS b/NEWS
index c7922ff..753aedc 100644
--- a/NEWS
+++ b/NEWS
@@ -2,6 +2,11 @@ GNU grep NEWS                                    -*- outline -*-
 
 * Noteworthy changes in release ?.? (????-??-??) [?]
 
+** Bug fixes
+
+  'grep' no longer falsely reports tiny text files as being binary
+  on file systems that store tiny files' contents in metadata.
+
 
 * Noteworthy changes in release 2.13 (2012-07-04) [stable]
 
diff --git a/src/main.c b/src/main.c
index dda7c9b..96e4f37 100644
--- a/src/main.c
+++ b/src/main.c
@@ -476,11 +476,18 @@ file_is_binary (char const *buf, size_t bufsize, int fd, struct stat const *st)
          represent its data, then it must have at least one hole.  */
       if (HAVE_STRUCT_STAT_ST_BLOCKS)
         {
-          off_t nonzeros_needed = st->st_size - cur + bufsize;
-          off_t full_blocks = nonzeros_needed / ST_NBLOCKSIZE;
-          int partial_block = 0 < nonzeros_needed % ST_NBLOCKSIZE;
-          if (ST_NBLOCKS (*st) < full_blocks + partial_block)
-            return 1;
+          /* Some servers store tiny files using zero blocks, so skip
+             this check at apparent EOF, to avoid falsely reporting
+             that a tiny zero-block file is binary.  */
+          off_t not_yet_read = st->st_size - cur;
+          if (0 < not_yet_read)
+            {
+              off_t nonzeros_needed = not_yet_read + bufsize;
+              off_t full_blocks = nonzeros_needed / ST_NBLOCKSIZE;
+              int partial_block = 0 < nonzeros_needed % ST_NBLOCKSIZE;
+              if (ST_NBLOCKS (*st) < full_blocks + partial_block)
+                return 1;
+            }
         }
 
       /* Look for a hole after the current location.  */
--
cgit v0.9.0.2
