From 67a7b5a99317ca1f92fb6a88542647aa3ad92c4b Mon Sep 17 00:00:00 2001
From: yanghuolin <Huolin.Yang@delphi.com>
Date: Thu, 15 Nov 2012 08:31:47 +0000
Subject: alsasink: don't use 100% CPU

The root cause is that alsa-lib is not thread safe for the same handle.
There are two threads in the gstreamer accessing alsa-lib not serilized.
The race condition happens when one thread holds the old framebuffer app_ptr
position in the kernel, another thread advances the framebuffer app_ptr.
when the former thread is scheduled to run again, it overwrites the app_ptr
to old value by copying from kernel.Thus,the app_ptr in the upper
alsa-lib(pcm_rate) become one period size more advanced than the lower
alsa-lib(pcm_hw & kernel).

gstreamer uses noblock and poll method to communicate with the alsa-lib.
The app_ptr unsync situation as described above makes the poll return immediately because
it concludes there is enough space for the ring-buffer via the low-level alsa-lib.
The write function returns immediately because it concludes there is not enough
space for the ring-buffer from the upper-level alsa-lib. Then the loop of poll
and write runs again and again until another period size is available for
ring-buffer.This leads to the cpu 100 problem.

delay_lock  is used to avoid the race condition.

Fixes: https://bugzilla.gnome.org/show_bug.cgi?id=690937
---
diff --git a/ext/alsa/gstalsasink.c b/ext/alsa/gstalsasink.c
index 1ef6b91..81731b6 100644
--- a/ext/alsa/gstalsasink.c
+++ b/ext/alsa/gstalsasink.c
@@ -118,6 +118,7 @@ gst_alsasink_finalise (GObject * object)
 
   g_free (sink->device);
   g_mutex_clear (&sink->alsa_lock);
+  g_mutex_clear (&sink->delay_lock);
 
   g_mutex_lock (&output_mutex);
   --output_ref;
@@ -255,6 +256,7 @@ gst_alsasink_init (GstAlsaSink * alsasink)
   alsasink->handle = NULL;
   alsasink->cached_caps = NULL;
   g_mutex_init (&alsasink->alsa_lock);
+  g_mutex_init (&alsasink->delay_lock);
 
   g_mutex_lock (&output_mutex);
   if (output_ref == 0) {
@@ -1011,7 +1013,9 @@ gst_alsasink_write (GstAudioSink * asink, gpointer data, guint length)
     if (err < 0) {
       GST_DEBUG_OBJECT (asink, "wait error, %d", err);
     } else {
+      GST_DELAY_SINK_LOCK (asink);
       err = snd_pcm_writei (alsa->handle, ptr, cptr);
+      GST_DELAY_SINK_UNLOCK (asink);
     }
 
     GST_DEBUG_OBJECT (asink, "written %d frames out of %d", err, cptr);
@@ -1057,7 +1061,9 @@ gst_alsasink_delay (GstAudioSink * asink)
 
   alsa = GST_ALSA_SINK (asink);
 
+  GST_DELAY_SINK_LOCK (asink);
   res = snd_pcm_delay (alsa->handle, &delay);
+  GST_DELAY_SINK_UNLOCK (asink);
   if (G_UNLIKELY (res < 0)) {
     /* on errors, report 0 delay */
     GST_DEBUG_OBJECT (alsa, "snd_pcm_delay returned %d", res);
diff --git a/ext/alsa/gstalsasink.h b/ext/alsa/gstalsasink.h
index 3a64a92..8c4c1b0 100644
--- a/ext/alsa/gstalsasink.h
+++ b/ext/alsa/gstalsasink.h
@@ -43,6 +43,10 @@ typedef struct _GstAlsaSinkClass GstAlsaSinkClass;
 #define GST_ALSA_SINK_LOCK(obj)	    (g_mutex_lock (GST_ALSA_SINK_GET_LOCK (obj)))
 #define GST_ALSA_SINK_UNLOCK(obj)   (g_mutex_unlock (GST_ALSA_SINK_GET_LOCK (obj)))
 
+#define GST_DELAY_SINK_GET_LOCK(obj)	(&GST_ALSA_SINK_CAST (obj)->delay_lock)
+#define GST_DELAY_SINK_LOCK(obj)	        (g_mutex_lock (GST_DELAY_SINK_GET_LOCK (obj)))
+#define GST_DELAY_SINK_UNLOCK(obj)	(g_mutex_unlock (GST_DELAY_SINK_GET_LOCK (obj)))
+
 /**
  * GstAlsaSink:
  *
@@ -73,6 +77,7 @@ struct _GstAlsaSink {
   GstCaps *cached_caps;
 
   GMutex alsa_lock;
+  GMutex delay_lock;
 };
 
 struct _GstAlsaSinkClass {
--
cgit v0.9.0.2-2-gbebe
