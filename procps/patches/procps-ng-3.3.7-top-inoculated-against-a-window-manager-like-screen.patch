From 9f6bd9a47a41942bbcecbb2648d6c4ffa456c744 Mon Sep 17 00:00:00 2001
From: Jim Warner <james.warner@comcast.net>
Date: Sat, 18 May 2013 00:00:00 -0500
Subject: [PATCH] top: inoculated against a window manager like 'screen'

If top were invoked under the 'screen' window manager,
writing the terminfo string 'exit_ca_mode' at top exit
would not restore the display to the state existing at
the time top was started. That's what occurs normally.
The net result of that failure was a corrupted screen.

However, there is a 'screen' configuration option that
will produce proper 'rmcup' behavior, but it is off by
default. That screencr option is known as 'altscreen'.
I stumbled across this provision by cloning the screen
git repository then searching for references to 'cup'.

If 'altscreen on' had been in either the /etc/screenrc
or the $HOME/.screenrc configuration file, my poor old
top would never have been accused of such corruptions.
Of course, the Programming Gods decree that any simple
solution for our problem must always be revealed last.

So before discovering that rc option, another approach
was taken involving top only. With just a little extra
refactoring of top display logic he was made immune to
any such quirk in the implementation of 'smcup/rmcup'.

I always feel good about any enhancement that actually
reduces the total number of lines of code. Even though
this change involved mostly rearranging some logic, it
yielded one less line (can't judge by diffstat because
of braces & notes). Anyway, rather than requiring some
change to a screenrc file, now we are self-sufficient.

Reference(s):
  procps ---------------------------------------------
https://bugzilla.redhat.com/show_bug.cgi?id=962022
http://www.freelists.org/post/procps/top-procpsng337-no-screen-cleaning-at-exit,3
. top : disable tty scrollback buffer to improve SIGWINCH
commit dedaf6e1a81738ff08ee8e8523871e12f555ad6d
  screen ---------------------------------------------
git://git.sv.gnu.org/screen.git
. Improve cursor store/restore on smcup/rmcup.
commit f95352946080be803b794c9f2733d8c809c1a39a
. Fix using alternate screen buffers in some cases.
commit ad56f746c6243d45124485d198d577bdbb78071c
http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=558724

Signed-off-by: Jim Warner <james.warner@comcast.net>
---
 NEWS      |  2 ++
 top/top.c | 18 ++++++++----------
 2 files changed, 10 insertions(+), 10 deletions(-)

diff --git a/top/top.c b/top/top.c
index 4caf658..2b05a60 100644
--- a/top/top.c
+++ b/top/top.c
@@ -350,16 +350,14 @@ static void at_eoj (void) {
    if (Ttychanged) {
       tcsetattr(STDIN_FILENO, TCSAFLUSH, &Tty_original);
       if (keypad_local) putp(keypad_local);
-      if (exit_ca_mode)
+      putp("\n");
+      if (exit_ca_mode) {
          // this next will also replace top's most recent screen with the
          // original display contents that were visible at our invocation
          putp(exit_ca_mode);
-      else {
-         // but if we can't, we'll simply do it as old top always used to
-         putp(tg2(0, Screen_rows));
-         putp("\n");
       }
       putp(Cap_curs_norm);
+      putp(Cap_clr_eol);
 #ifndef RMAN_IGNORED
       putp(Cap_smam);
 #endif
@@ -756,7 +754,6 @@ static int show_pmt (const char *str) {
          * Show a special coordinate message, in support of scrolling */
 static inline void show_scroll (void) {
    PUTT(Scroll_fmts, tg2(0, Msg_row), Frame_maxtask);
-   putp(tg2(0, Msg_row));
 } // end: show_scroll


@@ -5445,7 +5442,7 @@ static void frame_hlp (int wix, int max) {
          * (*subordinate* functions invoked know WHEN the user's had)
          * (ENOUGH already.  And at Frame End, it SHOULD be apparent)
          * (WE am d'MAN -- clearing UNUSED screen LINES and ensuring)
-         * (the CURSOR is STUCK in just the RIGHT place, know what I)
+         * (that those auto-sized columns are addressed, know what I)
          * (mean?  Huh, "doesn't DO MUCH"!  Never, EVER think or say)
          * (THAT about THIS function again, Ok?  Good that's better.)
          *
@@ -5474,7 +5471,10 @@ static void frame_make (void) {
    Tree_idx = Pseudo_row = Msg_row = scrlins = 0;
    summary_show();
    Max_lines = (Screen_rows - Msg_row) - 1;
-   OFFw(Curwin, INFINDS_xxx);
+   OFFw(w, INFINDS_xxx);
+
+   if (VIZISw(w) && CHKw(w, View_SCROLL)) show_scroll();
+   else PUTT("%s%s", tg2(0, Msg_row), Cap_clr_eol);

    if (!Rc.mode_altscr) {
       // only 1 window to show so, piece o' cake
@@ -5498,8 +5498,6 @@ static void frame_make (void) {
       putp(Cap_nl_clreos);
       PSU_CLREOS(Pseudo_row);
    }
-   if (VIZISw(w) && CHKw(w, View_SCROLL)) show_scroll();
-   else PUTT("%s%s", tg2(0, Msg_row), Cap_clr_eol);
    fflush(stdout);

    /* we'll deem any terminal not supporting tgoto as dumb and disable
--
1.8.1.2

