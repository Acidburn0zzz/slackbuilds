diff --git a/COPYING b/COPYING
--- a/COPYING
+++ b/COPYING
@@ -1,4 +1,4 @@
-The ZBar Bar Code Reader is Copyright (C) 2007-2009 Jeff Brown
+The ZBar Bar Code Reader is Copyright (C) 2007-2010 Jeff Brown
  <spadix@users.sourceforge.net>
 The QR Code reader is Copyright (C) 1999-2009 Timothy B. Terriberry
  <tterribe@xiph.org>
diff --git a/Makefile.am b/Makefile.am
--- a/Makefile.am
+++ b/Makefile.am
@@ -1,6 +1,3 @@
-AM_CPPFLAGS = -I$(srcdir)/include
-AM_CFLAGS = -Wall -Wno-parentheses
-AM_CXXFLAGS = $(AM_CFLAGS)
 ACLOCAL_AMFLAGS = -I config
 bin_PROGRAMS =
 check_PROGRAMS =
@@ -9,8 +6,10 @@ lib_LTLIBRARIES =
 pyexec_LTLIBRARIES =
 CLEANFILES =
 DISTCLEANFILES =
+MAINTAINERCLEANFILES =
 BUILT_SOURCES =
 EXTRA_DIST =
+SUBDIRS = .
 
 pkgconfigdir = $(libdir)/pkgconfig
 pkgconfig_DATA = zbar.pc
@@ -39,6 +38,9 @@ if HAVE_QT
 include $(srcdir)/qt/Makefile.am.inc
 pkgconfig_DATA += zbar-qt.pc
 endif
+if HAVE_JAVA
+SUBDIRS += java
+endif
 if HAVE_NPAPI
 include $(srcdir)/plugin/Makefile.am.inc
 endif
@@ -47,11 +49,8 @@ include $(srcdir)/doc/Makefile.am.inc
 
 EXTRA_DIST += zbar.ico zbar.nsi
 
-EXTRA_DIST += examples/upcrpc.pl examples/upcrpc.py examples/paginate.pl \
-    examples/barcode.png examples/processor.pl examples/processor.py \
-    examples/read_one.py examples/read_one.pl \
-    examples/scan_image.c examples/scan_image.cpp examples/scan_image.pl \
-    examples/scan_image.py examples/scan_image.vcproj
+EXTRA_DIST += examples/barcode.png examples/upcrpc.py examples/upcrpc.pl \
+    examples/scan_image.c examples/scan_image.cpp examples/scan_image.vcproj
 
 EXTRA_DIST += perl/MANIFEST perl/README perl/Changes perl/COPYING.LIB \
     perl/Makefile.PL perl/typemap perl/ZBar.xs perl/ppport.h \
diff --git a/configure.ac b/configure.ac
--- a/configure.ac
+++ b/configure.ac
@@ -46,6 +46,13 @@ AC_DEFINE_UNQUOTED([LIB_VERSION_REVISION
   [[`echo "$LIB_VERSION" | sed -e 's/^[^:]*:\([^:]*\):.*$/\1/'`]],
   [Library revision])
 
+AM_CPPFLAGS="-I$srcdir/include"
+AM_CFLAGS="-Wall -Wno-parentheses"
+AM_CXXFLAGS="$AM_CFLAGS"
+AC_SUBST([AM_CPPFLAGS])
+AC_SUBST([AM_CFLAGS])
+AC_SUBST([AM_CXXFLAGS])
+
 dnl windows build
 
 AC_CANONICAL_HOST
@@ -73,13 +80,36 @@ documentation generation])
 AC_ARG_VAR([XMLTOFLAGS], [additional arguments for xmlto])
 AC_CHECK_PROGS([XMLTO], [xmlto], [:])
 
+have_java="maybe"
+AC_ARG_VAR([JAVA_HOME], [root location of JDK])
+AS_IF([test "x$JAVA_HOME" = "x"],
+  [JAVA_PATH="$PATH"],
+  [JAVA_PATH="$JAVA_HOME/bin$PATH_SEPARATOR$PATH"])
+
+AC_ARG_VAR([JAVAC], [location of Java language compiler])
+AC_PATH_PROGS([JAVAC], [javac jikes ecj gcj], [:], [$JAVA_PATH])
+AS_IF([test "x$JAVAC" = "x:"], [have_java="no"])
+
+AC_ARG_VAR([JAVAH], [location of Java header generator])
+AC_PATH_PROGS([JAVAH], [javah], [/bin/false], [$JAVA_PATH])
+
+AC_ARG_VAR([JAR], [location of Java archive tool])
+AC_PATH_PROGS([JAR], [jar], [:], [$JAVA_PATH])
+AS_IF([test "x$JAR" = "x:"], [have_java="no"])
+
+AC_ARG_VAR([JAVA], [location of Java application launcher])
+AC_PATH_PROGS([JAVA], [java], [/bin/false], [$JAVA_PATH])
+
+AC_ARG_VAR([CLASSPATH], [Java class path (include JUnit to run java tests)])
+AS_IF([test "x$CLASSPATH" = "x"], [CLASSPATH="."])
+
 dnl symbologies
 
 AC_ARG_ENABLE([codes],
   [AS_HELP_STRING([--enable-codes=SYMS],
-    [select symbologies to compile [default=ean,i25,code39,code128,qrcode]])],
+    [select symbologies to compile [default=ean,databar,code128,code93,code39,i25,qrcode]])],
   [],
-  [enable_codes="ean,code39,code128,i25,qrcode"]) dnl pdf417
+  [enable_codes="ean,databar,code128,code93,code39,i25,qrcode"])
 
 AC_DEFUN([ZBAR_CHK_CODE], [
   AC_MSG_CHECKING([whether to build $2])
@@ -97,11 +127,13 @@ AC_DEFUN([ZBAR_CHK_CODE], [
 ])dnl
 
 ZBAR_CHK_CODE([ean], [EAN symbologies])
+ZBAR_CHK_CODE([databar], [DataBar symbology])
 ZBAR_CHK_CODE([code128], [Code 128 symbology])
+ZBAR_CHK_CODE([code93], [Code 93 symbology])
 ZBAR_CHK_CODE([code39], [Code 39 symbology])
-ZBAR_CHK_CODE([pdf417], [PDF417 symbology])
 ZBAR_CHK_CODE([i25], [Interleaved 2 of 5 symbology])
 ZBAR_CHK_CODE([qrcode], [QR Code])
+ZBAR_CHK_CODE([pdf417], [PDF417 symbology])
 
 dnl libraries
 
@@ -255,7 +287,7 @@ AM_CONDITIONAL([HAVE_JPEG], [test "x$wit
 dnl ImageMagick
 AC_ARG_WITH([imagemagick],
   [AS_HELP_STRING([--without-imagemagick],
-    [disable support for scanning images using ImageMagick])],
+    [disable support for scanning images with ImageMagick])],
   [],
   [with_imagemagick="yes"])
 
@@ -296,7 +328,7 @@ AM_CONDITIONAL([HAVE_MAGICK], [test "x$w
 dnl Mozilla NPAPI
 AC_ARG_WITH([npapi],
   [AS_HELP_STRING([--with-npapi],
-    [enable support for Firefox/Mozilla/OpenOffice NPAPI plugin])],
+    [enable support for Firefox/Mozilla/OpenOffice plugin])],
   [],
   [with_npapi="no"])
 
@@ -383,13 +415,38 @@ AS_IF([test "x$with_qt" != "xno"],
 
 AM_CONDITIONAL([HAVE_QT], [test "x$with_qt" = "xyes"])
 
+dnl Java
+AC_ARG_WITH([java],
+  [AS_HELP_STRING([--without-java],
+    [disable support for Java interface])],
+  [],
+  [with_java="check"])
+
+AC_ARG_VAR([JAVA_CFLAGS], [compiler flags for building JNI extensions])
+AS_IF([test "x$JAVA_CFLAGS" = "x" && test "x$JAVA_HOME" != "x"],
+  [JAVA_CFLAGS="-I$JAVA_HOME/include"])
+
+AS_IF([test "x$with_java" != "xno"],
+  [CPPFLAGS_save="$CPPFLAGS"
+   CPPFLAGS="$CPPFLAGS $JAVA_CFLAGS"
+   AC_CHECK_HEADER([jni.h], [], [have_java="no"])
+   CPPFLAGS="$CPPFLAGS_save"
+   AS_IF([test "x$have_java" != "xno"],
+     [with_java="yes"],
+     [test "x$with_java" = "xyes"],
+     [AC_MSG_FAILURE([unable to find Java JNI! ensure CFLAGS are set
+appropriately or configure --without-java])],
+     [with_java="no"])
+])
+AM_CONDITIONAL([HAVE_JAVA], [test "x$with_java" = "xyes"])
+
 
 dnl header files
 
 dnl FIXME switches for shm, mmap
 AC_HEADER_ASSERT
-AC_CHECK_HEADERS([fcntl.h features.h inttypes.h stdlib.h string.h unistd.h \
-  sys/ioctl.h sys/time.h sys/times.h sys/ipc.h sys/shm.h sys/mman.h])
+AC_CHECK_HEADERS([errno.h fcntl.h features.h inttypes.h stdlib.h string.h \
+  unistd.h sys/ioctl.h sys/time.h sys/times.h sys/ipc.h sys/shm.h sys/mman.h])
 
 dnl types
 
@@ -428,6 +485,7 @@ AC_CONFIG_COMMANDS([doc/reldate.xml],
 
 AC_CONFIG_FILES([
 Makefile
+java/Makefile
 zbar.pc
 zbar-gtk.pc
 zbar-qt.pc
@@ -460,6 +518,9 @@ AS_IF([test "x$with_gtk" != "xyes"],
 echo "Qt4               --with-qt=$with_qt"
 AS_IF([test "x$with_qt" != "xyes"],
   [echo "        => the Qt4 widget will *NOT* be built"])
+echo "Java              --with-java=$with_java"
+AS_IF([test "x$with_java" != "xyes"],
+  [echo "        => the Java interface will *NOT* be built"])
 #echo "NPAPI Plugin     --with-npapi=$with_npapi"
 #AS_IF([test "x$with_mozilla" != "xyes"],
 #  [echo "       => the Mozilla/Firefox/OpenOffice plugin will *NOT* be built"])
diff --git a/doc/Makefile.am.inc b/doc/Makefile.am.inc
--- a/doc/Makefile.am.inc
+++ b/doc/Makefile.am.inc
@@ -2,6 +2,7 @@
 DOCSOURCES = doc/manual.xml doc/version.xml doc/reldate.xml \
     doc/ref/zbarimg.xml doc/ref/zbarcam.xml doc/ref/commonoptions.xml
 
+MAINTAINERCLEANFILES += doc/man/man.stamp doc/version.xml doc/reldate.xml
 
 # man page targets to distribute and install
 dist_man_MANS =
diff --git a/doc/api/footer.html b/doc/api/footer.html
--- a/doc/api/footer.html
+++ b/doc/api/footer.html
@@ -9,9 +9,12 @@
 
 <address><a href="mailto:spadix@users.sourceforge.net">spadix@users.sourceforge.net</a></address>
 
-<p>Copyright 2008-2009 (c) Jeff Brown - All Rights Reserved.</p>
-<p>Verbatim copying and distribution of this entire article are
-  permitted worldwide, without royalty, in any medium, provided this
-  notice, and the copyright notice, are preserved.</p>
+<p>Copyright 2008-2010 (c) Jeff Brown</p>
+<p>This documentation is part of the ZBar Barcode Reader; you can
+redistribute it and/or modify it under the terms of the
+<a href="http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html">GNU
+Lesser General Public License</a> as published by the Free Software
+Foundation; either version 2.1 of the License, or (at your option) any
+later version.</p>
 
 </body></html>
diff --git a/doc/manual.xml b/doc/manual.xml
--- a/doc/manual.xml
+++ b/doc/manual.xml
@@ -29,10 +29,10 @@
       <year>2007</year>
       <year>2008</year>
       <year>2009</year>
+      <year>2010</year>
       <holder>Jeff Brown</holder>
     </copyright>
     <legalnotice><para>All Rights Reserved</para></legalnotice>
-    <!-- <legalnotice><para>insert GNU FDL header?</para></legalnotice> -->
   </bookinfo>
 
   <chapter id="intro">
@@ -47,7 +47,4 @@
     &refzbarimg;
 
   </reference>
-
-  <!-- insert GNU FDL? -->
-
 </book>
diff --git a/doc/ref/commonoptions.xml b/doc/ref/commonoptions.xml
--- a/doc/ref/commonoptions.xml
+++ b/doc/ref/commonoptions.xml
@@ -47,8 +47,9 @@
       <option>ean13</option>, <option>ean8</option>,
       <option>upca</option>, <option>upce</option>,
       <option>isbn13</option>, <option>isbn10</option>,
-      <option>i25</option>, <option>code39</option>,
-      <option>code128</option> or the special value <option>*</option>.
+      <option>i25</option>, <option>code39</option>, <option>code93</option>,
+      <option>code128</option>, <option>qrcode</option>
+      or the special value <option>*</option>.
       If <replaceable class="parameter">symbology</replaceable> is
       omitted or <option>*</option>, the <replaceable
       class="parameter">config</replaceable> will be set for all
diff --git a/doc/ref/zbarcam.xml b/doc/ref/zbarcam.xml
--- a/doc/ref/zbarcam.xml
+++ b/doc/ref/zbarcam.xml
@@ -60,9 +60,10 @@
     <filename>/dev/video0</filename></para>
 
     <para>The underlying library currently supports EAN-13 (including
-    UPC and ISBN subsets), EAN-8, Code 128, Code 39, and Interleaved
-    2 of 5 symbologies.  The specific type of each detected symbol is
-    printed with the decoded data.</para>
+    UPC and ISBN subsets), EAN-8, DataBar, DataBar Expanded, Code 128,
+    Code 93, Code 39, Interleaved 2 of 5 and QR Code symbologies.  The
+    specific type of each detected symbol is printed with the decoded
+    data.</para>
 
   </refsection>
 
@@ -160,6 +161,37 @@
   </refsection>
 
   <refsection>
+    <title>Exit Status</title>
+
+    <para><command>zbarcam</command> returns an exit code to indicate the
+    status of the program execution. Current exit codes are:</para>
+
+    <variablelist>
+      <varlistentry>
+        <term>0</term>
+        <listitem>
+          <para>Successful program completion.</para>
+        </listitem>
+      </varlistentry>
+
+      <varlistentry>
+        <term>1</term>
+        <listitem>
+          <para>An error occurred.  This includes bad arguments and I/O
+          errors.</para>
+        </listitem>
+      </varlistentry>
+
+      <varlistentry>
+        <term>2</term>
+        <listitem>
+          <para>A fatal error occurred.</para>
+        </listitem>
+      </varlistentry>
+    </variablelist>
+  </refsection>
+
+  <refsection>
     <title>See Also</title>
     <para><xref linkend="zbarimg"/></para>
     <para><link xlink:href="http://zbar.sf.net/"/></para>
diff --git a/doc/ref/zbarimg.xml b/doc/ref/zbarimg.xml
--- a/doc/ref/zbarimg.xml
+++ b/doc/ref/zbarimg.xml
@@ -59,9 +59,10 @@
     displayed to the screen.</para>
 
     <para>The underlying library currently supports EAN-13 (including
-    UPC and ISBN subsets), EAN-8, Code 128, Code 39, and Interleaved
-    2 of 5 symbologies.  The specific type of each detected symbol is
-    printed with the decoded data.</para>
+    UPC and ISBN subsets), EAN-8, DataBar, DataBar Expanded, Code 128,
+    Code 93, Code 39, Interleaved 2 of 5 and QR Code symbologies.  The
+    specific type of each detected symbol is printed with the decoded
+    data.</para>
 
     <para>Note that "<filename><replaceable>image</replaceable></filename>"
 
@@ -166,6 +167,56 @@
   </refsection>
 
   <refsection>
+    <title>Exit Status</title>
+
+    <para><command>zbarimg</command> returns an exit code to indicate the
+    status of the program execution. Current exit codes are:</para>
+
+    <variablelist>
+      <varlistentry>
+        <term>0</term>
+        <listitem>
+          <para>Barcodes successfully detected in all images. Warnings may
+          have been generated, but no errors.</para>
+        </listitem>
+      </varlistentry>
+
+      <varlistentry>
+        <term>1</term>
+        <listitem>
+          <para>An error occurred while processing some image(s).  This
+          includes bad arguments, I/O errors and image handling errors from
+          ImageMagick.</para>
+        </listitem>
+      </varlistentry>
+
+      <varlistentry>
+        <term>2</term>
+        <listitem>
+          <para>ImageMagick fatal error.</para>
+        </listitem>
+      </varlistentry>
+
+      <varlistentry>
+        <term>3</term>
+        <listitem>
+          <para>The user quit the program before all images were scanned.
+          Only applies when running in interactive mode
+          (with <option>--display</option>)</para>
+        </listitem>
+      </varlistentry>
+
+      <varlistentry>
+        <term>4</term>
+        <listitem>
+          <para>No barcode was detected in one or more of the images.  No
+          other errors occurred.</para>
+        </listitem>
+      </varlistentry>
+    </variablelist>
+  </refsection>
+
+  <refsection>
     <title>See Also</title>
     <para><xref linkend="zbarcam"/></para>
     <para><link xlink:href="http://zbar.sf.net/"/></para>
diff --git a/examples/paginate.pl b/examples/paginate.pl
deleted file mode 100755
--- a/examples/paginate.pl
+++ /dev/null
@@ -1,71 +0,0 @@
-#!/usr/bin/perl
-#------------------------------------------------------------------------
-#  Copyright 2009 (c) Jeff Brown <spadix@users.sourceforge.net>
-#
-#  This file is part of the ZBar Bar Code Reader.
-#
-#  The ZBar Bar Code Reader is free software; you can redistribute it
-#  and/or modify it under the terms of the GNU Lesser Public License as
-#  published by the Free Software Foundation; either version 2.1 of
-#  the License, or (at your option) any later version.
-#
-#  The ZBar Bar Code Reader is distributed in the hope that it will be
-#  useful, but WITHOUT ANY WARRANTY; without even the implied warranty
-#  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-#  GNU Lesser Public License for more details.
-#
-#  You should have received a copy of the GNU Lesser Public License
-#  along with the ZBar Bar Code Reader; if not, write to the Free
-#  Software Foundation, Inc., 51 Franklin St, Fifth Floor,
-#  Boston, MA  02110-1301  USA
-#
-#  http://sourceforge.net/projects/zbar
-#------------------------------------------------------------------------
-use warnings;
-use strict;
-
-use Barcode::ZBar;
-use Image::Magick;
-
-warn("no input files specified?\n") if(!@ARGV);
-
-# running output document
-my $out = undef;
-
-# barcode scanner
-my $scanner = Barcode::ZBar::ImageScanner->new();
-
-foreach my $file (@ARGV) {
-    print "scanning from \"$file\"\n";
-    my $imseq = Image::Magick->new();
-    my $err = $imseq->Read($file);
-    warn($err) if($err);
-
-    foreach my $page (@$imseq) {
-        # convert ImageMagick page to ZBar image
-        my $zimg = Barcode::ZBar::Image->new();
-        $zimg->set_format('Y800');
-        $zimg->set_size($page->Get(qw(columns rows)));
-        $zimg->set_data($page->Clone()->ImageToBlob(magick => 'GRAY', depth => 8));
-
-        # scan for barcodes
-        if($scanner->scan_image($zimg)) {
-            # write out previous document
-            $out->write() if($out);
-
-            # use first symbol found to name next image (FIXME sanitize)
-            my $data = ($zimg->get_symbols())[0]->get_data();
-            my $idx = $page->Get('scene') + 1;
-            print "splitting $data from page $idx\n";
-
-            # create new output document
-            $out = Image::Magick->new(filename => $data);
-        }
-
-        # append this page to current output
-        push(@$out, $page) if($out);
-    }
-
-    # write out final document
-    $out->write() if($out);
-}
diff --git a/examples/processor.c b/examples/processor.c
new file mode 100644
--- /dev/null
+++ b/examples/processor.c
@@ -0,0 +1,47 @@
+#include <stdio.h>
+#include <zbar.h>
+
+static void my_handler (zbar_image_t *image,
+                        const void *userdata)
+{
+    /* extract results */
+    const zbar_symbol_t *symbol = zbar_image_first_symbol(image);
+    for(; symbol; symbol = zbar_symbol_next(symbol)) {
+        /* do something useful with results */
+        zbar_symbol_type_t typ = zbar_symbol_get_type(symbol);
+        const char *data = zbar_symbol_get_data(symbol);
+        printf("decoded %s symbol \"%s\"\n",
+               zbar_get_symbol_name(typ), data);
+    }
+}
+
+int main (int argc, char **argv)
+{
+    const char *device = "/dev/video0";
+
+    /* create a Processor */
+    zbar_processor_t *proc = zbar_processor_create(1);
+
+    /* configure the Processor */
+    zbar_processor_set_config(proc, 0, ZBAR_CFG_ENABLE, 1);
+
+    /* initialize the Processor */
+    if(argc > 1)
+        device = argv[1];
+    zbar_processor_init(proc, device, 1);
+
+    /* setup a callback */
+    zbar_processor_set_data_handler(proc, my_handler, NULL);
+
+    /* enable the preview window */
+    zbar_processor_set_visible(proc, 1);
+    zbar_processor_set_active(proc, 1);
+
+    /* keep scanning until user provides key/mouse input */
+    zbar_processor_user_wait(proc, -1);
+
+    /* clean up */
+    zbar_processor_destroy(proc);
+
+    return(0);
+}
diff --git a/examples/processor.cpp b/examples/processor.cpp
new file mode 100644
--- /dev/null
+++ b/examples/processor.cpp
@@ -0,0 +1,45 @@
+#include <iostream>
+#include <zbar.h>
+
+using namespace std;
+using namespace zbar;
+
+class MyHandler : public Image::Handler
+{
+    void image_callback (Image &image)
+    {
+        for(SymbolIterator symbol = image.symbol_begin();
+            symbol != image.symbol_end();
+            ++symbol)
+            cout << "decoded " << symbol->get_type_name() << " symbol "
+                 << "\"" << symbol->get_data() << "\"" << endl;
+    }
+};
+
+int main (int argc, char **argv)
+{
+    // create and initialize a Processor
+    const char *device = "/dev/video0";
+    if(argc > 1)
+        device = argv[1];
+    Processor proc(true, device);
+
+    // configure the Processor
+    proc.set_config(ZBAR_NONE, ZBAR_CFG_ENABLE, 1);
+
+    // setup a callback
+    MyHandler my_handler;
+    proc.set_handler(my_handler);
+
+    // enable the preview window
+    proc.set_visible();
+    proc.set_active();
+
+    try {
+        // keep scanning until user provides key/mouse input
+        proc.user_wait();
+    }
+    catch(ClosedError &e) {
+    }
+    return(0);
+}
diff --git a/examples/processor.pl b/examples/processor.pl
deleted file mode 100755
--- a/examples/processor.pl
+++ /dev/null
@@ -1,35 +0,0 @@
-#!/usr/bin/env perl
-use warnings;
-use strict;
-require Barcode::ZBar;
-
-# create a Processor
-my $proc = Barcode::ZBar::Processor->new();
-
-# configure the Processor
-$proc->parse_config("enable");
-
-# initialize the Processor
-$proc->init($ARGV[0] || '/dev/video0');
-
-# setup a callback
-sub my_handler {
-    my ($proc, $image, $closure) = @_;
-
-    # extract results
-    foreach my $symbol ($proc->get_results()) {
-        # do something useful with results
-        print('decoded ' . $symbol->get_type() .
-              ' symbol "' . $symbol->get_data() . "\"\n");
-    }
-}
-$proc->set_data_handler(\&my_handler);
-
-# enable the preview window
-$proc->set_visible();
-
-# initiate scanning
-$proc->set_active();
-
-# keep scanning until user provides key/mouse input
-$proc->user_wait();
diff --git a/examples/read_one.pl b/examples/read_one.pl
deleted file mode 100755
--- a/examples/read_one.pl
+++ /dev/null
@@ -1,29 +0,0 @@
-#!/usr/bin/env perl
-use warnings;
-use strict;
-require Barcode::ZBar;
-
-# create a Processor
-my $proc = Barcode::ZBar::Processor->new();
-
-# configure the Processor
-$proc->parse_config("enable");
-
-# initialize the Processor
-$proc->init($ARGV[0] || '/dev/video0');
-
-# enable the preview window
-$proc->set_visible();
-
-# read at least one barcode (or until window closed)
-$proc->process_one();
-
-# hide the preview window
-$proc->set_visible(0);
-
-# extract results
-foreach my $symbol ($proc->get_results()) {
-  # do something useful with results
-  print('decoded ' . $symbol->get_type() .
-        ' symbol "' . $symbol->get_data() . "\"\n");
-}
diff --git a/examples/scan_image.c b/examples/scan_image.c
--- a/examples/scan_image.c
+++ b/examples/scan_image.c
@@ -65,7 +65,7 @@ int main (int argc, char **argv)
 
     /* wrap image data */
     zbar_image_t *image = zbar_image_create();
-    zbar_image_set_format(image, *(int*)"Y800");
+    zbar_image_set_format(image, zbar_fourcc('Y','8','0','0'));
     zbar_image_set_size(image, width, height);
     zbar_image_set_data(image, raw, width * height, zbar_image_free_data);
 
diff --git a/examples/scan_image.pl b/examples/scan_image.pl
deleted file mode 100755
--- a/examples/scan_image.pl
+++ /dev/null
@@ -1,37 +0,0 @@
-#!/usr/bin/perl
-use warnings;
-use strict;
-require Image::Magick;
-require Barcode::ZBar;
-
-$ARGV[0] || die;
-
-# create a reader
-my $scanner = Barcode::ZBar::ImageScanner->new();
-
-# configure the reader
-$scanner->parse_config("enable");
-
-# obtain image data
-my $magick = Image::Magick->new();
-$magick->Read($ARGV[0]) && die;
-my $raw = $magick->ImageToBlob(magick => 'GRAY', depth => 8);
-
-# wrap image data
-my $image = Barcode::ZBar::Image->new();
-$image->set_format('Y800');
-$image->set_size($magick->Get(qw(columns rows)));
-$image->set_data($raw);
-
-# scan the image for barcodes
-my $n = $scanner->scan_image($image);
-
-# extract results
-foreach my $symbol ($image->get_symbols()) {
-    # do something useful with results
-    print('decoded ' . $symbol->get_type() .
-          ' symbol "' . $symbol->get_data() . "\"\n");
-}
-
-# clean up
-undef($image);
diff --git a/examples/upcrpc.pl b/examples/upcrpc.pl
--- a/examples/upcrpc.pl
+++ b/examples/upcrpc.pl
@@ -3,7 +3,7 @@ use warnings;
 use strict;
 use Frontier::Client;
 use Data::Dumper;
-my $s = Frontier::Client->new('url' => 'http://dev.upcdatabase.com/rpc');
+my $s = Frontier::Client->new('url' => 'http://www.upcdatabase.com/rpc');
 
 $| = 1; # autoflush
 
diff --git a/examples/upcrpc.py b/examples/upcrpc.py
--- a/examples/upcrpc.py
+++ b/examples/upcrpc.py
@@ -2,7 +2,7 @@
 from xmlrpclib import ServerProxy
 import sys, re
 
-server = ServerProxy("http://dev.upcdatabase.com/rpc")
+server = ServerProxy("http://www.upcdatabase.com/rpc")
 ean_re = re.compile(r'^(UPC-A:|EAN-13:)?(\d{11,13})$', re.M)
 
 def lookup(decode):
diff --git a/gtk/zbargtk.c b/gtk/zbargtk.c
--- a/gtk/zbargtk.c
+++ b/gtk/zbargtk.c
@@ -1,5 +1,5 @@
 /*------------------------------------------------------------------------
- *  Copyright 2008-2009 (c) Jeff Brown <spadix@users.sourceforge.net>
+ *  Copyright 2008-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
  *
  *  This file is part of the ZBar Bar Code Reader.
  *
@@ -35,11 +35,6 @@
 #define DEFAULT_WIDTH 640
 #define DEFAULT_HEIGHT 480
 
-/* adapted from v4l2 spec */
-#define fourcc(a, b, c, d)                      \
-    ((long)(a) | ((long)(b) << 8) |             \
-     ((long)(c) << 16) | ((long)(d) << 24))
-
 enum {
     DECODED,
     DECODED_TEXT,
@@ -88,15 +83,15 @@ gboolean zbar_gtk_image_from_pixbuf (zba
 
     /* these are all guesses... */
     if(nchannels == 3 && bps == 8)
-        type = fourcc('R','G','B','3');
+        type = zbar_fourcc('R','G','B','3');
     else if(nchannels == 4 && bps == 8)
-        type = fourcc('B','G','R','4'); /* FIXME alpha flipped?! */
+        type = zbar_fourcc('B','G','R','4'); /* FIXME alpha flipped?! */
     else if(nchannels == 1 && bps == 8)
-        type = fourcc('Y','8','0','0');
+        type = zbar_fourcc('Y','8','0','0');
     else if(nchannels == 3 && bps == 5)
-        type = fourcc('R','G','B','R');
+        type = zbar_fourcc('R','G','B','R');
     else if(nchannels == 3 && bps == 4)
-        type = fourcc('R','4','4','4'); /* FIXME maybe? */
+        type = zbar_fourcc('R','4','4','4'); /* FIXME maybe? */
     else {
         g_warning("unsupported combination: nchannels=%d bps=%d\n",
                   nchannels, bps);
@@ -142,10 +137,6 @@ static inline gboolean zbar_gtk_video_op
 
     gdk_threads_enter();
 
-    zbar->req_width = DEFAULT_WIDTH;
-    zbar->req_height = DEFAULT_HEIGHT;
-    gtk_widget_queue_resize(GTK_WIDGET(self));
-
     zbar->video_opened = FALSE;
     if(zbar->thread)
         g_object_notify(G_OBJECT(self), "video-opened");
@@ -184,6 +175,10 @@ static inline gboolean zbar_gtk_video_op
          */
         gdk_threads_enter();
 
+        if(zbar->video_width && zbar->video_height)
+            zbar_video_request_size(zbar->video,
+                                    zbar->video_width, zbar->video_height);
+
         video_opened = !zbar_negotiate_format(zbar->video, zbar->window);
 
         if(video_opened) {
@@ -209,7 +204,7 @@ static inline int zbar_gtk_process_image
     if(!image)
         return(-1);
 
-    zbar_image_t *tmp = zbar_image_convert(image, fourcc('Y','8','0','0'));
+    zbar_image_t *tmp = zbar_image_convert(image, zbar_fourcc('Y','8','0','0'));
     if(!tmp)
         return(-1);
 
@@ -560,6 +555,19 @@ gboolean zbar_gtk_get_video_opened (ZBar
     return(zbar->video_opened);
 }
 
+void zbar_gtk_request_video_size (ZBarGtk *self,
+                                  int width,
+                                  int height)
+{
+    if(!self->_private || width < 0 || height < 0)
+        return;
+    ZBarGtkPrivate *zbar = ZBAR_GTK_PRIVATE(self->_private);
+
+    zbar->req_width = zbar->video_width = width;
+    zbar->req_height = zbar->video_height = height;
+    gtk_widget_queue_resize(GTK_WIDGET(self));
+}
+
 static void zbar_gtk_set_property (GObject *object,
                                    guint prop_id,
                                    const GValue *value,
@@ -613,8 +621,8 @@ static void zbar_gtk_init (ZBarGtk *self
     zbar->window = zbar_window_create();
     g_assert(zbar->window);
 
-    zbar->req_width = DEFAULT_WIDTH;
-    zbar->req_height = DEFAULT_HEIGHT;
+    zbar->req_width = zbar->video_width = DEFAULT_WIDTH;
+    zbar->req_height = zbar->video_width = DEFAULT_HEIGHT;
 
     /* spawn a thread to handle decoding and video */
     zbar->queue = g_async_queue_new();
diff --git a/gtk/zbargtkprivate.h b/gtk/zbargtkprivate.h
--- a/gtk/zbargtkprivate.h
+++ b/gtk/zbargtkprivate.h
@@ -71,6 +71,7 @@ typedef struct _ZBarGtkPrivate
      * protected by main gui lock
      */
     unsigned req_width, req_height;
+    unsigned video_width, video_height;
     gboolean video_opened;
 
     /* window is shared: owned by main gui thread.
diff --git a/include/zbar.h b/include/zbar.h
--- a/include/zbar.h
+++ b/include/zbar.h
@@ -1,5 +1,5 @@
 /*------------------------------------------------------------------------
- *  Copyright 2007-2009 (c) Jeff Brown <spadix@users.sourceforge.net>
+ *  Copyright 2007-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
  *
  *  This file is part of the ZBar Bar Code Reader.
  *
@@ -93,9 +93,12 @@ typedef enum zbar_symbol_type_e {
     ZBAR_EAN13       =     13,  /**< EAN-13 */
     ZBAR_ISBN13      =     14,  /**< ISBN-13 (from EAN-13). @since 0.4 */
     ZBAR_I25         =     25,  /**< Interleaved 2 of 5. @since 0.4 */
+    ZBAR_DATABAR     =     34,  /**< GS1 DataBar (RSS). @since 0.11 */
+    ZBAR_DATABAR_EXP =     35,  /**< GS1 DataBar Expanded. @since 0.11 */
     ZBAR_CODE39      =     39,  /**< Code 39. @since 0.4 */
     ZBAR_PDF417      =     57,  /**< PDF417. @since 0.6 */
     ZBAR_QRCODE      =     64,  /**< QR Code. @since 0.10 */
+    ZBAR_CODE93      =     93,  /**< Code 93. @since 0.11 */
     ZBAR_CODE128     =    128,  /**< Code 128 */
     ZBAR_SYMBOL      = 0x00ff,  /**< mask for base symbol type */
     ZBAR_ADDON2      = 0x0200,  /**< 2-digit add-on flag */
@@ -103,6 +106,17 @@ typedef enum zbar_symbol_type_e {
     ZBAR_ADDON       = 0x0700,  /**< add-on flag mask */
 } zbar_symbol_type_t;
 
+/** decoded symbol coarse orientation.
+ * @since 0.11
+ */
+typedef enum zbar_orientation_e {
+    ZBAR_ORIENT_UNKNOWN = -1,   /**< unable to determine orientation */
+    ZBAR_ORIENT_UP,             /**< upright, read left to right */
+    ZBAR_ORIENT_RIGHT,          /**< sideways, read top to bottom */
+    ZBAR_ORIENT_DOWN,           /**< upside-down, read right to left */
+    ZBAR_ORIENT_LEFT,           /**< sideways, read bottom to top */
+} zbar_orientation_t;
+
 /** error codes. */
 typedef enum zbar_error_e {
     ZBAR_OK = 0,                /**< no error */
@@ -133,12 +147,33 @@ typedef enum zbar_config_e {
     ZBAR_CFG_MIN_LEN = 0x20,    /**< minimum data length for valid decode */
     ZBAR_CFG_MAX_LEN,           /**< maximum data length for valid decode */
 
+    ZBAR_CFG_UNCERTAINTY = 0x40,/**< required video consistency frames */
+
     ZBAR_CFG_POSITION = 0x80,   /**< enable scanner to collect position data */
 
     ZBAR_CFG_X_DENSITY = 0x100, /**< image scanner vertical scan density */
     ZBAR_CFG_Y_DENSITY,         /**< image scanner horizontal scan density */
 } zbar_config_t;
 
+/** decoder symbology modifier flags.
+ * @since 0.11
+ */
+typedef enum zbar_modifier_e {
+    /** barcode tagged as GS1 (EAN.UCC) reserved
+     * (eg, FNC1 before first data character).
+     * data may be parsed as a sequence of GS1 AIs
+     */
+    ZBAR_MOD_GS1 = 0,
+
+    /** barcode tagged as AIM reserved
+     * (eg, FNC1 after first character or digit pair)
+     */
+    ZBAR_MOD_AIM,
+
+    /** number of modifiers */
+    ZBAR_MOD_NUM,
+} zbar_modifier_t;
+
 /** retrieve runtime library version information.
  * @param major set to the running major version (unless NULL)
  * @param minor set to the running minor version (unless NULL)
@@ -171,6 +206,28 @@ extern const char *zbar_get_symbol_name(
  */
 extern const char *zbar_get_addon_name(zbar_symbol_type_t sym);
 
+/** retrieve string name for configuration setting.
+ * @param config setting to name
+ * @returns static string name for config,
+ * or the empty string if value is not a known config
+ */
+extern const char *zbar_get_config_name(zbar_config_t config);
+
+/** retrieve string name for modifier.
+ * @param modifier flag to name
+ * @returns static string name for modifier,
+ * or the empty string if the value is not a known flag
+ */
+extern const char *zbar_get_modifier_name(zbar_modifier_t modifier);
+
+/** retrieve string name for orientation.
+ * @param orientation orientation encoding
+ * @returns the static string name for the specified orientation,
+ * or "UNKNOWN" if the orientation is not recognized
+ * @since 0.11
+ */
+extern const char *zbar_get_orientation_name(zbar_orientation_t orientation);
+
 /** parse a configuration string of the form "[symbology.]config[=value]".
  * the config must match one of the recognized names.
  * the symbology, if present, must match one of the recognized names.
@@ -184,6 +241,30 @@ extern int zbar_parse_config(const char 
                              zbar_config_t *config,
                              int *value);
 
+/** consistently compute fourcc values across architectures
+ * (adapted from v4l2 specification)
+ * @since 0.11
+ */
+#define zbar_fourcc(a, b, c, d)                 \
+        ((unsigned long)(a) |                   \
+         ((unsigned long)(b) << 8) |            \
+         ((unsigned long)(c) << 16) |           \
+         ((unsigned long)(d) << 24))
+
+/** parse a fourcc string into its encoded integer value.
+ * @since 0.11
+ */
+static inline unsigned long zbar_fourcc_parse (const char *format)
+{
+    unsigned long fourcc = 0;
+    if(format) {
+        int i;
+        for(i = 0; i < 4 && format[i]; i++)
+            fourcc |= ((unsigned long)format[i]) << (i * 8);
+    }
+    return(fourcc);
+}
+
 /** @internal type unsafe error API (don't use) */
 extern int _zbar_error_spew(const void *object,
                             int verbosity);
@@ -229,6 +310,20 @@ extern void zbar_symbol_ref(const zbar_s
  */
 extern zbar_symbol_type_t zbar_symbol_get_type(const zbar_symbol_t *symbol);
 
+/** retrieve symbology boolean config settings.
+ * @returns a bitmask indicating which configs were set for the detected
+ * symbology during decoding.
+ * @since 0.11
+ */
+extern unsigned int zbar_symbol_get_configs(const zbar_symbol_t *symbol);
+
+/** retrieve symbology modifier flag settings.
+ * @returns a bitmask indicating which characteristics were detected
+ * during decoding.
+ * @since 0.11
+ */
+extern unsigned int zbar_symbol_get_modifiers(const zbar_symbol_t *symbol);
+
 /** retrieve data decoded from symbol.
  * @returns the data string
  */
@@ -284,6 +379,14 @@ extern int zbar_symbol_get_loc_x(const z
 extern int zbar_symbol_get_loc_y(const zbar_symbol_t *symbol,
                                  unsigned index);
 
+/** retrieve general orientation of decoded symbol.
+ * @returns a coarse, axis-aligned indication of symbol orientation or
+ * ZBAR_ORIENT_UNKNOWN if unknown
+ * @since 0.11
+ */
+extern zbar_orientation_t
+zbar_symbol_get_orientation(const zbar_symbol_t *symbol);
+
 /** iterate the set to which this symbol belongs (there can be only one).
  * @returns the next symbol in the set, or
  * @returns NULL when no more results are available
@@ -357,6 +460,14 @@ extern int zbar_symbol_set_get_size(cons
 extern const zbar_symbol_t*
 zbar_symbol_set_first_symbol(const zbar_symbol_set_t *symbols);
 
+/** raw result iterator.
+ * @returns the first decoded symbol result in a set, *before* filtering
+ * @returns NULL if the set is empty
+ * @since 0.11
+ */
+extern const zbar_symbol_t*
+zbar_symbol_set_first_unfiltered(const zbar_symbol_set_t *symbols);
+
 /*@}*/
 
 /*------------------------------------------------------------*/
@@ -456,6 +567,25 @@ extern unsigned zbar_image_get_width(con
  */
 extern unsigned zbar_image_get_height(const zbar_image_t *image);
 
+/** retrieve both dimensions of the image.
+ * fills in the width and height in samples
+ */
+extern void zbar_image_get_size(const zbar_image_t *image,
+                                unsigned *width,
+                                unsigned *height);
+
+/** retrieve the crop rectangle.
+ * fills in the image coordinates of the upper left corner and size
+ * of an axis-aligned rectangular area of the image that will be scanned.
+ * defaults to the full image
+ * @since 0.11
+ */
+extern void zbar_image_get_crop(const zbar_image_t *image,
+                                unsigned *x,
+                                unsigned *y,
+                                unsigned *width,
+                                unsigned *height);
+
 /** return the image sample data.  the returned data buffer is only
  * valid until zbar_image_destroy() is called
  */
@@ -505,12 +635,24 @@ extern void zbar_image_set_sequence(zbar
                                     unsigned sequence_num);
 
 /** specify the pixel size of the image.
+ * @note this also resets the crop rectangle to the full image
+ * (0, 0, width, height)
  * @note this does not affect the data!
  */
 extern void zbar_image_set_size(zbar_image_t *image,
                                 unsigned width,
                                 unsigned height);
 
+/** specify a rectangular region of the image to scan.
+ * the rectangle will be clipped to the image boundaries.
+ * defaults to the full image specified by zbar_image_set_size()
+ */
+extern void zbar_image_set_crop(zbar_image_t *image,
+                                unsigned x,
+                                unsigned y,
+                                unsigned width,
+                                unsigned height);
+
 /** specify image sample data.  when image data is no longer needed by
  * the library the specific data cleanup handler will be called
  * (unless NULL)
@@ -1148,6 +1290,14 @@ static inline int zbar_decoder_parse_con
            zbar_decoder_set_config(decoder, sym, cfg, val));
 }
 
+/** retrieve symbology boolean config settings.
+ * @returns a bitmask indicating which configs are currently set for the
+ * specified symbology.
+ * @since 0.11
+ */
+extern unsigned int zbar_decoder_get_configs(const zbar_decoder_t *decoder,
+                                             zbar_symbol_type_t symbology);
+
 /** clear all decoder state.
  * any partial symbols are flushed
  */
@@ -1195,6 +1345,20 @@ zbar_decoder_get_data_length(const zbar_
 extern zbar_symbol_type_t
 zbar_decoder_get_type(const zbar_decoder_t *decoder);
 
+/** retrieve modifier flags for the last decoded symbol.
+ * @returns a bitmask indicating which characteristics were detected
+ * during decoding.
+ * @since 0.11
+ */
+extern unsigned int zbar_decoder_get_modifiers(const zbar_decoder_t *decoder);
+
+/** retrieve last decode direction.
+ * @returns 1 for forward and -1 for reverse
+ * @returns 0 if the decode direction is unknown or does not apply
+ * @since 0.11
+ */
+extern int zbar_decoder_get_direction(const zbar_decoder_t *decoder);
+
 /** setup data handler callback.
  * the registered function will be called by the decoder
  * just before zbar_decode_width() returns a non-zero value.
diff --git a/include/zbar/Decoder.h b/include/zbar/Decoder.h
--- a/include/zbar/Decoder.h
+++ b/include/zbar/Decoder.h
@@ -1,5 +1,5 @@
 //------------------------------------------------------------------------
-//  Copyright 2007-2009 (c) Jeff Brown <spadix@users.sourceforge.net>
+//  Copyright 2007-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
 //
 //  This file is part of the ZBar Bar Code Reader.
 //
@@ -149,6 +149,14 @@ class Decoder {
         return(zbar_decoder_get_data_length(_decoder));
     }
 
+    /// retrieve last decode direction.
+    /// see zbar_decoder_get_direction()
+    /// @since 0.11
+    int get_direction() const
+    {
+        return(zbar_decoder_get_direction(_decoder));
+    }
+
     /// setup callback to handle result data.
     void set_handler (Handler &handler)
     {
diff --git a/include/zbar/Image.h b/include/zbar/Image.h
--- a/include/zbar/Image.h
+++ b/include/zbar/Image.h
@@ -1,5 +1,5 @@
 //------------------------------------------------------------------------
-//  Copyright 2007-2009 (c) Jeff Brown <spadix@users.sourceforge.net>
+//  Copyright 2007-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
 //
 //  This file is part of the ZBar Bar Code Reader.
 //
@@ -67,7 +67,12 @@ public:
         {
             if(userdata) {
                 Image *image = (Image*)zbar_image_get_userdata(zimg);
-                ((Handler*)userdata)->image_callback(*image);
+                if(image)
+                    ((Handler*)userdata)->image_callback(*image);
+                else {
+                    Image tmp(zimg, 1);
+                    ((Handler*)userdata)->image_callback(tmp);
+                }
             }
         }
     };
@@ -110,6 +115,8 @@ public:
 
     ~Image ()
     {
+        set_data(NULL, 0);
+        zbar_image_set_userdata(_img, NULL);
         zbar_image_ref(_img, -1);
     }
 
@@ -143,12 +150,7 @@ public:
     /// see zbar_image_set_format()
     void set_format (const std::string& format)
     {
-        if(format.length() != 4)
-            throw FormatError();
-        unsigned long fourcc = ((format[0] & 0xff) |
-                                ((format[1] & 0xff) << 8) |
-                                ((format[2] & 0xff) << 16) |
-                                ((format[3] & 0xff) << 24));
+        unsigned long fourcc = zbar_fourcc_parse(format.c_str());
         zbar_image_set_format(_img, fourcc);
     }
 
@@ -183,6 +185,15 @@ public:
         return(zbar_image_get_height(_img));
     }
 
+    /// retrieve both dimensions of the image.
+    /// see zbar_image_get_size()
+    /// @since 0.11
+    void get_size (unsigned &width,
+                   unsigned &height) const
+    {
+        zbar_image_get_size(_img, &width, &height);
+    }
+
     /// specify the pixel size of the image.
     /// see zbar_image_set_size()
     void set_size (unsigned width,
@@ -191,6 +202,26 @@ public:
         zbar_image_set_size(_img, width, height);
     }
 
+    /// retrieve the scan crop rectangle.
+    /// see zbar_image_get_crop()
+    void get_crop (unsigned &x,
+                   unsigned &y,
+                   unsigned &width,
+                   unsigned &height) const
+    {
+        zbar_image_get_crop(_img, &x, &y, &width, &height);
+    }
+
+    /// set the scan crop rectangle.
+    /// see zbar_image_set_crop()
+    void set_crop (unsigned x,
+                   unsigned y,
+                   unsigned width,
+                   unsigned height)
+    {
+        zbar_image_set_crop(_img, x, y, width, height);
+    }
+
     /// return the image sample data.
     /// see zbar_image_get_data()
     const void *get_data () const
diff --git a/include/zbar/Processor.h b/include/zbar/Processor.h
--- a/include/zbar/Processor.h
+++ b/include/zbar/Processor.h
@@ -1,5 +1,5 @@
 //------------------------------------------------------------------------
-//  Copyright 2007-2009 (c) Jeff Brown <spadix@users.sourceforge.net>
+//  Copyright 2007-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
 //
 //  This file is part of the ZBar Bar Code Reader.
 //
@@ -183,8 +183,8 @@ class Processor {
     void force_format (std::string& input_format,
                        std::string& output_format)
     {
-        unsigned long ifourcc = *(unsigned long*)input_format.c_str();
-        unsigned long ofourcc = *(unsigned long*)output_format.c_str();
+        unsigned long ifourcc = zbar_fourcc_parse(input_format.c_str());
+        unsigned long ofourcc = zbar_fourcc_parse(output_format.c_str());
         if(zbar_processor_force_format(_processor, ifourcc, ofourcc))
             throw_exception(_processor);
     }
diff --git a/include/zbar/QZBarImage.h b/include/zbar/QZBarImage.h
--- a/include/zbar/QZBarImage.h
+++ b/include/zbar/QZBarImage.h
@@ -1,5 +1,5 @@
 //------------------------------------------------------------------------
-//  Copyright 2008-2009 (c) Jeff Brown <spadix@users.sourceforge.net>
+//  Copyright 2008-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
 //
 //  This file is part of the ZBar Bar Code Reader.
 //
@@ -53,7 +53,7 @@ public:
         unsigned width = bpl / 4;
         unsigned height = qimg.height();
         set_size(width, height);
-        set_format('B' | ('G' << 8) | ('R' << 16) | ('4' << 24));
+        set_format(zbar_fourcc('B','G','R','4'));
         unsigned long datalen = qimg.numBytes();
         set_data(qimg.bits(), datalen);
 
diff --git a/include/zbar/Symbol.h b/include/zbar/Symbol.h
--- a/include/zbar/Symbol.h
+++ b/include/zbar/Symbol.h
@@ -1,5 +1,5 @@
 //------------------------------------------------------------------------
-//  Copyright 2007-2009 (c) Jeff Brown <spadix@users.sourceforge.net>
+//  Copyright 2007-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
 //
 //  This file is part of the ZBar Bar Code Reader.
 //
@@ -64,6 +64,21 @@ public:
         ref(-1);
     }
 
+    /// assignment.
+    SymbolSet& operator= (const SymbolSet& syms)
+    {
+        syms.ref();
+        ref(-1);
+        _syms = syms._syms;
+        return(*this);
+    }
+
+    /// truth testing.
+    bool operator! () const
+    {
+        return(!_syms || !get_size());
+    }
+
     /// manipulate reference count.
     void ref (int delta = 1) const
     {
@@ -77,7 +92,7 @@ public:
         return(_syms);
     }
 
-    int get_size ()
+    int get_size () const
     {
         return((_syms) ? zbar_symbol_set_get_size(_syms) : 0);
     }
@@ -112,9 +127,16 @@ public:
 
         /// copy constructor.
         Point (const Point& pt)
+            : x(pt.x),
+              y(pt.y)
+        { }
+
+        /// assignment.
+        Point& operator= (const Point& pt)
         {
             x = pt.x;
             y = pt.y;
+            return(*this);
         }
     };
 
@@ -135,7 +157,7 @@ public:
                 _index = -1;
         }
 
-        /// constructor.
+        /// copy constructor.
         PointIterator (const PointIterator& iter)
             : _sym(iter._sym),
               _index(iter._index)
@@ -149,6 +171,22 @@ public:
             _sym->ref(-1);
         }
 
+        /// assignment.
+        PointIterator& operator= (const PointIterator& iter)
+        {
+            iter._sym->ref();
+            _sym->ref(-1);
+            _sym = iter._sym;
+            _index = iter._index;
+            return(*this);
+        }
+
+        /// truth testing.
+        bool operator! () const
+        {
+            return(!_sym || _index < 0);
+        }
+
         /// advance iterator to next Point.
         PointIterator& operator++ ()
         {
@@ -161,7 +199,9 @@ public:
         /// retrieve currently referenced Point.
         const Point operator* () const
         {
-            assert(_index >= 0);
+            assert(!!*this);
+            if(!*this)
+                return(Point());
             return(Point(zbar_symbol_get_loc_x(*_sym, _index),
                          zbar_symbol_get_loc_y(*_sym, _index)));
         }
@@ -213,6 +253,32 @@ public:
         ref(-1);
     }
 
+    /// assignment.
+    Symbol& operator= (const Symbol& sym)
+    {
+        sym.ref(1);
+        ref(-1);
+        _sym = sym._sym;
+        _type = sym._type;
+        _data = sym._data;
+        return(*this);
+    }
+
+    Symbol& operator= (const zbar_symbol_t *sym)
+    {
+        if(sym)
+            zbar_symbol_ref(sym, 1);
+        ref(-1);
+        init(sym);
+        return(*this);
+    }
+
+    /// truth testing.
+    bool operator! () const
+    {
+        return(!_sym);
+    }
+
     void ref (int delta = 1) const
     {
         if(_sym)
@@ -311,6 +377,13 @@ public:
         return((_sym) ? zbar_symbol_get_loc_y(_sym, index) : -1);
     }
 
+    /// see zbar_symbol_get_orientation().
+    /// @since 0.11
+    int get_orientation () const
+    {
+        return(zbar_symbol_get_orientation(_sym));
+    }
+
     /// see zbar_symbol_xml().
     const std::string xml () const
     {
@@ -320,9 +393,6 @@ public:
     }
 
 protected:
-
-    friend class SymbolIterator;
-
     /// (re)initialize Symbol from C symbol object.
     void init (const zbar_symbol_t *sym = NULL)
     {
@@ -361,7 +431,7 @@ public:
     {
         const zbar_symbol_set_t *zsyms = _syms;
         if(zsyms)
-            _sym.init(zbar_symbol_set_first_symbol(zsyms));
+            _sym = zbar_symbol_set_first_symbol(zsyms);
     }
 
     /// copy constructor.
@@ -370,25 +440,33 @@ public:
     {
         const zbar_symbol_set_t *zsyms = _syms;
         if(zsyms)
-            _sym.init(zbar_symbol_set_first_symbol(zsyms));
+            _sym = zbar_symbol_set_first_symbol(zsyms);
     }
 
     ~SymbolIterator ()
     {
-        _sym.init();
+    }
+
+    /// assignment.
+    SymbolIterator& operator= (const SymbolIterator& iter)
+    {
+        _syms = iter._syms;
+        _sym = iter._sym;
+        return(*this);
+    }
+
+    bool operator! () const
+    {
+        return(!_syms || !_sym);
     }
 
     /// advance iterator to next Symbol.
     SymbolIterator& operator++ ()
     {
-        const zbar_symbol_t *zsym = _sym;
-        if(zsym)
-            _sym.init(zbar_symbol_next(zsym));
-        else {
-            const zbar_symbol_set_t *zsyms = _syms;
-            if(zsyms)
-                _sym.init(zbar_symbol_set_first_symbol(zsyms));
-        }
+        if(!!_sym)
+            _sym = zbar_symbol_next(_sym);
+        else if(!!_syms)
+            _sym = zbar_symbol_set_first_symbol(_syms);
         return(*this);
     }
 
diff --git a/include/zbar/Video.h b/include/zbar/Video.h
--- a/include/zbar/Video.h
+++ b/include/zbar/Video.h
@@ -1,5 +1,5 @@
 //------------------------------------------------------------------------
-//  Copyright 2007-2009 (c) Jeff Brown <spadix@users.sourceforge.net>
+//  Copyright 2007-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
 //
 //  This file is part of the ZBar Bar Code Reader.
 //
@@ -92,7 +92,7 @@ public:
     /// see zbar_video_init()
     void init (std::string& format)
     {
-        unsigned int fourcc = *(unsigned int*)format.c_str();
+        unsigned int fourcc = zbar_fourcc_parse(format.c_str());
         if(zbar_video_init(_video, fourcc))
             throw_exception(_video);
     }
diff --git a/include/zbar/zbargtk.h b/include/zbar/zbargtk.h
--- a/include/zbar/zbargtk.h
+++ b/include/zbar/zbargtk.h
@@ -136,7 +136,7 @@ struct _ZBarGtkClass {
 
 GType zbar_gtk_get_type(void) G_GNUC_CONST;
 
-/** 
+/**
  * zbar_gtk_new:
  * create a new barcode reader widget instance.
  * initially has no associated video device or image.
@@ -189,7 +189,17 @@ void zbar_gtk_set_video_enabled(ZBarGtk 
  */
 gboolean zbar_gtk_get_video_opened(ZBarGtk *zbar);
 
-/** 
+/** set video camera resolution.
+ * @width: width in pixels
+ * @height: height in pixels
+ *
+ * @note this call must be made before video is initialized
+ */
+void zbar_gtk_request_video_size(ZBarGtk *zbar,
+                                 int width,
+                                 int height);
+
+/**
  * utility function to populate a zbar_image_t from a GdkPixbuf.
  * @image: the zbar library image destination to populate
  * @pixbuf: the GdkPixbuf source

diff --git a/java/Makefile.am b/java/Makefile.am
new file mode 100644
--- /dev/null
+++ b/java/Makefile.am
@@ -0,0 +1,39 @@
+javadir = $(pkgdatadir)/lib
+
+PKG = net/sourceforge/zbar
+java_DATA = zbar.jar
+
+java_LTLIBRARIES = libzbarjni.la
+libzbarjni_la_CPPFLAGS = $(JAVA_CFLAGS) $(AM_CPPFLAGS)
+libzbarjni_la_LIBADD = $(abs_top_builddir)/zbar/libzbar.la
+
+libzbarjni_la_SOURCES = zbarjni.c zbarjni.h
+BUILT_SOURCES = zbarjni.h
+MAINTAINERCLEANFILES = zbarjni.h
+
+zbar_jar_SRCS = \
+    $(PKG)/Config.java $(PKG)/Modifier.java $(PKG)/Orientation.java \
+    $(PKG)/Symbol.java $(PKG)/SymbolIterator.java $(PKG)/SymbolSet.java \
+    $(PKG)/Image.java $(PKG)/ImageScanner.java
+
+zbar_jar_CLASSES = $(zbar_jar_SRCS:.java=.class)
+
+test_SRCS = test/TestImage.java test/TestImageScanner.java \
+    test/TestScanImage.java
+test_CLASSES = TestImage TestImageScanner TestScanImage
+
+CLEANFILES = zbar.jar $(zbar_jar_CLASSES) $(test_CLASSES:=.class)
+
+zbarjni.h: $(zbar_jar_SRCS)
+	$(MAKE) $(AM_MAKEFLAGS) zbar.jar
+	classes=`echo $(zbar_jar_CLASSES:.class=) | tr / .` ; \
+	    $(JAVAH) -o $@ $$classes
+
+zbar.jar: $(zbar_jar_SRCS)
+	cd $(abs_srcdir); $(JAVAC) -d $(abs_builddir) $(zbar_jar_SRCS)
+	$(JAR) cf $@ $(zbar_jar_CLASSES) || $(RM) $@
+
+check-local:
+	echo "making check in java"
+	cd $(abs_srcdir); $(JAVAC) -classpath $(abs_builddir)/zbar.jar:.:$(CLASSPATH) -d $(abs_builddir) $(test_SRCS)
+	$(top_builddir)/libtool -dlopen $(top_builddir)/zbar/libzbar.la -dlopen libzbarjni.la --mode=execute $(JAVA) -Xcheck:jni -classpath zbar.jar:.:$(CLASSPATH) org.junit.runner.JUnitCore $(test_CLASSES)
diff --git a/java/net/sourceforge/zbar/Config.java b/java/net/sourceforge/zbar/Config.java
new file mode 100644
--- /dev/null
+++ b/java/net/sourceforge/zbar/Config.java
@@ -0,0 +1,56 @@
+/*------------------------------------------------------------------------
+ *  Config
+ *
+ *  Copyright 2010 (c) Jeff Brown <spadix@users.sourceforge.net>
+ *
+ *  This file is part of the ZBar Bar Code Reader.
+ *
+ *  The ZBar Bar Code Reader is free software; you can redistribute it
+ *  and/or modify it under the terms of the GNU Lesser Public License as
+ *  published by the Free Software Foundation; either version 2.1 of
+ *  the License, or (at your option) any later version.
+ *
+ *  The ZBar Bar Code Reader is distributed in the hope that it will be
+ *  useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+ *  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Lesser Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser Public License
+ *  along with the ZBar Bar Code Reader; if not, write to the Free
+ *  Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ *  Boston, MA  02110-1301  USA
+ *
+ *  http://sourceforge.net/projects/zbar
+ *------------------------------------------------------------------------*/
+
+package net.sourceforge.zbar;
+
+/** Decoder configuration options.
+ */
+public class Config
+{
+    /** Enable symbology/feature. */
+    public static final int ENABLE = 0;
+    /** Enable check digit when optional. */
+    public static final int ADD_CHECK = 1;
+    /** Return check digit when present. */
+    public static final int EMIT_CHECK = 2;
+    /** Enable full ASCII character set. */
+    public static final int ASCII = 3;
+
+    /** Minimum data length for valid decode. */
+    public static final int MIN_LEN = 0x20;
+    /** Maximum data length for valid decode. */
+    public static final int MAX_LEN = 0x21;
+
+    /** Required video consistency frames. */
+    public static final int UNCERTAINTY = 0x40;
+
+    /** Enable scanner to collect position data. */
+    public static final int POSITION = 0x80;
+
+    /** Image scanner vertical scan density. */
+    public static final int X_DENSITY = 0x100;
+    /** Image scanner horizontal scan density. */
+    public static final int Y_DENSITY = 0x101;
+}
diff --git a/java/net/sourceforge/zbar/Image.java b/java/net/sourceforge/zbar/Image.java
new file mode 100644
--- /dev/null
+++ b/java/net/sourceforge/zbar/Image.java
@@ -0,0 +1,163 @@
+/*------------------------------------------------------------------------
+ *  Image
+ *
+ *  Copyright 2007-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
+ *
+ *  This file is part of the ZBar Bar Code Reader.
+ *
+ *  The ZBar Bar Code Reader is free software; you can redistribute it
+ *  and/or modify it under the terms of the GNU Lesser Public License as
+ *  published by the Free Software Foundation; either version 2.1 of
+ *  the License, or (at your option) any later version.
+ *
+ *  The ZBar Bar Code Reader is distributed in the hope that it will be
+ *  useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+ *  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Lesser Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser Public License
+ *  along with the ZBar Bar Code Reader; if not, write to the Free
+ *  Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ *  Boston, MA  02110-1301  USA
+ *
+ *  http://sourceforge.net/projects/zbar
+ *------------------------------------------------------------------------*/
+
+package net.sourceforge.zbar;
+
+/** stores image data samples along with associated format and size
+ * metadata.
+ */
+public class Image
+{
+    /** C pointer to a zbar_symbol_t. */
+    private long peer;
+    private Object data;
+
+    static
+    {
+        System.loadLibrary("zbarjni");
+        init();
+    }
+    private static native void init();
+
+    public Image ()
+    {
+        peer = create();
+    }
+
+    public Image (int width, int height)
+    {
+        this();
+        setSize(width, height);
+    }
+
+    public Image (int width, int height, String format)
+    {
+        this();
+        setSize(width, height);
+        setFormat(format);
+    }
+
+    public Image (String format)
+    {
+        this();
+        setFormat(format);
+    }
+
+    Image (long peer)
+    {
+        this.peer = peer;
+    }
+
+    /** Create an associated peer instance. */
+    private native long create();
+
+    protected void finalize ()
+    {
+        destroy();
+    }
+
+    /** Clean up native data associated with an instance. */
+    public synchronized void destroy ()
+    {
+        if(peer != 0) {
+            destroy(peer);
+            peer = 0;
+        }
+    }
+
+    /** Destroy the associated peer instance.  */
+    private native void destroy(long peer);
+
+    /** Image format conversion.
+     * @returns a @em new image with the sample data from the original
+     * image converted to the requested format fourcc.  the original
+     * image is unaffected.
+     */
+    public Image convert (String format)
+    {
+        long newpeer = convert(peer, format);
+        if(newpeer == 0)
+            return(null);
+        return(new Image(newpeer));
+    }
+
+    private native long convert(long peer, String format);
+
+    /** Retrieve the image format fourcc. */
+    public native String getFormat();
+
+    /** Specify the fourcc image format code for image sample data. */
+    public native void setFormat(String format);
+
+    /** Retrieve a "sequence" (page/frame) number associated with this
+     * image.
+     */
+    public native int getSequence();
+
+    /** Associate a "sequence" (page/frame) number with this image. */
+    public native void setSequence(int seq);
+
+    /** Retrieve the width of the image. */
+    public native int getWidth();
+
+    /** Retrieve the height of the image. */
+    public native int getHeight();
+
+    /** Retrieve the size of the image. */
+    public native int[] getSize();
+
+    /** Specify the pixel size of the image. */
+    public native void setSize(int width, int height);
+
+    /** Specify the pixel size of the image. */
+    public native void setSize(int[] size);
+
+    /** Retrieve the crop region of the image. */
+    public native int[] getCrop();
+
+    /** Specify the crop region of the image. */
+    public native void setCrop(int x, int y, int width, int height);
+
+    /** Specify the crop region of the image. */
+    public native void setCrop(int[] crop);
+
+    /** Retrieve the image sample data. */
+    public native byte[] getData();
+
+    /** Specify image sample data. */
+    public native void setData(byte[] data);
+
+    /** Specify image sample data. */
+    public native void setData(int[] data);
+
+    /** Retrieve the decoded results associated with this image. */
+    public SymbolSet getSymbols ()
+    {
+        return(new SymbolSet(getSymbols(peer)));
+    }
+
+    private native long getSymbols(long peer);
+
+}
diff --git a/java/net/sourceforge/zbar/ImageScanner.java b/java/net/sourceforge/zbar/ImageScanner.java
new file mode 100644
--- /dev/null
+++ b/java/net/sourceforge/zbar/ImageScanner.java
@@ -0,0 +1,98 @@
+/*------------------------------------------------------------------------
+ *  ImageScanner
+ *
+ *  Copyright 2007-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
+ *
+ *  This file is part of the ZBar Bar Code Reader.
+ *
+ *  The ZBar Bar Code Reader is free software; you can redistribute it
+ *  and/or modify it under the terms of the GNU Lesser Public License as
+ *  published by the Free Software Foundation; either version 2.1 of
+ *  the License, or (at your option) any later version.
+ *
+ *  The ZBar Bar Code Reader is distributed in the hope that it will be
+ *  useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+ *  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Lesser Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser Public License
+ *  along with the ZBar Bar Code Reader; if not, write to the Free
+ *  Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ *  Boston, MA  02110-1301  USA
+ *
+ *  http://sourceforge.net/projects/zbar
+ *------------------------------------------------------------------------*/
+
+package net.sourceforge.zbar;
+
+/** Read barcodes from 2-D images.
+ */
+public class ImageScanner
+{
+    /** C pointer to a zbar_image_scanner_t. */
+    private long peer;
+
+    static
+    {
+        System.loadLibrary("zbarjni");
+        init();
+    }
+    private static native void init();
+
+    public ImageScanner ()
+    {
+        peer = create();
+    }
+
+    /** Create an associated peer instance. */
+    private native long create();
+
+    protected void finalize ()
+    {
+        destroy();
+    }
+
+    /** Clean up native data associated with an instance. */
+    public synchronized void destroy ()
+    {
+        if(peer != 0) {
+            destroy(peer);
+            peer = 0;
+        }
+    }
+
+    /** Destroy the associated peer instance.  */
+    private native void destroy(long peer);
+
+    /** Set config for indicated symbology (0 for all) to specified value.
+     */
+    public native void setConfig(int symbology, int config, int value)
+        throws IllegalArgumentException;
+
+    /** Parse configuration string and apply to image scanner. */
+    public native void parseConfig(String config);
+
+    /** Enable or disable the inter-image result cache (default disabled).
+     * Mostly useful for scanning video frames, the cache filters duplicate
+     * results from consecutive images, while adding some consistency
+     * checking and hysteresis to the results.  Invoking this method also
+     * clears the cache.
+     */
+    public native void enableCache(boolean enable);
+
+    /** Retrieve decode results for last scanned image.
+     * @returns the SymbolSet result container
+     */
+    public SymbolSet getResults ()
+    {
+        return(new SymbolSet(getResults(peer)));
+    }
+
+    private native long getResults(long peer);
+
+    /** Scan for symbols in provided Image.
+     * The image format must currently be "Y800" or "GRAY".
+     * @returns the number of symbols successfully decoded from the image.
+     */
+    public native int scanImage(Image image);
+}
diff --git a/java/net/sourceforge/zbar/Modifier.java b/java/net/sourceforge/zbar/Modifier.java
new file mode 100644
--- /dev/null
+++ b/java/net/sourceforge/zbar/Modifier.java
@@ -0,0 +1,42 @@
+/*------------------------------------------------------------------------
+ *  Modifier
+ *
+ *  Copyright 2010 (c) Jeff Brown <spadix@users.sourceforge.net>
+ *
+ *  This file is part of the ZBar Bar Code Reader.
+ *
+ *  The ZBar Bar Code Reader is free software; you can redistribute it
+ *  and/or modify it under the terms of the GNU Lesser Public License as
+ *  published by the Free Software Foundation; either version 2.1 of
+ *  the License, or (at your option) any later version.
+ *
+ *  The ZBar Bar Code Reader is distributed in the hope that it will be
+ *  useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+ *  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Lesser Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser Public License
+ *  along with the ZBar Bar Code Reader; if not, write to the Free
+ *  Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ *  Boston, MA  02110-1301  USA
+ *
+ *  http://sourceforge.net/projects/zbar
+ *------------------------------------------------------------------------*/
+
+package net.sourceforge.zbar;
+
+/** Decoder symbology modifiers.
+ */
+public class Modifier
+{
+    /** barcode tagged as GS1 (EAN.UCC) reserved
+     * (eg, FNC1 before first data character).
+     * data may be parsed as a sequence of GS1 AIs
+     */
+    public static final int GS1 = 0;
+
+    /** barcode tagged as AIM reserved
+     * (eg, FNC1 after first character or digit pair)
+     */
+    public static final int AIM = 1;
+}
diff --git a/java/net/sourceforge/zbar/Orientation.java b/java/net/sourceforge/zbar/Orientation.java
new file mode 100644
--- /dev/null
+++ b/java/net/sourceforge/zbar/Orientation.java
@@ -0,0 +1,42 @@
+/*------------------------------------------------------------------------
+ *  Orientation
+ *
+ *  Copyright 2010 (c) Jeff Brown <spadix@users.sourceforge.net>
+ *
+ *  This file is part of the ZBar Bar Code Reader.
+ *
+ *  The ZBar Bar Code Reader is free software; you can redistribute it
+ *  and/or modify it under the terms of the GNU Lesser Public License as
+ *  published by the Free Software Foundation; either version 2.1 of
+ *  the License, or (at your option) any later version.
+ *
+ *  The ZBar Bar Code Reader is distributed in the hope that it will be
+ *  useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+ *  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Lesser Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser Public License
+ *  along with the ZBar Bar Code Reader; if not, write to the Free
+ *  Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ *  Boston, MA  02110-1301  USA
+ *
+ *  http://sourceforge.net/projects/zbar
+ *------------------------------------------------------------------------*/
+
+package net.sourceforge.zbar;
+
+/** Decoded symbol coarse orientation.
+ */
+public class Orientation
+{
+    /** Unable to determine orientation. */
+    public static final int UNKNOWN = -1;
+    /** Upright, read left to right. */
+    public static final int UP = 0;
+    /** sideways, read top to bottom */
+    public static final int RIGHT = 1;
+    /** upside-down, read right to left */
+    public static final int DOWN = 2;
+    /** sideways, read bottom to top */
+    public static final int LEFT = 3;
+}
diff --git a/java/net/sourceforge/zbar/Symbol.java b/java/net/sourceforge/zbar/Symbol.java
new file mode 100644
--- /dev/null
+++ b/java/net/sourceforge/zbar/Symbol.java
@@ -0,0 +1,197 @@
+/*------------------------------------------------------------------------
+ *  Symbol
+ *
+ *  Copyright 2007-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
+ *
+ *  This file is part of the ZBar Bar Code Reader.
+ *
+ *  The ZBar Bar Code Reader is free software; you can redistribute it
+ *  and/or modify it under the terms of the GNU Lesser Public License as
+ *  published by the Free Software Foundation; either version 2.1 of
+ *  the License, or (at your option) any later version.
+ *
+ *  The ZBar Bar Code Reader is distributed in the hope that it will be
+ *  useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+ *  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Lesser Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser Public License
+ *  along with the ZBar Bar Code Reader; if not, write to the Free
+ *  Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ *  Boston, MA  02110-1301  USA
+ *
+ *  http://sourceforge.net/projects/zbar
+ *------------------------------------------------------------------------*/
+
+package net.sourceforge.zbar;
+
+/** Immutable container for decoded result symbols associated with an image
+ * or a composite symbol.
+ */
+public class Symbol
+{
+    /** No symbol decoded. */
+    public static final int NONE = 0;
+    /** Symbol detected but not decoded. */
+    public static final int PARTIAL = 1;
+
+    /** EAN-8. */
+    public static final int EAN8 = 8;
+    /** UPC-E. */
+    public static final int UPCE = 9;
+    /** ISBN-10 (from EAN-13). */
+    public static final int ISBN10 = 10;
+    /** UPC-A. */
+    public static final int UPCA = 12;
+    /** EAN-13. */
+    public static final int EAN13 = 13;
+    /** ISBN-13 (from EAN-13). */
+    public static final int ISBN13 = 14;
+    /** Interleaved 2 of 5. */
+    public static final int I25 = 25;
+    /** DataBar (RSS-14). */
+    public static final int DATABAR = 34;
+    /** DataBar Expanded. */
+    public static final int DATABAR_EXP = 35;
+    /** Code 93. */
+    public static final int CODE93 = 93;
+    /** Code 39. */
+    public static final int CODE39 = 39;
+    /** PDF417. */
+    public static final int PDF417 = 57;
+    /** QR Code. */
+    public static final int QRCODE = 64;
+    /** Code 128. */
+    public static final int CODE128 = 128;
+
+    /** C pointer to a zbar_symbol_t. */
+    private long peer;
+
+    /** Cached attributes. */
+    private int type;
+
+    static
+    {
+        System.loadLibrary("zbarjni");
+        init();
+    }
+    private static native void init();
+
+    /** Symbols are only created by other package methods. */
+    Symbol (long peer)
+    {
+        this.peer = peer;
+    }
+
+    protected void finalize ()
+    {
+        destroy();
+    }
+
+    /** Clean up native data associated with an instance. */
+    public synchronized void destroy ()
+    {
+        if(peer != 0) {
+            destroy(peer);
+            peer = 0;
+        }
+    }
+
+    /** Release the associated peer instance.  */
+    private native void destroy(long peer);
+
+    /** Retrieve type of decoded symbol. */
+    public int getType ()
+    {
+        if(type == 0)
+            type = getType(peer);
+        return(type);
+    }
+
+    private native int getType(long peer);
+
+    /** Retrieve symbology boolean configs settings used during decode. */
+    public native int getConfigMask();
+
+    /** Retrieve symbology characteristics detected during decode. */
+    public native int getModifierMask();
+
+    /** Retrieve data decoded from symbol as a String. */
+    public native String getData();
+
+    /** Retrieve raw data bytes decoded from symbol. */
+    public native byte[] getDataBytes();
+
+    /** Retrieve a symbol confidence metric.  Quality is an unscaled,
+     * relative quantity: larger values are better than smaller
+     * values, where "large" and "small" are application dependent.
+     */
+    public native int getQuality();
+
+    /** Retrieve current cache count.  When the cache is enabled for
+     * the image_scanner this provides inter-frame reliability and
+     * redundancy information for video streams.
+     * @returns < 0 if symbol is still uncertain
+     * @returns 0 if symbol is newly verified
+     * @returns > 0 for duplicate symbols
+     */
+    public native int getCount();
+
+    /** Retrieve an approximate, axis-aligned bounding box for the
+     * symbol.
+     */
+    public int[] getBounds ()
+    {
+        int n = getLocationSize(peer);
+        if(n <= 0)
+            return(null);
+
+        int[] bounds = new int[4];
+        int xmin = Integer.MAX_VALUE;
+        int xmax = Integer.MIN_VALUE;
+        int ymin = Integer.MAX_VALUE;
+        int ymax = Integer.MIN_VALUE;
+
+        for(int i = 0; i < n; i++) {
+            int x = getLocationX(peer, i);
+            if(xmin > x) xmin = x;
+            if(xmax < x) xmax = x;
+
+            int y = getLocationY(peer, i);
+            if(ymin > y) ymin = y;
+            if(ymax < y) ymax = y;
+        }
+        bounds[0] = xmin;
+        bounds[1] = ymin;
+        bounds[2] = xmax - xmin;
+        bounds[3] = ymax - ymin;
+        return(bounds);
+    }
+
+    private native int getLocationSize(long peer);
+    private native int getLocationX(long peer, int idx);
+    private native int getLocationY(long peer, int idx);
+
+    public int[] getLocationPoint (int idx)
+    {
+        int[] p = new int[2];
+        p[0] = getLocationX(peer, idx);
+        p[1] = getLocationY(peer, idx);
+        return(p);
+    }
+
+    /** Retrieve general axis-aligned, orientation of decoded
+     * symbol.
+     */
+    public native int getOrientation();
+
+    /** Retrieve components of a composite result. */
+    public SymbolSet getComponents ()
+    {
+        return(new SymbolSet(getComponents(peer)));
+    }
+
+    private native long getComponents(long peer);
+
+    native long next();
+}
diff --git a/java/net/sourceforge/zbar/SymbolIterator.java b/java/net/sourceforge/zbar/SymbolIterator.java
new file mode 100644
--- /dev/null
+++ b/java/net/sourceforge/zbar/SymbolIterator.java
@@ -0,0 +1,70 @@
+/*------------------------------------------------------------------------
+ *  SymbolIterator
+ *
+ *  Copyright 2007-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
+ *
+ *  This file is part of the ZBar Bar Code Reader.
+ *
+ *  The ZBar Bar Code Reader is free software; you can redistribute it
+ *  and/or modify it under the terms of the GNU Lesser Public License as
+ *  published by the Free Software Foundation; either version 2.1 of
+ *  the License, or (at your option) any later version.
+ *
+ *  The ZBar Bar Code Reader is distributed in the hope that it will be
+ *  useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+ *  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Lesser Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser Public License
+ *  along with the ZBar Bar Code Reader; if not, write to the Free
+ *  Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ *  Boston, MA  02110-1301  USA
+ *
+ *  http://sourceforge.net/projects/zbar
+ *------------------------------------------------------------------------*/
+
+package net.sourceforge.zbar;
+
+/** Iterator over a SymbolSet.
+ */
+public class SymbolIterator
+    implements java.util.Iterator<Symbol>
+{
+    /** Next symbol to be returned by the iterator. */
+    private Symbol current;
+
+    /** SymbolIterators are only created by internal interface methods. */
+    SymbolIterator (Symbol first)
+    {
+        current = first;
+    }
+
+    /** Returns true if the iteration has more elements. */
+    public boolean hasNext ()
+    {
+        return(current != null);
+    }
+
+    /** Retrieves the next element in the iteration. */
+    public Symbol next ()
+    {
+        if(current == null)
+            throw(new java.util.NoSuchElementException
+                  ("access past end of SymbolIterator"));
+
+        Symbol result = current;
+        long sym = current.next();
+        if(sym != 0)
+            current = new Symbol(sym);
+        else
+            current = null;
+        return(result);
+    }
+
+    /** Raises UnsupportedOperationException. */
+    public void remove ()
+    {
+        throw(new UnsupportedOperationException
+              ("SymbolIterator is immutable"));
+    }
+}
diff --git a/java/net/sourceforge/zbar/SymbolSet.java b/java/net/sourceforge/zbar/SymbolSet.java
new file mode 100644
--- /dev/null
+++ b/java/net/sourceforge/zbar/SymbolSet.java
@@ -0,0 +1,82 @@
+/*------------------------------------------------------------------------
+ *  SymbolSet
+ *
+ *  Copyright 2007-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
+ *
+ *  This file is part of the ZBar Bar Code Reader.
+ *
+ *  The ZBar Bar Code Reader is free software; you can redistribute it
+ *  and/or modify it under the terms of the GNU Lesser Public License as
+ *  published by the Free Software Foundation; either version 2.1 of
+ *  the License, or (at your option) any later version.
+ *
+ *  The ZBar Bar Code Reader is distributed in the hope that it will be
+ *  useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+ *  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Lesser Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser Public License
+ *  along with the ZBar Bar Code Reader; if not, write to the Free
+ *  Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ *  Boston, MA  02110-1301  USA
+ *
+ *  http://sourceforge.net/projects/zbar
+ *------------------------------------------------------------------------*/
+
+package net.sourceforge.zbar;
+
+/** Immutable container for decoded result symbols associated with an image
+ * or a composite symbol.
+ */
+public class SymbolSet
+    extends java.util.AbstractCollection<Symbol>
+{
+    /** C pointer to a zbar_symbol_set_t. */
+    private long peer;
+
+    static
+    {
+        System.loadLibrary("zbarjni");
+        init();
+    }
+    private static native void init();
+
+    /** SymbolSets are only created by other package methods. */
+    SymbolSet (long peer)
+    {
+        this.peer = peer;
+    }
+
+    protected void finalize ()
+    {
+        destroy();
+    }
+
+    /** Clean up native data associated with an instance. */
+    public synchronized void destroy ()
+    {
+        if(peer != 0) {
+            destroy(peer);
+            peer = 0;
+        }
+    }
+
+    /** Release the associated peer instance.  */
+    private native void destroy(long peer);
+
+    /** Retrieve an iterator over the Symbol elements in this collection. */
+    public java.util.Iterator<Symbol> iterator ()
+    {
+        long sym = firstSymbol(peer);
+        if(sym == 0)
+            return(new SymbolIterator(null));
+
+        return(new SymbolIterator(new Symbol(sym)));
+    }
+
+    /** Retrieve the number of elements in the collection. */
+    public native int size();
+
+    /** Retrieve C pointer to first symbol in the set. */
+    private native long firstSymbol(long peer);
+}
diff --git a/java/test/TestImage.java b/java/test/TestImage.java
new file mode 100644
--- /dev/null
+++ b/java/test/TestImage.java
@@ -0,0 +1,175 @@
+
+import org.junit.Test;
+import org.junit.Before;
+import org.junit.After;
+import static org.junit.Assert.*;
+
+import net.sourceforge.zbar.Image;
+
+public class TestImage
+{
+    protected Image image;
+
+    @Before public void setUp ()
+    {
+        image = new Image();
+    }
+
+    @After public void tearDown ()
+    {
+        image.destroy();
+        image = null;
+    }
+
+
+    @Test public void creation ()
+    {
+        Image img0 = new Image(123, 456);
+        Image img1 = new Image("BGR3");
+        Image img2 = new Image(987, 654, "UYVY");
+
+        assertEquals(123, img0.getWidth());
+        assertEquals(456, img0.getHeight());
+        assertEquals(null, img0.getFormat());
+
+        assertEquals(0, img1.getWidth());
+        assertEquals(0, img1.getHeight());
+        assertEquals("BGR3", img1.getFormat());
+
+        assertEquals(987, img2.getWidth());
+        assertEquals(654, img2.getHeight());
+        assertEquals("UYVY", img2.getFormat());
+    }
+
+    @Test public void sequence ()
+    {
+        assertEquals(0, image.getSequence());
+        image.setSequence(42);
+        assertEquals(42, image.getSequence());
+    }
+
+    @Test public void size ()
+    {
+        assertEquals(0, image.getWidth());
+        assertEquals(0, image.getHeight());
+
+        image.setSize(640, 480);
+        int[] size0 = { 640, 480 };
+        assertArrayEquals(size0, image.getSize());
+
+        int[] size1 = { 320, 240 };
+        image.setSize(size1);
+        assertEquals(320, image.getWidth());
+        assertEquals(240, image.getHeight());
+    }
+
+    @Test public void crop ()
+    {
+        int[] zeros = { 0, 0, 0, 0 };
+        assertArrayEquals(zeros, image.getCrop());
+
+        image.setSize(123, 456);
+        int[] crop0 = { 0, 0, 123, 456 };
+        assertArrayEquals(crop0, image.getCrop());
+
+        image.setCrop(1, 2, 34, 56);
+        int[] crop1 = { 1, 2, 34, 56 };
+        assertArrayEquals(crop1, image.getCrop());
+
+        image.setCrop(-20, -20, 200, 500);
+        assertArrayEquals(crop0, image.getCrop());
+
+        int[] crop2 = { 7, 8, 90, 12};
+        image.setCrop(crop2);
+        assertArrayEquals(crop2, image.getCrop());
+
+        image.setSize(654, 321);
+        int[] crop3 = { 0, 0, 654, 321 };
+        assertArrayEquals(crop3, image.getCrop());
+
+        int[] crop4 = { -10, -10, 700, 400 };
+        image.setCrop(crop4);
+        assertArrayEquals(crop3, image.getCrop());
+    }
+
+    @Test public void format ()
+    {
+        assertNull(image.getFormat());
+        image.setFormat("Y800");
+        assertEquals("Y800", image.getFormat());
+        boolean gotException = false;
+        try {
+            image.setFormat("[]");
+        }
+        catch(IllegalArgumentException e) {
+            // expected
+            gotException = true;
+        }
+        assertTrue("Expected exception", gotException);
+        assertEquals("Y800", image.getFormat());
+    }
+
+    @Test(expected=IllegalArgumentException.class)
+        public void setFormatInvalid0 ()
+    {
+        image.setFormat(null);
+    }
+
+    @Test(expected=IllegalArgumentException.class)
+        public void setFormatInvalid1 ()
+    {
+        image.setFormat("");
+    }
+
+    @Test(expected=IllegalArgumentException.class)
+        public void setFormatInvalid2 ()
+    {
+        image.setFormat("YOMAMA");
+    }
+
+    @Test(expected=IllegalArgumentException.class)
+        public void setFormatInvalid3 ()
+    {
+        image.setFormat("foo");
+    }
+
+    @Test public void data ()
+    {
+        assertNull(image.getData());
+
+        int[] ints = new int[24];
+        image.setData(ints);
+        assertSame(ints, image.getData());
+
+        byte[] bytes = new byte[280];
+        image.setData(bytes);
+        assertSame(bytes, image.getData());
+
+        image.setData((byte[])null);
+        assertNull(image.getData());
+    }
+
+    @Test public void convert ()
+    {
+        image.setSize(4, 4);
+        image.setFormat("RGB4");
+        int[] rgb4 = new int[16];
+        byte[] exp = new byte[16];
+        for(int i = 0; i < 16; i++) {
+            int c = i * 15;
+            rgb4[i] = c | (c << 8) | (c << 16) | (c << 24);
+            exp[i] = (byte)c;
+        }
+        image.setData(rgb4);
+
+        Image gray = image.convert("Y800");
+        assertEquals(4, gray.getWidth());
+        assertEquals(4, gray.getHeight());
+        assertEquals("Y800", gray.getFormat());
+
+        byte[] y800 = gray.getData();
+        assertEquals(16, y800.length);
+
+        assertArrayEquals(exp, y800);
+    }
+}
diff --git a/java/test/TestImageScanner.java b/java/test/TestImageScanner.java
new file mode 100644
--- /dev/null
+++ b/java/test/TestImageScanner.java
@@ -0,0 +1,53 @@
+
+import org.junit.Test;
+import org.junit.Before;
+import org.junit.After;
+import org.junit.Assert.*;
+
+import net.sourceforge.zbar.ImageScanner;
+import net.sourceforge.zbar.Config;
+
+public class TestImageScanner
+{
+    protected ImageScanner scanner;
+
+    @Before public void setUp ()
+    {
+        scanner = new ImageScanner();
+    }
+
+    @After public void tearDown ()
+    {
+        scanner.destroy();
+        scanner = null;
+    }
+
+
+    @Test public void creation ()
+    {
+        // create/destroy
+    }
+
+    @Test public void callSetConfig ()
+    {
+        scanner.setConfig(0, Config.X_DENSITY, 2);
+        scanner.setConfig(0, Config.Y_DENSITY, 4);
+    }
+
+    @Test public void callParseConfig ()
+    {
+        scanner.parseConfig("disable");
+    }
+
+    @Test(expected=IllegalArgumentException.class)
+        public void callParseConfigInvalid ()
+    {
+        scanner.parseConfig("yomama");
+    }
+
+    @Test public void callEnableCache ()
+    {
+        scanner.enableCache(true);
+        scanner.enableCache(false);
+    }
+}
diff --git a/java/test/TestScanImage.java b/java/test/TestScanImage.java
new file mode 100644
--- /dev/null
+++ b/java/test/TestScanImage.java
@@ -0,0 +1,183 @@
+
+import org.junit.Test;
+import org.junit.Before;
+import org.junit.After;
+import static org.junit.Assert.*;
+
+import net.sourceforge.zbar.*;
+
+import java.text.CharacterIterator;
+import java.text.StringCharacterIterator;
+import java.util.Iterator;
+
+public class TestScanImage
+{
+    protected ImageScanner scanner;
+    protected Image image;
+
+    @Before public void setUp ()
+    {
+        scanner = new ImageScanner();
+        image = new Image();
+    }
+
+    @After public void tearDown ()
+    {
+        image = null;
+        scanner = null;
+        System.gc();
+    }
+
+    public static final String encoded_widths =
+        "9 111 212241113121211311141132 11111 311213121312121332111132 111 9";
+
+    protected void generateY800 ()
+    {
+        int width = 114, height = 85;
+        image.setSize(width, height);
+        image.setFormat("Y800");
+        int datalen = width * height;
+        byte[] data = new byte[datalen];
+
+        int y = 0;
+        int p = 0;
+        for(; y < 10 && y < height; y++)
+            for(int x = 0; x < width; x++)
+                data[p++] = -1;
+
+        for(; y < height - 10; y++) {
+            int x = 0;
+            byte color = -1;
+            CharacterIterator it = new StringCharacterIterator(encoded_widths);
+            for(char c = it.first();
+                c != CharacterIterator.DONE;
+                c = it.next())
+            {
+                if(c == ' ')
+                    continue;
+                for(int dx = (int)c - 0x30; dx > 0; dx--) {
+                    data[p++] = color;
+                    x++;
+                }
+                color = (byte)~color;
+            }
+            for(; x < width; x++)
+                data[p++] = (byte)~color;
+        }
+
+        for(; y < height; y++)
+            for(int x = 0; x < width; x++)
+                data[p++] = -1;
+        assert(p == datalen);
+
+        image.setData(data);
+    }
+
+    protected void checkResults (SymbolSet syms)
+    {
+        assertNotNull(syms);
+        assert(syms.size() == 1);
+        Iterator<Symbol> it = syms.iterator();
+        assertTrue(it.hasNext());
+        Symbol sym = it.next();
+        assertNotNull(sym);
+        assertFalse(it.hasNext());
+
+        assertEquals(Symbol.EAN13, sym.getType());
+        assertEquals(sym.EAN13, sym.getType()); // cached
+
+        assertTrue(sym.getQuality() > 1);
+        assertEquals(0, sym.getCount());
+
+        SymbolSet comps = sym.getComponents();
+        assertNotNull(comps);
+        assertEquals(0, comps.size());
+        it = comps.iterator();
+        assertNotNull(it);
+        assertFalse(it.hasNext());
+
+        String data = sym.getData();
+        assertEquals("6268964977804", data);
+
+        byte[] bytes = sym.getDataBytes();
+        byte[] exp = { '6','2','6','8','9','6','4','9','7','7','8','0','4' };
+        assertArrayEquals(exp, bytes);
+
+        int[] r = sym.getBounds();
+        assertTrue(r[0] > 6);
+        assertTrue(r[1] > 6);
+        assertTrue(r[2] < 102);
+        assertTrue(r[3] < 73);
+
+        assertEquals(Orientation.UP, sym.getOrientation());
+    }
+
+    @Test public void generated ()
+    {
+        generateY800();
+        int n = scanner.scanImage(image);
+        assertEquals(1, n);
+
+        checkResults(image.getSymbols());
+        checkResults(scanner.getResults());
+    }
+
+    @Test public void config ()
+    {
+        generateY800();
+        scanner.setConfig(Symbol.EAN13, Config.ENABLE, 0);
+        int n = scanner.scanImage(image);
+        assertEquals(0, n);
+    }
+
+    @Test public void cache ()
+    {
+        generateY800();
+        scanner.enableCache(true);
+
+        int n = 0;
+        for(int i = 0; i < 10; i++) {
+            n = scanner.scanImage(image);
+            if(n > 0) {
+                assertTrue(i > 1);
+                break;
+            }
+        }
+
+        assertEquals(1, n);
+        checkResults(scanner.getResults());
+    }
+
+    @Test public void orientation()
+    {
+        generateY800();
+
+        // flip the image
+        int width = image.getWidth();
+        int height = image.getHeight();
+        byte[] data = image.getData();
+        int p = 0;
+        for(int y = 0; y < height; y++) {
+            for(int x0 = 0; x0 < width / 2; x0++) {
+                int x1 = width - x0 - 1;
+                assert(x0 < x1);
+                byte b = data[p + x0];
+                data[p + x0] = data[p + x1];
+                data[p + x1] = b;
+            }
+            p += width;
+        }
+        image.setData(data);
+
+        int n = scanner.scanImage(image);
+        assertEquals(1, n);
+
+        SymbolSet syms = scanner.getResults();
+        assert(syms.size() == 1);
+        for(Symbol sym : syms) {
+            assertEquals(Symbol.EAN13, sym.getType());
+            assertEquals("6268964977804", sym.getData());
+            assertEquals(Orientation.DOWN, sym.getOrientation());
+        }
+    }
+}
diff --git a/java/zbarjni.c b/java/zbarjni.c
new file mode 100644
--- /dev/null
+++ b/java/zbarjni.c
@@ -0,0 +1,701 @@
+/*------------------------------------------------------------------------
+ *  Copyright 2010 (c) Jeff Brown <spadix@users.sourceforge.net>
+ *
+ *  This file is part of the ZBar Bar Code Reader.
+ *
+ *  The ZBar Bar Code Reader is free software; you can redistribute it
+ *  and/or modify it under the terms of the GNU Lesser Public License as
+ *  published by the Free Software Foundation; either version 2.1 of
+ *  the License, or (at your option) any later version.
+ *
+ *  The ZBar Bar Code Reader is distributed in the hope that it will be
+ *  useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+ *  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Lesser Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser Public License
+ *  along with the ZBar Bar Code Reader; if not, write to the Free
+ *  Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ *  Boston, MA  02110-1301  USA
+ *
+ *  http://sourceforge.net/projects/zbar
+ *------------------------------------------------------------------------*/
+#include <inttypes.h>
+#include <assert.h>
+#include <zbar.h>
+#include <jni.h>
+
+static jfieldID SymbolSet_peer;
+static jfieldID Symbol_peer;
+static jfieldID Image_peer, Image_data;
+static jfieldID ImageScanner_peer;
+
+static struct {
+    int SymbolSet_create, SymbolSet_destroy;
+    int Symbol_create, Symbol_destroy;
+    int Image_create, Image_destroy;
+    int ImageScanner_create, ImageScanner_destroy;
+} stats;
+
+
+#define PEER_CAST(l) \
+    ((void*)(uintptr_t)(l))
+
+#define GET_PEER(c, o) \
+    PEER_CAST((*env)->GetLongField(env, (o), c ## _peer))
+
+
+static inline void
+throw_exc(JNIEnv *env,
+          const char *name,
+          const char *msg)
+{
+    jclass cls = (*env)->FindClass(env, name);
+    if(cls)
+        (*env)->ThrowNew(env, cls, msg);
+    (*env)->DeleteLocalRef(env, cls);
+}
+
+static inline uint32_t
+format_to_fourcc(JNIEnv *env,
+                 jstring format)
+{
+    if(!format)
+        goto invalid;
+
+    int n = (*env)->GetStringLength(env, format);
+    if(0 >= n || n > 4)
+        goto invalid;
+
+    char fmtstr[8];
+    (*env)->GetStringUTFRegion(env, format, 0, n, fmtstr);
+
+    uint32_t fourcc = 0;
+    int i;
+    for(i = 0; i < n; i++) {
+        if(fmtstr[i] < ' ' || 'Z' < fmtstr[i] ||
+           ('9' < fmtstr[i] && fmtstr[i] < 'A') ||
+           (' ' < fmtstr[i] && fmtstr[i] < '0'))
+            goto invalid;
+        fourcc |= ((uint32_t)fmtstr[i]) << (8 * i);
+    }
+    return(fourcc);
+
+invalid:
+    throw_exc(env, "java/lang/IllegalArgumentException",
+              "invalid format fourcc");
+    return(0);
+}
+
+static JavaVM *jvm = NULL;
+
+JNIEXPORT jint JNICALL
+JNI_OnLoad (JavaVM *_jvm,
+            void *reserved)
+{
+    jvm = _jvm;
+    return(JNI_VERSION_1_2);
+}
+
+JNIEXPORT void JNICALL
+JNI_OnUnload (JavaVM *_jvm,
+              void *reserved)
+{
+    assert(stats.SymbolSet_create == stats.SymbolSet_destroy);
+    assert(stats.Symbol_create == stats.Symbol_destroy);
+    assert(stats.Image_create == stats.Image_destroy);
+    assert(stats.ImageScanner_create == stats.ImageScanner_destroy);
+}
+
+
+JNIEXPORT void JNICALL
+Java_net_sourceforge_zbar_SymbolSet_init (JNIEnv *env,
+                                          jclass cls)
+{
+    SymbolSet_peer = (*env)->GetFieldID(env, cls, "peer", "J");
+}
+
+JNIEXPORT void JNICALL
+Java_net_sourceforge_zbar_SymbolSet_destroy (JNIEnv *env,
+                                             jobject obj,
+                                             jlong peer)
+{
+    zbar_symbol_set_ref(PEER_CAST(peer), -1);
+    stats.SymbolSet_destroy++;
+}
+
+JNIEXPORT jint JNICALL
+Java_net_sourceforge_zbar_SymbolSet_size (JNIEnv *env,
+                                          jobject obj)
+{
+    zbar_symbol_set_t *zsyms = GET_PEER(SymbolSet, obj);
+    if(!zsyms)
+        return(0);
+    return(zbar_symbol_set_get_size(zsyms));
+}
+
+JNIEXPORT jlong JNICALL
+Java_net_sourceforge_zbar_SymbolSet_firstSymbol (JNIEnv *env,
+                                                 jobject obj,
+                                                 jlong peer)
+{
+    if(!peer)
+        return(0);
+    const zbar_symbol_t *zsym = zbar_symbol_set_first_symbol(PEER_CAST(peer));
+    if(zsym) {
+        zbar_symbol_ref(zsym, 1);
+        stats.Symbol_create++;
+    }
+    return((intptr_t)zsym);
+}
+
+
+
+JNIEXPORT void JNICALL
+Java_net_sourceforge_zbar_Symbol_init (JNIEnv *env,
+                                       jclass cls)
+{
+    Symbol_peer = (*env)->GetFieldID(env, cls, "peer", "J");
+}
+
+JNIEXPORT void JNICALL
+Java_net_sourceforge_zbar_Symbol_destroy (JNIEnv *env,
+                                          jobject obj,
+                                          jlong peer)
+{
+    zbar_symbol_ref(PEER_CAST(peer), -1);
+    stats.Symbol_destroy++;
+}
+
+JNIEXPORT jint JNICALL
+Java_net_sourceforge_zbar_Symbol_getType (JNIEnv *env,
+                                          jobject obj,
+                                          jlong peer)
+{
+    return(zbar_symbol_get_type(PEER_CAST(peer)));
+}
+
+JNIEXPORT jint JNICALL
+Java_net_sourceforge_zbar_Symbol_getConfigMask (JNIEnv *env,
+                                                jobject obj)
+{
+    return(zbar_symbol_get_configs(GET_PEER(Symbol, obj)));
+}
+
+JNIEXPORT jint JNICALL
+Java_net_sourceforge_zbar_Symbol_getModifierMask (JNIEnv *env,
+                                                  jobject obj)
+{
+    return(zbar_symbol_get_modifiers(GET_PEER(Symbol, obj)));
+}
+
+JNIEXPORT jstring JNICALL
+Java_net_sourceforge_zbar_Symbol_getData (JNIEnv *env,
+                                          jobject obj)
+{
+    const char *data = zbar_symbol_get_data(GET_PEER(Symbol, obj));
+    return((*env)->NewStringUTF(env, data));
+}
+
+JNIEXPORT jstring JNICALL
+Java_net_sourceforge_zbar_Symbol_getDataBytes (JNIEnv *env,
+                                               jobject obj)
+{
+    const zbar_symbol_t *zsym = GET_PEER(Symbol, obj);
+    const void *data = zbar_symbol_get_data(zsym);
+    unsigned long datalen = zbar_symbol_get_data_length(zsym);
+    if(!data || !datalen)
+        return(NULL);
+
+    jbyteArray bytes = (*env)->NewByteArray(env, datalen);
+    if(!bytes)
+        return(NULL);
+
+    (*env)->SetByteArrayRegion(env, bytes, 0, datalen, data);
+    return(bytes);
+}
+
+JNIEXPORT jint JNICALL
+Java_net_sourceforge_zbar_Symbol_getQuality (JNIEnv *env,
+                                             jobject obj)
+{
+    return(zbar_symbol_get_quality(GET_PEER(Symbol, obj)));
+}
+
+JNIEXPORT jint JNICALL
+Java_net_sourceforge_zbar_Symbol_getCount (JNIEnv *env,
+                                           jobject obj)
+{
+    return(zbar_symbol_get_count(GET_PEER(Symbol, obj)));
+}
+
+JNIEXPORT jint JNICALL
+Java_net_sourceforge_zbar_Symbol_getLocationSize (JNIEnv *env,
+                                                  jobject obj,
+                                                  jlong peer)
+{
+    return(zbar_symbol_get_loc_size(PEER_CAST(peer)));
+}
+
+JNIEXPORT jint JNICALL
+Java_net_sourceforge_zbar_Symbol_getLocationX (JNIEnv *env,
+                                               jobject obj,
+                                               jlong peer,
+                                               jint idx)
+{
+    return(zbar_symbol_get_loc_x(PEER_CAST(peer), idx));
+}
+
+JNIEXPORT jint JNICALL
+Java_net_sourceforge_zbar_Symbol_getLocationY (JNIEnv *env,
+                                               jobject obj,
+                                               jlong peer,
+                                               jint idx)
+{
+    return(zbar_symbol_get_loc_y(PEER_CAST(peer), idx));
+}
+
+JNIEXPORT jint JNICALL
+Java_net_sourceforge_zbar_Symbol_getOrientation (JNIEnv *env,
+                                                 jobject obj)
+{
+    return(zbar_symbol_get_orientation(GET_PEER(Symbol, obj)));
+}
+
+JNIEXPORT jlong JNICALL
+Java_net_sourceforge_zbar_Symbol_getComponents (JNIEnv *env,
+                                                jobject obj,
+                                                jlong peer)
+{
+    const zbar_symbol_set_t *zsyms =
+        zbar_symbol_get_components(PEER_CAST(peer));
+    if(zsyms) {
+        zbar_symbol_set_ref(zsyms, 1);
+        stats.SymbolSet_create++;
+    }
+    return((intptr_t)zsyms);
+}
+
+JNIEXPORT jlong JNICALL
+Java_net_sourceforge_zbar_Symbol_next (JNIEnv *env,
+                                       jobject obj)
+{
+    const zbar_symbol_t *zsym = zbar_symbol_next(GET_PEER(Symbol, obj));
+    if(zsym) {
+        zbar_symbol_ref(zsym, 1);
+        stats.Symbol_create++;
+    }
+    return((intptr_t)zsym);
+}
+
+
+
+static void
+Image_cleanupByteArray (zbar_image_t *zimg)
+{
+    jobject data = zbar_image_get_userdata(zimg);
+    assert(data);
+
+    JNIEnv *env = NULL;
+    if((*jvm)->AttachCurrentThread(jvm, (void**)&env, NULL))
+        return;
+    assert(env);
+    if(env && data) {
+        void *raw = (void*)zbar_image_get_data(zimg);
+        assert(raw);
+        /* const image data is unchanged - abort copy back */
+        (*env)->ReleaseByteArrayElements(env, data, raw, JNI_ABORT);
+        (*env)->DeleteGlobalRef(env, data);
+        zbar_image_set_userdata(zimg, NULL);
+    }
+}
+
+static void
+Image_cleanupIntArray (zbar_image_t *zimg)
+{
+    jobject data = zbar_image_get_userdata(zimg);
+    assert(data);
+
+    JNIEnv *env = NULL;
+    if((*jvm)->AttachCurrentThread(jvm, (void**)&env, NULL))
+        return;
+    assert(env);
+    if(env && data) {
+        void *raw = (void*)zbar_image_get_data(zimg);
+        assert(raw);
+        /* const image data is unchanged - abort copy back */
+        (*env)->ReleaseIntArrayElements(env, data, raw, JNI_ABORT);
+        (*env)->DeleteGlobalRef(env, data);
+        zbar_image_set_userdata(zimg, NULL);
+    }
+}
+
+
+JNIEXPORT void JNICALL
+Java_net_sourceforge_zbar_Image_init (JNIEnv *env,
+                                      jclass cls)
+{
+    Image_peer = (*env)->GetFieldID(env, cls, "peer", "J");
+    Image_data = (*env)->GetFieldID(env, cls, "data", "Ljava/lang/Object;");
+}
+
+JNIEXPORT jlong JNICALL
+Java_net_sourceforge_zbar_Image_create (JNIEnv *env,
+                                        jobject obj)
+{
+    zbar_image_t *zimg = zbar_image_create();
+    if(!zimg) {
+        throw_exc(env, "java/lang/OutOfMemoryError", NULL);
+        return(0);
+    }
+    stats.Image_create++;
+    return((intptr_t)zimg);
+}
+
+JNIEXPORT void JNICALL
+Java_net_sourceforge_zbar_Image_destroy (JNIEnv *env,
+                                         jobject obj,
+                                         jlong peer)
+{
+    zbar_image_ref(PEER_CAST(peer), -1);
+    stats.Image_destroy++;
+}
+
+JNIEXPORT jlong JNICALL
+Java_net_sourceforge_zbar_Image_convert (JNIEnv *env,
+                                         jobject obj,
+                                         jlong peer,
+                                         jstring format)
+{
+    uint32_t fourcc = format_to_fourcc(env, format);
+    if(!fourcc)
+        return(0);
+    zbar_image_t *zimg = zbar_image_convert(PEER_CAST(peer), fourcc);
+    if(!zimg)
+        throw_exc(env, "java/lang/UnsupportedOperationException",
+                  "unsupported image format");
+    else
+        stats.Image_create++;
+    return((intptr_t)zimg);
+}
+
+JNIEXPORT jstring JNICALL
+Java_net_sourceforge_zbar_Image_getFormat (JNIEnv *env,
+                                           jobject obj)
+{
+    uint32_t fourcc = zbar_image_get_format(GET_PEER(Image, obj));
+    if(!fourcc)
+        return(NULL);
+    char fmtstr[5] = { fourcc, fourcc >> 8, fourcc >> 16, fourcc >> 24, 0 };
+    return((*env)->NewStringUTF(env, fmtstr));
+}
+
+JNIEXPORT void JNICALL
+Java_net_sourceforge_zbar_Image_setFormat (JNIEnv *env,
+                                           jobject obj,
+                                           jstring format)
+{
+    uint32_t fourcc = format_to_fourcc(env, format);
+    if(!fourcc)
+        return;
+    zbar_image_set_format(GET_PEER(Image, obj), fourcc);
+}
+
+JNIEXPORT jint JNICALL
+Java_net_sourceforge_zbar_Image_getSequence (JNIEnv *env,
+                                             jobject obj)
+{
+    return(zbar_image_get_sequence(GET_PEER(Image, obj)));
+}
+
+JNIEXPORT void JNICALL
+Java_net_sourceforge_zbar_Image_setSequence (JNIEnv *env,
+                                             jobject obj,
+                                             jint seq)
+{
+    zbar_image_set_sequence(GET_PEER(Image, obj), seq);
+}
+
+JNIEXPORT jint JNICALL
+Java_net_sourceforge_zbar_Image_getWidth (JNIEnv *env,
+                                          jobject obj)
+{
+    return(zbar_image_get_width(GET_PEER(Image, obj)));
+}
+
+JNIEXPORT jint JNICALL
+Java_net_sourceforge_zbar_Image_getHeight (JNIEnv *env,
+                                           jobject obj)
+{
+    return(zbar_image_get_height(GET_PEER(Image, obj)));
+}
+
+JNIEXPORT jobject JNICALL
+Java_net_sourceforge_zbar_Image_getSize (JNIEnv *env,
+                                         jobject obj)
+{
+    jintArray size = (*env)->NewIntArray(env, 2);
+    if(!size)
+        return(NULL);
+
+    unsigned dims[2];
+    zbar_image_get_size(GET_PEER(Image, obj), dims, dims + 1);
+    jint jdims[2] = { dims[0], dims[1] };
+    (*env)->SetIntArrayRegion(env, size, 0, 2, jdims);
+    return(size);
+}
+
+JNIEXPORT void JNICALL
+Java_net_sourceforge_zbar_Image_setSize__II (JNIEnv *env,
+                                             jobject obj,
+                                             jint width,
+                                             jint height)
+{
+    if(width < 0) width = 0;
+    if(height < 0) height = 0;
+    zbar_image_set_size(GET_PEER(Image, obj), width, height);
+}
+
+JNIEXPORT void JNICALL
+Java_net_sourceforge_zbar_Image_setSize___3I (JNIEnv *env,
+                                              jobject obj,
+                                              jintArray size)
+{
+    if((*env)->GetArrayLength(env, size) != 2)
+        throw_exc(env, "java/lang/IllegalArgumentException",
+                  "size must be an array of two ints");
+    jint dims[2];
+    (*env)->GetIntArrayRegion(env, size, 0, 2, dims);
+    if(dims[0] < 0) dims[0] = 0;
+    if(dims[1] < 0) dims[1] = 0;
+    zbar_image_set_size(GET_PEER(Image, obj), dims[0], dims[1]);
+}
+
+JNIEXPORT jobject JNICALL
+Java_net_sourceforge_zbar_Image_getCrop (JNIEnv *env,
+                                         jobject obj)
+{
+    jintArray crop = (*env)->NewIntArray(env, 4);
+    if(!crop)
+        return(NULL);
+
+    unsigned dims[4];
+    zbar_image_get_crop(GET_PEER(Image, obj), dims, dims + 1,
+                        dims + 2, dims + 3);
+    jint jdims[4] = { dims[0], dims[1], dims[2], dims[3] };
+    (*env)->SetIntArrayRegion(env, crop, 0, 4, jdims);
+    return(crop);
+}
+
+#define VALIDATE_CROP(u, m) \
+    if((u) < 0) {           \
+        (m) += (u);         \
+        (u) = 0;            \
+    }
+
+JNIEXPORT void JNICALL
+Java_net_sourceforge_zbar_Image_setCrop__IIII (JNIEnv *env,
+                                               jobject obj,
+                                               jint x, jint y,
+                                               jint w, jint h)
+{
+    VALIDATE_CROP(x, w);
+    VALIDATE_CROP(y, h);
+    zbar_image_set_crop(GET_PEER(Image, obj), x, y, w, h);
+}
+
+JNIEXPORT void JNICALL
+Java_net_sourceforge_zbar_Image_setCrop___3I (JNIEnv *env,
+                                              jobject obj,
+                                              jintArray crop)
+{
+    if((*env)->GetArrayLength(env, crop) != 4)
+        throw_exc(env, "java/lang/IllegalArgumentException",
+                  "crop must be an array of four ints");
+    jint dims[4];
+    (*env)->GetIntArrayRegion(env, crop, 0, 4, dims);
+    VALIDATE_CROP(dims[0], dims[2]);
+    VALIDATE_CROP(dims[1], dims[3]);
+    zbar_image_set_crop(GET_PEER(Image, obj),
+                        dims[0], dims[1], dims[2], dims[3]);
+}
+#undef VALIDATE_CROP
+
+JNIEXPORT jobject JNICALL
+Java_net_sourceforge_zbar_Image_getData (JNIEnv *env,
+                                         jobject obj)
+{
+    jobject data = (*env)->GetObjectField(env, obj, Image_data);
+    if(data)
+        return(data);
+
+    zbar_image_t *zimg = GET_PEER(Image, obj);
+    data = zbar_image_get_userdata(zimg);
+    if(data)
+        return(data);
+
+    unsigned long rawlen = zbar_image_get_data_length(zimg);
+    const void *raw = zbar_image_get_data(zimg);
+    if(!rawlen || !raw)
+        return(NULL);
+
+    data = (*env)->NewByteArray(env, rawlen);
+    if(!data)
+        return(NULL);
+
+    (*env)->SetByteArrayRegion(env, data, 0, rawlen, raw);
+    (*env)->SetObjectField(env, obj, Image_data, data);
+    return(data);
+}
+
+static inline void
+Image_setData (JNIEnv *env,
+               jobject obj,
+               jbyteArray data,
+               void *raw,
+               unsigned long rawlen,
+               zbar_image_cleanup_handler_t *cleanup)
+{
+    if(!data)
+        cleanup = NULL;
+    (*env)->SetObjectField(env, obj, Image_data, data);
+    zbar_image_t *zimg = GET_PEER(Image, obj);
+    zbar_image_set_data(zimg, raw, rawlen, cleanup);
+    zbar_image_set_userdata(zimg, (*env)->NewGlobalRef(env, data));
+}
+
+JNIEXPORT void JNICALL
+Java_net_sourceforge_zbar_Image_setData___3B (JNIEnv *env,
+                                              jobject obj,
+                                              jbyteArray data)
+{
+    jbyte *raw = NULL;
+    unsigned long rawlen = 0;
+    if(data) {
+        raw = (*env)->GetByteArrayElements(env, data, NULL);
+        if(!raw)
+            return;
+        rawlen = (*env)->GetArrayLength(env, data);
+    }
+    Image_setData(env, obj, data, raw, rawlen, Image_cleanupByteArray);
+}
+
+JNIEXPORT void JNICALL
+Java_net_sourceforge_zbar_Image_setData___3I (JNIEnv *env,
+                                              jobject obj,
+                                              jintArray data)
+{
+    jint *raw = NULL;
+    unsigned long rawlen = 0;
+    if(data) {
+        raw = (*env)->GetIntArrayElements(env, data, NULL);
+        if(!raw)
+            return;
+        rawlen = (*env)->GetArrayLength(env, data) * sizeof(*raw);
+    }
+    Image_setData(env, obj, data, raw, rawlen, Image_cleanupIntArray);
+}
+
+JNIEXPORT jlong JNICALL
+Java_net_sourceforge_zbar_Image_getSymbols (JNIEnv *env,
+                                            jobject obj,
+                                            jlong peer)
+{
+    const zbar_symbol_set_t *zsyms = zbar_image_get_symbols(PEER_CAST(peer));
+    if(zsyms) {
+        zbar_symbol_set_ref(zsyms, 1);
+        stats.SymbolSet_create++;
+    }
+    return((intptr_t)zsyms);
+}
+
+
+JNIEXPORT void JNICALL
+Java_net_sourceforge_zbar_ImageScanner_init (JNIEnv *env,
+                                             jclass cls)
+{
+    ImageScanner_peer = (*env)->GetFieldID(env, cls, "peer", "J");
+}
+
+JNIEXPORT jlong JNICALL
+Java_net_sourceforge_zbar_ImageScanner_create (JNIEnv *env,
+                                               jobject obj)
+{
+    zbar_image_scanner_t *zscn = zbar_image_scanner_create();
+    if(!zscn) {
+        throw_exc(env, "java/lang/OutOfMemoryError", NULL);
+        return(0);
+    }
+    stats.ImageScanner_create++;
+    return((intptr_t)zscn);
+}
+
+JNIEXPORT void JNICALL
+Java_net_sourceforge_zbar_ImageScanner_destroy (JNIEnv *env,
+                                                jobject obj,
+                                                jlong peer)
+{
+    zbar_image_scanner_destroy(PEER_CAST(peer));
+    stats.ImageScanner_destroy++;
+}
+
+JNIEXPORT void JNICALL
+Java_net_sourceforge_zbar_ImageScanner_setConfig (JNIEnv *env,
+                                                  jobject obj,
+                                                  jint symbology,
+                                                  jint config,
+                                                  jint value)
+{
+    zbar_image_scanner_set_config(GET_PEER(ImageScanner, obj),
+                                  symbology, config, value);
+}
+
+JNIEXPORT void JNICALL
+Java_net_sourceforge_zbar_ImageScanner_parseConfig (JNIEnv *env,
+                                                    jobject obj,
+                                                    jstring cfg)
+{
+    const char *cfgstr = (*env)->GetStringUTFChars(env, cfg, NULL);
+    if(!cfgstr)
+        return;
+    if(zbar_image_scanner_parse_config(GET_PEER(ImageScanner, obj), cfgstr))
+        throw_exc(env, "java/lang/IllegalArgumentException",
+                  "unknown configuration");
+}
+
+JNIEXPORT void JNICALL
+Java_net_sourceforge_zbar_ImageScanner_enableCache (JNIEnv *env,
+                                                    jobject obj,
+                                                    jboolean enable)
+{
+    zbar_image_scanner_enable_cache(GET_PEER(ImageScanner, obj), enable);
+}
+
+JNIEXPORT jlong JNICALL
+Java_net_sourceforge_zbar_ImageScanner_getResults (JNIEnv *env,
+                                                   jobject obj,
+                                                   jlong peer)
+{
+    const zbar_symbol_set_t *zsyms =
+        zbar_image_scanner_get_results(PEER_CAST(peer));
+    if(zsyms) {
+        zbar_symbol_set_ref(zsyms, 1);
+        stats.SymbolSet_create++;
+    }
+    return((intptr_t)zsyms);
+}
+
+JNIEXPORT jint JNICALL
+Java_net_sourceforge_zbar_ImageScanner_scanImage (JNIEnv *env,
+                                                  jobject obj,
+                                                  jobject image)
+{
+    zbar_image_scanner_t *zscn = GET_PEER(ImageScanner, obj);
+    zbar_image_t *zimg = GET_PEER(Image, image);
+
+    int n = zbar_scan_image(zscn, zimg);
+    if(n < 0)
+        throw_exc(env, "java/lang/UnsupportedOperationException",
+                  "unsupported image format");
+    return(n);
+}
diff --git a/perl/Changes b/perl/Changes
--- a/perl/Changes
+++ b/perl/Changes
@@ -1,5 +1,17 @@
 Revision history for Perl extension Barcode::ZBar.
 
+current spadix
+	* add Symbol orientation and Decoder direction interfaces
+
+0.04  2009-10-23 spadix
+	* add result query interfaces to ImageScanner and Processor
+
+0.03  2009-09-24 spadix
+	* add support for binary symbol data
+	* fix symbol leaks
+	* add symbol quality metric
+	* add support for QR Code
+
 0.02  2009-04-16 spadix
 	* project name change: package becomes Barcode::ZBar
 
diff --git a/perl/README b/perl/README
--- a/perl/README
+++ b/perl/README
@@ -1,10 +1,11 @@
 Barcode::ZBar Perl module
 =========================
 
-The ZBar Bar Code Reader is a library for scanning and decoding bar
-codes from various sources such as video streams, image files or raw
-intensity sensors.  It supports EAN, UPC, Code 128, Code 39 and
-Interleaved 2 of 5.  These are the Perl bindings for the library.
+ZBar Bar Code Reader is an open source software suite for reading bar
+codes from various sources, such as video streams, image files and raw
+intensity sensors. It supports EAN-13/UPC-A, UPC-E, EAN-8, Code 128,
+Code 93, Code 39, Interleaved 2 of 5 and QR Code.  These are the Perl
+bindings for the library.
 
 Check the ZBar project home page for the latest release, mailing
 lists, etc.
@@ -34,4 +35,4 @@ COPYRIGHT AND LICENCE
 Licensed under the GNU Lesser General Public License, version 2.1.
 http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt
 
-Copyright 2008-2009 (c) Jeff Brown <spadix@users.sourceforge.net>
+Copyright 2008-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
diff --git a/perl/ZBar.pm b/perl/ZBar.pm
--- a/perl/ZBar.pm
+++ b/perl/ZBar.pm
@@ -1,5 +1,5 @@
 #------------------------------------------------------------------------
-#  Copyright 2008-2009 (c) Jeff Brown <spadix@users.sourceforge.net>
+#  Copyright 2008-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
 #
 #  This file is part of the ZBar Bar Code Reader.
 #
@@ -137,6 +137,56 @@ Dark area or colored bar segment.
 
 =back
 
+Decoder configuration constants:
+
+=over 4
+
+=item Config::ENABLE
+
+=item Config::ADD_CHECK
+
+=item Config::EMIT_CHECK
+
+=item Config::ASCII
+
+=item Config::MIN_LEN
+
+=item Config::MAX_LEN
+
+=item Config::POSITION
+
+=item Config::X_DENSITY
+
+=item Config::Y_DENSITY
+
+=back
+
+Symbology modifier constants:
+
+=over 4
+
+=item Modifier::GS1
+
+=item Modifier::AIM
+
+=back
+
+Symbol orientation constants:
+
+=over 4
+
+=item Orient::UNKNOWN
+
+=item Orient::UP
+
+=item Orient::RIGHT
+
+=item Orient::DOWN
+
+=item Orient::LEFT
+
+=back
+
 
 =head1 SEE ALSO
 
@@ -156,7 +206,7 @@ Jeff Brown, E<lt>spadix@users.sourceforg
 
 =head1 COPYRIGHT AND LICENSE
 
-Copyright 2008-2009 (c) Jeff Brown E<lt>spadix@users.sourceforge.netE<gt>
+Copyright 2008-2010 (c) Jeff Brown E<lt>spadix@users.sourceforge.netE<gt>
 
 The ZBar Bar Code Reader is free software; you can redistribute it
 and/or modify it under the terms of the GNU Lesser Public License as
diff --git a/perl/ZBar.xs b/perl/ZBar.xs
--- a/perl/ZBar.xs
+++ b/perl/ZBar.xs
@@ -1,5 +1,5 @@
 //------------------------------------------------------------------------
-//  Copyright 2008-2009 (c) Jeff Brown <spadix@users.sourceforge.net>
+//  Copyright 2008-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
 //
 //  This file is part of the ZBar Bar Code Reader.
 //
@@ -53,6 +53,8 @@ static AV *LOOKUP_zbar_color_t = NULL;
 static AV *LOOKUP_zbar_symbol_type_t = NULL;
 static AV *LOOKUP_zbar_error_t = NULL;
 static AV *LOOKUP_zbar_config_t = NULL;
+static AV *LOOKUP_zbar_modifier_t = NULL;
+static AV *LOOKUP_zbar_orientation_t = NULL;
 
 #define CONSTANT(typ, prefix, sym, name)                \
     do {                                                \
@@ -93,6 +95,15 @@ static inline void check_error (int rc, 
         }                                                               \
     } while(0);
 
+#define PUSH_ENUM_MASK(typ, TYP, val)                         \
+    do {                                                      \
+        unsigned mask = (val);                                \
+        int i;                                                \
+        for(i = 0; i < ZBAR_ ## TYP ## _NUM; i++, mask >>= 1) \
+            if(mask & 1)                                      \
+                XPUSHs(LOOKUP_ENUM(typ, i));                  \
+    } while(0);
+
 static void image_cleanup_handler (zbar_image_t *image)
 {
     SV *data = zbar_image_get_userdata(image);
@@ -151,7 +162,7 @@ static inline void activate_handler (han
     SAVETMPS;
 
     PUSHMARK(SP);
-    EXTEND(SP, 2);
+    EXTEND(SP, 3);
     PUSHs(sv_mortalcopy(wrap->instance));
     if(param)
         PUSHs(param);
@@ -277,11 +288,37 @@ BOOT:
         CONSTANT(config, CFG_, ASCII, "ascii");
         CONSTANT(config, CFG_, MIN_LEN, "min-length");
         CONSTANT(config, CFG_, MAX_LEN, "max-length");
+        CONSTANT(config, CFG_, UNCERTAINTY, "uncertainty");
         CONSTANT(config, CFG_, POSITION, "position");
         CONSTANT(config, CFG_, X_DENSITY, "x-density");
         CONSTANT(config, CFG_, Y_DENSITY, "y-density");
     }
 
+MODULE = Barcode::ZBar  PACKAGE = Barcode::ZBar::Modifier  PREFIX = zbar_mod_
+
+BOOT:
+    {
+        HV *stash = gv_stashpv("Barcode::ZBar::Modifier", TRUE);
+
+        LOOKUP_zbar_modifier_t = newAV();
+        CONSTANT(modifier, MOD_, GS1, "GS1");
+        CONSTANT(modifier, MOD_, AIM, "AIM");
+    }
+
+MODULE = Barcode::ZBar	PACKAGE = Barcode::ZBar::Orient	PREFIX = zbar_orientation_
+
+BOOT:
+    {
+        HV *stash = gv_stashpv("Barcode::ZBar::Orient", TRUE);
+
+        LOOKUP_zbar_orientation_t = newAV();
+        CONSTANT(orientation, ORIENT_, UNKNOWN, "UNKNOWN");
+        CONSTANT(orientation, ORIENT_, UP, "UP");
+        CONSTANT(orientation, ORIENT_, RIGHT, "RIGHT");
+        CONSTANT(orientation, ORIENT_, DOWN, "DOWN");
+        CONSTANT(orientation, ORIENT_, LEFT, "LEFT");
+    }
+
 
 MODULE = Barcode::ZBar	PACKAGE = Barcode::ZBar::Symbol	PREFIX = zbar_symbol_
 
@@ -298,10 +335,14 @@ BOOT:
         CONSTANT(symbol_type, , UPCA, zbar_get_symbol_name(ZBAR_UPCA));
         CONSTANT(symbol_type, , EAN13, zbar_get_symbol_name(ZBAR_EAN13));
         CONSTANT(symbol_type, , ISBN13, zbar_get_symbol_name(ZBAR_ISBN13));
+        CONSTANT(symbol_type, , DATABAR, zbar_get_symbol_name(ZBAR_DATABAR));
+        CONSTANT(symbol_type, , DATABAR_EXP,
+                 zbar_get_symbol_name(ZBAR_DATABAR_EXP));
         CONSTANT(symbol_type, , I25, zbar_get_symbol_name(ZBAR_I25));
         CONSTANT(symbol_type, , CODE39, zbar_get_symbol_name(ZBAR_CODE39));
         CONSTANT(symbol_type, , PDF417, zbar_get_symbol_name(ZBAR_PDF417));
         CONSTANT(symbol_type, , QRCODE, zbar_get_symbol_name(ZBAR_QRCODE));
+        CONSTANT(symbol_type, , CODE93, zbar_get_symbol_name(ZBAR_CODE93));
         CONSTANT(symbol_type, , CODE128, zbar_get_symbol_name(ZBAR_CODE128));
     }
 
@@ -316,6 +357,18 @@ zbar_symbol_get_type(symbol)
 	Barcode::ZBar::Symbol symbol
 
 SV *
+zbar_symbol_get_configs(symbol)
+	Barcode::ZBar::Symbol	symbol
+    PPCODE:
+        PUSH_ENUM_MASK(config, CFG, zbar_symbol_get_configs(symbol));
+
+SV *
+zbar_symbol_get_modifiers(symbol)
+	Barcode::ZBar::Symbol	symbol
+    PPCODE:
+        PUSH_ENUM_MASK(modifier, MOD, zbar_symbol_get_modifiers(symbol));
+
+SV *
 zbar_symbol_get_data(symbol)
 	Barcode::ZBar::Symbol symbol
     CODE:
@@ -347,6 +400,10 @@ zbar_symbol_get_loc(symbol)
             av_push(pt, newSVuv(zbar_symbol_get_loc_y(symbol, i)));
         }
 
+zbar_orientation_t
+zbar_symbol_get_orientation(symbol)
+	Barcode::ZBar::Symbol symbol
+
 SV *
 get_components(symbol)
         Barcode::ZBar::Symbol	symbol
@@ -398,6 +455,19 @@ get_size(image)
         mPUSHu(zbar_image_get_width(image));
         mPUSHu(zbar_image_get_height(image));
 
+void
+get_crop(image)
+        Barcode::ZBar::Image	image
+    PREINIT:
+        unsigned x, y, w, h;
+    PPCODE:
+        zbar_image_get_crop(image, &x, &y, &w, &h);
+        EXTEND(SP, 4);
+        mPUSHu(x);
+        mPUSHu(y);
+        mPUSHu(w);
+        mPUSHu(h);
+
 SV *
 zbar_image_get_data(image)
         Barcode::ZBar::Image	image
@@ -426,8 +496,16 @@ zbar_image_set_sequence(image, seq_num)
 void
 zbar_image_set_size(image, width, height)
         Barcode::ZBar::Image	image
-	unsigned	width
-	unsigned	height
+        int	width + if(width < 0) width = 0;
+        int	height + if(height < 0) height = 0;
+
+void
+zbar_image_set_crop(image, x, y, width, height)
+        Barcode::ZBar::Image	image
+        int	x + if(x < 0) { width += x; x = 0; }
+        int	y + if(y < 0) { height += y; y = 0; }
+        int	width
+        int	height
 
 void
 zbar_image_set_data(image, data)
@@ -712,6 +790,25 @@ zbar_symbol_type_t
 zbar_decoder_get_type(decoder)
 	Barcode::ZBar::Decoder	decoder
 
+SV *
+zbar_decoder_get_configs(decoder, symbology)
+	Barcode::ZBar::Decoder	decoder
+        zbar_symbol_type_t	symbology
+    PPCODE:
+        if(symbology == ZBAR_NONE)
+            symbology = zbar_decoder_get_type(decoder)
+        PUSH_ENUM_MASK(config, CFG, zbar_decoder_get_configs(decoder, symbology));
+
+SV *
+zbar_decoder_get_modifiers(decoder)
+	Barcode::ZBar::Decoder	decoder
+    PPCODE:
+        PUSH_ENUM_MASK(modifier, MOD, zbar_decoder_get_modifiers(decoder));
+
+int
+zbar_decoder_get_direction(decoder)
+	Barcode::ZBar::Decoder	decoder
+
 void
 zbar_decoder_set_handler(decoder, handler = 0, closure = 0)
 	Barcode::ZBar::Decoder	decoder
diff --git a/perl/ZBar/Image.pod b/perl/ZBar/Image.pod
--- a/perl/ZBar/Image.pod
+++ b/perl/ZBar/Image.pod
@@ -132,7 +132,7 @@ Jeff Brown, E<lt>spadix@users.sourceforg
 
 =head1 COPYRIGHT AND LICENSE
 
-Copyright 2008-2009 (c) Jeff Brown E<lt>spadix@users.sourceforge.netE<gt>
+Copyright 2008-2010 (c) Jeff Brown E<lt>spadix@users.sourceforge.netE<gt>
 
 The ZBar Bar Code Reader is free software; you can redistribute it
 and/or modify it under the terms of the GNU Lesser Public License as
diff --git a/perl/ZBar/ImageScanner.pod b/perl/ZBar/ImageScanner.pod
--- a/perl/ZBar/ImageScanner.pod
+++ b/perl/ZBar/ImageScanner.pod
@@ -89,7 +89,7 @@ Jeff Brown, E<lt>spadix@users.sourceforg
 
 =head1 COPYRIGHT AND LICENSE
 
-Copyright 2008-2009 (c) Jeff Brown E<lt>spadix@users.sourceforge.netE<gt>
+Copyright 2008-2010 (c) Jeff Brown E<lt>spadix@users.sourceforge.netE<gt>
 
 The ZBar Bar Code Reader is free software; you can redistribute it
 and/or modify it under the terms of the GNU Lesser Public License as
diff --git a/perl/ZBar/Processor.pod b/perl/ZBar/Processor.pod
--- a/perl/ZBar/Processor.pod
+++ b/perl/ZBar/Processor.pod
@@ -137,7 +137,7 @@ Jeff Brown, E<lt>spadix@users.sourceforg
 
 =head1 COPYRIGHT AND LICENSE
 
-Copyright 2008-2009 (c) Jeff Brown E<lt>spadix@users.sourceforge.netE<gt>
+Copyright 2008-2010 (c) Jeff Brown E<lt>spadix@users.sourceforge.netE<gt>
 
 The ZBar Bar Code Reader is free software; you can redistribute it
 and/or modify it under the terms of the GNU Lesser Public License as
diff --git a/perl/ZBar/Symbol.pod b/perl/ZBar/Symbol.pod
--- a/perl/ZBar/Symbol.pod
+++ b/perl/ZBar/Symbol.pod
@@ -1,5 +1,5 @@
 #------------------------------------------------------------------------
-#  Copyright 2008-2009 (c) Jeff Brown <spadix@users.sourceforge.net>
+#  Copyright 2008-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
 #
 #  This file is part of the ZBar Bar Code Reader.
 #
@@ -72,6 +72,12 @@ Current cache count of the symbol.  This
 inter-scan reliability and redundancy information if enabled at the
 Barcode::ZBar::ImageScanner.
 
+=item get_orientation()
+
+General orientation of decoded symbol.  This returns one of the
+Barcode::ZBar::Orient constants, which provide a coarse, axis-aligned
+indication of symbol orientation.
+
 =item get_components()
 
 Components of a composite result.  This yields an array of physical
@@ -122,6 +128,8 @@ Bar code type "symbology" constants:
 
 =item CODE39
 
+=item CODE93
+
 =item CODE128
 
 =item QRCODE
@@ -144,7 +152,7 @@ Jeff Brown, E<lt>spadix@users.sourceforg
 
 =head1 COPYRIGHT AND LICENSE
 
-Copyright 2008-2009 (c) Jeff Brown E<lt>spadix@users.sourceforge.netE<gt>
+Copyright 2008-2010 (c) Jeff Brown E<lt>spadix@users.sourceforge.netE<gt>
 
 The ZBar Bar Code Reader is free software; you can redistribute it
 and/or modify it under the terms of the GNU Lesser Public License as
diff --git a/perl/t/Decoder.t b/perl/t/Decoder.t
--- a/perl/t/Decoder.t
+++ b/perl/t/Decoder.t
@@ -3,7 +3,7 @@
 
 use warnings;
 use strict;
-use Test::More tests => 13;
+use Test::More tests => 17;
 
 #########################
 
@@ -19,7 +19,8 @@ isa_ok($decoder, 'Barcode::ZBar::Decoder
 #########################
 
 can_ok($decoder, qw(set_config parse_config reset new_scan decode_width
-                    get_color get_data get_type set_handler));
+                    get_color get_configs get_direction get_data get_modifiers
+                    get_type set_handler));
 
 #########################
 
@@ -58,6 +59,10 @@ is($decoder->get_color(), Barcode::ZBar:
 
 #########################
 
+is($decoder->get_direction(), 0, 'reset direction');
+
+#########################
+
 $decoder->set_config(Barcode::ZBar::Symbol::QRCODE,
                      Barcode::ZBar::Config::ENABLE, 0);
 
@@ -74,6 +79,17 @@ is($sym, Barcode::ZBar::Symbol::EAN13, '
 
 #########################
 
+is_deeply([$decoder->get_configs($sym)],
+          [Barcode::ZBar::Config::ENABLE,
+           Barcode::ZBar::Config::EMIT_CHECK],
+          'read configs');
+
+#########################
+
+is_deeply([$decoder->get_modifiers()], [], 'read modifiers');
+
+#########################
+
 is($decoder->get_data(), '6268964977804', 'EAN-13 data');
 
 #########################
@@ -82,6 +98,10 @@ is($decoder->get_color(), Barcode::ZBar:
 
 #########################
 
+is($decoder->get_direction(), 1, 'decode direction');
+
+#########################
+
 is($handler_type, Barcode::ZBar::Symbol::EAN13, 'handler type');
 
 #########################
diff --git a/perl/t/Image.t b/perl/t/Image.t
--- a/perl/t/Image.t
+++ b/perl/t/Image.t
@@ -3,7 +3,7 @@
 
 use warnings;
 use strict;
-use Test::More tests => 22;
+use Test::More tests => 29;
 
 #########################
 
@@ -48,6 +48,26 @@ is_deeply([$image->get_size()], [114, 80
 
 #########################
 
+$image->set_crop(20, 20, 74, 40);
+is_deeply([$image->get_crop()], [20, 20, 74, 40], 'crop accessors');
+
+#########################
+
+$image->set_crop(-57, -40, 228, 160);
+is_deeply([$image->get_crop()], [0, 0, 114, 80], 'crop clipping');
+
+#########################
+
+$image->set_crop(10, 10, 94, 60);
+is_deeply([$image->get_crop()], [10, 10, 94, 60], 'crop accessors');
+
+#########################
+
+$image->set_size(114, 80);
+is_deeply([$image->get_crop()], [0, 0, 114, 80], 'crop reset');
+
+#########################
+
 # FIXME avoid skipping these (eg embed image vs ImageMagick)
 SKIP: {
     eval { require Image::Magick };
@@ -94,7 +114,8 @@ SKIP: {
 
     #########################
 
-    can_ok($sym, qw(get_type get_data get_quality get_count get_loc));
+    can_ok($sym, qw(get_type get_configs get_modifiers get_data get_quality
+                    get_count get_loc get_orientation));
 
     #########################
 
@@ -102,6 +123,17 @@ SKIP: {
 
     #########################
 
+    is_deeply([$sym->get_configs()],
+              [Barcode::ZBar::Config::ENABLE,
+               Barcode::ZBar::Config::EMIT_CHECK],
+              'result configs');
+
+    #########################
+
+    is_deeply([$sym->get_modifiers()], [], 'result modifiers');
+
+    #########################
+
     is($sym->get_data(), '9876543210128', 'result data');
 
     #########################
@@ -133,6 +165,10 @@ SKIP: {
 
     #########################
 
+    is($sym->get_orientation(), Barcode::ZBar::Orient::UP, 'orientation');
+
+    #########################
+
     my @comps = $sym->get_components();
     is(scalar(@comps), 0, 'components size');
 
diff --git a/perl/t/ZBar.t b/perl/t/ZBar.t
--- a/perl/t/ZBar.t
+++ b/perl/t/ZBar.t
@@ -3,7 +3,7 @@
 
 use warnings;
 use strict;
-use Test::More tests => 3;
+use Test::More tests => 37;
 
 #########################
 
@@ -20,3 +20,49 @@ Barcode::ZBar::increase_verbosity();
 pass('verbosity');
 
 #########################
+
+# performs (2 * n) tests
+sub test_enum {
+    my $name = shift;
+    foreach my $test (@_) {
+        my $enum = $test->[0];
+
+        is($enum, $test->[1], "$name enum/string compare");
+
+        #########################
+
+        ok($enum == $test->[2], "$name enum/numeric compare");
+    }
+}
+
+test_enum('config',
+    [Barcode::ZBar::Config::ENABLE,      'enable',        0],
+    [Barcode::ZBar::Config::ADD_CHECK,   'add-check',     1],
+    [Barcode::ZBar::Config::EMIT_CHECK,  'emit-check',    2],
+    [Barcode::ZBar::Config::ASCII,       'ascii',         3],
+    [Barcode::ZBar::Config::MIN_LEN,     'min-length',   32],
+    [Barcode::ZBar::Config::MAX_LEN,     'max-length',   33],
+    [Barcode::ZBar::Config::UNCERTAINTY, 'uncertainty',  64],
+    [Barcode::ZBar::Config::POSITION,    'position',    128],
+    [Barcode::ZBar::Config::X_DENSITY,   'x-density',   256],
+    [Barcode::ZBar::Config::Y_DENSITY,   'y-density',   257],
+);
+
+#########################
+
+test_enum('modifier',
+    [Barcode::ZBar::Modifier::GS1, 'GS1', 0],
+    [Barcode::ZBar::Modifier::AIM, 'AIM', 1],
+);
+
+#########################
+
+test_enum('orientation',
+    [Barcode::ZBar::Orient::UNKNOWN, 'UNKNOWN', -1],
+    [Barcode::ZBar::Orient::UP,      'UP',       0],
+    [Barcode::ZBar::Orient::RIGHT,   'RIGHT',    1],
+    [Barcode::ZBar::Orient::DOWN,    'DOWN',     2],
+    [Barcode::ZBar::Orient::LEFT,    'LEFT',     3],
+);
+
+#########################
diff --git a/perl/typemap b/perl/typemap
--- a/perl/typemap
+++ b/perl/typemap
@@ -14,6 +14,8 @@ zbar_color_t					T_ENUM
 zbar_error_t					T_ENUM
 zbar_symbol_type_t				T_ENUM
 zbar_config_t					T_ENUM
+zbar_modifier_t                                 T_ENUM
+zbar_orientation_t				T_ENUM
 
 # special scalars
 fourcc_t					T_FOURCC
@@ -30,14 +32,8 @@ T_ENUM
 T_FOURCC
 	{
             if(SvPOK($arg)) {
-                STRLEN len;
-                char *str = SvPV($arg, len);
-                if(len != 4)
-                    croak(\"invalid fourcc: \%s\", str);
-                $var = ((unsigned long)str[0] |
-                        ((unsigned long)str[1] << 8) |
-                        ((unsigned long)str[2] << 16) |
-                        ((unsigned long)str[3] << 24));
+                char *str = SvPV_nolen($arg);
+                $var = zbar_fourcc_parse(str);
             }
             else
                 $var = SvUV($arg);
diff --git a/python/MANIFEST.in b/python/MANIFEST.in
new file mode 100644
--- /dev/null
+++ b/python/MANIFEST.in
@@ -0,0 +1,2 @@
+include MANIFEST MANIFEST.in zbarmodule.h test/barcode.png
+recursive-include examples *.py
diff --git a/python/Makefile.am.inc b/python/Makefile.am.inc
--- a/python/Makefile.am.inc
+++ b/python/Makefile.am.inc
@@ -9,4 +9,5 @@ python_zbar_la_SOURCES = python/zbarmodu
     python/symboliter.c python/image.c \
     python/processor.c python/imagescanner.c python/decoder.c python/scanner.c
 
-EXTRA_DIST += python/test/barcode.png python/test/test_zbar.py
+EXTRA_DIST += python/test/barcode.png python/test/test_zbar.py \
+    python/examples/processor.py python/examples/read_one.py
diff --git a/python/README b/python/README
new file mode 100644
--- /dev/null
+++ b/python/README
@@ -0,0 +1,59 @@
+==========================================
+zbar -- read barcodes from images or video
+==========================================
+
+ZBar Bar Code Reader is an open source software suite for reading bar
+codes from various sources, such as video streams, image files and raw
+intensity sensors. It supports EAN-13/UPC-A, UPC-E, EAN-8, Code 128,
+Code 93, Code 39, Interleaved 2 of 5 and QR Code.  These are the
+Python bindings for the library.
+
+Check the ZBar project home page for the latest release, mailing
+lists, etc.
+
+* http://zbar.sourceforge.net/
+
+Installation
+------------
+
+To install this module type the following::
+
+   python setup.py install
+
+Dependencies
+------------
+
+This module requires the ZBar Bar Code Reader, which may be obtained
+from:
+
+* http://zbar.sourceforge.net/
+
+Windows users please note: the module *will NOT load* unless the ZBar
+library DLL (currently libzbar-0.dll) is available in your PATH!
+
+Examples
+--------
+
+To scan an image, wrap the raw image data in a ``zbar.Image`` and feed
+it to a ``zbar.ImageScanner``::
+
+    import zbar
+    scanner = zbar.ImageScanner()
+    image = zbar.Image(width, height, 'Y800', raw_data)
+    scanner.scan(image)
+    for symbol in image:
+        print 'decoded', symbol.type, 'symbol', '"%s"' % symbol.data
+
+Complete, runnable examples may be found in the source distribution,
+under the ``examples/`` directory.  A couple of HOWTOs_ that cover
+programming with the library may be found on the project wiki.
+
+.. _HOWTOs: http://sourceforge.net/apps/mediawiki/zbar/index.php?title=Category:HOWTOs
+
+Copyright and License
+---------------------
+
+Licensed under the GNU Lesser General Public License, version 2.1.
+http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt
+
+Copyright 2008-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
diff --git a/python/decoder.c b/python/decoder.c
--- a/python/decoder.c
+++ b/python/decoder.c
@@ -1,5 +1,5 @@
 /*------------------------------------------------------------------------
- *  Copyright 2009 (c) Jeff Brown <spadix@users.sourceforge.net>
+ *  Copyright 2009-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
  *
  *  This file is part of the ZBar Bar Code Reader.
  *
@@ -104,6 +104,23 @@ decoder_get_type (zbarDecoder *self,
 }
 
 static PyObject*
+decoder_get_configs (zbarDecoder *self,
+                     void *closure)
+{
+    unsigned int sym = zbar_decoder_get_type(self->zdcode);
+    unsigned int mask = zbar_decoder_get_configs(self->zdcode, sym);
+    return(zbarEnum_SetFromMask(config_enum, mask));
+}
+
+static PyObject*
+decoder_get_modifiers (zbarDecoder *self,
+                       void *closure)
+{
+    unsigned int mask = zbar_decoder_get_modifiers(self->zdcode);
+    return(zbarEnum_SetFromMask(modifier_enum, mask));
+}
+
+static PyObject*
 decoder_get_data (zbarDecoder *self,
                   void *closure)
 {
@@ -111,10 +128,20 @@ decoder_get_data (zbarDecoder *self,
                                       zbar_decoder_get_data_length(self->zdcode)));
 }
 
+static PyObject*
+decoder_get_direction (zbarDecoder *self,
+                       void *closure)
+{
+    return(PyInt_FromLong(zbar_decoder_get_direction(self->zdcode)));
+}
+
 static PyGetSetDef decoder_getset[] = {
-    { "color",    (getter)decoder_get_color, },
-    { "type",     (getter)decoder_get_type, },
-    { "data",     (getter)decoder_get_data, },
+    { "color",     (getter)decoder_get_color, },
+    { "type",      (getter)decoder_get_type, },
+    { "configs",   (getter)decoder_get_configs, },
+    { "modifiers", (getter)decoder_get_modifiers, },
+    { "data",      (getter)decoder_get_data, },
+    { "direction", (getter)decoder_get_direction },
     { NULL, },
 };
 
@@ -139,6 +166,23 @@ decoder_set_config (zbarDecoder *self,
 }
 
 static PyObject*
+decoder_get_configs_meth (zbarDecoder *self,
+                          PyObject *args,
+                          PyObject *kwds)
+{
+    zbar_symbol_type_t sym = ZBAR_NONE;
+    static char *kwlist[] = { "symbology", NULL };
+    if(!PyArg_ParseTupleAndKeywords(args, kwds, "|i", kwlist, &sym))
+        return(NULL);
+
+    if(sym == ZBAR_NONE)
+        sym = zbar_decoder_get_type(self->zdcode);
+
+    unsigned int mask = zbar_decoder_get_configs(self->zdcode, sym);
+    return(zbarEnum_SetFromMask(config_enum, mask));
+}
+
+static PyObject*
 decoder_parse_config (zbarDecoder *self,
                       PyObject *args,
                       PyObject *kwds)
@@ -262,6 +306,8 @@ decoder_decode_width (zbarDecoder *self,
 static PyMethodDef decoder_methods[] = {
     { "set_config",   (PyCFunction)decoder_set_config,
       METH_VARARGS | METH_KEYWORDS, },
+    { "get_configs",  (PyCFunction)decoder_get_configs_meth,
+      METH_VARARGS | METH_KEYWORDS, },
     { "parse_config", (PyCFunction)decoder_parse_config,
       METH_VARARGS | METH_KEYWORDS, },
     { "reset",        (PyCFunction)decoder_reset,
diff --git a/python/enum.c b/python/enum.c
--- a/python/enum.c
+++ b/python/enum.c
@@ -1,5 +1,5 @@
 /*------------------------------------------------------------------------
- *  Copyright 2009 (c) Jeff Brown <spadix@users.sourceforge.net>
+ *  Copyright 2009-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
  *
  *  This file is part of the ZBar Bar Code Reader.
  *
@@ -192,3 +192,31 @@ zbarEnum_Add (zbarEnum *self,
         return(-1);
     return(0);
 }
+
+zbarEnumItem*
+zbarEnum_LookupValue (zbarEnum *self,
+                      int val)
+{
+    PyObject *key = PyInt_FromLong(val);
+    zbarEnumItem *e = (zbarEnumItem*)PyDict_GetItem(self->byvalue, key);
+    if(!e)
+        return((zbarEnumItem*)key);
+    Py_INCREF((PyObject*)e);
+    Py_DECREF(key);
+    return(e);
+}
+
+PyObject*
+zbarEnum_SetFromMask (zbarEnum *self,
+                      unsigned int mask)
+{
+    PyObject *result = PySet_New(NULL);
+    PyObject *key, *item;
+    Py_ssize_t i = 0;
+    while(PyDict_Next(self->byvalue, &i, &key, &item)) {
+        int val = PyInt_AsLong(item);
+        if(val < sizeof(mask) * 8 && ((mask >> val) & 1))
+            PySet_Add(result, item);
+    }
+    return(result);
+}
diff --git a/examples/processor.py b/python/examples/processor.py
rename from examples/processor.py
rename to python/examples/processor.py
diff --git a/examples/read_one.py b/python/examples/read_one.py
rename from examples/read_one.py
rename to python/examples/read_one.py
diff --git a/examples/scan_image.py b/python/examples/scan_image.py
rename from examples/scan_image.py
rename to python/examples/scan_image.py
diff --git a/python/image.c b/python/image.c
--- a/python/image.c
+++ b/python/image.c
@@ -1,5 +1,5 @@
 /*------------------------------------------------------------------------
- *  Copyright 2009 (c) Jeff Brown <spadix@users.sourceforge.net>
+ *  Copyright 2009-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
  *
  *  This file is part of the ZBar Bar Code Reader.
  *
@@ -139,16 +139,18 @@ image_set_format (zbarImage *self,
         PyErr_SetString(PyExc_TypeError, "cannot delete format attribute");
         return(-1);
     }
-    char *format;
+    char *format = NULL;
     Py_ssize_t len;
     if(PyString_AsStringAndSize(value, &format, &len) ||
        !format || len != 4) {
+        if(!format)
+            format = "(nil)";
         PyErr_Format(PyExc_ValueError,
                      "format '%.50s' is not a valid four character code",
                      format);
         return(-1);
     }
-    zbar_image_set_format(self->zimg,*((unsigned long*)format));
+    zbar_image_set_format(self->zimg, zbar_fourcc_parse(format));
     return(0);
 }
 
@@ -156,9 +158,9 @@ static PyObject*
 image_get_size (zbarImage *self,
                 void *closure)
 {
-    unsigned int width = zbar_image_get_width(self->zimg);
-    unsigned int height = zbar_image_get_height(self->zimg);
-    return(PyTuple_Pack(2, PyInt_FromLong(width), PyInt_FromLong(height)));
+    unsigned int w, h;
+    zbar_image_get_size(self->zimg, &w, &h);
+    return(PyTuple_Pack(2, PyInt_FromLong(w), PyInt_FromLong(h)));
 }
 
 static int
@@ -170,33 +172,82 @@ image_set_size (zbarImage *self,
         PyErr_SetString(PyExc_TypeError, "cannot delete size attribute");
         return(-1);
     }
-    int rc = -1;
-    PyObject *wobj = NULL, *hobj = NULL;
+    int rc = -1, i, dims[2];
     if(!PySequence_Check(value) ||
        PySequence_Size(value) != 2)
         goto error;
-    wobj = PySequence_GetItem(value, 0);
-    hobj = PySequence_GetItem(value, 1);
-    if(!wobj || !hobj)
-        goto error;
+    for(i = 0; i < 2; i++) {
+        PyObject *dim = PySequence_GetItem(value, i);
+        if(!dim)
+            goto error;
+        dims[i] = PyInt_AsSsize_t(dim);
+        Py_DECREF(dim);
+        if(dims[i] < 0)
+            goto error;
+    }
 
-    int width = PyInt_AsSsize_t(wobj);
-    if(width == -1 && PyErr_Occurred())
-        goto error;
-
-    int height = PyInt_AsSsize_t(hobj);
-    if(height == -1 && PyErr_Occurred())
-        goto error;
-
-    zbar_image_set_size(self->zimg, width, height);
+    zbar_image_set_size(self->zimg, dims[0], dims[1]);
     rc = 0;
 
 error:
-    Py_XDECREF(wobj);
-    Py_XDECREF(hobj);
     if(rc)
         PyErr_SetString(PyExc_ValueError,
-                        "size must be a sequence of two ints");
+                        "size must be a sequence of two positive ints");
+    return(rc);
+}
+
+static PyObject*
+image_get_crop (zbarImage *self,
+                void *closure)
+{
+    unsigned int x, y, w, h;
+    zbar_image_get_crop(self->zimg, &x, &y, &w, &h);
+    return(PyTuple_Pack(4, PyInt_FromLong(x), PyInt_FromLong(y),
+                        PyInt_FromLong(w), PyInt_FromLong(h)));
+}
+
+static int
+image_set_crop (zbarImage *self,
+                PyObject *value,
+                void *closure)
+{
+    unsigned w, h;
+    zbar_image_get_size(self->zimg, &w, &h);
+    if(!value) {
+        zbar_image_set_crop(self->zimg, 0, 0, w, h);
+        return(0);
+    }
+    int rc = -1, i, dims[4];
+    if(!PySequence_Check(value) ||
+       PySequence_Size(value) != 4)
+        goto error;
+    for(i = 0; i < 4; i++) {
+        PyObject *dim = PySequence_GetItem(value, i);
+        if(!dim)
+            goto error;
+        dims[i] = PyInt_AsSsize_t(dim);
+        Py_DECREF(dim);
+        if(dims[i] == -1 && PyErr_Occurred())
+            goto error;
+    }
+    if(dims[2] < 0 || dims[3] < 0)
+        goto error;
+    if(dims[0] < 0) {
+        dims[2] += dims[0];
+        dims[0] = 0;
+    }
+    if(dims[1] < 0) {
+        dims[3] += dims[1];
+        dims[1] = 0;
+    }
+
+    zbar_image_set_crop(self->zimg, dims[0], dims[1], dims[2], dims[3]);
+    rc = 0;
+
+error:
+    if(rc)
+        PyErr_SetString(PyExc_ValueError,
+                        "crop must be a sequence of four positive ints");
     return(rc);
 }
 
@@ -308,6 +359,7 @@ image_set_data (zbarImage *self,
 static PyGetSetDef image_getset[] = {
     { "format",   (getter)image_get_format, (setter)image_set_format, },
     { "size",     (getter)image_get_size,   (setter)image_set_size, },
+    { "crop",     (getter)image_get_crop,   (setter)image_set_crop, },
     { "width",    (getter)image_get_int,    (setter)image_set_int,
       NULL, (void*)0 },
     { "height",   (getter)image_get_int,    (setter)image_set_int,
@@ -359,6 +411,7 @@ image_convert (zbarImage *self,
                      format);
         return(NULL);
     }
+    unsigned long fourcc = zbar_fourcc_parse(format);
 
     zbarImage *img = PyObject_GC_New(zbarImage, &zbarImage_Type);
     if(!img)
@@ -366,11 +419,9 @@ image_convert (zbarImage *self,
     img->data = NULL;
     if(width > 0 && height > 0)
         img->zimg =
-            zbar_image_convert_resize(self->zimg,
-                                       *((unsigned long*)format),
-                                       width, height);
+            zbar_image_convert_resize(self->zimg, fourcc, width, height);
     else
-        img->zimg = zbar_image_convert(self->zimg, *((unsigned long*)format));
+        img->zimg = zbar_image_convert(self->zimg, fourcc);
 
     if(!img->zimg) {
         /* FIXME propagate exception */
diff --git a/python/setup.py b/python/setup.py
new file mode 100755
--- /dev/null
+++ b/python/setup.py
@@ -0,0 +1,44 @@
+#!/usr/bin/env python
+from distutils.core import setup, Extension
+
+setup(
+    name = 'zbar',
+    version = '0.10',
+    author = 'Jeff Brown',
+    author_email = 'spadix@users.sourceforge.net',
+    url = 'http://zbar.sourceforge.net',
+    description = 'read barcodes from images or video',
+    license = 'LGPL',
+    long_description = open('README').read(),
+    classifiers = [
+        'License :: OSI Approved :: GNU Library or Lesser General Public License (LGPL)',
+        'Development Status :: 4 - Beta',
+        'Intended Audience :: Developers',
+        'Environment :: Console',
+        'Environment :: X11 Applications',
+        'Environment :: Win32 (MS Windows)',
+        'Operating System :: POSIX',
+        'Operating System :: Unix',
+        'Operating System :: Microsoft :: Windows',
+        'Topic :: Communications',
+        'Topic :: Multimedia :: Graphics',
+        'Topic :: Software Development :: Libraries',
+    ],
+    ext_modules = [
+        Extension('zbar', [
+                'zbarmodule.c',
+                'enum.c',
+                'exception.c',
+                'symbol.c',
+                'symbolset.c',
+                'symboliter.c',
+                'image.c',
+                'processor.c',
+                'imagescanner.c',
+                'decoder.c',
+                'scanner.c',
+                ],
+            libraries = [ 'zbar' ],
+        ),
+    ],
+)
diff --git a/python/symbol.c b/python/symbol.c
--- a/python/symbol.c
+++ b/python/symbol.c
@@ -1,5 +1,5 @@
 /*------------------------------------------------------------------------
- *  Copyright 2009 (c) Jeff Brown <spadix@users.sourceforge.net>
+ *  Copyright 2009-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
  *
  *  This file is part of the ZBar Bar Code Reader.
  *
@@ -81,6 +81,22 @@ symbol_get_type (zbarSymbol *self,
 }
 
 static PyObject*
+symbol_get_configs (zbarSymbol *self,
+                    void *closure)
+{
+    unsigned int mask = zbar_symbol_get_configs(self->zsym);
+    return(zbarEnum_SetFromMask(config_enum, mask));
+}
+
+static PyObject*
+symbol_get_modifiers (zbarSymbol *self,
+                      void *closure)
+{
+    unsigned int mask = zbar_symbol_get_modifiers(self->zsym);
+    return(zbarEnum_SetFromMask(modifier_enum, mask));
+}
+
+static PyObject*
 symbol_get_long (zbarSymbol *self,
                  void *closure)
 {
@@ -128,12 +144,23 @@ symbol_get_location (zbarSymbol *self,
     return(self->loc);
 }
 
+static zbarEnumItem*
+symbol_get_orientation (zbarSymbol *self,
+                        void *closure)
+{
+    return(zbarEnum_LookupValue(orient_enum,
+                                zbar_symbol_get_orientation(self->zsym)));
+}
+
 static PyGetSetDef symbol_getset[] = {
     { "type",       (getter)symbol_get_type, },
+    { "configs",    (getter)symbol_get_configs, },
+    { "modifiers",  (getter)symbol_get_modifiers, },
     { "quality",    (getter)symbol_get_long, NULL, NULL, (void*)0 },
     { "count",      (getter)symbol_get_long, NULL, NULL, (void*)1 },
     { "data",       (getter)symbol_get_data, },
     { "location",   (getter)symbol_get_location, },
+    { "orientation",(getter)symbol_get_orientation, },
     { "components", (getter)symbol_get_components,  },
     { NULL, },
 };
diff --git a/python/test/test_zbar.py b/python/test/test_zbar.py
--- a/python/test/test_zbar.py
+++ b/python/test/test_zbar.py
@@ -20,6 +20,9 @@ def load_image():
 encoded_widths = \
     '9 111 212241113121211311141132 11111 311213121312121332111132 111 9'
 
+databar_widths = \
+    '11 31111333 13911 31131231 11214222 11553 21231313 1'
+
 VIDEO_DEVICE = None
 if 'VIDEO_DEVICE' in os.environ:
     VIDEO_DEVICE = os.environ['VIDEO_DEVICE']
@@ -59,6 +62,7 @@ class TestZBarFunctions(ut.TestCase):
                     zbar.Config.ASCII,
                     zbar.Config.MIN_LEN,
                     zbar.Config.MAX_LEN,
+                    zbar.Config.UNCERTAINTY,
                     zbar.Config.POSITION,
                     zbar.Config.X_DENSITY,
                     zbar.Config.Y_DENSITY):
@@ -66,6 +70,13 @@ class TestZBarFunctions(ut.TestCase):
             self.assert_(int(cfg) >= 0)
             self.assert_(is_identifier.match(str(cfg)))
 
+    def test_modifiers(self):
+        for mod in (zbar.Modifier.GS1,
+                    zbar.Modifier.AIM):
+            self.assert_(isinstance(mod, zbar.EnumItem))
+            self.assert_(int(mod) >= 0)
+            self.assert_(is_identifier.match(str(mod)))
+
     def test_symbologies(self):
         for sym in (zbar.Symbol.NONE,
                     zbar.Symbol.PARTIAL,
@@ -75,15 +86,28 @@ class TestZBarFunctions(ut.TestCase):
                     zbar.Symbol.UPCA,
                     zbar.Symbol.EAN13,
                     zbar.Symbol.ISBN13,
+                    zbar.Symbol.DATABAR,
+                    zbar.Symbol.DATABAR_EXP,
                     zbar.Symbol.I25,
                     zbar.Symbol.CODE39,
                     zbar.Symbol.PDF417,
                     zbar.Symbol.QRCODE,
+                    zbar.Symbol.CODE93,
                     zbar.Symbol.CODE128):
             self.assert_(isinstance(sym, zbar.EnumItem))
             self.assert_(int(sym) >= 0)
             self.assert_(is_identifier.match(str(sym)))
 
+    def test_orientations(self):
+        for orient in (zbar.Orient.UNKNOWN,
+                       zbar.Orient.UP,
+                       zbar.Orient.RIGHT,
+                       zbar.Orient.DOWN,
+                       zbar.Orient.LEFT):
+            self.assert_(isinstance(orient, zbar.EnumItem))
+            self.assert_(-1 <= int(orient) <= 3)
+            self.assert_(is_identifier.match(str(orient)))
+
 class TestScanner(ut.TestCase):
     def setUp(self):
         self.scn = zbar.Scanner()
@@ -135,6 +159,9 @@ class TestDecoder(ut.TestCase):
             self.dcode.data = data
         self.assertRaises(AttributeError, set_data, 'yomama')
 
+        self.assertRaises(AttributeError,
+                          self.dcode.__setattr__, 'direction', -1)
+
     def test_width(self):
         sym = self.dcode.decode_width(5)
         self.assert_(sym is zbar.Symbol.NONE)
@@ -150,6 +177,7 @@ class TestDecoder(ut.TestCase):
         self.assert_(self.dcode.color is zbar.BAR)
         self.dcode.reset()
         self.assert_(self.dcode.color is zbar.SPACE)
+        self.assertEqual(self.dcode.direction, 0)
 
     def test_decode(self):
         inline_sym = [ -1 ]
@@ -172,12 +200,33 @@ class TestDecoder(ut.TestCase):
             else:
                 self.assert_(sym is zbar.Symbol.EAN13)
 
+        self.assertEqual(self.dcode.configs,
+                         set((zbar.Config.ENABLE, zbar.Config.EMIT_CHECK)))
+        self.assertEqual(self.dcode.modifiers, set())
         self.assertEqual(self.dcode.data, '6268964977804')
         self.assert_(self.dcode.color is zbar.BAR)
+        self.assertEqual(self.dcode.direction, 1)
         self.assert_(sym is zbar.Symbol.EAN13)
         self.assert_(inline_sym[0] is zbar.Symbol.EAN13)
         self.assertEqual(explicit_closure, [ 2 ])
 
+    def test_databar(self):
+        self.dcode.set_config(zbar.Symbol.QRCODE, zbar.Config.ENABLE, 0)
+        for (i, width) in enumerate(databar_widths):
+            if width == ' ': continue
+            sym = self.dcode.decode_width(int(width))
+            if i < len(databar_widths) - 1:
+                self.assert_(sym is zbar.Symbol.NONE or
+                             sym is zbar.Symbol.PARTIAL)
+
+        self.assert_(sym is zbar.Symbol.DATABAR)
+        self.assertEqual(self.dcode.get_configs(zbar.Symbol.EAN13),
+                         set((zbar.Config.ENABLE, zbar.Config.EMIT_CHECK)))
+        self.assertEqual(self.dcode.modifiers, set((zbar.Modifier.GS1,)))
+        self.assertEqual(self.dcode.data, '0124012345678905')
+        self.assert_(self.dcode.color is zbar.BAR)
+        self.assertEqual(self.dcode.direction, 1)
+
     # FIXME test exception during callback
 
 class TestImage(ut.TestCase):
@@ -194,11 +243,13 @@ class TestImage(ut.TestCase):
     def test_new(self):
         self.assertEqual(self.image.format, 'Y800')
         self.assertEqual(self.image.size, (123, 456))
+        self.assertEqual(self.image.crop, (0, 0, 123, 456))
 
         image = zbar.Image()
         self.assert_(isinstance(image, zbar.Image))
         self.assertEqual(image.format, '\0\0\0\0')
         self.assertEqual(image.size, (0, 0))
+        self.assertEqual(image.crop, (0, 0, 0, 0))
 
     def test_format(self):
         def set_format(fmt):
@@ -231,6 +282,23 @@ class TestImage(ut.TestCase):
         self.assertEqual(self.image.width, 81)
         self.assertEqual(self.image.height, 64)
 
+    def test_crop(self):
+        def set_crop(crp):
+            self.image.crop = crp
+        self.assertRaises(ValueError, set_crop, (1,))
+        self.assertRaises(ValueError, set_crop, 1)
+        self.image.crop = (1, 2, 100, 200)
+        self.assertRaises(ValueError, set_crop, (1, 2, 3, 4, 5))
+        self.assertEqual(self.image.crop, (1, 2, 100, 200))
+        self.assertRaises(ValueError, set_crop, "foo")
+        self.assertEqual(self.image.crop, (1, 2, 100, 200))
+        self.image.crop = (-100, -100, 400, 700)
+        self.assertEqual(self.image.crop, (0, 0, 123, 456))
+        self.image.crop = (40, 50, 60, 70)
+        self.assertEqual(self.image.crop, (40, 50, 60, 70))
+        self.image.size = (82, 65)
+        self.assertEqual(self.image.crop, (0, 0, 82, 65))
+
 class TestImageScanner(ut.TestCase):
     def setUp(self):
         self.scn = zbar.ImageScanner()
@@ -289,6 +357,20 @@ class TestImageScan(ut.TestCase):
             self.assert_(sym.type is zbar.Symbol.EAN13)
             self.assert_(sym.type is sym.EAN13)
             self.assertEqual(str(sym.type), 'EAN13')
+
+            cfgs = sym.configs
+            self.assert_(isinstance(cfgs, set))
+            for cfg in cfgs:
+                self.assert_(isinstance(cfg, zbar.EnumItem))
+            self.assertEqual(cfgs,
+                             set((zbar.Config.ENABLE, zbar.Config.EMIT_CHECK)))
+
+            mods = sym.modifiers
+            self.assert_(isinstance(mods, set))
+            for mod in mods:
+                self.assert_(isinstance(mod, zbar.EnumItem))
+            self.assertEqual(mods, set())
+
             self.assert_(sym.quality > 0)
             self.assertEqual(sym.count, 0)
 
@@ -310,6 +392,7 @@ class TestImageScan(ut.TestCase):
                 self.assertEqual(len(pt), 2)
                 # FIXME test values (API currently in flux)
 
+            self.assert_(sym.orientation is zbar.Orient.UP)
             self.assert_(data is sym.data)
             self.assert_(loc is sym.location)
 
@@ -320,6 +403,21 @@ class TestImageScan(ut.TestCase):
         self.scn.recycle(self.image)
         self.assertEqual(len(self.image.symbols), 0)
 
+    def test_scan_crop(self):
+        self.image.crop = (0, 71, 114, 9)
+        self.assertEqual(self.image.crop, (0, 71, 114, 9))
+        n = self.scn.scan(self.image)
+        self.assertEqual(n, 0)
+
+        self.image.crop = (12, 24, 90, 12)
+        self.assertEqual(self.image.crop, (12, 24, 90, 12))
+        n = self.scn.scan(self.image)
+        self.assertEqual(n, 0)
+
+        self.image.crop = (9, 24, 96, 12)
+        self.assertEqual(self.image.crop, (9, 24, 96, 12))
+        self.test_scan()
+
     def test_scan_again(self):
         self.test_scan()
 
@@ -370,13 +468,14 @@ class TestProcessor(ut.TestCase):
             symiter = iter(image)
             self.assert_(isinstance(symiter, zbar.SymbolIter))
 
-            symbols = tuple(image)
-            self.assertEqual(len(symbols), 1)
-            for symbol in symbols:
-                self.assert_(isinstance(symbol, zbar.Symbol))
-                self.assert_(symbol.type is zbar.Symbol.EAN13)
-                self.assertEqual(symbol.data, '9876543210128')
-                self.assert_(symbol.quality > 0)
+            syms = tuple(image)
+            self.assertEqual(len(syms), 1)
+            for sym in syms:
+                self.assert_(isinstance(sym, zbar.Symbol))
+                self.assert_(sym.type is zbar.Symbol.EAN13)
+                self.assertEqual(sym.data, '9876543210128')
+                self.assert_(sym.quality > 0)
+                self.assert_(sym.orientation is zbar.Orient.UP)
             closure[0] += 1
 
         explicit_closure = [ 0 ]
diff --git a/python/zbarmodule.c b/python/zbarmodule.c
--- a/python/zbarmodule.c
+++ b/python/zbarmodule.c
@@ -1,5 +1,5 @@
 /*------------------------------------------------------------------------
- *  Copyright 2009 (c) Jeff Brown <spadix@users.sourceforge.net>
+ *  Copyright 2009-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
  *
  *  This file is part of the ZBar Bar Code Reader.
  *
@@ -23,6 +23,11 @@
 
 #include "zbarmodule.h"
 
+typedef struct enumdef {
+    const char *strval;
+    int intval;
+} enumdef;
+
 static char *exc_names[] = {
     "zbar.Exception",
     NULL,
@@ -38,6 +43,55 @@ static char *exc_names[] = {
     "zbar.WinAPIError",
 };
 
+static const enumdef symbol_defs[] = {
+    { "NONE",           ZBAR_NONE },
+    { "PARTIAL",        ZBAR_PARTIAL },
+    { "EAN8",           ZBAR_EAN8 },
+    { "UPCE",           ZBAR_UPCE },
+    { "ISBN10",         ZBAR_ISBN10 },
+    { "UPCA",           ZBAR_UPCA },
+    { "EAN13",          ZBAR_EAN13 },
+    { "ISBN13",         ZBAR_ISBN13 },
+    { "DATABAR",        ZBAR_DATABAR },
+    { "DATABAR_EXP",    ZBAR_DATABAR_EXP },
+    { "I25",            ZBAR_I25 },
+    { "CODE39",         ZBAR_CODE39 },
+    { "PDF417",         ZBAR_PDF417 },
+    { "QRCODE",         ZBAR_QRCODE },
+    { "CODE93",         ZBAR_CODE93 },
+    { "CODE128",        ZBAR_CODE128 },
+    { NULL, }
+};
+
+static const enumdef config_defs[] = {
+    { "ENABLE",         ZBAR_CFG_ENABLE },
+    { "ADD_CHECK",      ZBAR_CFG_ADD_CHECK },
+    { "EMIT_CHECK",     ZBAR_CFG_EMIT_CHECK },
+    { "ASCII",          ZBAR_CFG_ASCII },
+    { "MIN_LEN",        ZBAR_CFG_MIN_LEN },
+    { "MAX_LEN",        ZBAR_CFG_MAX_LEN },
+    { "UNCERTAINTY",    ZBAR_CFG_UNCERTAINTY },
+    { "POSITION",       ZBAR_CFG_POSITION },
+    { "X_DENSITY",      ZBAR_CFG_X_DENSITY },
+    { "Y_DENSITY",      ZBAR_CFG_Y_DENSITY },
+    { NULL, }
+};
+
+static const enumdef modifier_defs[] = {
+    { "GS1",            ZBAR_MOD_GS1 },
+    { "AIM",            ZBAR_MOD_AIM },
+    { NULL, }
+};
+
+static const enumdef orient_defs[] = {
+    { "UNKNOWN",        ZBAR_ORIENT_UNKNOWN },
+    { "UP",             ZBAR_ORIENT_UP },
+    { "RIGHT",          ZBAR_ORIENT_RIGHT },
+    { "DOWN",           ZBAR_ORIENT_DOWN },
+    { "LEFT",           ZBAR_ORIENT_LEFT },
+    { NULL, }
+};
+
 int
 object_to_bool (PyObject *obj,
                 int *val)
@@ -52,8 +106,10 @@ object_to_bool (PyObject *obj,
 PyObject *zbar_exc[ZBAR_ERR_NUM];
 zbarEnumItem *color_enum[2];
 zbarEnum *config_enum;
+zbarEnum *modifier_enum;
 PyObject *symbol_enum;
 zbarEnumItem *symbol_NONE;
+zbarEnum *orient_enum;
 
 static PyObject*
 version (PyObject *self,
@@ -105,12 +161,6 @@ static PyMethodDef zbar_functions[] = {
 PyMODINIT_FUNC
 initzbar (void)
 {
-    /* initialize constant containers */
-    config_enum = zbarEnum_New();
-    symbol_enum = PyDict_New();
-    if(!config_enum || !symbol_enum)
-        return;
-
     /* initialize types */
     zbarEnumItem_Type.tp_base = &PyInt_Type;
     zbarException_Type.tp_base = (PyTypeObject*)PyExc_Exception;
@@ -128,6 +178,14 @@ initzbar (void)
        PyType_Ready(&zbarScanner_Type) < 0)
         return;
 
+    /* initialize constant containers */
+    config_enum = zbarEnum_New();
+    modifier_enum = zbarEnum_New();
+    symbol_enum = PyDict_New();
+    orient_enum = zbarEnum_New();
+    if(!config_enum || !modifier_enum || !symbol_enum || !orient_enum)
+        return;
+
     zbar_exc[0] = (PyObject*)&zbarException_Type;
     zbar_exc[ZBAR_ERR_NOMEM] = NULL;
     zbar_error_t ei;
@@ -151,6 +209,8 @@ initzbar (void)
     PyModule_AddObject(mod, "EnumItem", (PyObject*)&zbarEnumItem_Type);
     PyModule_AddObject(mod, "Image", (PyObject*)&zbarImage_Type);
     PyModule_AddObject(mod, "Config", (PyObject*)config_enum);
+    PyModule_AddObject(mod, "Modifier", (PyObject*)modifier_enum);
+    PyModule_AddObject(mod, "Orient", (PyObject*)orient_enum);
     PyModule_AddObject(mod, "Symbol", (PyObject*)&zbarSymbol_Type);
     PyModule_AddObject(mod, "SymbolSet", (PyObject*)&zbarSymbolSet_Type);
     PyModule_AddObject(mod, "SymbolIter", (PyObject*)&zbarSymbolIter_Type);
@@ -170,29 +230,16 @@ initzbar (void)
     color_enum[ZBAR_BAR] =
         zbarEnumItem_New(dict, NULL, ZBAR_BAR, "BAR");
 
-    zbarEnum_Add(config_enum, ZBAR_CFG_ENABLE,     "ENABLE");
-    zbarEnum_Add(config_enum, ZBAR_CFG_ADD_CHECK,  "ADD_CHECK");
-    zbarEnum_Add(config_enum, ZBAR_CFG_EMIT_CHECK, "EMIT_CHECK");
-    zbarEnum_Add(config_enum, ZBAR_CFG_ASCII,      "ASCII");
-    zbarEnum_Add(config_enum, ZBAR_CFG_MIN_LEN,    "MIN_LEN");
-    zbarEnum_Add(config_enum, ZBAR_CFG_MAX_LEN,    "MAX_LEN");
-    zbarEnum_Add(config_enum, ZBAR_CFG_X_DENSITY,  "POSITION");
-    zbarEnum_Add(config_enum, ZBAR_CFG_X_DENSITY,  "X_DENSITY");
-    zbarEnum_Add(config_enum, ZBAR_CFG_Y_DENSITY,  "Y_DENSITY");
+    const enumdef *item;
+    for(item = config_defs; item->strval; item++)
+        zbarEnum_Add(config_enum, item->intval, item->strval);
+    for(item = modifier_defs; item->strval; item++)
+        zbarEnum_Add(modifier_enum, item->intval, item->strval);
+    for(item = orient_defs; item->strval; item++)
+        zbarEnum_Add(orient_enum, item->intval, item->strval);
 
     PyObject *tp_dict = zbarSymbol_Type.tp_dict;
-    symbol_NONE =
-        zbarEnumItem_New(tp_dict, symbol_enum, ZBAR_NONE, "NONE");
-    zbarEnumItem_New(tp_dict, symbol_enum, ZBAR_PARTIAL, "PARTIAL");
-    zbarEnumItem_New(tp_dict, symbol_enum, ZBAR_EAN8,    "EAN8");
-    zbarEnumItem_New(tp_dict, symbol_enum, ZBAR_UPCE,    "UPCE");
-    zbarEnumItem_New(tp_dict, symbol_enum, ZBAR_ISBN10,  "ISBN10");
-    zbarEnumItem_New(tp_dict, symbol_enum, ZBAR_UPCA,    "UPCA");
-    zbarEnumItem_New(tp_dict, symbol_enum, ZBAR_EAN13,   "EAN13");
-    zbarEnumItem_New(tp_dict, symbol_enum, ZBAR_ISBN13,  "ISBN13");
-    zbarEnumItem_New(tp_dict, symbol_enum, ZBAR_I25,     "I25");
-    zbarEnumItem_New(tp_dict, symbol_enum, ZBAR_CODE39,  "CODE39");
-    zbarEnumItem_New(tp_dict, symbol_enum, ZBAR_PDF417,  "PDF417");
-    zbarEnumItem_New(tp_dict, symbol_enum, ZBAR_QRCODE,  "QRCODE");
-    zbarEnumItem_New(tp_dict, symbol_enum, ZBAR_CODE128, "CODE128");
+    for(item = symbol_defs; item->strval; item++)
+        zbarEnumItem_New(tp_dict, symbol_enum, item->intval, item->strval);
+    symbol_NONE = zbarSymbol_LookupEnum(ZBAR_NONE);
 }
diff --git a/python/zbarmodule.h b/python/zbarmodule.h
--- a/python/zbarmodule.h
+++ b/python/zbarmodule.h
@@ -1,5 +1,5 @@
 /*------------------------------------------------------------------------
- *  Copyright 2009 (c) Jeff Brown <spadix@users.sourceforge.net>
+ *  Copyright 2009-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
  *
  *  This file is part of the ZBar Bar Code Reader.
  *
@@ -61,6 +61,10 @@ extern zbarEnum *zbarEnum_New(void);
 extern int zbarEnum_Add(zbarEnum *self,
                          int val,
                          const char *name);
+extern zbarEnumItem *zbarEnum_LookupValue(zbarEnum *self,
+                                          int val);
+extern PyObject *zbarEnum_SetFromMask(zbarEnum *self,
+                                      unsigned int mask);
 
 typedef struct {
     PyObject_HEAD
@@ -144,8 +148,10 @@ extern PyTypeObject zbarScanner_Type;
 
 extern zbarEnumItem *color_enum[2];
 extern zbarEnum *config_enum;
+extern zbarEnum *modifier_enum;
 extern PyObject *symbol_enum;
 extern zbarEnumItem *symbol_NONE;
+extern zbarEnum *orient_enum;
 
 int object_to_bool(PyObject *obj,
                    int *val);
diff --git a/test/Makefile.am.inc b/test/Makefile.am.inc
--- a/test/Makefile.am.inc
+++ b/test/Makefile.am.inc
@@ -67,3 +67,14 @@ EXTRA_DIST += test/test_pygtk.py test/te
 CLEANFILES += test/.libs/test_decode test/.libs/test_proc \
     test/.libs/test_convert test/.libs/test_window \
     test/.libs/test_video test/.libs/dbg_scan test/.libs/test_gtk
+
+check-decoder: test/test_decode
+	test/test_decode -q
+
+regress-decoder: test/test_decode
+	test/test_decode -n 100000
+
+check-local: check-decoder check-images
+regress: regress-decoder regress-images
+
+.PHONY: check-decoder check-images regress-decoder regress-images regress
diff --git a/test/barcodetest.py b/test/barcodetest.py
--- a/test/barcodetest.py
+++ b/test/barcodetest.py
@@ -124,6 +124,8 @@ def run_zbarimg(images):
     assert rc in (0, 4), \
            'zbarimg returned error status (%d)\n' % rc + err
 
+    assert not err, err
+
     result = ET.XML(xml)
     assert result.tag == ET.QName(BC, 'barcodes')
     return result
@@ -167,7 +169,8 @@ class BuiltinTestCase(TestCase):
             href = 'http://zbar.sf.net/test/barcode.png'
 
         self.source = src = ET.Element(ET.QName(BC, 'source'), href=href)
-        sym = ET.SubElement(src, ET.QName(BC, 'symbol'), type='EAN-13')
+        sym = ET.SubElement(src, ET.QName(BC, 'symbol'), type='EAN-13',
+                            orientation='UP')
         data = ET.SubElement(sym, ET.QName(BC, 'data'))
         data.text = '9876543210128'
 
@@ -258,8 +261,9 @@ def compare_indices(expect, actual):
 
 
 def compare_symbols(expect, actual):
-    pass
-
+    orient = expect.get('orientation')
+    if orient:
+        assert actual.get('orientation') == orient
 
 # override unittest.TestLoader to populate tests from xml description
 class TestLoader:
diff --git a/test/test_decode.c b/test/test_decode.c
--- a/test/test_decode.c
+++ b/test/test_decode.c
@@ -22,33 +22,86 @@
  *------------------------------------------------------------------------*/
 
 #include <inttypes.h>
+#include <limits.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <string.h>
+#include <ctype.h>
+#include <time.h>
 #include <assert.h>
 
 #include <zbar.h>
 
 zbar_decoder_t *decoder;
 
+zbar_symbol_type_t expect_sym;
+char *expect_data = NULL;
+
+unsigned seed = 0;
+int verbosity = 1;
+int rnd_size = 9;  /* NB should be odd */
+int iter = 0;      /* test iteration */
+
+#define zprintf(level, format, ...) do {                                \
+        if(verbosity >= (level)) {                                      \
+            fprintf(stderr, format , ##__VA_ARGS__); \
+        }                                                               \
+    } while(0)
+
+static inline void print_sep (int level)
+{
+    zprintf(level,
+            "----------------------------------------------------------\n");
+}
+
 static void symbol_handler (zbar_decoder_t *decoder)
 {
     zbar_symbol_type_t sym = zbar_decoder_get_type(decoder);
-    if(sym <= ZBAR_PARTIAL)
+    if(sym <= ZBAR_PARTIAL || sym == ZBAR_QRCODE)
         return;
-    printf("%s%s:%s\n",
-           zbar_get_symbol_name(sym),
-           zbar_get_addon_name(sym),
-           zbar_decoder_get_data(decoder));
-    /* FIXME add check! */
+    const char *data = zbar_decoder_get_data(decoder);
+
+    int pass = (sym == expect_sym) && !strcmp(data, expect_data) &&
+        zbar_decoder_get_data_length(decoder) == strlen(data);
+    pass *= 3;
+
+    zprintf(pass, "decode %s:%s\n", zbar_get_symbol_name(sym), data);
+
+    if(!expect_sym)
+        zprintf(0, "UNEXPECTED!\n");
+    else
+        zprintf(pass, "expect %s:%s\n", zbar_get_symbol_name(expect_sym),
+                expect_data);
+    if(!pass) {
+        zprintf(0, "SEED=%d\n", seed);
+        abort();
+    }
+
+    expect_sym = ZBAR_NONE;
+    free(expect_data);
+    expect_data = NULL;
+}
+
+static void expect (zbar_symbol_type_t sym,
+                    const char *data)
+{
+    if(expect_sym) {
+        zprintf(0, "MISSING %s:%s\n"
+                "SEED=%d\n",
+                zbar_get_symbol_name(expect_sym), expect_data, seed);
+        abort();
+    }
+    expect_sym = sym;
+    expect_data = (data) ? strdup(data) : NULL;
 }
 
 static void encode_junk (int n)
 {
-    printf("encode random junk...\n");
+    if(n > 1)
+        zprintf(3, "encode random junk...\n");
     int i;
     for(i = 0; i < n; i++)
-        zbar_decode_width(decoder, 10. * (rand() / (RAND_MAX + 1.)));
+        zbar_decode_width(decoder, 20. * (rand() / (RAND_MAX + 1.)) + 1);
 }
 
 #define FWD 1
@@ -57,8 +110,8 @@ static void encode_junk (int n)
 static void encode (uint64_t units,
                     int fwd)
 {
-    printf(" raw=%x%x%c\n", (unsigned)(units >> 32),
-           (unsigned)(units & 0xffffffff), (fwd) ? '<' : '>');
+    zprintf(3, " raw=%x%x%c\n", (unsigned)(units >> 32),
+            (unsigned)(units & 0xffffffff), (fwd) ? '<' : '>');
     if(!fwd)
         while(units && !(units >> 0x3c))
             units <<= 4;
@@ -122,47 +175,188 @@ static const unsigned int code128[107] =
     0x2331112a,                             /* STOP (6a) */
 };
 
-static void encode_code128b (unsigned char *data)
+static void encode_code128b (char *data)
 {
-    printf("------------------------------------------------------------\n"
-           "encode CODE-128(B): %s\n"
-           "    encode START_B: %02x", data, START_B);
+    assert(zbar_decoder_get_color(decoder) == ZBAR_SPACE);
+    print_sep(3);
+    zprintf(2, "CODE-128(B): %s\n", data);
+    zprintf(3, "    encode START_B: %02x", START_B);
     encode(code128[START_B], 0);
     int i, chk = START_B;
     for(i = 0; data[i]; i++) {
-        printf("    encode '%c': %02x", data[i], data[i] - 0x20);
+        zprintf(3, "    encode '%c': %02x", data[i], data[i] - 0x20);
         encode(code128[data[i] - 0x20], 0);
         chk += (i + 1) * (data[i] - 0x20);
     }
     chk %= 103;
-    printf("    encode checksum: %02x", chk);
+    zprintf(3, "    encode checksum: %02x", chk);
     encode(code128[chk], 0);
-    printf("    encode STOP: %02x", STOP);
+    zprintf(3, "    encode STOP: %02x", STOP);
     encode(code128[STOP], 0);
-    printf("------------------------------------------------------------\n");
+    print_sep(3);
 }
 
-static void encode_code128c (unsigned char *data)
+static void encode_code128c (char *data)
 {
-    printf("------------------------------------------------------------\n"
-           "encode CODE-128(C): %s\n"
-           "    encode START_C: %02x", data, START_C);
+    assert(zbar_decoder_get_color(decoder) == ZBAR_SPACE);
+    print_sep(3);
+    zprintf(2, "CODE-128(C): %s\n", data);
+    zprintf(3, "    encode START_C: %02x", START_C);
     encode(code128[START_C], 0);
     int i, chk = START_C;
     for(i = 0; data[i]; i += 2) {
         assert(data[i] >= '0');
         assert(data[i + 1] >= '0');
         unsigned char c = (data[i] - '0') * 10 + (data[i + 1] - '0');
-        printf("    encode '%c%c': %02d", data[i], data[i + 1], c);
+        zprintf(3, "    encode '%c%c': %02d", data[i], data[i + 1], c);
         encode(code128[c], 0);
         chk += (i / 2 + 1) * c;
     }
     chk %= 103;
-    printf("    encode checksum: %02x", chk);
+    zprintf(3, "    encode checksum: %02x", chk);
     encode(code128[chk], 0);
-    printf("    encode STOP: %02x", STOP);
+    zprintf(3, "    encode STOP: %02x", STOP);
     encode(code128[STOP], 0);
-    printf("------------------------------------------------------------\n");
+    print_sep(3);
+}
+
+/*------------------------------------------------------------*/
+/* Code 93 encoding */
+
+#define CODE93_START_STOP 0x2f
+
+static const unsigned int code93[47 + 1] = {
+    0x131112, 0x111213, 0x111312, 0x111411, /* 00 */
+    0x121113, 0x121212, 0x121311, 0x111114,
+    0x131211, 0x141111, 0x211113, 0x211212, /* 08 */
+    0x211311, 0x221112, 0x221211, 0x231111,
+    0x112113, 0x112212, 0x112311, 0x122112, /* 10 */
+    0x132111, 0x111123, 0x111222, 0x111321,
+    0x121122, 0x131121, 0x212112, 0x212211, /* 18 */
+    0x211122, 0x211221, 0x221121, 0x222111,
+    0x112122, 0x112221, 0x122121, 0x123111, /* 20 */
+    0x121131, 0x311112, 0x311211, 0x321111,
+    0x112131, 0x113121, 0x211131, 0x121221, /* 28 */
+    0x312111, 0x311121, 0x122211,
+    0x111141,                               /* START/STOP (2f) */
+};
+
+#define S1 0x2b00|
+#define S2 0x2c00|
+#define S3 0x2d00|
+#define S4 0x2e00|
+
+static const unsigned short code93_ext[0x80] = {
+    S2'U', S1'A', S1'B', S1'C', S1'D', S1'E', S1'F', S1'G',
+    S1'H', S1'I', S1'J', S1'K', S1'L', S1'M', S1'N', S1'O',
+    S1'P', S1'Q', S1'R', S1'S', S1'T', S1'U', S1'V', S1'W',
+    S1'X', S1'Y', S1'Z', S2'A', S2'B', S2'C', S2'D', S2'E',
+    0x26,  S3'A', S3'B', S3'C', 0x27,  0x2a,  S3'F', S3'G',
+    S3'H', S3'I', S3'J', 0x29,  S3'L', 0x24,  0x25,  0x28,
+    0x00,  0x01,  0x02,  0x03,  0x04,  0x05,  0x06,  0x07,
+    0x08,  0x09,  S3'Z', S2'F', S2'G', S2'H', S2'I', S2'J',
+    S2'V', 0x0a,  0x0b,  0x0c,  0x0d,  0x0e,  0x0f,  0x10,
+    0x11,  0x12,  0x13,  0x14,  0x15,  0x16,  0x17,  0x18,
+    0x19,  0x1a,  0x1b,  0x1c,  0x1d,  0x1e,  0x1f,  0x20,
+    0x21,  0x22,  0x23,  S2'K', S2'L', S2'M', S2'N', S2'O',
+    S2'W', S4'A', S4'B', S4'C', S4'D', S4'E', S4'F', S4'G',
+    S4'H', S4'I', S4'J', S4'K', S4'L', S4'M', S4'N', S4'O',
+    S4'P', S4'Q', S4'R', S4'S', S4'T', S4'U', S4'V', S4'W',
+    S4'X', S4'Y', S4'Z', S2'P', S2'Q', S2'R', S2'S', S2'T',
+};
+
+#undef S1
+#undef S2
+#undef S3
+#undef S4
+
+static void encode_char93 (unsigned char c,
+                           int dir)
+{
+    unsigned ext = code93_ext[c];
+    unsigned shift = ext >> 8;
+    assert(shift < 0x30);
+    c = ext & 0xff;
+    if(shift) {
+        assert(c < 0x80);
+        c = code93_ext[c];
+    }
+    assert(c < 0x30);
+
+    if(shift) {
+        encode(code93[(dir) ? shift : c], dir ^ 1);
+        encode(code93[(dir) ? c : shift], dir ^ 1);
+    }
+    else
+        encode(code93[c], dir ^ 1);
+}
+
+static void encode_code93 (char *data,
+                           int dir)
+{
+    assert(zbar_decoder_get_color(decoder) == ZBAR_SPACE);
+    print_sep(3);
+
+    /* calculate checksums */
+    int i, j, chk_c = 0, chk_k = 0, n = 0;
+    for(i = 0; data[i]; i++, n++) {
+        unsigned c = data[i], ext;
+        assert(c < 0x80);
+        ext = code93_ext[c];
+        n += ext >> 13;
+    }
+
+    for(i = 0, j = 0; data[i]; i++, j++) {
+        unsigned ext = code93_ext[(unsigned)data[i]];
+        unsigned shift = ext >> 8;
+        unsigned c = ext & 0xff;
+        if(shift) {
+            chk_c += shift * (((n - 1 - j) % 20) + 1);
+            chk_k += shift * (((n - j) % 15) + 1);
+            j++;
+            c = code93_ext[c];
+        }
+        chk_c += c * (((n - 1 - j) % 20) + 1);
+        chk_k += c * (((n - j) % 15) + 1);
+    }
+    chk_c %= 47;
+    chk_k += chk_c;
+    chk_k %= 47;
+
+    zprintf(2, "CODE-93: %s (n=%x C=%02x K=%02x)\n", data, n, chk_c, chk_k);
+    encode(0xa, 0);  /* leading quiet */
+
+    zprintf(3, "    encode %s:", (dir) ? "START" : "STOP");
+    if(!dir)
+        encode(0x1, REV);
+    encode(code93[CODE93_START_STOP], dir ^ 1);
+    if(!dir) {
+        zprintf(3, "    encode checksum (K): %02x", chk_k);
+        encode(code93[chk_k], REV ^ 1);
+        zprintf(3, "    encode checksum (C): %02x", chk_c);
+        encode(code93[chk_c], REV ^ 1);
+    }
+
+    n = strlen(data);
+    for(i = 0; i < n; i++) {
+        unsigned char c = data[(dir) ? i : (n - i - 1)];
+        zprintf(3, "    encode '%c':", c);
+        encode_char93(c, dir);
+    }
+
+    if(dir) {
+        zprintf(3, "    encode checksum (C): %02x", chk_c);
+        encode(code93[chk_c], FWD ^ 1);
+        zprintf(3, "    encode checksum (K): %02x", chk_k);
+        encode(code93[chk_k], FWD ^ 1);
+    }
+    zprintf(3, "    encode %s:", (dir) ? "STOP" : "START");
+    encode(code93[CODE93_START_STOP], dir ^ 1);
+    if(dir)
+        encode(0x1, FWD);
+
+    encode(0xa, 0);  /* trailing quiet */
+    print_sep(3);
 }
 
 /*------------------------------------------------------------*/
@@ -182,14 +376,29 @@ static const unsigned int code39[91-32] 
 /* FIXME configurable/randomized ratio, ics */
 /* FIXME check digit option, ASCII escapes */
 
+static void convert_code39 (char *data)
+{
+    char *src, *dst;
+    for(src = data, dst = data; *src; src++) {
+        char c = *src;
+        if(c >= 'a' && c <= 'z')
+            *(dst++) = c - ('a' - 'A');
+        else if(c == ' ' ||
+                c == '$' || c == '%' ||
+                c == '+' || c == '-' ||
+                (c >= '.' && c <= '9') ||
+                (c >= 'A' && c <= 'Z'))
+            *(dst++) = c;
+        else
+            /* skip (FIXME) */;
+    }
+    *dst = 0;
+}
+
 static void encode_char39 (unsigned char c,
                            unsigned ics)
 {
-    if(c >= 'a' && c <= 'z')
-        c -= 'a' - 'A';
-    else if(c < 0x20 || c > 0x5a)
-        return; /* skip (FIXME) */
-
+    assert(0x20 <= c && c <= 0x5a);
     unsigned int raw = code39[c - 0x20];
     if(!raw)
         return; /* skip (FIXME) */
@@ -201,15 +410,16 @@ static void encode_char39 (unsigned char
         raw <<= 1;
     }
     enc = (enc << 4) | ics;
-    printf("    encode '%c': %02x%08x: ", c,
-           (unsigned)(enc >> 32), (unsigned)(enc & 0xffffffff));
+    zprintf(3, "    encode '%c': %02x%08x: ", c,
+            (unsigned)(enc >> 32), (unsigned)(enc & 0xffffffff));
     encode(enc, REV);
 }
 
-static void encode_code39 (unsigned char *data)
+static void encode_code39 (char *data)
 {
-    printf("------------------------------------------------------------\n"
-           "encode CODE-39: %s\n", data);
+    assert(zbar_decoder_get_color(decoder) == ZBAR_SPACE);
+    print_sep(3);
+    zprintf(2, "CODE-39: %s\n", data);
     encode(0xa, 0);  /* leading quiet */
     encode_char39('*', 1);
     int i;
@@ -217,10 +427,10 @@ static void encode_code39 (unsigned char
         if(data[i] != '*') /* skip (FIXME) */
             encode_char39(data[i], 1);
     encode_char39('*', 0xa);  /* w/trailing quiet */
-    printf("------------------------------------------------------------\n");
+    print_sep(3);
 }
 
-
+#if 0
 /*------------------------------------------------------------*/
 /* PDF417 encoding */
 
@@ -258,32 +468,33 @@ static void encode_row417 (int r,
 {
     int k = r % 3;
 
-    printf("    [%d] encode %s:", r, (dir) ? "stop" : "start");
+    zprintf(3, "    [%d] encode %s:", r, (dir) ? "stop" : "start");
     encode((dir) ? PDF417_STOP : PDF417_START, dir);
 
     int cw = calc_ind417(k + !dir, r, cols);
-    printf("    [%d,%c] encode %03d(%d): ", r, (dir) ? 'R' : 'L', cw, k);
+    zprintf(3, "    [%d,%c] encode %03d(%d): ", r, (dir) ? 'R' : 'L', cw, k);
     encode(pdf417_encode[cw][k], dir);
 
     int c;
     for(c = 0; c < cols; c++) {
         cw = cws[c];
-        printf("    [%d,%d] encode %03d(%d): ", r, c, cw, k);
+        zprintf(3, "    [%d,%d] encode %03d(%d): ", r, c, cw, k);
         encode(pdf417_encode[cw][k], dir);
     }
 
     cw = calc_ind417(k + dir, r, cols);
-    printf("    [%d,%c] encode %03d(%d): ", r, (dir) ? 'L' : 'R', cw, k);
+    zprintf(3, "    [%d,%c] encode %03d(%d): ", r, (dir) ? 'L' : 'R', cw, k);
     encode(pdf417_encode[cw][k], dir);
 
-    printf("    [%d] encode %s:", r, (dir) ? "start" : "stop");
+    zprintf(3, "    [%d] encode %s:", r, (dir) ? "start" : "stop");
     encode((dir) ? PDF417_START : PDF417_STOP, dir);
 }
 
-static void encode_pdf417 (unsigned char *data)
+static void encode_pdf417 (char *data)
 {
-    printf("------------------------------------------------------------\n"
-           "encode PDF417: hello world\n");
+    assert(zbar_decoder_get_color(decoder) == ZBAR_SPACE);
+    print_sep(3);
+    zprintf(2, "PDF417: hello world\n");
     encode(0xa, 0);
 
     int r;
@@ -292,9 +503,9 @@ static void encode_pdf417 (unsigned char
         encode(0xa, 0);
     }
 
-    printf("------------------------------------------------------------\n");
+    print_sep(3);
 }
-
+#endif
 
 /*------------------------------------------------------------*/
 /* Interleaved 2 of 5 encoding */
@@ -303,21 +514,22 @@ static const unsigned char i25[10] = {
     0x06, 0x11, 0x09, 0x18, 0x05, 0x14, 0x0c, 0x03, 0x12, 0x0a,
 };
 
-static void encode_i25 (unsigned char *data,
+static void encode_i25 (char *data,
                         int dir)
 {
-    printf("------------------------------------------------------------\n"
-           "encode Interleaved 2 of 5: %s\n"
-           "    encode start:", data);
+    assert(zbar_decoder_get_color(decoder) == ZBAR_SPACE);
+    print_sep(3);
+    zprintf(2, "Interleaved 2 of 5: %s\n", data);
+    zprintf(3, "    encode start:");
     encode((dir) ? 0xa1111 : 0xa112, 0);
 
     /* FIXME rev case data reversal */
     int i;
-    for(i = (strlen((char*)data) & 1) ? -1 : 0; i < 0 || data[i]; i += 2) {
+    for(i = (strlen(data) & 1) ? -1 : 0; i < 0 || data[i]; i += 2) {
         /* encode 2 digits */
         unsigned char c0 = (i < 0) ? 0 : data[i] - '0';
         unsigned char c1 = data[i + 1] - '0';
-        printf("    encode '%d%d':", c0, c1);
+        zprintf(3, "    encode '%d%d':", c0, c1);
         assert(c0 < 10);
         assert(c1 < 10);
 
@@ -337,12 +549,252 @@ static void encode_i25 (unsigned char *d
         encode(enc, dir);
     }
 
-    printf("    encode end:");
+    zprintf(3, "    encode end:");
     encode((dir) ? 0x211a : 0x1111a, 0);
-    printf("------------------------------------------------------------\n");
+    print_sep(3);
 }
 
 /*------------------------------------------------------------*/
+/* DataBar encoding */
+
+
+/* character encoder reference algorithm from ISO/IEC 24724:2009 */
+
+struct rss_group {
+    int T_odd, T_even, n_odd, w_max;
+};
+
+static const struct rss_group databar_groups_outside[] = {
+    { 161,   1, 12, 8 },
+    {  80,  10, 10, 6 },
+    {  31,  34,  8, 4 },
+    {  10,  70,  6, 3 },
+    {   1, 126,  4, 1 },
+    {   0, }
+};
+
+static const struct rss_group databar_groups_inside[] = {
+    {  4, 84,  5, 2 },
+    { 20, 35,  7, 4 },
+    { 48, 10,  9, 6 },
+    { 81,  1, 11, 8 },
+    {  0, }
+};
+
+static const uint32_t databar_finders[9] = {
+    0x38211, 0x35511, 0x33711, 0x31911, 0x27411,
+    0x25611, 0x23811, 0x15711, 0x13911,
+};
+
+int combins (int n,
+             int r)
+{
+    int i, j;
+    int maxDenom, minDenom;
+    int val;
+    if(n-r > r) {
+        minDenom = r;
+        maxDenom = n-r;
+    }
+    else {
+        minDenom = n-r;
+        maxDenom = r;
+    }
+    val = 1;
+    j = 1;
+    for(i = n; i > maxDenom; i--) {
+        val *= i;
+        if(j <= minDenom) {
+            val /= j;
+            j++;
+        }
+    }
+    for(; j <= minDenom; j++)
+        val /= j;
+    return(val);
+}
+
+void getRSSWidths (int val,
+                   int n,
+                   int elements,
+                   int maxWidth,
+                   int noNarrow,
+                   int *widths)
+{
+    int narrowMask = 0;
+    int bar;
+    for(bar = 0; bar < elements - 1; bar++) {
+        int elmWidth, subVal;
+        for(elmWidth = 1, narrowMask |= (1<<bar);
+            ;
+            elmWidth++, narrowMask &= ~(1<<bar))
+        {
+            subVal = combins(n-elmWidth-1, elements-bar-2);
+            if((!noNarrow) && !narrowMask &&
+                (n-elmWidth-(elements-bar-1) >= elements-bar-1))
+                subVal -= combins(n-elmWidth-(elements-bar), elements-bar-2);
+            if(elements-bar-1 > 1) {
+                int mxwElement, lessVal = 0;
+                for (mxwElement = n-elmWidth-(elements-bar-2);
+                     mxwElement > maxWidth;
+                     mxwElement--)
+                    lessVal += combins(n-elmWidth-mxwElement-1, elements-bar-3);
+                subVal -= lessVal * (elements-1-bar);
+            }
+            else if (n-elmWidth > maxWidth)
+                subVal--;
+            val -= subVal;
+            if(val < 0)
+                break;
+        }
+        val += subVal;
+        n -= elmWidth;
+        widths[bar] = elmWidth;
+    }
+    widths[bar] = n;
+}
+
+static uint64_t encode_databar_char (unsigned val,
+                                     const struct rss_group *grp,
+                                     int nmodules,
+                                     int nelems,
+                                     int dir)
+{
+    int G_sum = 0;
+    while(1) {
+        assert(grp->T_odd);
+        int sum = G_sum + grp->T_odd * grp->T_even;
+        if(val >= sum)
+            G_sum = sum;
+        else
+            break;
+        grp++;
+    }
+
+    zprintf(3, "char=%d", val);
+
+    int V_grp = val - G_sum;
+    int V_odd, V_even;
+    if(!dir) {
+        V_odd = V_grp / grp->T_even;
+        V_even = V_grp % grp->T_even;
+    }
+    else {
+        V_even = V_grp / grp->T_odd;
+        V_odd = V_grp % grp->T_odd;
+    }
+
+    zprintf(3, " G_sum=%d T_odd=%d T_even=%d n_odd=%d w_max=%d V_grp=%d\n",
+            G_sum, grp->T_odd, grp->T_even, grp->n_odd, grp->w_max, V_grp);
+
+    int odd[16];
+    getRSSWidths(V_odd, grp->n_odd, nelems, grp->w_max, !dir, odd);
+    zprintf(3, "    V_odd=%d odd=%d%d%d%d",
+            V_odd, odd[0], odd[1], odd[2], odd[3]);
+
+    int even[16];
+    getRSSWidths(V_even, nmodules - grp->n_odd, nelems, 9 - grp->w_max,
+                 dir, even);
+    zprintf(3, " V_even=%d even=%d%d%d%d",
+            V_even, even[0], even[1], even[2], even[3]);
+
+    uint64_t units = 0;
+    int i;
+    for(i = 0; i < nelems; i++)
+        units = (units << 8) | (odd[i] << 4) | even[i];
+
+    zprintf(3, " raw=%"PRIx64"\n", units);
+    return(units);
+}
+
+#define SWAP(a, b) do { \
+        uint32_t tmp = (a); \
+        (a) = (b); \
+        (b) = tmp; \
+    } while(0);
+
+static void encode_databar (char *data,
+                            int dir)
+{
+    assert(zbar_decoder_get_color(decoder) == ZBAR_SPACE);
+
+    print_sep(3);
+    zprintf(2, "DataBar: %s\n", data);
+
+    uint32_t v[4] = { 0, };
+    int i, j;
+    for(i = 0; i < 14; i++) {
+        for(j = 0; j < 4; j++)
+            v[j] *= 10;
+        assert(data[i]);
+        v[0] += data[i] - '0';
+        v[1] += v[0] / 1597;
+        v[0] %= 1597;
+        v[2] += v[1] / 2841;
+        v[1] %= 2841;
+        v[3] += v[2] / 1597;
+        v[2] %= 1597;
+        /*printf("    [%d] %c (%d,%d,%d,%d)\n",
+               i, data[i], v[0], v[1], v[2], v[3]);*/
+    }
+    zprintf(3, "chars=(%d,%d,%d,%d)\n", v[3], v[2], v[1], v[0]);
+
+    uint32_t c[4] = {
+        encode_databar_char(v[3], databar_groups_outside, 16, 4, 0),
+        encode_databar_char(v[2], databar_groups_inside, 15, 4, 1),
+        encode_databar_char(v[1], databar_groups_outside, 16, 4, 0),
+        encode_databar_char(v[0], databar_groups_inside, 15, 4, 1),
+    };
+
+    int chk = 0, w = 1;
+    for(i = 0; i < 4; i++, chk %= 79, w %= 79)
+        for(j = 0; j < 8; j++, w *= 3)
+            chk += ((c[i] >> (28 - j * 4)) & 0xf) * w;
+    zprintf(3, "chk=%d\n", chk);
+
+    if(chk >= 8) chk++;
+    if(chk >= 72) chk++;
+    int C_left = chk / 9;
+    int C_right = chk % 9;
+
+    if(dir == REV) {
+        SWAP(C_left, C_right);
+        SWAP(c[0], c[2]);
+        SWAP(c[1], c[3]);
+        SWAP(v[0], v[2]);
+        SWAP(v[1], v[3]);
+    }
+
+    zprintf(3, "    encode start guard:");
+    encode_junk(dir);
+    encode(0x1, FWD);
+
+    zprintf(3, "encode char[0]=%d", v[3]);
+    encode(c[0], REV);
+
+    zprintf(3, "encode left finder=%d", C_left);
+    encode(databar_finders[C_left], REV);
+
+    zprintf(3, "encode char[1]=%d", v[2]);
+    encode(c[1], FWD);
+
+    zprintf(3, "encode char[3]=%d", v[0]);
+    encode(c[3], REV);
+
+    zprintf(3, "encode right finder=%d", C_right);
+    encode(databar_finders[C_right], FWD);
+
+    zprintf(3, "encode char[2]=%d", v[1]);
+    encode(c[2], FWD);
+
+    zprintf(3, "    encode end guard:");
+    encode(0x1, FWD);
+    encode_junk(!dir);
+    print_sep(3);
+}
+
+
+/*------------------------------------------------------------*/
 /* EAN/UPC encoding */
 
 static const unsigned int ean_digits[10] = {
@@ -372,7 +824,7 @@ static const unsigned char ean_parity_en
     0x25,       /* ABBABA = 9 */
 };
 
-static void calc_ean_parity (unsigned char *data,
+static void calc_ean_parity (char *data,
                              int n)
 {
     int i, chk = 0;
@@ -387,119 +839,293 @@ static void calc_ean_parity (unsigned ch
     data[i] = 0;
 }
 
-static void encode_ean13 (unsigned char *data)
+static void encode_ean13 (char *data)
 {
     int i;
     unsigned char par = ean_parity_encode[data[0] - '0'];
+    assert(zbar_decoder_get_color(decoder) == ZBAR_SPACE);
 
-    printf("------------------------------------------------------------\n"
-           "encode EAN-13: %s (%02x)\n"
-           "    encode start guard:",
-           data, par);
+    print_sep(3);
+    zprintf(2, "EAN-13: %s (%02x)\n", data, par);
+    zprintf(3, "    encode start guard:");
     encode(ean_guard[3], FWD);
     for(i = 1; i < 7; i++, par <<= 1) {
-        printf("    encode %x%c:", (par >> 5) & 1, data[i]);
-        encode(ean_digits[data[i] - '0'], REV ^ ((par >> 5) & 1));
+        zprintf(3, "    encode %x%c:", (par >> 5) & 1, data[i]);
+        encode(ean_digits[data[i] - '0'], (par >> 5) & 1);
     }
-    printf("    encode center guard:");
+    zprintf(3, "    encode center guard:");
     encode(ean_guard[5], FWD);
     for(; i < 13; i++) {
-        printf("    encode %x%c:", 0, data[i]);
+        zprintf(3, "    encode %x%c:", 0, data[i]);
         encode(ean_digits[data[i] - '0'], FWD);
     }
-    printf("    encode end guard:");
+    zprintf(3, "    encode end guard:");
     encode(ean_guard[3], REV);
-    printf("------------------------------------------------------------\n");
+    print_sep(3);
 }
 
-static void encode_ean8 (unsigned char *data)
+static void encode_ean8 (char *data)
 {
     int i;
-    printf("------------------------------------------------------------\n"
-           "encode EAN-8: %s\n"
-           "    encode start guard:",
-           data);
+    assert(zbar_decoder_get_color(decoder) == ZBAR_SPACE);
+    print_sep(3);
+    zprintf(2, "EAN-8: %s\n", data);
+    zprintf(3, "    encode start guard:");
     encode(ean_guard[3], FWD);
     for(i = 0; i < 4; i++) {
-        printf("    encode %c:", data[i]);
+        zprintf(3, "    encode %c:", data[i]);
         encode(ean_digits[data[i] - '0'], FWD);
     }
-    printf("    encode center guard:");
+    zprintf(3, "    encode center guard:");
     encode(ean_guard[5], FWD);
     for(; i < 8; i++) {
-        printf("    encode %c:", data[i]);
+        zprintf(3, "    encode %c:", data[i]);
         encode(ean_digits[data[i] - '0'], FWD);
     }
-    printf("    encode end guard:");
+    zprintf(3, "    encode end guard:");
     encode(ean_guard[3], REV);
-    printf("------------------------------------------------------------\n");
+    print_sep(3);
 }
 
 
 /*------------------------------------------------------------*/
 /* main test flow */
 
-int main (int argc, char **argv)
+int test_databar_F_1 ()
 {
-    int i;
-    int rnd_size = 9;           /* should be odd */
-    srand(0xbabeface);
+    expect(ZBAR_DATABAR, "0124012345678905");
+    assert(zbar_decoder_get_color(decoder) == ZBAR_SPACE);
+    encode(0x11, 0);
+    encode(0x31111333, 0);
+    encode(0x13911, 0);
+    encode(0x31131231, 0);
+    encode(0x11214222, 0);
+    encode(0x11553, 0);
+    encode(0x21231313, 0);
+    encode(0x1, 0);
+    encode_junk(rnd_size);
+    return(0);
+}
 
-    /* FIXME TBD:
-     *   - random module width (!= 1.0)
-     *   - simulate scan speed variance
-     *   - simulate dark "swelling" and light "blooming"
-     *   - inject parity errors
-     */
-    decoder = zbar_decoder_create();
-    zbar_decoder_set_handler(decoder, symbol_handler);
-    zbar_decoder_set_config(decoder, 0, ZBAR_CFG_MIN_LEN, 0);
+int test_databar_F_3 ()
+{
+    expect(ZBAR_DATABAR_EXP, "1012A");
+    assert(zbar_decoder_get_color(decoder) == ZBAR_SPACE);
+    encode(0x11, 0);
+    encode(0x11521151, 0);
+    encode(0x18411, 0);
+    encode(0x13171121, 0);
+    encode(0x11521232, 0);
+    encode(0x11481, 0);
+    encode(0x23171111, 0);
+    encode(0x1, 0);
+    encode_junk(rnd_size);
+    return(0);
+}
 
-    encode_junk(rnd_size + 1);
+int test_orange ()
+{
+    char data[32] = "0100845963000052";
+    expect(ZBAR_DATABAR, data);
+    assert(zbar_decoder_get_color(decoder) == ZBAR_SPACE);
+    encode(0x1, 0);
+    encode(0x23212321, 0);   // data[0]
+    encode(0x31911, 0);      // finder[?] = 3
+    encode(0x21121215, 1);   // data[1]
+    encode(0x41111133, 0);   // data[3]
+    encode(0x23811, 1);      // finder[?] = 6
+    encode(0x11215141, 1);   // data[2]
+    encode(0x11, 0);
+    encode_junk(rnd_size);
 
-    unsigned char data[32] = { 0 };
-    for(i = 0; i < 12; i++)
-        data[i] = (rand() % 10) + '0';
+    expect(ZBAR_DATABAR, data);
+    data[1] = '0';
+    encode_databar(data + 1, FWD);
+    encode_junk(rnd_size);
+    return(0);
+}
 
-    calc_ean_parity(data, 12);
-    encode_ean13(data);
+int test_numeric (char *data)
+{
+    char tmp[32] = "01";
+    strncpy(tmp + 2, data + 1, 13);
+    calc_ean_parity(tmp + 2, 13);
+    expect(ZBAR_DATABAR, tmp);
+
+    tmp[1] = data[0] & '1';
+    encode_databar(tmp + 1, (rand() >> 8) & 1);
 
     encode_junk(rnd_size);
 
-    data[i] = 0;
+    data[strlen(data) & ~1] = 0;
+    expect(ZBAR_CODE128, data);
     encode_code128c(data);
 
     encode_junk(rnd_size);
 
+    expect(ZBAR_I25, data);
     encode_i25(data, FWD);
 
     encode_junk(rnd_size);
 
+#if 0 /* FIXME encoding broken */
     encode_i25(data, REV);
 
     encode_junk(rnd_size);
+#endif
 
-    calc_ean_parity(data, 7);
-    encode_ean8(data);
+    calc_ean_parity(data + 2, 12);
+    expect(ZBAR_EAN13, data + 2);
+    encode_ean13(data + 2);
 
     encode_junk(rnd_size);
 
+    calc_ean_parity(data + 7, 7);
+    expect(ZBAR_EAN8, data + 7);
+    encode_ean8(data + 7);
+
+    encode_junk(rnd_size);
+
+    expect(ZBAR_NONE, NULL);
+    return(0);
+}
+
+int test_alpha (char *data)
+{
+    expect(ZBAR_CODE128, data);
+    encode_code128b(data);
+
+    encode_junk(rnd_size);
+
+    expect(ZBAR_CODE93, data);
+    encode_code93(data, FWD);
+
+    encode_junk(rnd_size);
+
+    expect(ZBAR_CODE93, data);
+    encode_code93(data, REV);
+
+    encode_junk(rnd_size);
+
+    /*encode_code39("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%");*/
+    convert_code39(data);
+    expect(ZBAR_CODE39, data);
+    encode_code39(data);
+
+    encode_junk(rnd_size);
+
+#if 0 /* FIXME decoder unfinished */
+    encode_pdf417(data);
+
+    encode_junk(rnd_size);
+#endif
+
+    expect(ZBAR_NONE, NULL);
+    return(0);
+}
+
+int test1 ()
+{
+    print_sep(2);
+    if(!seed)
+        seed = 0xbabeface;
+    zprintf(1, "[%d] SEED=%d\n", iter++, seed);
+    srand(seed);
+
+    int i;
+    char data[32] = { 0, };
+    for(i = 0; i < 14; i++)
+        data[i] = (rand() % 10) + '0';
+
+    test_numeric(data);
+
     for(i = 0; i < 10; i++)
         data[i] = (rand() % 0x5f) + 0x20;
     data[i] = 0;
 
-    encode_code128b(data);
+    test_alpha(data);
+    return(0);
+}
 
-    encode_junk(rnd_size);
+/* FIXME TBD:
+ *   - random module width (!= 1.0)
+ *   - simulate scan speed variance
+ *   - simulate dark "swelling" and light "blooming"
+ *   - inject parity errors
+ */
 
-    /*encode_code39("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%");*/
-    encode_code39(data);
+int main (int argc, char **argv)
+{
+    int n, i, j;
+    char *end;
 
-    encode_junk(rnd_size);
+    decoder = zbar_decoder_create();
+    zbar_decoder_set_handler(decoder, symbol_handler);
 
-    encode_pdf417(data);
+    encode_junk(rnd_size + 1);
 
-    encode_junk(rnd_size);
+    for(i = 1; i < argc; i++) {
+        if(argv[i][0] != '-') {
+            fprintf(stderr, "ERROR: unknown argument: %s\n", argv[i]);
+            return(2);
+        }
+        for(j = 1; argv[i][j]; j++) {
+            switch(argv[i][j])
+            {
+            case 'q': verbosity = 0; break;
+            case 'v': verbosity++; break;
+            case 'r':
+                seed = time(NULL);
+                srand(seed);
+                seed = (rand() << 8) ^ rand();
+                zprintf(0, "-r SEED=%d\n", seed);
+                break;
+
+            case 's':
+                if(!argv[i][++j] && !(j = 0) && ++i >= argc) {
+                    fprintf(stderr, "ERROR: -s needs <seed> argument\n");
+                    return(2);
+                }
+                seed = strtol(argv[i] + j, &end, 0);
+                if((!isdigit(argv[i][j]) && argv[i][j] != '-') ||
+                   !seed || seed == LONG_MAX || seed == LONG_MIN) {
+                    fprintf(stderr, "ERROR: invalid <seed>: \"%s\"\n",
+                            argv[i] + j);
+                    return(2);
+                }
+                j = end - argv[i] - 1;
+                break;
+
+            case 'n':
+                if(!argv[i][++j] && !(j = 0) && ++i >= argc) {
+                    fprintf(stderr, "ERROR: -n needs <num> argument\n");
+                    return(2);
+                }
+                n = strtol(argv[i] + j, &end, 0);
+                if(!isdigit(argv[i][j]) || !n) {
+                    fprintf(stderr, "ERROR: invalid <num>: \"%s\"\n",
+                            argv[i] + j);
+                    return(2);
+                }
+                j = end - argv[i] - 1;
+
+                while(n--) {
+                    test1();
+                    seed = (rand() << 8) ^ rand();
+                }
+                break;
+            }
+        }
+    }
+
+    if(!iter) {
+        test_databar_F_1();
+        test_databar_F_3();
+        test_orange();
+        test1();
+    }
+
+    /* FIXME "Ran %d iterations in %gs\n\nOK\n" */
 
     zbar_decoder_destroy(decoder);
     return(0);
diff --git a/test/test_images.h b/test/test_images.h
--- a/test/test_images.h
+++ b/test/test_images.h
@@ -1,5 +1,5 @@
 /*------------------------------------------------------------------------
- *  Copyright 2007-2009 (c) Jeff Brown <spadix@users.sourceforge.net>
+ *  Copyright 2007-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
  *
  *  This file is part of the ZBar Bar Code Reader.
  *
@@ -23,10 +23,7 @@
 #ifndef _TEST_IMAGES_H_
 #define _TEST_IMAGES_H_
 
-/* adapted from v4l2 spec */
-#define fourcc(a, b, c, d)                      \
-    ((uint32_t)(a) | ((uint32_t)(b) << 8) |     \
-     ((uint32_t)(c) << 16) | ((uint32_t)(d) << 24))
+#define fourcc zbar_fourcc
 
 int test_image_check_cleanup(void);
 int test_image_bars(zbar_image_t*);
diff --git a/zbar/Makefile.am.inc b/zbar/Makefile.am.inc
--- a/zbar/Makefile.am.inc
+++ b/zbar/Makefile.am.inc
@@ -19,9 +19,15 @@ EXTRA_zbar_libzbar_la_SOURCES = zbar/svg
 if ENABLE_EAN
 zbar_libzbar_la_SOURCES += zbar/decoder/ean.h zbar/decoder/ean.c
 endif
+if ENABLE_DATABAR
+zbar_libzbar_la_SOURCES += zbar/decoder/databar.h zbar/decoder/databar.c
+endif
 if ENABLE_CODE128
 zbar_libzbar_la_SOURCES += zbar/decoder/code128.h zbar/decoder/code128.c
 endif
+if ENABLE_CODE93
+zbar_libzbar_la_SOURCES += zbar/decoder/code93.h zbar/decoder/code93.c
+endif
 if ENABLE_CODE39
 zbar_libzbar_la_SOURCES += zbar/decoder/code39.h zbar/decoder/code39.c
 endif
diff --git a/zbar/config.c b/zbar/config.c
--- a/zbar/config.c
+++ b/zbar/config.c
@@ -1,5 +1,5 @@
 /*------------------------------------------------------------------------
- *  Copyright 2008-2009 (c) Jeff Brown <spadix@users.sourceforge.net>
+ *  Copyright 2008-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
  *
  *  This file is part of the ZBar Bar Code Reader.
  *
@@ -24,20 +24,24 @@
 #include <config.h>
 #include <stdlib.h>     /* strtol */
 #include <string.h>     /* strchr, strncmp, strlen */
-#include <errno.h>
-#include <assert.h>
+#ifdef HAVE_ERRNO_H
+# include <errno.h>
+#endif
 
 #include <zbar.h>
 
 int zbar_parse_config (const char *cfgstr,
-                        zbar_symbol_type_t *sym,
-                        zbar_config_t *cfg,
-                        int *val)
+                       zbar_symbol_type_t *sym,
+                       zbar_config_t *cfg,
+                       int *val)
 {
+    const char *dot, *eq;
+    int len;
+    char negate;
     if(!cfgstr)
         return(1);
 
-    const char *dot = strchr(cfgstr, '.');
+    dot = strchr(cfgstr, '.');
     if(dot) {
         int len = dot - cfgstr;
         if(!len || (len == 1 && !strncmp(cfgstr, "*", len)))
@@ -46,6 +50,8 @@ int zbar_parse_config (const char *cfgst
             return(1);
         else if(!strncmp(cfgstr, "qrcode", len))
             *sym = ZBAR_QRCODE;
+        else if(!strncmp(cfgstr, "db", len))
+            *sym = ZBAR_DATABAR;
         else if(len < 3)
             return(1);
         else if(!strncmp(cfgstr, "upca", len))
@@ -66,6 +72,8 @@ int zbar_parse_config (const char *cfgst
             *sym = ZBAR_ISBN13;
         else if(!strncmp(cfgstr, "isbn10", len))
             *sym = ZBAR_ISBN10;
+        else if(!strncmp(cfgstr, "db-exp", len))
+            *sym = ZBAR_DATABAR_EXP;
 #if 0
         /* FIXME addons are configured per-main symbol type */
         else if(!strncmp(cfgstr, "addon2", len))
@@ -75,6 +83,8 @@ int zbar_parse_config (const char *cfgst
 #endif
         else if(len < 6)
             return(1);
+        else if(!strncmp(cfgstr, "code93", len))
+            *sym = ZBAR_CODE93;
         else if(!strncmp(cfgstr, "code39", len))
             *sym = ZBAR_CODE39;
         else if(!strncmp(cfgstr, "pdf417", len))
@@ -83,6 +93,10 @@ int zbar_parse_config (const char *cfgst
             return(1);
         else if(!strncmp(cfgstr, "code128", len))
             *sym = ZBAR_CODE128;
+        else if(!strncmp(cfgstr, "databar", len))
+            *sym = ZBAR_DATABAR;
+        else if(!strncmp(cfgstr, "databar-exp", len))
+            *sym = ZBAR_DATABAR_EXP;
         else
             return(1);
         cfgstr = dot + 1;
@@ -90,13 +104,13 @@ int zbar_parse_config (const char *cfgst
     else
         *sym = 0;
 
-    int len = strlen(cfgstr);
-    const char *eq = strchr(cfgstr, '=');
+    len = strlen(cfgstr);
+    eq = strchr(cfgstr, '=');
     if(eq)
         len = eq - cfgstr;
     else
         *val = 1;  /* handle this here so we can override later */
-    char negate = 0;
+    negate = 0;
 
     if(len > 3 && !strncmp(cfgstr, "no-", 3)) {
         negate = 1;
@@ -130,16 +144,22 @@ int zbar_parse_config (const char *cfgst
         *cfg = ZBAR_CFG_ADD_CHECK;
     else if(!strncmp(cfgstr, "emit-check", len))
         *cfg = ZBAR_CFG_EMIT_CHECK;
+    else if(!strncmp(cfgstr, "uncertainty", len))
+        *cfg = ZBAR_CFG_UNCERTAINTY;
     else if(!strncmp(cfgstr, "position", len))
         *cfg = ZBAR_CFG_POSITION;
     else 
         return(1);
 
     if(eq) {
+#ifdef HAVE_ERRNO_H
         errno = 0;
+#endif
         *val = strtol(eq + 1, NULL, 0);
+#ifdef HAVE_ERRNO_H
         if(errno)
             return(1);
+#endif
     }
     if(negate)
         *val = !*val;
diff --git a/zbar/convert.c b/zbar/convert.c
--- a/zbar/convert.c
+++ b/zbar/convert.c
@@ -1,5 +1,5 @@
 /*------------------------------------------------------------------------
- *  Copyright 2007-2009 (c) Jeff Brown <spadix@users.sourceforge.net>
+ *  Copyright 2007-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
  *
  *  This file is part of the ZBar Bar Code Reader.
  *
@@ -236,12 +236,13 @@ static inline void uv_round (zbar_image_
 static inline void uv_roundup (zbar_image_t *img,
                                const zbar_format_def_t *fmt)
 {
+    unsigned xmask, ymask;
     if(fmt->group == ZBAR_FMT_GRAY)
         return;
-    unsigned xmask = (1 << fmt->p.yuv.xsub2) - 1;
+    xmask = (1 << fmt->p.yuv.xsub2) - 1;
     if(img->width & xmask)
         img->width = (img->width + xmask) & ~xmask;
-    unsigned ymask = (1 << fmt->p.yuv.ysub2) - 1;
+    ymask = (1 << fmt->p.yuv.ysub2) - 1;
     if(img->height & ymask)
         img->height = (img->height + ymask) & ~ymask;
 }
@@ -306,16 +307,18 @@ static inline void convert_y_resize (zba
                                      const zbar_format_def_t *srcfmt,
                                      size_t n)
 {
+    uint8_t *psrc, *pdst;
+    unsigned width, height, xpad, y;
+
     if(dst->width == src->width && dst->height == src->height) {
         memcpy((void*)dst->data, src->data, n);
         return;
     }
-    uint8_t *psrc = (void*)src->data;
-    uint8_t *pdst = (void*)dst->data;
-    unsigned width = (dst->width > src->width) ? src->width : dst->width;
-    unsigned xpad = (dst->width > src->width) ? dst->width - src->width : 0;
-    unsigned height = (dst->height > src->height) ? src->height : dst->height;
-    unsigned y;
+    psrc = (void*)src->data;
+    pdst = (void*)dst->data;
+    width = (dst->width > src->width) ? src->width : dst->width;
+    xpad = (dst->width > src->width) ? dst->width - src->width : 0;
+    height = (dst->height > src->height) ? src->height : dst->height;
     for(y = 0; y < height; y++) {
         memcpy(pdst, psrc, width);
         pdst += width;
@@ -344,10 +347,10 @@ static void convert_copy (zbar_image_t *
 {
     if(src->width == dst->width &&
        src->height == dst->height) {
+        zbar_image_t *s = (zbar_image_t*)src;
         dst->data = src->data;
         dst->datalen = src->datalen;
         dst->cleanup = cleanup_ref;
-        zbar_image_t *s = (zbar_image_t*)src;
         dst->next = s;
         _zbar_image_refcnt(s, 1);
     }
@@ -362,9 +365,10 @@ static void convert_uvp_append (zbar_ima
                                 const zbar_image_t *src,
                                 const zbar_format_def_t *srcfmt)
 {
+    unsigned long n;
     uv_roundup(dst, dstfmt);
     dst->datalen = uvp_size(dst, dstfmt) * 2;
-    unsigned long n = dst->width * dst->height;
+    n = dst->width * dst->height;
     dst->datalen += n;
     assert(src->datalen >= src->width * src->height);
     zprintf(24, "dst=%dx%d (%lx) %lx src=%dx%d %lx\n",
@@ -373,7 +377,7 @@ static void convert_uvp_append (zbar_ima
     dst->data = malloc(dst->datalen);
     if(!dst->data) return;
     convert_y_resize(dst, dstfmt, src, srcfmt, n);
-    memset((void*)dst->data + n, 0x80, dst->datalen - n);
+    memset((uint8_t*)dst->data + n, 0x80, dst->datalen - n);
 }
 
 /* interleave YUV planes into packed YUV */
@@ -382,32 +386,35 @@ static void convert_yuv_pack (zbar_image
                               const zbar_image_t *src,
                               const zbar_format_def_t *srcfmt)
 {
+    unsigned long srcm, srcn;
+    uint8_t flags, *srcy, *dstp;
+    const uint8_t *srcu, *srcv;
+    unsigned srcl, xmask, ymask, x, y;
+    uint8_t y0 = 0, y1 = 0, u = 0x80, v = 0x80;
+
     uv_roundup(dst, dstfmt);
     dst->datalen = dst->width * dst->height + uvp_size(dst, dstfmt) * 2;
     dst->data = malloc(dst->datalen);
     if(!dst->data) return;
-    uint8_t *dstp = (void*)dst->data;
+    dstp = (void*)dst->data;
 
-    unsigned long srcm = uvp_size(src, srcfmt);
-    unsigned long srcn = src->width * src->height;
+    srcm = uvp_size(src, srcfmt);
+    srcn = src->width * src->height;
     assert(src->datalen >= srcn + 2 * srcn);
-    uint8_t flags = dstfmt->p.yuv.packorder ^ srcfmt->p.yuv.packorder;
-    uint8_t *srcy = (void*)src->data;
-    const uint8_t *srcu, *srcv;
+    flags = dstfmt->p.yuv.packorder ^ srcfmt->p.yuv.packorder;
+    srcy = (void*)src->data;
     if(flags & 1) {
-        srcv = src->data + srcn;
+        srcv = (uint8_t*)src->data + srcn;
         srcu = srcv + srcm;
     } else {
-        srcu = src->data + srcn;
+        srcu = (uint8_t*)src->data + srcn;
         srcv = srcu + srcm;
     }
     flags = dstfmt->p.yuv.packorder & 2;
 
-    unsigned srcl = src->width >> srcfmt->p.yuv.xsub2;
-    unsigned xmask = (1 << srcfmt->p.yuv.xsub2) - 1;
-    unsigned ymask = (1 << srcfmt->p.yuv.ysub2) - 1;
-    unsigned x, y;
-    uint8_t y0 = 0, y1 = 0, u = 0x80, v = 0x80;
+    srcl = src->width >> srcfmt->p.yuv.xsub2;
+    xmask = (1 << srcfmt->p.yuv.xsub2) - 1;
+    ymask = (1 << srcfmt->p.yuv.ysub2) - 1;
     for(y = 0; y < dst->height; y++) {
         if(y >= src->height) {
             srcy -= src->width;
@@ -448,25 +455,29 @@ static void convert_yuv_unpack (zbar_ima
                                 const zbar_image_t *src,
                                 const zbar_format_def_t *srcfmt)
 {
+    unsigned long dstn, dstm2;
+    uint8_t *dsty, flags;
+    const uint8_t *srcp;
+    unsigned srcl, x, y;
+    uint8_t y0 = 0, y1 = 0;
+
     uv_roundup(dst, dstfmt);
-    unsigned long dstn = dst->width * dst->height;
-    unsigned long dstm2 = uvp_size(dst, dstfmt) * 2;
+    dstn = dst->width * dst->height;
+    dstm2 = uvp_size(dst, dstfmt) * 2;
     dst->datalen = dstn + dstm2;
     dst->data = malloc(dst->datalen);
     if(!dst->data) return;
     if(dstm2)
-        memset((void*)dst->data + dstn, 0x80, dstm2);
-    uint8_t *dsty = (void*)dst->data;
+        memset((uint8_t*)dst->data + dstn, 0x80, dstm2);
+    dsty = (uint8_t*)dst->data;
 
-    uint8_t flags = srcfmt->p.yuv.packorder ^ dstfmt->p.yuv.packorder;
+    flags = srcfmt->p.yuv.packorder ^ dstfmt->p.yuv.packorder;
     flags &= 2;
-    const uint8_t *srcp = src->data;
+    srcp = src->data;
     if(flags)
         srcp++;
 
-    unsigned srcl = src->width + (src->width >> srcfmt->p.yuv.xsub2);
-    unsigned x, y;
-    uint8_t y0 = 0, y1 = 0;
+    srcl = src->width + (src->width >> srcfmt->p.yuv.xsub2);
     for(y = 0; y < dst->height; y++) {
         if(y >= src->height)
             srcp -= srcl;
@@ -491,15 +502,16 @@ static void convert_uvp_resample (zbar_i
                                   const zbar_image_t *src,
                                   const zbar_format_def_t *srcfmt)
 {
+    unsigned long dstn, dstm2;
     uv_roundup(dst, dstfmt);
-    unsigned long dstn = dst->width * dst->height;
-    unsigned long dstm2 = uvp_size(dst, dstfmt) * 2;
+    dstn = dst->width * dst->height;
+    dstm2 = uvp_size(dst, dstfmt) * 2;
     dst->datalen = dstn + dstm2;
     dst->data = malloc(dst->datalen);
     if(!dst->data) return;
     convert_y_resize(dst, dstfmt, src, srcfmt, dstn);
     if(dstm2)
-        memset((void*)dst->data + dstn, 0x80, dstm2);
+        memset((uint8_t*)dst->data + dstn, 0x80, dstm2);
 }
 
 /* rearrange interleaved UV componets */
@@ -508,19 +520,23 @@ static void convert_uv_resample (zbar_im
                                  const zbar_image_t *src,
                                  const zbar_format_def_t *srcfmt)
 {
+    unsigned long dstn;
+    uint8_t *dstp, flags;
+    const uint8_t *srcp;
+    unsigned srcl, x, y;
+    uint8_t y0 = 0, y1 = 0, u = 0x80, v = 0x80;
+
     uv_roundup(dst, dstfmt);
-    unsigned long dstn = dst->width * dst->height;
+    dstn = dst->width * dst->height;
     dst->datalen = dstn + uvp_size(dst, dstfmt) * 2;
     dst->data = malloc(dst->datalen);
     if(!dst->data) return;
-    uint8_t *dstp = (void*)dst->data;
+    dstp = (void*)dst->data;
 
-    uint8_t flags = (srcfmt->p.yuv.packorder ^ dstfmt->p.yuv.packorder) & 1;
-    const uint8_t *srcp = src->data;
+    flags = (srcfmt->p.yuv.packorder ^ dstfmt->p.yuv.packorder) & 1;
+    srcp = src->data;
 
-    unsigned srcl = src->width + (src->width >> srcfmt->p.yuv.xsub2);
-    unsigned x, y;
-    uint8_t y0 = 0, y1 = 0, u = 0x80, v = 0x80;
+    srcl = src->width + (src->width >> srcfmt->p.yuv.xsub2);
     for(y = 0; y < dst->height; y++) {
         if(y >= src->height)
             srcp -= srcl;
@@ -560,25 +576,29 @@ static void convert_yuvp_to_rgb (zbar_im
                                  const zbar_image_t *src,
                                  const zbar_format_def_t *srcfmt)
 {
+    uint8_t *dstp, *srcy;
+    int drbits, drbit0, dgbits, dgbit0, dbbits, dbbit0;
+    unsigned long srcm, srcn;
+    unsigned x, y;
+    uint32_t p = 0;
+
     dst->datalen = dst->width * dst->height * dstfmt->p.rgb.bpp;
     dst->data = malloc(dst->datalen);
     if(!dst->data) return;
-    uint8_t *dstp = (void*)dst->data;
+    dstp = (void*)dst->data;
 
-    int drbits = RGB_SIZE(dstfmt->p.rgb.red);
-    int drbit0 = RGB_OFFSET(dstfmt->p.rgb.red);
-    int dgbits = RGB_SIZE(dstfmt->p.rgb.green);
-    int dgbit0 = RGB_OFFSET(dstfmt->p.rgb.green);
-    int dbbits = RGB_SIZE(dstfmt->p.rgb.blue);
-    int dbbit0 = RGB_OFFSET(dstfmt->p.rgb.blue);
+    drbits = RGB_SIZE(dstfmt->p.rgb.red);
+    drbit0 = RGB_OFFSET(dstfmt->p.rgb.red);
+    dgbits = RGB_SIZE(dstfmt->p.rgb.green);
+    dgbit0 = RGB_OFFSET(dstfmt->p.rgb.green);
+    dbbits = RGB_SIZE(dstfmt->p.rgb.blue);
+    dbbit0 = RGB_OFFSET(dstfmt->p.rgb.blue);
 
-    unsigned long srcm = uvp_size(src, srcfmt);
-    unsigned long srcn = src->width * src->height;
+    srcm = uvp_size(src, srcfmt);
+    srcn = src->width * src->height;
     assert(src->datalen >= srcn + 2 * srcm);
-    uint8_t *srcy = (void*)src->data;
+    srcy = (void*)src->data;
 
-    unsigned x, y;
-    uint32_t p = 0;
     for(y = 0; y < dst->height; y++) {
         if(y >= src->height)
             srcy -= src->width;
@@ -606,29 +626,34 @@ static void convert_rgb_to_yuvp (zbar_im
                                  const zbar_image_t *src,
                                  const zbar_format_def_t *srcfmt)
 {
+    unsigned long dstn, dstm2;
+    uint8_t *dsty;
+    const uint8_t *srcp;
+    int rbits, rbit0, gbits, gbit0, bbits, bbit0;
+    unsigned srcl, x, y;
+    uint16_t y0 = 0;
+
     uv_roundup(dst, dstfmt);
-    unsigned long dstn = dst->width * dst->height;
-    unsigned long dstm2 = uvp_size(dst, dstfmt) * 2;
+    dstn = dst->width * dst->height;
+    dstm2 = uvp_size(dst, dstfmt) * 2;
     dst->datalen = dstn + dstm2;
     dst->data = malloc(dst->datalen);
     if(!dst->data) return;
     if(dstm2)
-        memset((void*)dst->data + dstn, 0x80, dstm2);
-    uint8_t *dsty = (void*)dst->data;
+        memset((uint8_t*)dst->data + dstn, 0x80, dstm2);
+    dsty = (void*)dst->data;
 
     assert(src->datalen >= (src->width * src->height * srcfmt->p.rgb.bpp));
-    const uint8_t *srcp = src->data;
+    srcp = src->data;
 
-    int rbits = RGB_SIZE(srcfmt->p.rgb.red);
-    int rbit0 = RGB_OFFSET(srcfmt->p.rgb.red);
-    int gbits = RGB_SIZE(srcfmt->p.rgb.green);
-    int gbit0 = RGB_OFFSET(srcfmt->p.rgb.green);
-    int bbits = RGB_SIZE(srcfmt->p.rgb.blue);
-    int bbit0 = RGB_OFFSET(srcfmt->p.rgb.blue);
+    rbits = RGB_SIZE(srcfmt->p.rgb.red);
+    rbit0 = RGB_OFFSET(srcfmt->p.rgb.red);
+    gbits = RGB_SIZE(srcfmt->p.rgb.green);
+    gbit0 = RGB_OFFSET(srcfmt->p.rgb.green);
+    bbits = RGB_SIZE(srcfmt->p.rgb.blue);
+    bbit0 = RGB_OFFSET(srcfmt->p.rgb.blue);
 
-    unsigned srcl = src->width * srcfmt->p.rgb.bpp;
-    unsigned x, y;
-    uint16_t y0 = 0;
+    srcl = src->width * srcfmt->p.rgb.bpp;
     for(y = 0; y < dst->height; y++) {
         if(y >= src->height)
             srcp -= srcl;
@@ -659,29 +684,33 @@ static void convert_yuv_to_rgb (zbar_ima
                                 const zbar_image_t *src,
                                 const zbar_format_def_t *srcfmt)
 {
+    uint8_t *dstp;
     unsigned long dstn = dst->width * dst->height;
+    int drbits, drbit0, dgbits, dgbit0, dbbits, dbbit0;
+    const uint8_t *srcp;
+    unsigned srcl, x, y;
+    uint32_t p = 0;
+
     dst->datalen = dstn * dstfmt->p.rgb.bpp;
     dst->data = malloc(dst->datalen);
     if(!dst->data) return;
-    uint8_t *dstp = (void*)dst->data;
+    dstp = (void*)dst->data;
 
-    int drbits = RGB_SIZE(dstfmt->p.rgb.red);
-    int drbit0 = RGB_OFFSET(dstfmt->p.rgb.red);
-    int dgbits = RGB_SIZE(dstfmt->p.rgb.green);
-    int dgbit0 = RGB_OFFSET(dstfmt->p.rgb.green);
-    int dbbits = RGB_SIZE(dstfmt->p.rgb.blue);
-    int dbbit0 = RGB_OFFSET(dstfmt->p.rgb.blue);
+    drbits = RGB_SIZE(dstfmt->p.rgb.red);
+    drbit0 = RGB_OFFSET(dstfmt->p.rgb.red);
+    dgbits = RGB_SIZE(dstfmt->p.rgb.green);
+    dgbit0 = RGB_OFFSET(dstfmt->p.rgb.green);
+    dbbits = RGB_SIZE(dstfmt->p.rgb.blue);
+    dbbit0 = RGB_OFFSET(dstfmt->p.rgb.blue);
 
     assert(src->datalen >= (src->width * src->height +
                             uvp_size(src, srcfmt) * 2));
-    const uint8_t *srcp = src->data;
+    srcp = src->data;
     if(srcfmt->p.yuv.packorder & 2)
         srcp++;
 
     assert(srcfmt->p.yuv.xsub2 == 1);
-    unsigned srcl = src->width + (src->width >> 1);
-    unsigned x, y;
-    uint32_t p = 0;
+    srcl = src->width + (src->width >> 1);
     for(y = 0; y < dst->height; y++) {
         if(y >= src->height)
             srcp -= srcl;
@@ -717,26 +746,30 @@ static void convert_rgb_to_yuv (zbar_ima
                                 const zbar_image_t *src,
                                 const zbar_format_def_t *srcfmt)
 {
+    uint8_t *dstp, flags;
+    const uint8_t *srcp;
+    int rbits, rbit0, gbits, gbit0, bbits, bbit0;
+    unsigned srcl, x, y;
+    uint16_t y0 = 0;
+
     uv_roundup(dst, dstfmt);
     dst->datalen = dst->width * dst->height + uvp_size(dst, dstfmt) * 2;
     dst->data = malloc(dst->datalen);
     if(!dst->data) return;
-    uint8_t *dstp = (void*)dst->data;
-    uint8_t flags = dstfmt->p.yuv.packorder & 2;
+    dstp = (void*)dst->data;
+    flags = dstfmt->p.yuv.packorder & 2;
 
     assert(src->datalen >= (src->width * src->height * srcfmt->p.rgb.bpp));
-    const uint8_t *srcp = src->data;
+    srcp = src->data;
 
-    int rbits = RGB_SIZE(srcfmt->p.rgb.red);
-    int rbit0 = RGB_OFFSET(srcfmt->p.rgb.red);
-    int gbits = RGB_SIZE(srcfmt->p.rgb.green);
-    int gbit0 = RGB_OFFSET(srcfmt->p.rgb.green);
-    int bbits = RGB_SIZE(srcfmt->p.rgb.blue);
-    int bbit0 = RGB_OFFSET(srcfmt->p.rgb.blue);
+    rbits = RGB_SIZE(srcfmt->p.rgb.red);
+    rbit0 = RGB_OFFSET(srcfmt->p.rgb.red);
+    gbits = RGB_SIZE(srcfmt->p.rgb.green);
+    gbit0 = RGB_OFFSET(srcfmt->p.rgb.green);
+    bbits = RGB_SIZE(srcfmt->p.rgb.blue);
+    bbit0 = RGB_OFFSET(srcfmt->p.rgb.blue);
 
-    unsigned srcl = src->width * srcfmt->p.rgb.bpp;
-    unsigned x, y;
-    uint16_t y0 = 0;
+    srcl = src->width * srcfmt->p.rgb.bpp;
     for(y = 0; y < dst->height; y++) {
         if(y >= src->height)
             srcp -= srcl;
@@ -773,31 +806,36 @@ static void convert_rgb_resample (zbar_i
                                   const zbar_format_def_t *srcfmt)
 {
     unsigned long dstn = dst->width * dst->height;
+    uint8_t *dstp;
+    int drbits, drbit0, dgbits, dgbit0, dbbits, dbbit0;
+    int srbits, srbit0, sgbits, sgbit0, sbbits, sbbit0;
+    const uint8_t *srcp;
+    unsigned srcl, x, y;
+    uint32_t p = 0;
+
     dst->datalen = dstn * dstfmt->p.rgb.bpp;
     dst->data = malloc(dst->datalen);
     if(!dst->data) return;
-    uint8_t *dstp = (void*)dst->data;
+    dstp = (void*)dst->data;
 
-    int drbits = RGB_SIZE(dstfmt->p.rgb.red);
-    int drbit0 = RGB_OFFSET(dstfmt->p.rgb.red);
-    int dgbits = RGB_SIZE(dstfmt->p.rgb.green);
-    int dgbit0 = RGB_OFFSET(dstfmt->p.rgb.green);
-    int dbbits = RGB_SIZE(dstfmt->p.rgb.blue);
-    int dbbit0 = RGB_OFFSET(dstfmt->p.rgb.blue);
+    drbits = RGB_SIZE(dstfmt->p.rgb.red);
+    drbit0 = RGB_OFFSET(dstfmt->p.rgb.red);
+    dgbits = RGB_SIZE(dstfmt->p.rgb.green);
+    dgbit0 = RGB_OFFSET(dstfmt->p.rgb.green);
+    dbbits = RGB_SIZE(dstfmt->p.rgb.blue);
+    dbbit0 = RGB_OFFSET(dstfmt->p.rgb.blue);
 
     assert(src->datalen >= (src->width * src->height * srcfmt->p.rgb.bpp));
-    const uint8_t *srcp = src->data;
+    srcp = src->data;
 
-    int srbits = RGB_SIZE(srcfmt->p.rgb.red);
-    int srbit0 = RGB_OFFSET(srcfmt->p.rgb.red);
-    int sgbits = RGB_SIZE(srcfmt->p.rgb.green);
-    int sgbit0 = RGB_OFFSET(srcfmt->p.rgb.green);
-    int sbbits = RGB_SIZE(srcfmt->p.rgb.blue);
-    int sbbit0 = RGB_OFFSET(srcfmt->p.rgb.blue);
+    srbits = RGB_SIZE(srcfmt->p.rgb.red);
+    srbit0 = RGB_OFFSET(srcfmt->p.rgb.red);
+    sgbits = RGB_SIZE(srcfmt->p.rgb.green);
+    sgbit0 = RGB_OFFSET(srcfmt->p.rgb.green);
+    sbbits = RGB_SIZE(srcfmt->p.rgb.blue);
+    sbbit0 = RGB_OFFSET(srcfmt->p.rgb.blue);
 
-    unsigned srcl = src->width * srcfmt->p.rgb.bpp;
-    unsigned x, y;
-    uint32_t p = 0;
+    srcl = src->width * srcfmt->p.rgb.bpp;
     for(y = 0; y < dst->height; y++) {
         if(y >= src->height)
             y -= srcl;
@@ -928,14 +966,12 @@ static void convert_jpeg (zbar_image_t *
     if(!src->src) {
         tmp = zbar_image_create();
         tmp->format = fourcc('Y','8','0','0');
-        tmp->width = dst->width;
-        tmp->height = dst->height;
+        _zbar_image_copy_size(tmp, dst);
     }
     else {
         tmp = src->src->jpeg_img;
         assert(tmp);
-        dst->width = tmp->width;
-        dst->height = tmp->height;
+        _zbar_image_copy_size(dst, tmp);
     }
 
     const zbar_format_def_t *tmpfmt = _zbar_format_lookup(tmp->format);
@@ -945,8 +981,7 @@ static void convert_jpeg (zbar_image_t *
     _zbar_convert_jpeg_to_y(tmp, tmpfmt, src, srcfmt);
 
     /* now convert to dst */
-    dst->width = tmp->width;
-    dst->height = tmp->height;
+    _zbar_image_copy_size(dst, tmp);
 
     conversion_handler_t *func =
         conversions[tmpfmt->group][dstfmt->group].func;
@@ -963,10 +998,14 @@ zbar_image_t *zbar_image_convert_resize 
                                          unsigned width,
                                          unsigned height)
 {
+    const zbar_format_def_t *srcfmt, *dstfmt;
+    conversion_handler_t *func;
     zbar_image_t *dst = zbar_image_create();
     dst->format = fmt;
     dst->width = width;
     dst->height = height;
+    zbar_image_set_crop(dst, src->crop_x, src->crop_y,
+                        src->crop_w, src->crop_h);
     if(src->format == fmt &&
        src->width == width &&
        src->height == height) {
@@ -974,8 +1013,8 @@ zbar_image_t *zbar_image_convert_resize 
         return(dst);
     }
 
-    const zbar_format_def_t *srcfmt = _zbar_format_lookup(src->format);
-    const zbar_format_def_t *dstfmt = _zbar_format_lookup(dst->format);
+    srcfmt = _zbar_format_lookup(src->format);
+    dstfmt = _zbar_format_lookup(dst->format);
     if(!srcfmt || !dstfmt)
         /* FIXME free dst */
         return(NULL);
@@ -988,8 +1027,7 @@ zbar_image_t *zbar_image_convert_resize 
         return(dst);
     }
 
-    conversion_handler_t *func =
-        conversions[srcfmt->group][dstfmt->group].func;
+    func = conversions[srcfmt->group][dstfmt->group].func;
 
     dst->cleanup = zbar_image_free_data;
     func(dst, dstfmt, src, srcfmt);
@@ -1021,6 +1059,9 @@ int _zbar_best_format (uint32_t src,
                        uint32_t *dst,
                        const uint32_t *dsts)
 {
+    const zbar_format_def_t *srcfmt;
+    unsigned min_cost = -1;
+
     if(dst)
         *dst = 0;
     if(!dsts)
@@ -1031,17 +1072,16 @@ int _zbar_best_format (uint32_t src,
             *dst = src;
         return(0);
     }
-    const zbar_format_def_t *srcfmt = _zbar_format_lookup(src);
+    srcfmt = _zbar_format_lookup(src);
     if(!srcfmt)
         return(-1);
 
     zprintf(8, "from %.4s(%08" PRIx32 ") to", (char*)&src, src);
-    unsigned min_cost = -1;
     for(; *dsts; dsts++) {
         const zbar_format_def_t *dstfmt = _zbar_format_lookup(*dsts);
+        int cost;
         if(!dstfmt)
             continue;
-        int cost;
         if(srcfmt->group == dstfmt->group &&
            srcfmt->p.cmp == dstfmt->p.cmp)
             cost = 0;
@@ -1065,13 +1105,20 @@ int _zbar_best_format (uint32_t src,
 int zbar_negotiate_format (zbar_video_t *vdo,
                            zbar_window_t *win)
 {
+    static const uint32_t y800[2] = { fourcc('Y','8','0','0'), 0 };
+    errinfo_t *errdst;
+    const uint32_t *srcs, *dsts;
+    unsigned min_cost = -1;
+    uint32_t min_fmt = 0;
+    const uint32_t *fmt;
+
     if(!vdo && !win)
         return(0);
 
     if(win)
         (void)window_lock(win);
 
-    errinfo_t *errdst = (vdo) ? &vdo->err : &win->err;
+    errdst = (vdo) ? &vdo->err : &win->err;
     if(verify_format_sort()) {
         if(win)
             (void)window_unlock(win);
@@ -1086,19 +1133,16 @@ int zbar_negotiate_format (zbar_video_t 
                            "no input or output formats available"));
     }
 
-    static const uint32_t y800[2] = { fourcc('Y','8','0','0'), 0 };
-    const uint32_t *srcs = (vdo) ? vdo->formats : y800;
-    const uint32_t *dsts = (win) ? win->formats : y800;
+    srcs = (vdo) ? vdo->formats : y800;
+    dsts = (win) ? win->formats : y800;
 
-    unsigned min_cost = -1;
-    uint32_t min_fmt = 0;
-    const uint32_t *fmt;
     for(fmt = _zbar_formats; *fmt; fmt++) {
         /* only consider formats supported by video device */
+        uint32_t win_fmt = 0;
+        int cost;
         if(!has_format(*fmt, srcs))
             continue;
-        uint32_t win_fmt = 0;
-        int cost = _zbar_best_format(*fmt, &win_fmt, dsts);
+        cost = _zbar_best_format(*fmt, &win_fmt, dsts);
         if(cost < 0) {
             zprintf(4, "%.4s(%08" PRIx32 ") -> ? (unsupported)\n",
                     (char*)fmt, *fmt);
diff --git a/zbar/debug.h b/zbar/debug.h
--- a/zbar/debug.h
+++ b/zbar/debug.h
@@ -27,10 +27,10 @@
 
 # ifdef __GNUC__
     /* older versions of gcc (< 2.95) require a named varargs parameter */
-#  define dprintf(args...)
+#  define dprintf(args...) while(0)
 # else
     /* unfortunately named vararg parameter is a gcc-specific extension */
-#  define dprintf(...)
+#  define dprintf(...) while(0)
 # endif
 
 #else
@@ -38,13 +38,15 @@
 # include <stdio.h>
 
 # ifdef __GNUC__
-#  define dprintf(level, args...) \
-    if((level) <= DEBUG_LEVEL)    \
-        fprintf(stderr, args)
+#  define dprintf(level, args...) do {  \
+        if((level) <= DEBUG_LEVEL)      \
+            fprintf(stderr, args);      \
+    } while(0)
 # else
-#  define dprintf(level, ...)     \
-    if((level) <= DEBUG_LEVEL)    \
-        fprintf(stderr, __VA_ARGS__)
+#  define dprintf(level, ...) do {          \
+        if((level) <= DEBUG_LEVEL)          \
+            fprintf(stderr, __VA_ARGS__);   \
+    } while(0)
 # endif
 
 #endif /* DEBUG_LEVEL */
diff --git a/zbar/decoder.c b/zbar/decoder.c
--- a/zbar/decoder.c
+++ b/zbar/decoder.c
@@ -1,5 +1,5 @@
 /*------------------------------------------------------------------------
- *  Copyright 2007-2009 (c) Jeff Brown <spadix@users.sourceforge.net>
+ *  Copyright 2007-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
  *
  *  This file is part of the ZBar Bar Code Reader.
  *
@@ -27,15 +27,15 @@
 #include <string.h>     /* memset, strlen */
 
 #include <zbar.h>
-#include "decoder.h"
 
-#if defined(DEBUG_DECODER) || defined(DEBUG_EAN) ||             \
-    defined(DEBUG_CODE39) || defined(DEBUG_I25) ||              \
+#if defined(DEBUG_DECODER) || defined(DEBUG_EAN) || defined(DEBUG_CODE93) || \
+    defined(DEBUG_CODE39) || defined(DEBUG_I25) || defined(DEBUG_DATABAR) || \
     defined(DEBUG_CODE128) || defined(DEBUG_QR_FINDER) ||       \
     (defined(DEBUG_PDF417) && (DEBUG_PDF417 >= 4))
 # define DEBUG_LEVEL 1
 #endif
 #include "debug.h"
+#include "decoder.h"
 
 zbar_decoder_t *zbar_decoder_create ()
 {
@@ -59,10 +59,21 @@ zbar_decoder_t *zbar_decoder_create ()
     dcode->i25.config = 1 << ZBAR_CFG_ENABLE;
     CFG(dcode->i25, ZBAR_CFG_MIN_LEN) = 6;
 #endif
+#ifdef ENABLE_DATABAR
+    dcode->databar.config = ((1 << ZBAR_CFG_ENABLE) |
+                             (1 << ZBAR_CFG_EMIT_CHECK));
+    dcode->databar.config_exp = ((1 << ZBAR_CFG_ENABLE) |
+                                 (1 << ZBAR_CFG_EMIT_CHECK));
+    dcode->databar.csegs = 4;
+    dcode->databar.segs = calloc(4, sizeof(*dcode->databar.segs));
+#endif
 #ifdef ENABLE_CODE39
     dcode->code39.config = 1 << ZBAR_CFG_ENABLE;
     CFG(dcode->code39, ZBAR_CFG_MIN_LEN) = 1;
 #endif
+#ifdef ENABLE_CODE93
+    dcode->code93.config = 1 << ZBAR_CFG_ENABLE;
+#endif
 #ifdef ENABLE_CODE128
     dcode->code128.config = 1 << ZBAR_CFG_ENABLE;
 #endif
@@ -79,6 +90,10 @@ zbar_decoder_t *zbar_decoder_create ()
 
 void zbar_decoder_destroy (zbar_decoder_t *dcode)
 {
+#ifdef ENABLE_DATABAR
+    if(dcode->databar.segs)
+        free(dcode->databar.segs);
+#endif
     if(dcode->buf)
         free(dcode->buf);
     free(dcode);
@@ -93,9 +108,15 @@ void zbar_decoder_reset (zbar_decoder_t 
 #ifdef ENABLE_I25
     i25_reset(&dcode->i25);
 #endif
+#ifdef ENABLE_DATABAR
+    databar_reset(&dcode->databar);
+#endif
 #ifdef ENABLE_CODE39
     code39_reset(&dcode->code39);
 #endif
+#ifdef ENABLE_CODE93
+    code93_reset(&dcode->code93);
+#endif
 #ifdef ENABLE_CODE128
     code128_reset(&dcode->code128);
 #endif
@@ -113,15 +134,22 @@ void zbar_decoder_new_scan (zbar_decoder
     memset(dcode->w, 0, sizeof(dcode->w));
     dcode->lock = 0;
     dcode->idx = 0;
+    dcode->s6 = 0;
 #ifdef ENABLE_EAN
     ean_new_scan(&dcode->ean);
 #endif
 #ifdef ENABLE_I25
     i25_reset(&dcode->i25);
 #endif
+#ifdef ENABLE_DATABAR
+    databar_new_scan(&dcode->databar);
+#endif
 #ifdef ENABLE_CODE39
     code39_reset(&dcode->code39);
 #endif
+#ifdef ENABLE_CODE93
+    code93_reset(&dcode->code93);
+#endif
 #ifdef ENABLE_CODE128
     code128_reset(&dcode->code128);
 #endif
@@ -149,9 +177,14 @@ unsigned int zbar_decoder_get_data_lengt
     return(dcode->buflen);
 }
 
+int zbar_decoder_get_direction (const zbar_decoder_t *dcode)
+{
+    return(dcode->direction);
+}
+
 zbar_decoder_handler_t *
 zbar_decoder_set_handler (zbar_decoder_t *dcode,
-                          zbar_decoder_handler_t handler)
+                          zbar_decoder_handler_t *handler)
 {
     zbar_decoder_handler_t *result = dcode->handler;
     dcode->handler = handler;
@@ -174,62 +207,82 @@ zbar_symbol_type_t zbar_decoder_get_type
     return(dcode->type);
 }
 
+unsigned int zbar_decoder_get_modifiers (const zbar_decoder_t *dcode)
+{
+    return(dcode->modifiers);
+}
+
 zbar_symbol_type_t zbar_decode_width (zbar_decoder_t *dcode,
                                       unsigned w)
 {
+    zbar_symbol_type_t tmp, sym = ZBAR_NONE;
+
     dcode->w[dcode->idx & (DECODE_WINDOW - 1)] = w;
     dprintf(1, "    decode[%x]: w=%d (%g)\n", dcode->idx, w, (w / 32.));
 
+    /* update shared character width */
+    dcode->s6 -= get_width(dcode, 7);
+    dcode->s6 += get_width(dcode, 1);
+
     /* each decoder processes width stream in parallel */
-    zbar_symbol_type_t sym = dcode->type = ZBAR_NONE;
-
 #ifdef ENABLE_EAN
     if((dcode->ean.enable) &&
-       (sym = _zbar_decode_ean(dcode)))
-        dcode->type = sym;
+       (tmp = _zbar_decode_ean(dcode)))
+        sym = tmp;
+#endif
+#ifdef ENABLE_QRCODE
+    if(TEST_CFG(dcode->qrf.config, ZBAR_CFG_ENABLE) &&
+       (tmp = _zbar_find_qr(dcode)) > ZBAR_PARTIAL)
+        sym = tmp;
 #endif
 #ifdef ENABLE_CODE39
     if(TEST_CFG(dcode->code39.config, ZBAR_CFG_ENABLE) &&
-       (sym = _zbar_decode_code39(dcode)) > ZBAR_PARTIAL)
-        dcode->type = sym;
+       (tmp = _zbar_decode_code39(dcode)) > ZBAR_PARTIAL)
+        sym = tmp;
+#endif
+#ifdef ENABLE_CODE93
+    if(TEST_CFG(dcode->code93.config, ZBAR_CFG_ENABLE) &&
+       (tmp = _zbar_decode_code93(dcode)) > ZBAR_PARTIAL)
+        sym = tmp;
 #endif
 #ifdef ENABLE_CODE128
     if(TEST_CFG(dcode->code128.config, ZBAR_CFG_ENABLE) &&
-       (sym = _zbar_decode_code128(dcode)) > ZBAR_PARTIAL)
-        dcode->type = sym;
+       (tmp = _zbar_decode_code128(dcode)) > ZBAR_PARTIAL)
+        sym = tmp;
+#endif
+#ifdef ENABLE_DATABAR
+    if(TEST_CFG(dcode->databar.config | dcode->databar.config_exp,
+                ZBAR_CFG_ENABLE) &&
+       (tmp = _zbar_decode_databar(dcode)) > ZBAR_PARTIAL)
+        sym = tmp;
 #endif
 #ifdef ENABLE_I25
     if(TEST_CFG(dcode->i25.config, ZBAR_CFG_ENABLE) &&
-       (sym = _zbar_decode_i25(dcode)) > ZBAR_PARTIAL)
-        dcode->type = sym;
+       (tmp = _zbar_decode_i25(dcode)) > ZBAR_PARTIAL)
+        sym = tmp;
 #endif
 #ifdef ENABLE_PDF417
     if(TEST_CFG(dcode->pdf417.config, ZBAR_CFG_ENABLE) &&
-       (sym = _zbar_decode_pdf417(dcode)) > ZBAR_PARTIAL)
-        dcode->type = sym;
-#endif
-#ifdef ENABLE_QRCODE
-    if(TEST_CFG(dcode->qrf.config, ZBAR_CFG_ENABLE) &&
-       (sym = _zbar_find_qr(dcode)) > ZBAR_PARTIAL)
-        dcode->type = sym;
+       (tmp = _zbar_decode_pdf417(dcode)) > ZBAR_PARTIAL)
+        sym = tmp;
 #endif
 
     dcode->idx++;
-    if(dcode->type) {
+    dcode->type = sym;
+    if(sym) {
+        if(dcode->lock && sym > ZBAR_PARTIAL && sym != ZBAR_QRCODE)
+            release_lock(dcode, sym);
         if(dcode->handler)
             dcode->handler(dcode);
-        if(dcode->lock && dcode->type > ZBAR_PARTIAL)
-            dcode->lock = 0;
     }
-    return(dcode->type);
+    return(sym);
 }
 
-static inline int decoder_set_config_bool (zbar_decoder_t *dcode,
-                                           zbar_symbol_type_t sym,
-                                           zbar_config_t cfg,
-                                           int val)
+static inline const unsigned int*
+decoder_get_configp (const zbar_decoder_t *dcode,
+                     zbar_symbol_type_t sym)
 {
-    unsigned *config = NULL;
+    const unsigned int *config;
     switch(sym) {
 #ifdef ENABLE_EAN
     case ZBAR_EAN13:
@@ -263,12 +316,27 @@ static inline int decoder_set_config_boo
         break;
 #endif
 
+#ifdef ENABLE_DATABAR
+    case ZBAR_DATABAR:
+        config = &dcode->databar.config;
+        break;
+    case ZBAR_DATABAR_EXP:
+        config = &dcode->databar.config_exp;
+        break;
+#endif
+
 #ifdef ENABLE_CODE39
     case ZBAR_CODE39:
         config = &dcode->code39.config;
         break;
 #endif
 
+#ifdef ENABLE_CODE93
+    case ZBAR_CODE93:
+        config = &dcode->code93.config;
+        break;
+#endif
+
 #ifdef ENABLE_CODE128
     case ZBAR_CODE128:
         config = &dcode->code128.config;
@@ -290,8 +358,26 @@ static inline int decoder_set_config_boo
     /* FIXME handle addons */
 
     default:
-        return(1);
+        config = NULL;
     }
+    return(config);
+}
+
+unsigned int zbar_decoder_get_configs (const zbar_decoder_t *dcode,
+                                       zbar_symbol_type_t sym)
+{
+    const unsigned *config = decoder_get_configp(dcode, sym);
+    if(!config)
+        return(0);
+    return(*config);
+}
+
+static inline int decoder_set_config_bool (zbar_decoder_t *dcode,
+                                           zbar_symbol_type_t sym,
+                                           zbar_config_t cfg,
+                                           int val)
+{
+    unsigned *config = (void*)decoder_get_configp(dcode, sym);
     if(!config || cfg >= ZBAR_CFG_NUM)
         return(1);
 
@@ -332,6 +418,11 @@ static inline int decoder_set_config_int
         CFG(dcode->code39, cfg) = val;
         break;
 #endif
+#ifdef ENABLE_CODE93
+    case ZBAR_CODE93:
+        CFG(dcode->code93, cfg) = val;
+        break;
+#endif
 #ifdef ENABLE_CODE128
     case ZBAR_CODE128:
         CFG(dcode->code128, cfg) = val;
@@ -362,7 +453,10 @@ int zbar_decoder_set_config (zbar_decode
         zbar_decoder_set_config(dcode, ZBAR_ISBN10, cfg, val);
         zbar_decoder_set_config(dcode, ZBAR_ISBN13, cfg, val);
         zbar_decoder_set_config(dcode, ZBAR_I25, cfg, val);
+        zbar_decoder_set_config(dcode, ZBAR_DATABAR, cfg, val);
+        zbar_decoder_set_config(dcode, ZBAR_DATABAR_EXP, cfg, val);
         zbar_decoder_set_config(dcode, ZBAR_CODE39, cfg, val);
+        zbar_decoder_set_config(dcode, ZBAR_CODE93, cfg, val);
         zbar_decoder_set_config(dcode, ZBAR_CODE128, cfg, val);
         zbar_decoder_set_config(dcode, ZBAR_PDF417, cfg, val);
         zbar_decoder_set_config(dcode, ZBAR_QRCODE, cfg, val);
@@ -385,16 +479,18 @@ const char *_zbar_decoder_buf_dump (unsi
                                     unsigned int buflen)
 {
     int dumplen = (buflen * 3) + 12;
+    char *p;
+    int i;
+
     if(!decoder_dump || dumplen > decoder_dumplen) {
         if(decoder_dump)
             free(decoder_dump);
         decoder_dump = malloc(dumplen);
         decoder_dumplen = dumplen;
     }
-    char *p = decoder_dump +
+    p = decoder_dump +
         snprintf(decoder_dump, 12, "buf[%04x]=",
                  (buflen > 0xffff) ? 0xffff : buflen);
-    int i;
     for(i = 0; i < buflen; i++)
         p += snprintf(p, 4, "%s%02x", (i) ? " " : "",  buf[i]);
     return(decoder_dump);
diff --git a/zbar/decoder.h b/zbar/decoder.h
--- a/zbar/decoder.h
+++ b/zbar/decoder.h
@@ -1,5 +1,5 @@
 /*------------------------------------------------------------------------
- *  Copyright 2007-2009 (c) Jeff Brown <spadix@users.sourceforge.net>
+ *  Copyright 2007-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
  *
  *  This file is part of the ZBar Bar Code Reader.
  *
@@ -36,9 +36,15 @@
 #ifdef ENABLE_I25
 # include "decoder/i25.h"
 #endif
+#ifdef ENABLE_DATABAR
+# include "decoder/databar.h"
+#endif
 #ifdef ENABLE_CODE39
 # include "decoder/code39.h"
 #endif
+#ifdef ENABLE_CODE93
+# include "decoder/code93.h"
+#endif
 #ifdef ENABLE_CODE128
 # include "decoder/code128.h"
 #endif
@@ -73,6 +79,7 @@
 
 #define CFG(dcode, cfg) ((dcode).configs[(cfg) - ZBAR_CFG_MIN_LEN])
 #define TEST_CFG(config, cfg) (((config) >> (cfg)) & 1)
+#define MOD(mod) (1 << (mod))
 
 /* symbology independent decoder state */
 struct zbar_decoder_s {
@@ -80,6 +87,9 @@ struct zbar_decoder_s {
     unsigned w[DECODE_WINDOW];          /* window of last N bar widths */
     zbar_symbol_type_t type;            /* type of last decoded data */
     zbar_symbol_type_t lock;            /* buffer lock */
+    unsigned modifiers;                 /* symbology modifier */
+    int direction;                      /* direction of last decoded data */
+    unsigned s6;                        /* 6-element character width */
 
     /* everything above here is automatically reset */
     unsigned buf_alloc;                 /* dynamic buffer allocation */
@@ -95,9 +105,15 @@ struct zbar_decoder_s {
 #ifdef ENABLE_I25
     i25_decoder_t i25;                  /* Interleaved 2 of 5 decode state */
 #endif
+#ifdef ENABLE_DATABAR
+    databar_decoder_t databar;          /* DataBar decode state */
+#endif
 #ifdef ENABLE_CODE39
     code39_decoder_t code39;            /* Code 39 decode state */
 #endif
+#ifdef ENABLE_CODE93
+    code93_decoder_t code93;            /* Code 93 decode state */
+#endif
 #ifdef ENABLE_CODE128
     code128_decoder_t code128;          /* Code 128 decode state */
 #endif
@@ -168,19 +184,32 @@ static inline int decode_e (unsigned e,
 }
 
 /* acquire shared state lock */
-static inline char get_lock (zbar_decoder_t *dcode,
-                             zbar_symbol_type_t req)
+static inline char acquire_lock (zbar_decoder_t *dcode,
+                                 zbar_symbol_type_t req)
 {
-    if(dcode->lock)
+    if(dcode->lock) {
+        dprintf(2, " [locked %d]\n", dcode->lock);
         return(1);
+    }
     dcode->lock = req;
     return(0);
 }
 
+/* check and release shared state lock */
+static inline char release_lock (zbar_decoder_t *dcode,
+                                 zbar_symbol_type_t req)
+{
+    zassert(dcode->lock == req, 1, "lock=%d req=%d\n",
+            dcode->lock, req);
+    dcode->lock = 0;
+    return(0);
+}
+
 /* ensure output buffer has sufficient allocation for request */
 static inline char size_buf (zbar_decoder_t *dcode,
                              unsigned len)
 {
+    unsigned char *buf;
     if(len < dcode->buf_alloc)
         /* FIXME size reduction heuristic? */
         return(0);
@@ -191,7 +220,7 @@ static inline char size_buf (zbar_decode
         if(len > BUFFER_MAX)
             len = BUFFER_MAX;
     }
-    unsigned char *buf = realloc(dcode->buf, len);
+    buf = realloc(dcode->buf, len);
     if(!buf)
         return(1);
     dcode->buf = buf;
@@ -200,6 +229,6 @@ static inline char size_buf (zbar_decode
 }
 
 extern const char *_zbar_decoder_buf_dump (unsigned char *buf,
-                                            unsigned int buflen);
+                                           unsigned int buflen);
 
 #endif
diff --git a/zbar/decoder/code128.c b/zbar/decoder/code128.c
--- a/zbar/decoder/code128.c
+++ b/zbar/decoder/code128.c
@@ -1,5 +1,5 @@
 /*------------------------------------------------------------------------
- *  Copyright 2007-2009 (c) Jeff Brown <spadix@users.sourceforge.net>
+ *  Copyright 2007-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
  *
  *  This file is part of the ZBar Bar Code Reader.
  *
@@ -25,12 +25,12 @@
 #include <string.h>     /* memmove */
 
 #include <zbar.h>
-#include "decoder.h"
 
 #ifdef DEBUG_CODE128
 # define DEBUG_LEVEL (DEBUG_CODE128)
 #endif
 #include "debug.h"
+#include "decoder.h"
 
 #define NUM_CHARS 108           /* total number of character codes */
 
@@ -120,6 +120,8 @@ static inline signed char decode_lo (int
                             ((sig >> 5) & 0x18) |
                             ((sig >> 7) & 0x60));
     unsigned char idx = lo_offset[offset];
+    unsigned char base, c;
+
     if(sig & 1)
         idx &= 0xf;
     else
@@ -127,14 +129,14 @@ static inline signed char decode_lo (int
     if(idx == 0xf)
         return(-1);
 
-    unsigned char base = (sig >> 11) | ((sig >> 9) & 1);
+    base = (sig >> 11) | ((sig >> 9) & 1);
     zassert(base < 8, -1, "sig=%x offset=%x idx=%x base=%x\n",
             sig, offset, idx, base);
     idx += lo_base[base];
 
     zassert(idx <= 0x50, -1, "sig=%x offset=%x base=%x idx=%x\n",
             sig, offset, base, idx);
-    unsigned char c = characters[idx];
+    c = characters[idx];
     dprintf(2, " %02x(%x(%02x)/%x(%02x)) => %02x",
             idx, base, lo_base[base], offset, lo_offset[offset],
             (unsigned char)c);
@@ -144,6 +146,7 @@ static inline signed char decode_lo (int
 static inline signed char decode_hi (int sig)
 {
     unsigned char rev = (sig & 0x4400) != 0;
+    unsigned char idx, c;
     if(rev)
         sig = (((sig >> 12) & 0x000f) |
                ((sig >>  4) & 0x00f0) |
@@ -151,7 +154,6 @@ static inline signed char decode_hi (int
                ((sig << 12) & 0xf000));
     dprintf(2, " rev=%x", rev != 0);
 
-    unsigned char idx;
     switch(sig) {
     case 0x0014: idx = 0x0; break;
     case 0x0025: idx = 0x1; break;
@@ -171,7 +173,7 @@ static inline signed char decode_hi (int
     }
     if(rev)
         idx += 0xe;
-    unsigned char c = characters[0x51 + idx];
+    c = characters[0x51 + idx];
     dprintf(2, " %02x => %02x", idx, c);
     return(c);
 }
@@ -190,13 +192,18 @@ static inline unsigned char calc_check (
 
 static inline signed char decode6 (zbar_decoder_t *dcode)
 {
+    int sig;
+    signed char c, chk;
+    unsigned bars;
+
     /* build edge signature of character */
     unsigned s = dcode->code128.s6;
+
     dprintf(2, " s=%d", s);
     if(s < 5)
         return(-1);
     /* calculate similar edge measurements */
-    int sig = (get_color(dcode) == ZBAR_BAR)
+    sig = (get_color(dcode) == ZBAR_BAR)
         ? ((decode_e(get_width(dcode, 0) + get_width(dcode, 1), s, 11) << 12) |
            (decode_e(get_width(dcode, 1) + get_width(dcode, 2), s, 11) << 8) |
            (decode_e(get_width(dcode, 2) + get_width(dcode, 3), s, 11) << 4) |
@@ -209,16 +216,16 @@ static inline signed char decode6 (zbar_
         return(-1);
     dprintf(2, " sig=%04x", sig);
     /* lookup edge signature */
-    signed char c = (sig & 0x4444) ? decode_hi(sig) : decode_lo(sig);
+    c = (sig & 0x4444) ? decode_hi(sig) : decode_lo(sig);
     if(c == -1)
         return(-1);
 
     /* character validation */
-    unsigned bars = (get_color(dcode) == ZBAR_BAR)
+    bars = (get_color(dcode) == ZBAR_BAR)
         ? (get_width(dcode, 0) + get_width(dcode, 2) + get_width(dcode, 4))
         : (get_width(dcode, 1) + get_width(dcode, 3) + get_width(dcode, 5));
     bars = bars * 11 * 4 / s;
-    unsigned char chk = calc_check(c);
+    chk = calc_check(c);
     dprintf(2, " bars=%d chk=%d", bars, chk);
     if(chk - 7 > bars || bars > chk + 7)
         return(-1);
@@ -228,18 +235,20 @@ static inline signed char decode6 (zbar_
 
 static inline unsigned char validate_checksum (zbar_decoder_t *dcode)
 {
+    unsigned idx, sum, i, acc = 0;
+    unsigned char check, err;
+
     code128_decoder_t *dcode128 = &dcode->code128;
     if(dcode128->character < 3)
         return(1);
 
     /* add in irregularly weighted start character */
-    unsigned idx = (dcode128->direction) ? dcode128->character - 1 : 0;
-    unsigned sum = dcode->buf[idx];
+    idx = (dcode128->direction) ? dcode128->character - 1 : 0;
+    sum = dcode->buf[idx];
     if(sum >= 103)
         sum -= 103;
 
     /* calculate sum in reverse to avoid multiply operations */
-    unsigned i, acc = 0;
     for(i = dcode128->character - 3; i; i--) {
         zassert(sum < 103, -1, "dir=%x i=%x sum=%x acc=%x %s\n",
                 dcode128->direction, i, sum, acc,
@@ -258,9 +267,9 @@ static inline unsigned char validate_che
 
     /* and compare to check character */
     idx = (dcode128->direction) ? 1 : dcode128->character - 2;
-    unsigned char check = dcode->buf[idx];
+    check = dcode->buf[idx];
     dprintf(2, " chk=%02x(%02x)", sum, check);
-    unsigned char err = (sum != check);
+    err = (sum != check);
     if(err)
         dprintf(1, " [checksum error]\n");
     return(err);
@@ -272,6 +281,8 @@ static inline unsigned postprocess_c (zb
                                       unsigned end,
                                       unsigned dst)
 {
+    unsigned i, j;
+
     /* expand buffer to accomodate 2x set C characters (2 digits per-char) */
     unsigned delta = end - start;
     unsigned newlen = dcode->code128.character + delta;
@@ -282,7 +293,6 @@ static inline unsigned postprocess_c (zb
             dcode->code128.character - start);
     dcode->code128.character = newlen;
 
-    unsigned i, j;
     for(i = 0, j = dst; i < delta; i++, j += 2) {
         /* convert each set C character into two ASCII digits */
         unsigned char code = dcode->buf[start + delta + i];
@@ -317,10 +327,12 @@ static inline unsigned postprocess_c (zb
 /* resolve scan direction and convert to ASCII */
 static inline unsigned char postprocess (zbar_decoder_t *dcode)
 {
+    unsigned i, j, cexp;
+    unsigned char code = 0, charset;
     code128_decoder_t *dcode128 = &dcode->code128;
     dprintf(2, "\n    postproc len=%d", dcode128->character);
-    unsigned i, j;
-    unsigned char code = 0;
+    dcode->modifiers = 0;
+    dcode->direction = 1 - 2 * dcode128->direction;
     if(dcode128->direction) {
         /* reverse buffer */
         dprintf(2, " (rev)");
@@ -343,8 +355,8 @@ static inline unsigned char postprocess 
     zassert(code >= START_A && code <= START_C, 1, "%s\n",
             _zbar_decoder_buf_dump(dcode->buf, dcode->code128.character));
 
-    unsigned char charset = code - START_A;
-    unsigned cexp = (code == START_C) ? 1 : 0;
+    charset = code - START_A;
+    cexp = (code == START_C) ? 1 : 0;
     dprintf(2, " start=%c", 'A' + charset);
 
     for(i = 1, j = 0; i < dcode128->character - 2; i++) {
@@ -370,12 +382,13 @@ static inline unsigned char postprocess 
         else {
             dprintf(2, " %02x", code);
             if(charset & 0x2) {
+                unsigned delta;
                 /* expand character set C to ASCII */
                 zassert(cexp, 1, "i=%x j=%x code=%02x charset=%x cexp=%x %s\n",
                         i, j, code, charset, cexp,
                         _zbar_decoder_buf_dump(dcode->buf,
                                                 dcode->code128.character));
-                unsigned delta = postprocess_c(dcode, cexp, i, j);
+                delta = postprocess_c(dcode, cexp, i, j);
                 i += delta;
                 j += delta * 2;
                 cexp = 0;
@@ -383,28 +396,39 @@ static inline unsigned char postprocess 
             if(code < CODE_C) {
                 if(code == SHIFT)
                     charset |= 0x80;
-                else if(code == FNC2)
-                    /* FIXME FNC2 - message append */;
-                else if(code == FNC3)
-                    /* FIXME FNC3 - initialize */;
+                else if(code == FNC2) {
+                    /* FIXME FNC2 - message append */
+                }
+                else if(code == FNC3) {
+                    /* FIXME FNC3 - initialize */
+                }
             }
-            else if(code == FNC1)
-                /* FIXME FNC1 - Code 128 subsets or ASCII 0x1d */;
+            else if(code == FNC1) {
+                /* FNC1 - Code 128 subsets or ASCII 0x1d */
+                if(i == 1)
+                    dcode->modifiers |= MOD(ZBAR_MOD_GS1);
+                else if(i == 2)
+                    dcode->modifiers |= MOD(ZBAR_MOD_AIM);
+                else if(i < dcode->code128.character - 3)
+                    dcode->buf[j++] = 0x1d;
+                /*else drop trailing FNC1 */
+            }
             else if(code >= START_A) {
                 dprintf(1, " [truncated]\n");
                 return(1);
             }
             else {
+                unsigned char newset = CODE_A - code;
                 zassert(code >= CODE_C && code <= CODE_A, 1,
                         "i=%x j=%x code=%02x charset=%x cexp=%x %s\n",
                         i, j, code, charset, cexp,
                         _zbar_decoder_buf_dump(dcode->buf,
                                                 dcode->code128.character));
-                unsigned char newset = CODE_A - code;
                 if(newset != charset)
                     charset = newset;
-                else
-                    /* FIXME FNC4 - extended ASCII */;
+                else {
+                    /* FIXME FNC4 - extended ASCII */
+                }
             }
             if(charset & 0x2)
                 cexp = i + 1;
@@ -426,16 +450,18 @@ static inline unsigned char postprocess 
 zbar_symbol_type_t _zbar_decode_code128 (zbar_decoder_t *dcode)
 {
     code128_decoder_t *dcode128 = &dcode->code128;
+    signed char c;
 
     /* update latest character width */
     dcode128->s6 -= get_width(dcode, 6);
     dcode128->s6 += get_width(dcode, 0);
 
-    if(/* process every 6th element of active symbol */
-       (dcode128->character >= 0 &&
-        (++dcode128->element) != 6) ||
-       /* decode color based on direction */
-       (get_color(dcode) != dcode128->direction))
+    if((dcode128->character < 0)
+       ? get_color(dcode) != ZBAR_SPACE
+       : (/* process every 6th element of active symbol */
+          ++dcode128->element != 6 ||
+          /* decode color based on direction */
+          get_color(dcode) != dcode128->direction))
         return(0);
     dcode128->element = 0;
 
@@ -443,49 +469,73 @@ zbar_symbol_type_t _zbar_decode_code128 
             (dcode128->direction) ? '<' : '>',
             dcode128->character, dcode128->element);
 
-    signed char c = decode6(dcode);
+    c = decode6(dcode);
     if(dcode128->character < 0) {
+        unsigned qz;
         dprintf(2, " c=%02x", c);
         if(c < START_A || c > STOP_REV || c == STOP_FWD) {
             dprintf(2, " [invalid]\n");
             return(0);
         }
-        unsigned qz = get_width(dcode, 6);
-        if(qz && qz < (dcode->code128.s6 * 3) / 4) {
+        qz = get_width(dcode, 6);
+        if(qz && qz < (dcode128->s6 * 3) / 4) {
             dprintf(2, " [invalid qz %d]\n", qz);
             return(0);
         }
-        /* lock shared resources */
-        if(get_lock(dcode, ZBAR_CODE128)) {
-            dprintf(2, " [locked %d]\n", dcode->lock);
-            dcode128->character = -1;
-            return(0);
-        }
         /* decoded valid start/stop */
         /* initialize state */
-        dcode128->character = 0;
+        dcode128->character = 1;
         if(c == STOP_REV) {
             dcode128->direction = ZBAR_BAR;
             dcode128->element = 7;
         }
         else
             dcode128->direction = ZBAR_SPACE;
-        dprintf(2, " dir=%x [valid start]", dcode128->direction);
+        dcode128->start = c;
+        dcode128->width = dcode128->s6;
+        dprintf(2, " dir=%x [valid start]\n", dcode128->direction);
+        return(0);
     }
     else if((c < 0) ||
             ((dcode128->character >= BUFFER_MIN) &&
              size_buf(dcode, dcode128->character + 1))) {
         dprintf(1, (c < 0) ? " [aborted]\n" : " [overflow]\n");
-        dcode->lock = 0;
+        if(dcode128->character > 1)
+            release_lock(dcode, ZBAR_CODE128);
         dcode128->character = -1;
         return(0);
     }
+    else {
+        unsigned dw;
+        if(dcode128->width > dcode128->s6)
+            dw = dcode128->width - dcode128->s6;
+        else
+            dw = dcode128->s6 - dcode128->width;
+        dw *= 4;
+        if(dw > dcode128->width) {
+            dprintf(1, " [width var]\n");
+            if(dcode128->character > 1)
+                release_lock(dcode, ZBAR_CODE128);
+            dcode128->character = -1;
+            return(0);
+        }
+    }
+    dcode128->width = dcode128->s6;
 
     zassert(dcode->buf_alloc > dcode128->character, 0,
             "alloc=%x idx=%x c=%02x %s\n",
             dcode->buf_alloc, dcode128->character, c,
             _zbar_decoder_buf_dump(dcode->buf, dcode->buf_alloc));
 
+    if(dcode128->character == 1) {
+        /* lock shared resources */
+        if(acquire_lock(dcode, ZBAR_CODE128)) {
+            dcode128->character = -1;
+            return(0);
+        }
+        dcode->buf[0] = dcode128->start;
+    }
+
     dcode->buf[dcode128->character++] = c;
 
     if(dcode128->character > 2 &&
@@ -506,7 +556,7 @@ zbar_symbol_type_t _zbar_decode_code128 
             dprintf(2, " [valid end]\n");
         dcode128->character = -1;
         if(!sym)
-            dcode->lock = 0;
+            release_lock(dcode, ZBAR_CODE128);
         return(sym);
     }
 
diff --git a/zbar/decoder/code128.h b/zbar/decoder/code128.h
--- a/zbar/decoder/code128.h
+++ b/zbar/decoder/code128.h
@@ -28,7 +28,9 @@ typedef struct code128_decoder_s {
     unsigned direction : 1;     /* scan direction: 0=fwd/space, 1=rev/bar */
     unsigned element : 3;       /* element offset 0-5 */
     int character : 12;         /* character position in symbol */
+    unsigned char start;        /* start character */
     unsigned s6;                /* character width */
+    unsigned width;             /* last character width */
 
     unsigned config;
     int configs[NUM_CFGS];      /* int valued configurations */
diff --git a/zbar/decoder/code39.c b/zbar/decoder/code39.c
--- a/zbar/decoder/code39.c
+++ b/zbar/decoder/code39.c
@@ -1,5 +1,5 @@
 /*------------------------------------------------------------------------
- *  Copyright 2008-2009 (c) Jeff Brown <spadix@users.sourceforge.net>
+ *  Copyright 2008-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
  *
  *  This file is part of the ZBar Bar Code Reader.
  *
@@ -25,12 +25,12 @@
 #include <string.h>     /* memmove */
 
 #include <zbar.h>
-#include "decoder.h"
 
 #ifdef DEBUG_CODE39
 # define DEBUG_LEVEL (DEBUG_CODE39)
 #endif
 #include "debug.h"
+#include "decoder.h"
 
 #define NUM_CHARS (0x2c)
 
@@ -130,11 +130,11 @@ static inline unsigned char code39_decod
                                             unsigned e,
                                             unsigned s)
 {
-    unsigned char E = decode_e(e, s, 36);
-    if(E > 7)
+    unsigned char E = decode_e(e, s, 72);
+    if(E > 18)
         return(0xff);
     enc <<= 1;
-    if(E > 2) {
+    if(E > 6) {
         enc |= 1;
         dprintf(2, "1");
     }
@@ -147,7 +147,6 @@ static inline signed char code39_decode9
 {
     code39_decoder_t *dcode39 = &dcode->code39;
 
-    dprintf(2, " s=%d ", dcode39->s9);
     if(dcode39->s9 < 9)
         return(-1);
 
@@ -192,14 +191,14 @@ static inline signed char code39_decode9
 static inline signed char code39_decode_start (zbar_decoder_t *dcode)
 {
     code39_decoder_t *dcode39 = &dcode->code39;
+    dprintf(2, " s=%d ", dcode39->s9);
 
     signed char c = code39_decode9(dcode);
-    if(c == 0x19)
-        dcode39->direction ^= 1;
-    else if(c != 0x2b) {
+    if(c != 0x19 && c != 0x2b) {
         dprintf(2, "\n");
         return(ZBAR_NONE);
     }
+    dcode39->direction ^= (c == 0x19);
 
     /* check leading quiet zone - spec is 10x */
     unsigned quiet = get_width(dcode, 9);
@@ -217,6 +216,7 @@ static inline signed char code39_decode_
 static inline void code39_postprocess (zbar_decoder_t *dcode)
 {
     code39_decoder_t *dcode39 = &dcode->code39;
+    dcode->direction = 1 - 2 * dcode39->direction;
     int i;
     if(dcode39->direction) {
         /* reverse buffer */
@@ -234,6 +234,17 @@ static inline void code39_postprocess (z
                          : '?');
     dcode->buflen = i;
     dcode->buf[i] = '\0';
+    dcode->modifiers = 0;
+}
+
+static inline int
+check_width (unsigned ref,
+             unsigned w)
+{
+    unsigned dref = ref;
+    ref *= 4;
+    w *= 4;
+    return(ref - dref <= w && w <= ref + dref);
 }
 
 zbar_symbol_type_t _zbar_decode_code39 (zbar_decoder_t *dcode)
@@ -284,27 +295,36 @@ zbar_symbol_type_t _zbar_decode_code39 (
             }
             dcode39->character = -1;
             if(!sym)
-                dcode->lock = 0;
+                release_lock(dcode, ZBAR_CODE39);
             return(sym);
         }
         if(space > dcode39->width / 2) {
             /* inter-character space check failure */
-            dcode->lock = 0;
+            dprintf(2, " ics>%d [invalid ics]", dcode39->width);
+            if(dcode39->character)
+                release_lock(dcode, ZBAR_CODE39);
             dcode39->character = -1;
-            dprintf(2, " ics>%d [invalid ics]", dcode39->width);
         }
         dcode39->element = 0;
         dprintf(2, "\n");
         return(ZBAR_NONE);
     }
 
+    dprintf(2, " s=%d ", dcode39->s9);
+    if(!check_width(dcode39->width, dcode39->s9)) {
+        dprintf(2, " [width]\n");
+        if(dcode39->character)
+            release_lock(dcode, ZBAR_CODE39);
+        dcode39->character = -1;
+        return(ZBAR_NONE);
+    }
+
     signed char c = code39_decode9(dcode);
     dprintf(2, " c=%d", c);
 
     /* lock shared resources */
-    if(!dcode39->character && get_lock(dcode, ZBAR_CODE39)) {
+    if(!dcode39->character && acquire_lock(dcode, ZBAR_CODE39)) {
         dcode39->character = -1;
-        dprintf(1, " [locked %d]\n", dcode->lock);
         return(ZBAR_PARTIAL);
     }
 
@@ -312,7 +332,7 @@ zbar_symbol_type_t _zbar_decode_code39 (
        ((dcode39->character >= BUFFER_MIN) &&
         size_buf(dcode, dcode39->character + 1))) {
         dprintf(1, (c < 0) ? " [aborted]\n" : " [overflow]\n");
-        dcode->lock = 0;
+        release_lock(dcode, ZBAR_CODE39);
         dcode39->character = -1;
         return(ZBAR_NONE);
     }
diff --git a/zbar/decoder/code93.c b/zbar/decoder/code93.c
new file mode 100644
--- /dev/null
+++ b/zbar/decoder/code93.c
@@ -0,0 +1,398 @@
+/*------------------------------------------------------------------------
+ *  Copyright 2010 (c) Jeff Brown <spadix@users.sourceforge.net>
+ *
+ *  This file is part of the ZBar Bar Code Reader.
+ *
+ *  The ZBar Bar Code Reader is free software; you can redistribute it
+ *  and/or modify it under the terms of the GNU Lesser Public License as
+ *  published by the Free Software Foundation; either version 2.1 of
+ *  the License, or (at your option) any later version.
+ *
+ *  The ZBar Bar Code Reader is distributed in the hope that it will be
+ *  useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+ *  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Lesser Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser Public License
+ *  along with the ZBar Bar Code Reader; if not, write to the Free
+ *  Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ *  Boston, MA  02110-1301  USA
+ *
+ *  http://sourceforge.net/projects/zbar
+ *------------------------------------------------------------------------*/
+
+#include <config.h>
+#include <zbar.h>
+
+#ifdef DEBUG_CODE93
+# define DEBUG_LEVEL (DEBUG_CODE93)
+#endif
+#include "debug.h"
+#include "decoder.h"
+
+static const signed char code93_hash[0x40] = {
+    0x0f, 0x2b, 0x30, 0x38, 0x13, 0x1b, 0x11, 0x2a,
+    0x0a,   -1, 0x2f, 0x0f, 0x38, 0x38, 0x2f, 0x37,
+    0x24, 0x3a, 0x1b, 0x36, 0x18, 0x26, 0x02, 0x2c,
+    0x2b, 0x05, 0x21, 0x3b, 0x04, 0x15, 0x12, 0x0c,
+    0x00, 0x26, 0x23, 0x00,   -1, 0x2e, 0x3f, 0x13,
+    0x2e, 0x36,   -1, 0x08, 0x09,   -1, 0x15, 0x14,
+      -1, 0x00, 0x21, 0x3b,   -1, 0x33, 0x00,   -1,
+    0x2d, 0x0c, 0x1b, 0x0a, 0x3f, 0x3f, 0x29, 0x1c,
+};
+
+static inline int
+check_width (unsigned cur,
+             unsigned prev)
+{
+    unsigned dw;
+    if(prev > cur)
+        dw = prev - cur;
+    else
+        dw = cur - prev;
+    dw *= 4;
+    return(dw > prev);
+}
+
+static inline int
+encode6 (zbar_decoder_t *dcode)
+{
+    /* build edge signature of character */
+    unsigned s = dcode->s6;
+    int sig = 0, i;
+
+    dprintf(2, " s=%d ", s);
+    if(s < 9)
+        return(-1);
+
+    for(i = 6; --i > 0; ) {
+        unsigned c = decode_e(pair_width(dcode, i), s, 9);
+        if(c > 3)
+            return(-1);
+        sig = (sig << 2) | c;
+        dprintf(2, "%d", c);
+    }
+    dprintf(2, " sig=%03x", sig);
+
+    return(sig);
+}
+
+static inline int
+validate_sig (int sig)
+{
+    int i, sum = 0, emin = 0, sig0 = 0, sig1 = 0;
+    dprintf(3, " sum=0");
+    for(i = 3; --i >= 0; ) {
+        int e = sig & 3;
+        sig >>= 2;
+        sum = e - sum;
+        sig1 <<= 4;
+        sig1 += sum;
+        dprintf(3, "%d", sum);
+        if(!i)
+            break;
+
+        e = sig & 3;
+        sig >>= 2;
+        sum = e - sum;
+        sig0 <<= 4;
+        if(emin > sum)
+            emin = sum;
+        sig0 += sum;
+        dprintf(3, "%d", sum);
+    }
+
+    dprintf(3, " emin=%d sig=%03x/%03x", emin, sig1 & 0xfff, sig0 & 0xfff);
+
+    emin = emin + (emin << 4) + (emin << 8);
+    sig0 -= emin;
+    sig1 += emin;
+
+    dprintf(3, "=%03x/%03x", sig1 & 0xfff, sig0 & 0xfff);
+    return((sig0 | sig1) & 0x888);
+}
+
+static inline int
+decode6 (zbar_decoder_t *dcode)
+{
+    int sig = encode6(dcode);
+    int g0, g1, c;
+    if(sig < 0 ||
+       (sig & 0x3) + ((sig >> 4) & 0x3) + ((sig >> 8) & 0x3) != 3 ||
+       validate_sig(sig))
+        return(-1);
+
+    if(dcode->code93.direction) {
+        /* reverse signature */
+        unsigned tmp = sig & 0x030;
+        sig = ((sig & 0x3c0) >> 6) | ((sig & 0x00f) << 6);
+        sig = ((sig & 0x30c) >> 2) | ((sig & 0x0c3) << 2) | tmp;
+    }
+
+    g0 = code93_hash[(sig - (sig >> 4)) & 0x3f];
+    g1 = code93_hash[((sig >> 2) - (sig >> 7)) & 0x3f];
+    zassert(g0 >= 0 && g1 >= 0, -1,
+            "dir=%x sig=%03x g0=%03x g1=%03x %s\n",
+            dcode->code93.direction, sig, g0, g1,
+            _zbar_decoder_buf_dump(dcode->buf, dcode->code93.character));
+
+    c = (g0 + g1) & 0x3f;
+    dprintf(2, " g0=%x g1=%x c=%02x", g0, g1, c);
+    return(c);
+}
+
+static inline zbar_symbol_type_t
+decode_start (zbar_decoder_t *dcode)
+{
+    code93_decoder_t *dcode93 = &dcode->code93;
+    unsigned dir, qz, s = dcode->s6;
+    int c;
+
+    dprintf(2, "      code93:");
+    c = encode6(dcode);
+    if(c < 0 || (c != 0x00f && c != 0x0f0))
+        return(ZBAR_NONE);
+
+    dir = (c >> 7);
+
+    if(dir) {
+        if(decode_e(pair_width(dcode, 0), s, 9))
+            return(ZBAR_NONE);
+        qz = get_width(dcode, 8);
+    }
+
+    qz = get_width(dcode, 7);
+    if(qz && qz < (s * 3) / 4) {
+        dprintf(2, " [invalid qz %d]", qz);
+        return(ZBAR_NONE);
+    }
+
+    /* decoded valid start/stop - initialize state */
+    dcode93->direction = dir;
+    dcode93->element = (!dir) ? 0 : 7;
+    dcode93->character = 0;
+    dcode93->width = s;
+
+    dprintf(2, " dir=%x [valid start]", dir);
+    return(ZBAR_PARTIAL);
+}
+
+static inline zbar_symbol_type_t
+decode_abort (zbar_decoder_t *dcode,
+              const char *reason)
+{
+    code93_decoder_t *dcode93 = &dcode->code93;
+    if(dcode93->character > 1)
+        release_lock(dcode, ZBAR_CODE93);
+    dcode93->character = -1;
+    if(reason)
+        dprintf(1, " [%s]\n", reason);
+    return(ZBAR_NONE);
+}
+
+static inline zbar_symbol_type_t
+check_stop (zbar_decoder_t *dcode)
+{
+    code93_decoder_t *dcode93 = &dcode->code93;
+    unsigned n = dcode93->character, s = dcode->s6;
+    int max_len = CFG(*dcode93, ZBAR_CFG_MAX_LEN);
+    if(n < 2 ||
+       n < CFG(*dcode93, ZBAR_CFG_MIN_LEN) ||
+       (max_len && n > max_len))
+        return(decode_abort(dcode, "invalid len"));
+
+    if(dcode93->direction) {
+        unsigned qz = get_width(dcode, 0);
+        if(qz && qz < (s * 3) / 4)
+            return(decode_abort(dcode, "invalid qz"));
+    }
+    else if(decode_e(pair_width(dcode, 0), s, 9))
+        /* FIXME forward-trailing QZ check */
+        return(decode_abort(dcode, "invalid stop"));
+
+    return(ZBAR_CODE93);
+}
+
+#define CHKMOD (47)
+
+static inline int
+plusmod47 (int acc,
+           int add)
+{
+    acc += add;
+    if(acc >= CHKMOD)
+        acc -= CHKMOD;
+    return(acc);
+}
+
+static inline int
+validate_checksums (zbar_decoder_t *dcode)
+{
+    code93_decoder_t *dcode93 = &dcode->code93;
+    unsigned d, i, n = dcode93->character;
+    unsigned sum_c = 0, acc_c = 0, i_c = (n - 2) % 20;
+    unsigned sum_k = 0, acc_k = 0, i_k = (n - 1) % 15;
+
+    for(i = 0; i < n - 2; i++) {
+        d = dcode->buf[(dcode93->direction) ? n - 1 - i : i];
+
+        if(!i_c--) {
+            acc_c = 0;
+            i_c = 19;
+        }
+        acc_c = plusmod47(acc_c, d);
+        sum_c = plusmod47(sum_c, acc_c);
+
+        if(!i_k--) {
+            acc_k = 0;
+            i_k = 14;
+        }
+        acc_k = plusmod47(acc_k, d);
+        sum_k = plusmod47(sum_k, acc_k);
+    }
+
+    d = dcode->buf[(dcode93->direction) ? 1 : n - 2];
+    dprintf(2, " C=%02x?=%02x", d, sum_c);
+    if(d != sum_c)
+        return(1);
+
+    acc_k = plusmod47(acc_k, sum_c);
+    sum_k = plusmod47(sum_k, acc_k);
+    d = dcode->buf[(dcode93->direction) ? 0 : n - 1];
+    dprintf(2, " K=%02x?=%02x", d, sum_k);
+    if(d != sum_k)
+        return(1);
+
+    return(0);
+}
+
+/* resolve scan direction and convert to ASCII */
+static inline int
+postprocess (zbar_decoder_t *dcode)
+{
+    code93_decoder_t *dcode93 = &dcode->code93;
+    unsigned i, j, n = dcode93->character;
+    static const unsigned char code93_graph[] = "-. $/+%";
+    static const unsigned char code93_s2[] =
+        "\x1b\x1c\x1d\x1e\x1f;<=>?[\\]^_{|}~\x7f\x00\x40`\x7f\x7f\x7f";
+
+    dprintf(2, "\n    postproc len=%d", n);
+    dcode->direction = 1 - 2 * dcode93->direction;
+    if(dcode93->direction) {
+        /* reverse buffer */
+        dprintf(2, " (rev)");
+        for(i = 0; i < n / 2; i++) {
+            unsigned j = n - 1 - i;
+            unsigned char d = dcode->buf[i];
+            dcode->buf[i] = dcode->buf[j];
+            dcode->buf[j] = d;
+        }
+    }
+
+    n -= 2;
+    for(i = 0, j = 0; i < n; ) {
+        unsigned char d = dcode->buf[i++];
+        if(d < 0xa)
+            d = '0' + d;
+        else if(d < 0x24)
+            d = 'A' + d - 0xa;
+        else if(d < 0x2b)
+            d = code93_graph[d - 0x24];
+        else {
+            unsigned shift = d;
+            zassert(shift < 0x2f, -1, "%s\n",
+                    _zbar_decoder_buf_dump(dcode->buf, dcode93->character));
+            d = dcode->buf[i++];
+            if(d < 0xa || d >= 0x24)
+                return(1);
+            d -= 0xa;
+            switch(shift)
+            {
+            case 0x2b: d++; break;
+            case 0x2c: d = code93_s2[d]; break;
+            case 0x2d: d += 0x21; break;
+            case 0x2e: d += 0x61; break;
+            default: return(1);
+            }
+        }
+        dcode->buf[j++] = d;
+    }
+
+    dcode->buflen = j;
+    dcode->buf[j] = '\0';
+    dcode->modifiers = 0;
+    return(0);
+}
+
+zbar_symbol_type_t
+_zbar_decode_code93 (zbar_decoder_t *dcode)
+{
+    code93_decoder_t *dcode93 = &dcode->code93;
+    int c;
+
+    if(dcode93->character < 0) {
+        zbar_symbol_type_t sym;
+        if(get_color(dcode) != ZBAR_BAR)
+            return(ZBAR_NONE);
+        sym = decode_start(dcode);
+        dprintf(2, "\n");
+        return(sym);
+    }
+
+    if(/* process every 6th element of active symbol */
+       ++dcode93->element != 6 ||
+       /* decode color based on direction */
+       get_color(dcode) == dcode93->direction)
+        return(ZBAR_NONE);
+
+    dcode93->element = 0;
+
+    dprintf(2, "      code93[%c%02d+%x]:",
+            (dcode93->direction) ? '<' : '>',
+            dcode93->character, dcode93->element);
+
+    if(check_width(dcode->s6, dcode93->width))
+        return(decode_abort(dcode, "width var"));
+
+    c = decode6(dcode);
+    if(c < 0)
+        return(decode_abort(dcode, "aborted"));
+
+    if(c == 0x2f) {
+        if(!check_stop(dcode))
+            return(ZBAR_NONE);
+        if(validate_checksums(dcode))
+            return(decode_abort(dcode, "checksum error"));
+        if(postprocess(dcode))
+            return(decode_abort(dcode, "invalid encoding"));
+
+        dprintf(2, " [valid end]\n");
+        dprintf(3, "    %s\n",
+                _zbar_decoder_buf_dump(dcode->buf, dcode93->character));
+
+        dcode93->character = -1;
+        return(ZBAR_CODE93);
+    }
+
+    if(dcode93->character >= BUFFER_MIN &&
+       size_buf(dcode, dcode93->character + 1))
+        return(decode_abort(dcode, "overflow"));
+
+    dcode93->width = dcode->s6;
+
+    if(dcode93->character == 1) {
+        /* lock shared resources */
+        if(acquire_lock(dcode, ZBAR_CODE93))
+            return(decode_abort(dcode, NULL));
+        dcode->buf[0] = dcode93->buf;
+    }
+
+    if(!dcode93->character)
+        dcode93->buf = c;
+    else 
+        dcode->buf[dcode93->character] = c;
+    dcode93->character++;
+
+    dprintf(2, "\n");
+    return(ZBAR_NONE);
+}
diff --git a/zbar/decoder/code93.h b/zbar/decoder/code93.h
new file mode 100644
--- /dev/null
+++ b/zbar/decoder/code93.h
@@ -0,0 +1,49 @@
+/*------------------------------------------------------------------------
+ *  Copyright 2010 (c) Jeff Brown <spadix@users.sourceforge.net>
+ *
+ *  This file is part of the ZBar Bar Code Reader.
+ *
+ *  The ZBar Bar Code Reader is free software; you can redistribute it
+ *  and/or modify it under the terms of the GNU Lesser Public License as
+ *  published by the Free Software Foundation; either version 2.1 of
+ *  the License, or (at your option) any later version.
+ *
+ *  The ZBar Bar Code Reader is distributed in the hope that it will be
+ *  useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+ *  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Lesser Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser Public License
+ *  along with the ZBar Bar Code Reader; if not, write to the Free
+ *  Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ *  Boston, MA  02110-1301  USA
+ *
+ *  http://sourceforge.net/projects/zbar
+ *------------------------------------------------------------------------*/
+#ifndef _CODE93_H_
+#define _CODE93_H_
+
+/* Code 93 specific decode state */
+typedef struct code93_decoder_s {
+    unsigned direction : 1;     /* scan direction: 0=fwd/space, 1=rev/bar */
+    unsigned element : 3;       /* element offset 0-5 */
+    int character : 12;         /* character position in symbol */
+    unsigned width;             /* last character width */
+    unsigned char buf;          /* first character */
+
+    unsigned config;
+    int configs[NUM_CFGS];      /* int valued configurations */
+} code93_decoder_t;
+
+/* reset Code 93 specific state */
+static inline void code93_reset (code93_decoder_t *dcode93)
+{
+    dcode93->direction = 0;
+    dcode93->element = 0;
+    dcode93->character = -1;
+}
+
+/* decode Code 93 symbols */
+zbar_symbol_type_t _zbar_decode_code93(zbar_decoder_t *dcode);
+
+#endif
diff --git a/zbar/decoder/databar.c b/zbar/decoder/databar.c
new file mode 100644
--- /dev/null
+++ b/zbar/decoder/databar.c
@@ -0,0 +1,1277 @@
+/*------------------------------------------------------------------------
+ *  Copyright 2010 (c) Jeff Brown <spadix@users.sourceforge.net>
+ *
+ *  This file is part of the ZBar Bar Code Reader.
+ *
+ *  The ZBar Bar Code Reader is free software; you can redistribute it
+ *  and/or modify it under the terms of the GNU Lesser Public License as
+ *  published by the Free Software Foundation; either version 2.1 of
+ *  the License, or (at your option) any later version.
+ *
+ *  The ZBar Bar Code Reader is distributed in the hope that it will be
+ *  useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+ *  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Lesser Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser Public License
+ *  along with the ZBar Bar Code Reader; if not, write to the Free
+ *  Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ *  Boston, MA  02110-1301  USA
+ *
+ *  http://sourceforge.net/projects/zbar
+ *------------------------------------------------------------------------*/
+
+#include <config.h>
+#include <zbar.h>
+
+#ifdef DEBUG_DATABAR
+# define DEBUG_LEVEL (DEBUG_DATABAR)
+#endif
+#include "debug.h"
+#include "decoder.h"
+
+#define GS ('\035')
+
+enum { SCH_NUM, SCH_ALNUM, SCH_ISO646 };
+
+static const signed char finder_hash[0x20] = {
+    0x16, 0x1f, 0x02, 0x00, 0x03, 0x00, 0x06, 0x0b,
+    0x1f, 0x0e, 0x17, 0x0c, 0x0b, 0x14, 0x11, 0x0c,
+    0x1f, 0x03, 0x13, 0x08, 0x00, 0x0a,   -1, 0x16,
+    0x0c, 0x09,   -1, 0x1a, 0x1f, 0x1c, 0x00,   -1,
+};
+
+/* DataBar character encoding groups */
+struct group_s {
+    unsigned short sum;
+    unsigned char wmax;
+    unsigned char todd;
+    unsigned char teven;
+} groups[] = {
+    /* (17,4) DataBar Expanded character groups */
+    {    0, 7,  87,   4 },
+    {  348, 5,  52,  20 },
+    { 1388, 4,  30,  52 },
+    { 2948, 3,  10, 104 },
+    { 3988, 1,   1, 204 },
+
+    /* (16,4) DataBar outer character groups */
+    {    0, 8, 161,   1 },
+    {  161, 6,  80,  10 },
+    {  961, 4,  31,  34 },
+    { 2015, 3,  10,  70 },
+    { 2715, 1,   1, 126 },
+
+    /* (15,4) DataBar inner character groups */
+    { 1516, 8,  81,   1 },
+    { 1036, 6,  48,  10 },
+    {  336, 4,  20,  35 },
+    {    0, 2,   4,  84 },
+};
+
+static const unsigned char exp_sequences[] = {
+    /* sequence Group 1 */
+    0x01,
+    0x23,
+    0x25, 0x07,
+    0x29, 0x47,
+    0x29, 0x67, 0x0b,
+    0x29, 0x87, 0xab,
+    /* sequence Group 2 */
+    0x21, 0x43, 0x65, 0x07,
+    0x21, 0x43, 0x65, 0x89,
+    0x21, 0x43, 0x65, 0xa9, 0x0b,
+    0x21, 0x43, 0x67, 0x89, 0xab
+};
+
+/* DataBar expanded checksum multipliers */
+static const unsigned char exp_checksums[] = {
+    1, 189, 62, 113, 46, 43, 109, 134, 6, 79, 161, 45
+};
+
+static inline void
+append_check14 (unsigned char *buf)
+{
+    unsigned char chk = 0, d;
+    int i;
+    for(i = 13; --i >= 0; ) {
+        d = *(buf++) - '0';
+        chk += d;
+        if(!(i & 1))
+            chk += d << 1;
+    }
+    chk %= 10;
+    if(chk)
+        chk = 10 - chk;
+    *buf = chk + '0';
+}
+
+static inline void
+decode10 (unsigned char *buf,
+          unsigned long n,
+          int i)
+{
+    buf += i;
+    while(--i >= 0) {
+        unsigned char d = n % 10;
+        n /= 10;
+        *--buf = '0' + d;
+    }
+}
+
+#define VAR_MAX(l, i) ((((l) * 12 + (i)) * 2 + 6) / 7)
+
+#define FEED_BITS(b)                         \
+    while(i < (b) && len) {                  \
+        d = (d << 12) | (*(data++) & 0xfff); \
+        i += 12;                             \
+        len--;                               \
+        dprintf(2, " %03lx", d & 0xfff);     \
+    }
+
+#define PUSH_CHAR(c) \
+    *(buf++) = (c)
+
+#define PUSH_CHAR4(c0, c1, c2, c3) do { \
+        PUSH_CHAR(c0);                  \
+        PUSH_CHAR(c1);                  \
+        PUSH_CHAR(c2);                  \
+        PUSH_CHAR(c3);                  \
+    } while(0);
+
+static inline int
+databar_postprocess_exp (zbar_decoder_t *dcode,
+                         int *data)
+{
+    int i = 0, enc;
+    unsigned n;
+    unsigned char *buf;
+    unsigned long d = *(data++);
+    int len = d / 211 + 4, buflen;
+
+    /* grok encodation method */
+    d = *(data++);
+    dprintf(2, "\n    len=%d %03lx", len, d & 0xfff);
+    n = (d >> 4) & 0x7f;
+    if(n >= 0x40) {
+        i = 10;
+        enc = 1;
+        buflen = 2 + 14 + VAR_MAX(len, 10 - 2 - 44 + 6) + 2;
+    }
+    else if(n >= 0x38) {
+        i = 4;
+        enc = 6 + (n & 7);
+        buflen = 2 + 14 + 4 + 6 + 2 + 6 + 2;
+    }
+    else if(n >= 0x30) {
+        i = 6;
+        enc = 2 + ((n >> 2) & 1);
+        buflen = 2 + 14 + 4 + 3 + VAR_MAX(len, 6 - 2 - 44 - 2 - 10) + 2;
+    }
+    else if(n >= 0x20) {
+        i = 7;
+        enc = 4 + ((n >> 3) & 1);
+        buflen = 2 + 14 + 4 + 6;
+    }
+    else {
+        i = 9;
+        enc = 0;
+        buflen = VAR_MAX(len, 9 - 2) + 2;
+    }
+    dprintf(2, " buflen=%d enc=%d", buflen, enc);
+    zassert(buflen > 2, -1, "buflen=%d\n", buflen);
+
+    if(enc < 4) {
+        /* grok variable length symbol bit field */
+        if((len ^ (d >> (--i))) & 1)
+            /* even/odd length mismatch */
+            return(-1);
+        if(((d >> (--i)) & 1) != (len > 14))
+            /* size group mismatch */
+            return(-1);
+    }
+    len -= 2;
+    dprintf(2, " [%d+%d]", i, len);
+
+    if(size_buf(dcode, buflen))
+        return(-1);
+    buf = dcode->buf;
+
+    /* handle compressed fields */
+    if(enc) {
+        PUSH_CHAR('0');
+        PUSH_CHAR('1');
+    }
+
+    if(enc == 1) {
+        i -= 4;
+        n = (d >> i) & 0xf;
+        if(i >= 10)
+            return(-1);
+        PUSH_CHAR('0' + n);
+    }
+    else if(enc)
+        PUSH_CHAR('9');
+
+    if(enc) {
+        int j;
+        for(j = 0; j < 4; j++) {
+            FEED_BITS(10);
+            i -= 10;
+            n = (d >> i) & 0x3ff;
+            if(n >= 1000)
+                return(-1);
+            decode10(buf, n, 3);
+            buf += 3;
+        }
+        append_check14(buf - 13);
+        buf++;
+    }
+
+    switch(enc)
+    {
+    case 2: /* 01100: AI 392x */
+        FEED_BITS(2);
+        i -= 2;
+        n = (d >> i) & 0x3;
+        PUSH_CHAR4('3', '9', '2', '0' + n);
+        break;
+
+    case 3: /* 01101: AI 393x */
+        FEED_BITS(12);
+        i -= 2;
+        n = (d >> i) & 0x3;
+        PUSH_CHAR4('3', '9', '3', '0' + n);
+        i -= 10;
+        n = (d >> i) & 0x3ff;
+        if(n >= 1000)
+            return(-1);
+        decode10(buf, n, 3);
+        buf += 3;
+        break;
+
+    case 4: /* 0100: AI 3103 */
+        FEED_BITS(15);
+        i -= 15;
+        n = (d >> i) & 0x7fff;
+        PUSH_CHAR4('3', '1', '0', '3');
+        decode10(buf, n, 6);
+        buf += 6;
+        break;
+
+    case 5: /* 0101: AI 3202/3203 */
+        FEED_BITS(15);
+        i -= 15;
+        n = (d >> i) & 0x7fff;
+        dprintf(2, " v=%d", n);
+        PUSH_CHAR4('3', '2', '0', (n >= 10000) ? '3' : '2' );
+        if(n >= 10000)
+            n -= 10000;
+        decode10(buf, n, 6);
+        buf += 6;
+        break;
+    }
+    if(enc >= 6) {
+        /* 0111000 - 0111111: AI 310x/320x + AI 11/13/15/17 */
+        PUSH_CHAR4('3', '1' + (enc & 1), '0', 'x');
+        FEED_BITS(20);
+        i -= 20;
+        n = (d >> i) & 0xfffff;
+        dprintf(2, " [%d+%d] %d", i, len, n);
+        if(n >= 1000000)
+            return(-1);
+        decode10(buf, n, 6);
+        *(buf - 1) = *buf;
+        *buf = '0';
+        buf += 6;
+
+        FEED_BITS(16);
+        i -= 16;
+        n = (d >> i) & 0xffff;
+        if(n < 38400) {
+            int dd, mm, yy;
+            dd = n % 32;
+            n /= 32;
+            mm = n % 12 + 1;
+            n /= 12;
+            yy = n;
+            PUSH_CHAR('1');
+            PUSH_CHAR('0' + (enc - 6) | 1);
+            decode10(buf, yy, 2);
+            buf += 2;
+            decode10(buf, mm, 2);
+            buf += 2;
+            decode10(buf, dd, 2);
+            buf += 2;
+        }
+        else if(n > 38400)
+            return(-1);
+    }
+
+    if(enc < 4) {
+        /* remainder is general-purpose data compaction */
+        int scheme = SCH_NUM;
+        while(i > 0 || len > 0) {
+            FEED_BITS(8);
+            dprintf(2, " [%d+%d]", i, len);
+
+            if(scheme == SCH_NUM) {
+                int n1;
+                i -= 4;
+                if(i < 0)
+                    break;
+                if(!((d >> i) & 0xf)) {
+                    scheme = SCH_ALNUM;
+                    dprintf(2, ">A");
+                    continue;
+                }
+                if(!len && i < 3) {
+                    /* special case last digit */
+                    n = ((d >> i) & 0xf) - 1;
+                    if(n > 9)
+                        return(-1);
+                    *(buf++) = '0' + n;
+                    break;
+                }
+                i -= 3;
+                zassert(i >= 0, -1, "\n");
+                n = ((d >> i) & 0x7f) - 8;
+                n1 = n % 11;
+                n = n / 11;
+                dprintf(2, "N%d%d", n, n1);
+                *(buf++) = (n < 10) ? '0' + n : GS;
+                *(buf++) = (n1 < 10) ? '0' + n1 : GS;
+            }
+            else  {
+                unsigned c = 0;
+                i -= 3;
+                if(i < 0)
+                    break;
+                if(!((d >> i) & 0x7)) {
+                    scheme = SCH_NUM;
+                    continue;
+                }
+                i -= 2;
+                if(i < 0)
+                    break;
+                n = (d >> i) & 0x1f;
+                if(n == 0x04) {
+                    scheme ^= 0x3;
+                    dprintf(2, ">%d", scheme);
+                }
+                else if(n == 0x0f)
+                    c = GS;
+                else if(n < 0x0f)
+                    c = 43 + n;
+                else if(scheme == SCH_ALNUM) {
+                    i--;
+                    if(i < 0)
+                        return(-1);
+                    n = (d >> i) & 0x1f;
+                    if(n < 0x1a)
+                        c = 'A' + n;
+                    else if(n == 0x1a)
+                        c = '*';
+                    else if(n < 0x1f)
+                        c = ',' + n - 0x1b;
+                    else
+                        return(-1);
+                }
+                else if(scheme == SCH_ISO646 && n < 0x1d) {
+                    i -= 2;
+                    if(i < 0)
+                        return(-1);
+                    n = (d >> i) & 0x3f;
+                    if(n < 0x1a)
+                        c = 'A' + n;
+                    else if(n < 0x34)
+                        c = 'a' + n - 0x1a;
+                    else
+                        return(-1);
+                }
+                else if(scheme == SCH_ISO646) {
+                    i -= 3;
+                    if(i < 0)
+                        return(-1);
+                    n = ((d >> i) & 0x1f);
+                    dprintf(2, "(%02x)", n);
+                    if(n < 0xa)
+                        c = '!' + n - 8;
+                    else if(n < 0x15)
+                        c = '%' + n - 0xa;
+                    else if(n < 0x1b)
+                        c = ':' + n - 0x15;
+                    else if(n == 0x1b)
+                        c = '_';
+                    else if(n == 0x1c)
+                        c = ' ';
+                    else
+                        return(-1);
+                }
+                else
+                    return(-1);
+
+                if(c) {
+                    dprintf(2, "%d%c", scheme, c);
+                    *(buf++) = c;
+                }
+            }
+        }
+        /* FIXME check pad? */
+    }
+
+    *buf = 0;
+    i = buf - dcode->buf;
+    dcode->buflen = i;
+    if(i && *--buf == GS) {
+        *buf = 0;
+        dcode->buflen--;
+    }
+
+    dprintf(2, "\n    %s", _zbar_decoder_buf_dump(dcode->buf, dcode->buflen));
+    return(0);
+}
+#undef FEED_BITS
+
+/* convert from heterogeneous base {1597,2841}
+ * to base 10 character representation
+ */
+static inline void
+databar_postprocess (zbar_decoder_t *dcode,
+                     unsigned d[4])
+{
+    databar_decoder_t *db = &dcode->databar;
+    int i;
+    unsigned c, chk = 0;
+    unsigned char *buf = dcode->buf;
+    *(buf++) = '0';
+    *(buf++) = '1';
+    buf += 15;
+    *--buf = '\0';
+    *--buf = '\0';
+
+    dprintf(2, "\n    d={%d,%d,%d,%d}", d[0], d[1], d[2], d[3]);
+    unsigned long r = d[0] * 1597 + d[1];
+    d[1] = r / 10000;
+    r %= 10000;
+    r = r * 2841 + d[2];
+    d[2] = r / 10000;
+    r %= 10000;
+    r = r * 1597 + d[3];
+    d[3] = r / 10000;
+    dprintf(2, " r=%ld", r);
+
+    for(i = 4; --i >= 0; ) {
+        c = r % 10;
+        chk += c;
+        if(i & 1)
+            chk += c << 1;
+        *--buf = c + '0';
+        if(i)
+            r /= 10;
+    }
+
+    dprintf(2, " d={%d,%d,%d}", d[1], d[2], d[3]);
+    r = d[1] * 2841 + d[2];
+    d[2] = r / 10000;
+    r %= 10000;
+    r = r * 1597 + d[3];
+    d[3] = r / 10000;
+    dprintf(2, " r=%ld", r);
+
+    for(i = 4; --i >= 0; ) {
+        c = r % 10;
+        chk += c;
+        if(i & 1)
+            chk += c << 1;
+        *--buf = c + '0';
+        if(i)
+            r /= 10;
+    }
+
+    r = d[2] * 1597 + d[3];
+    dprintf(2, " d={%d,%d} r=%ld", d[2], d[3], r);
+
+    for(i = 5; --i >= 0; ) {
+        c = r % 10;
+        chk += c;
+        if(!(i & 1))
+            chk += c << 1;
+        *--buf = c + '0';
+        if(i)
+            r /= 10;
+    }
+
+    /* NB linkage flag not supported */
+    if(TEST_CFG(db->config, ZBAR_CFG_EMIT_CHECK)) {
+        chk %= 10;
+        if(chk)
+            chk = 10 - chk;
+        buf[13] = chk + '0';
+        dcode->buflen = buf - dcode->buf + 14;
+    }
+    else
+        dcode->buflen = buf - dcode->buf + 13;
+
+    dprintf(2, "\n    %s", _zbar_decoder_buf_dump(dcode->buf, 16));
+}
+
+static inline int
+check_width (unsigned wf,
+             unsigned wd,
+             unsigned n)
+{
+    unsigned dwf = wf * 3;
+    wd *= 14;
+    wf *= n;
+    return(wf - dwf <= wd && wd <= wf + dwf);
+}
+
+static inline void
+merge_segment (databar_decoder_t *db,
+               databar_segment_t *seg)
+{
+    unsigned csegs = db->csegs;
+    int i;
+    for(i = 0; i < csegs; i++) {
+        databar_segment_t *s = db->segs + i;
+        if(s != seg && s->finder == seg->finder && s->exp == seg->exp &&
+           s->color == seg->color && s->side == seg->side &&
+           s->data == seg->data && s->check == seg->check &&
+           check_width(seg->width, s->width, 14)) {
+            /* merge with existing segment */
+            unsigned cnt = s->count;
+            if(cnt < 0x7f)
+                cnt++;
+            seg->count = cnt;
+            seg->partial &= s->partial;
+            seg->width = (3 * seg->width + s->width + 2) / 4;
+            s->finder = -1;
+            dprintf(2, " dup@%d(%d,%d)",
+                    i, cnt, (db->epoch - seg->epoch) & 0xff);
+        }
+        else if(s->finder >= 0) {
+            unsigned age = (db->epoch - s->epoch) & 0xff;
+            if(age >= 248 || (age >= 128 && s->count < 2))
+                s->finder = -1;
+        }
+    }
+}
+
+static inline zbar_symbol_type_t
+match_segment (zbar_decoder_t *dcode,
+               databar_segment_t *seg)
+{
+    databar_decoder_t *db = &dcode->databar;
+    unsigned csegs = db->csegs, maxage = 0xfff;
+    int i0, i1, i2, maxcnt = 0;
+    databar_segment_t *smax[3] = { NULL, };
+
+    if(seg->partial && seg->count < 4)
+        return(ZBAR_PARTIAL);
+
+    for(i0 = 0; i0 < csegs; i0++) {
+        databar_segment_t *s0 = db->segs + i0;
+        if(s0 == seg || s0->finder != seg->finder || s0->exp ||
+           s0->color != seg->color || s0->side == seg->side ||
+           (s0->partial && s0->count < 4) ||
+           !check_width(seg->width, s0->width, 14))
+            continue;
+
+        for(i1 = 0; i1 < csegs; i1++) {
+            databar_segment_t *s1 = db->segs + i1;
+            int chkf, chks, chk;
+            unsigned age1;
+            if(i1 == i0 || s1->finder < 0 || s1->exp ||
+               s1->color == seg->color ||
+               (s1->partial && s1->count < 4) ||
+               !check_width(seg->width, s1->width, 14))
+                continue;
+            dprintf(2, "\n\t[%d,%d] f=%d(0%xx)/%d(%x%x%x)",
+                    i0, i1, seg->finder, seg->color,
+                    s1->finder, s1->exp, s1->color, s1->side);
+
+            if(seg->color)
+                chkf = seg->finder + s1->finder * 9;
+            else
+                chkf = s1->finder + seg->finder * 9;
+            if(chkf > 72)
+                chkf--;
+            if(chkf > 8)
+                chkf--;
+
+            chks = (seg->check + s0->check + s1->check) % 79;
+
+            if(chkf >= chks)
+                chk = chkf - chks;
+            else
+                chk = 79 + chkf - chks;
+
+            dprintf(2, " chk=(%d,%d) => %d", chkf, chks, chk);
+            age1 = ((db->epoch - s0->epoch) & 0xff +
+                    (db->epoch - s1->epoch) & 0xff);
+
+            for(i2 = i1 + 1; i2 < csegs; i2++) {
+                databar_segment_t *s2 = db->segs + i2;
+                unsigned cnt, age2, age;
+                if(i2 == i0 || s2->finder != s1->finder || s2->exp ||
+                   s2->color != s1->color || s2->side == s1->side ||
+                   s2->check != chk ||
+                   (s2->partial && s2->count < 4) ||
+                   !check_width(seg->width, s2->width, 14))
+                    continue;
+                age2 = (db->epoch - s2->epoch) & 0xff;
+                age = age1 + age2;
+                cnt = s0->count + s1->count + s2->count;
+                dprintf(2, " [%d] MATCH cnt=%d age=%d", i2, cnt, age);
+                if(maxcnt < cnt ||
+                   (maxcnt == cnt && maxage > age)) {
+                    maxcnt = cnt;
+                    maxage = age;
+                    smax[0] = s0;
+                    smax[1] = s1;
+                    smax[2] = s2;
+                }
+            }
+        }
+    }
+
+    if(!smax[0])
+        return(ZBAR_PARTIAL);
+
+    unsigned d[4];
+    d[(seg->color << 1) | seg->side] = seg->data;
+    for(i0 = 0; i0 < 3; i0++) {
+        d[(smax[i0]->color << 1) | smax[i0]->side] = smax[i0]->data;
+        if(!--(smax[i0]->count))
+            smax[i0]->finder = -1;
+    }
+    seg->finder = -1;
+
+    if(size_buf(dcode, 18))
+        return(ZBAR_PARTIAL);
+
+    if(acquire_lock(dcode, ZBAR_DATABAR))
+        return(ZBAR_PARTIAL);
+
+    databar_postprocess(dcode, d);
+    dcode->modifiers = MOD(ZBAR_MOD_GS1);
+    dcode->direction = 1 - 2 * (seg->side ^ seg->color ^ 1);
+    return(ZBAR_DATABAR);
+}
+
+static inline unsigned
+lookup_sequence (databar_segment_t *seg,
+                 int fixed,
+                 int seq[22])
+{
+    unsigned n = seg->data / 211, i;
+    const unsigned char *p;
+    i = (n + 1) / 2 + 1;
+    n += 4;
+    i = (i * i) / 4;
+    dprintf(2, " {%d,%d:", i, n);
+    p = exp_sequences + i;
+
+    fixed >>= 1;
+    seq[0] = 0;
+    seq[1] = 1;
+    for(i = 2; i < n; ) {
+        int s = *p;
+        if(!(i & 2)) {
+            p++;
+            s >>= 4;
+        }
+        else
+            s &= 0xf;
+        if(s == fixed)
+            fixed = -1;
+        s <<= 1;
+        dprintf(2, "%x", s);
+        seq[i++] = s++;
+        seq[i++] = s;
+    }
+    dprintf(2, "}");
+    seq[n] = -1;
+    return(fixed < 1);
+}
+
+#define IDX(s) \
+    (((s)->finder << 2) | ((s)->color << 1) | ((s)->color ^ (s)->side))
+
+static inline zbar_symbol_type_t
+match_segment_exp (zbar_decoder_t *dcode,
+                   databar_segment_t *seg,
+                   int dir)
+{
+    databar_decoder_t *db = &dcode->databar;
+    int bestsegs[22], i = 0, segs[22], seq[22];
+    int ifixed = seg - db->segs, fixed = IDX(seg), maxcnt = 0;
+    int iseg[DATABAR_MAX_SEGMENTS];
+    unsigned csegs = db->csegs, width = seg->width, maxage = 0x7fff;
+
+    bestsegs[0] = segs[0] = seq[1] = -1;
+    seq[0] = 0;
+
+    dprintf(2, "\n    fixed=%d@%d: ", fixed, ifixed);
+    for(i = csegs, seg = db->segs + csegs - 1; --i >= 0; seg--) {
+        if(seg->exp && seg->finder >= 0 &&
+           (!seg->partial || seg->count >= 4))
+            iseg[i] = IDX(seg);
+        else
+            iseg[i] = -1;
+        dprintf(2, " %d", iseg[i]);
+    }
+
+    for(i = 0; ; i--) {
+        if(!i)
+            dprintf(2, "\n   ");
+        for(; i >= 0 && seq[i] >= 0; i--) {
+            int j;
+            dprintf(2, " [%d]%d", i, seq[i]);
+
+            if(seq[i] == fixed) {
+                seg = db->segs + ifixed;
+                if(segs[i] < 0 && check_width(width, seg->width, 14)) {
+                    dprintf(2, "*");
+                    j = ifixed;
+                }
+                else
+                    continue;
+            }
+            else {
+                for(j = segs[i] + 1; j < csegs; j++) {
+                    if(iseg[j] == seq[i] &&
+                       (!i || check_width(width, db->segs[j].width, 14))) {
+                        seg = db->segs + j;
+                        break;
+                    }
+                }
+                if(j == csegs)
+                    continue;
+            }
+
+            if(!i) {
+                if(!lookup_sequence(seg, fixed, seq)) {
+                    dprintf(2, "[nf]");
+                    continue;
+                }
+                width = seg->width;
+                dprintf(2, " A00@%d", j);
+            }
+            else {
+                width = (width + seg->width) / 2;
+                dprintf(2, " %c%x%x@%d",
+                        'A' + seg->finder, seg->color, seg->side, j);
+            }
+            segs[i++] = j;
+            segs[i++] = -1;
+        }
+        if(i < 0)
+            break;
+
+        seg = db->segs + segs[0];
+        unsigned cnt = 0, chk = 0, age = (db->epoch - seg->epoch) & 0xff;
+        for(i = 1; segs[i] >= 0; i++) {
+            seg = db->segs + segs[i];
+            chk += seg->check;
+            cnt += seg->count;
+            age += (db->epoch - seg->epoch) & 0xff;
+        }
+
+        unsigned data0 = db->segs[segs[0]].data;
+        unsigned chk0 = data0 % 211;
+        chk %= 211;
+
+        dprintf(2, " chk=%d ?= %d", chk, chk0);
+        if(chk != chk0)
+            continue;
+
+        dprintf(2, " cnt=%d age=%d", cnt, age);
+        if(maxcnt > cnt || (maxcnt == cnt && maxage <= age))
+            continue;
+
+        dprintf(2, " !");
+        maxcnt = cnt;
+        maxage = age;
+        for(i = 0; segs[i] >= 0; i++)
+            bestsegs[i] = segs[i];
+        bestsegs[i] = -1;
+    }
+
+    if(bestsegs[0] < 0)
+        return(ZBAR_PARTIAL);
+
+    if(acquire_lock(dcode, ZBAR_DATABAR_EXP))
+        return(ZBAR_PARTIAL);
+
+    for(i = 0; bestsegs[i] >= 0; i++)
+        segs[i] = db->segs[bestsegs[i]].data;
+
+    if(databar_postprocess_exp(dcode, segs)) {
+        release_lock(dcode, ZBAR_DATABAR_EXP);
+        return(ZBAR_PARTIAL);
+    }
+
+    for(i = 0; bestsegs[i] >= 0; i++)
+        if(bestsegs[i] != ifixed) {
+            seg = db->segs + bestsegs[i];
+            if(!--seg->count)
+                seg->finder = -1;
+        }
+
+    /* FIXME stacked rows are frequently reversed,
+     * so direction is impossible to determine at this level
+     */
+    dcode->direction = (1 - 2 * (seg->side ^ seg->color)) * dir;
+    dcode->modifiers = MOD(ZBAR_MOD_GS1);
+    return(ZBAR_DATABAR_EXP);
+}
+#undef IDX
+
+static inline unsigned
+calc_check (unsigned sig0,
+            unsigned sig1,
+            unsigned side,
+            unsigned mod)
+{
+    unsigned chk = 0;
+    int i;
+    for(i = 4; --i >= 0; ) {
+        chk = (chk * 3 + (sig1 & 0xf) + 1) * 3 + (sig0 & 0xf) + 1;
+        sig1 >>= 4;
+        sig0 >>= 4;
+        if(!(i & 1))
+            chk %= mod;
+    }
+    dprintf(2, " chk=%d", chk);
+
+    if(side)
+        chk = (chk * (6561 % mod)) % mod;
+    return(chk);
+}
+
+static inline int
+calc_value4 (unsigned sig,
+             unsigned n,
+             unsigned wmax,
+             unsigned nonarrow)
+{
+    unsigned v = 0;
+    n--;
+
+    unsigned w0 = (sig >> 12) & 0xf;
+    if(w0 > 1) {
+        if(w0 > wmax)
+            return(-1);
+        unsigned n0 = n - w0;
+        unsigned sk20 = (n - 1) * n * (2 * n - 1);
+        unsigned sk21 = n0 * (n0 + 1) * (2 * n0 + 1);
+        v = sk20 - sk21 - 3 * (w0 - 1) * (2 * n - w0);
+
+        if(!nonarrow && w0 > 2 && n > 4) {
+            unsigned k = (n - 2) * (n - 1) * (2 * n - 3) - sk21;
+            k -= 3 * (w0 - 2) * (14 * n - 7 * w0 - 31);
+            v -= k;
+        }
+
+        if(n - 2 > wmax) {
+            unsigned wm20 = 2 * wmax * (wmax + 1);
+            unsigned wm21 = (2 * wmax + 1);
+            unsigned k = sk20;
+            if(n0 > wmax) {
+                k -= sk21;
+                k += 3 * (w0 - 1) * (wm20 - wm21 * (2 * n - w0));
+            }
+            else {
+                k -= (wmax + 1) * (wmax + 2) * (2 * wmax + 3);
+                k += 3 * (n - wmax - 2) * (wm20 - wm21 * (n + wmax + 1));
+            }
+            k *= 3;
+            v -= k;
+        }
+        v /= 12;
+    }
+    else
+        nonarrow = 1;
+    n -= w0;
+
+    unsigned w1 = (sig >> 8) & 0xf;
+    if(w1 > 1) {
+        if(w1 > wmax)
+            return(-1);
+        v += (2 * n - w1) * (w1 - 1) / 2;
+        if(!nonarrow && w1 > 2 && n > 3)
+            v -= (2 * n - w1 - 5) * (w1 - 2) / 2;
+        if(n - 1 > wmax) {
+            if(n - w1 > wmax)
+                v -= (w1 - 1) * (2 * n - w1 - 2 * wmax);
+            else
+                v -= (n - wmax) * (n - wmax - 1);
+        }
+    }
+    else
+        nonarrow = 1;
+    n -= w1;
+
+    unsigned w2 = (sig >> 4) & 0xf;
+    if(w2 > 1) {
+        if(w2 > wmax)
+            return(-1);
+        v += w2 - 1;
+        if(!nonarrow && w2 > 2 && n > 2)
+            v -= n - 2;
+        if(n > wmax)
+            v -= n - wmax;
+    }
+    else
+        nonarrow = 1;
+
+    unsigned w3 = sig & 0xf;
+    if(w3 == 1)
+        nonarrow = 1;
+    else if(w3 > wmax)
+        return(-1);
+
+    if(!nonarrow)
+        return(-1);
+
+    return(v);
+}
+
+static inline zbar_symbol_type_t
+decode_char (zbar_decoder_t *dcode,
+             databar_segment_t *seg,
+             int off,
+             int dir)
+{
+    databar_decoder_t *db = &dcode->databar;
+    unsigned s = calc_s(dcode, (dir > 0) ? off : off - 6, 8);
+    int n, i, emin[2] = { 0, }, sum = 0;
+    unsigned sig0 = 0, sig1 = 0;
+
+    if(seg->exp)
+        n = 17;
+    else if(seg->side)
+        n = 15;
+    else
+        n = 16;
+    emin[1] = -n;
+
+    dprintf(2, "\n        char[%c%d]: n=%d s=%d w=%d sig=",
+            (dir < 0) ? '>' : '<', off, n, s, seg->width);
+    if(s < 13 || !check_width(seg->width, s, n))
+        return(ZBAR_NONE);
+
+    for(i = 4; --i >= 0; ) {
+        int e = decode_e(pair_width(dcode, off), s, n);
+        if(e < 0)
+            return(ZBAR_NONE);
+        dprintf(2, "%d", e);
+        sum = e - sum;
+        off += dir;
+        sig1 <<= 4;
+        if(emin[1] < -sum)
+            emin[1] = -sum;
+        sig1 += sum;
+        if(!i)
+            break;
+
+        e = decode_e(pair_width(dcode, off), s, n);
+        if(e < 0)
+            return(ZBAR_NONE);
+        dprintf(2, "%d", e);
+        sum = e - sum;
+        off += dir;
+        sig0 <<= 4;
+        if(emin[0] > sum)
+            emin[0] = sum;
+        sig0 += sum;
+    }
+
+    int diff = emin[~n & 1];
+    diff = diff + (diff << 4);
+    diff = diff + (diff << 8);
+
+    sig0 -= diff;
+    sig1 += diff;
+
+    dprintf(2, " emin=%d,%d el=%04x/%04x", emin[0], emin[1], sig0, sig1);
+
+    unsigned sum0 = sig0 + (sig0 >> 8);
+    unsigned sum1 = sig1 + (sig1 >> 8);
+    sum0 += sum0 >> 4;
+    sum1 += sum1 >> 4;
+    sum0 &= 0xf;
+    sum1 &= 0xf;
+
+    dprintf(2, " sum=%d/%d", sum0, sum1);
+
+    if(sum0 + sum1 + 8 != n) {
+        dprintf(2, " [SUM]");
+        return(ZBAR_NONE);
+    }
+
+    if(((sum0 ^ (n >> 1)) | (sum1 ^ (n >> 1) ^ n)) & 1) {
+        dprintf(2, " [ODD]");
+        return(ZBAR_NONE);
+    }
+
+    i = ((n & 0x3) ^ 1) * 5 + (sum1 >> 1);
+    zassert(i < sizeof(groups) / sizeof(*groups), -1,
+            "n=%d sum=%d/%d sig=%04x/%04x g=%d",
+            n, sum0, sum1, sig0, sig1, i);
+    struct group_s *g = groups + i;
+    dprintf(2, "\n            g=%d(%d,%d,%d/%d)",
+            i, g->sum, g->wmax, g->todd, g->teven);
+
+    int vodd = calc_value4(sig0 + 0x1111, sum0 + 4, g->wmax, ~n & 1);
+    dprintf(2, " v=%d", vodd);
+    if(vodd < 0 || vodd > g->todd)
+        return(ZBAR_NONE);
+
+    int veven = calc_value4(sig1 + 0x1111, sum1 + 4, 9 - g->wmax, n & 1);
+    dprintf(2, "/%d", veven);
+    if(veven < 0 || veven > g->teven)
+        return(ZBAR_NONE);
+
+    int v = g->sum;
+    if(n & 2)
+        v += vodd + veven * g->todd;
+    else
+        v += veven + vodd * g->teven;
+
+    dprintf(2, " f=%d(%x%x%x)", seg->finder, seg->exp, seg->color, seg->side);
+
+    unsigned chk = 0;
+    if(seg->exp) {
+        unsigned side = seg->color ^ seg->side ^ 1;
+        if(v >= 4096)
+            return(ZBAR_NONE);
+        /* skip A1 left */
+        chk = calc_check(sig0, sig1, side, 211);
+        if(seg->finder || seg->color || seg->side) {
+            i = (seg->finder << 1) - side + seg->color;
+            zassert(i >= 0 && i < 12, ZBAR_NONE,
+                    "f=%d(%x%x%x) side=%d i=%d\n",
+                    seg->finder, seg->exp, seg->color, seg->side, side, i);
+            chk = (chk * exp_checksums[i]) % 211;
+        }
+        else if(v >= 4009)
+            return(ZBAR_NONE);
+        else
+            chk = 0;
+    }
+    else {
+        chk = calc_check(sig0, sig1, seg->side, 79);
+        if(seg->color)
+            chk = (chk * 16) % 79;
+    }
+    dprintf(2, " => %d val=%d", chk, v);
+
+    seg->check = chk;
+    seg->data = v;
+
+    merge_segment(db, seg);
+
+    if(seg->exp)
+        return(match_segment_exp(dcode, seg, dir));
+    else if(dir > 0)
+        return(match_segment(dcode, seg));
+    return(ZBAR_PARTIAL);
+}
+
+static inline int
+alloc_segment (databar_decoder_t *db)
+{
+    unsigned maxage = 0, csegs = db->csegs;
+    int i, old = -1;
+    for(i = 0; i < csegs; i++) {
+        databar_segment_t *seg = db->segs + i;
+        unsigned age;
+        if(seg->finder < 0) {
+            dprintf(2, " free@%d", i);
+            return(i);
+        }
+        age = (db->epoch - seg->epoch) & 0xff;
+        if(age >= 128 && seg->count < 2) {
+            seg->finder = -1;
+            dprintf(2, " stale@%d (%d - %d = %d)",
+                    i, db->epoch, seg->epoch, age);
+            return(i);
+        }
+
+        /* score based on both age and count */
+        if(age > seg->count)
+            age = age - seg->count + 1;
+        else
+            age = 1;
+
+        if(maxage < age) {
+            maxage = age;
+            old = i;
+            dprintf(2, " old@%d(%u)", i, age);
+        }
+    }
+
+    if(csegs < DATABAR_MAX_SEGMENTS) {
+        dprintf(2, " new@%d", i);
+        i = csegs;
+        csegs *= 2;
+        if(csegs > DATABAR_MAX_SEGMENTS)
+            csegs = DATABAR_MAX_SEGMENTS;
+        if(csegs != db->csegs) {
+            databar_segment_t *seg;
+            db->segs = realloc(db->segs, csegs * sizeof(*db->segs));
+            db->csegs = csegs;
+            seg = db->segs + csegs;
+            while(--seg, --csegs >= i) {
+                seg->finder = -1;
+                seg->exp = 0;
+                seg->color = 0;
+                seg->side = 0;
+                seg->partial = 0;
+                seg->count = 0;
+                seg->epoch = 0;
+                seg->check = 0;
+            }
+            return(i);
+        }
+    }
+    zassert(old >= 0, -1, "\n");
+
+    db->segs[old].finder = -1;
+    return(old);
+}
+
+static inline zbar_symbol_type_t
+decode_finder (zbar_decoder_t *dcode)
+{
+    databar_decoder_t *db = &dcode->databar;
+    databar_segment_t *seg;
+    unsigned e0 = pair_width(dcode, 1);
+    unsigned e2 = pair_width(dcode, 3);
+    unsigned e1, e3, s, finder, dir;
+    int sig, iseg;
+    dprintf(2, "      databar: e0=%d e2=%d", e0, e2);
+    if(e0 < e2) {
+        unsigned e = e2 * 4;
+        if(e < 15 * e0 || e > 34 * e0)
+            return(ZBAR_NONE);
+        dir = 0;
+        e3 = pair_width(dcode, 4);
+    }
+    else {
+        unsigned e = e0 * 4;
+        if(e < 15 * e2 || e > 34 * e2)
+            return(ZBAR_NONE);
+        dir = 1;
+        e2 = e0;
+        e3 = pair_width(dcode, 0);
+    }
+    e1 = pair_width(dcode, 2);
+
+    s = e1 + e3;
+    dprintf(2, " e1=%d e3=%d dir=%d s=%d", e1, e3, dir, s);
+    if(s < 12)
+        return(ZBAR_NONE);
+
+    sig = ((decode_e(e3, s, 14) << 8) | (decode_e(e2, s, 14) << 4) |
+           decode_e(e1, s, 14));
+    dprintf(2, " sig=%04x", sig & 0xfff);
+    if(sig < 0 ||
+       ((sig >> 4) & 0xf) < 8 ||
+       ((sig >> 4) & 0xf) > 10 ||
+       (sig & 0xf) >= 10 ||
+       ((sig >> 8) & 0xf) >= 10 ||
+       (((sig >> 8) + sig) & 0xf) != 10)
+        return(ZBAR_NONE);
+
+    finder = (finder_hash[(sig - (sig >> 5)) & 0x1f] +
+              finder_hash[(sig >> 1) & 0x1f]) & 0x1f;
+    dprintf(2, " finder=%d", finder);
+    if(finder == 0x1f ||
+       !TEST_CFG((finder < 9) ? db->config : db->config_exp, ZBAR_CFG_ENABLE))
+        return(ZBAR_NONE);
+
+    zassert(finder >= 0, ZBAR_NONE, "dir=%d sig=%04x f=%d\n",
+            dir, sig & 0xfff, finder);
+
+    iseg = alloc_segment(db);
+    if(iseg < 0)
+        return(ZBAR_NONE);
+
+    seg = db->segs + iseg;
+    seg->finder = (finder >= 9) ? finder - 9 : finder;
+    seg->exp = (finder >= 9);
+    seg->color = get_color(dcode) ^ dir ^ 1;
+    seg->side = dir;
+    seg->partial = 0;
+    seg->count = 1;
+    seg->width = s;
+    seg->epoch = db->epoch;
+
+    int rc = decode_char(dcode, seg, 12 - dir, -1);
+    if(!rc)
+        seg->partial = 1;
+    else
+        db->epoch++;
+
+    int i = (dcode->idx + 8 + dir) & 0xf;
+    zassert(db->chars[i] == -1, ZBAR_NONE, "\n");
+    db->chars[i] = iseg;
+    return(rc);
+}
+
+zbar_symbol_type_t
+_zbar_decode_databar (zbar_decoder_t *dcode)
+{
+    databar_decoder_t *db = &dcode->databar;
+    databar_segment_t *seg, *pair;
+    zbar_symbol_type_t sym;
+    int iseg, i = dcode->idx & 0xf;
+
+    sym = decode_finder(dcode);
+    dprintf(2, "\n");
+
+    iseg = db->chars[i];
+    if(iseg < 0)
+        return(sym);
+
+    db->chars[i] = -1;
+    seg = db->segs + iseg;
+    dprintf(2, "        databar: i=%d part=%d f=%d(%x%x%x)",
+            iseg, seg->partial, seg->finder, seg->exp, seg->color, seg->side);
+    zassert(seg->finder >= 0, ZBAR_NONE, "i=%d f=%d(%x%x%x) part=%x\n",
+            iseg, seg->finder, seg->exp, seg->color, seg->side, seg->partial);
+
+    if(seg->partial) {
+        pair = NULL;
+        seg->side = !seg->side;
+    }
+    else {
+        int jseg = alloc_segment(db);
+        pair = db->segs + iseg;
+        seg = db->segs + jseg;
+        seg->finder = pair->finder;
+        seg->exp = pair->exp;
+        seg->color = pair->color;
+        seg->side = !pair->side;
+        seg->partial = 0;
+        seg->count = 1;
+        seg->width = pair->width;
+        seg->epoch = db->epoch;
+    }
+
+    sym = decode_char(dcode, seg, 1, 1);
+    if(!sym) {
+        seg->finder = -1;
+        if(pair)
+            pair->partial = 1;
+    }
+    else
+        db->epoch++;
+    dprintf(2, "\n");
+
+    return(sym);
+}
diff --git a/zbar/decoder/databar.h b/zbar/decoder/databar.h
new file mode 100644
--- /dev/null
+++ b/zbar/decoder/databar.h
@@ -0,0 +1,80 @@
+/*------------------------------------------------------------------------
+ *  Copyright 2010 (c) Jeff Brown <spadix@users.sourceforge.net>
+ *
+ *  This file is part of the ZBar Bar Code Reader.
+ *
+ *  The ZBar Bar Code Reader is free software; you can redistribute it
+ *  and/or modify it under the terms of the GNU Lesser Public License as
+ *  published by the Free Software Foundation; either version 2.1 of
+ *  the License, or (at your option) any later version.
+ *
+ *  The ZBar Bar Code Reader is distributed in the hope that it will be
+ *  useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+ *  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Lesser Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser Public License
+ *  along with the ZBar Bar Code Reader; if not, write to the Free
+ *  Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ *  Boston, MA  02110-1301  USA
+ *
+ *  http://sourceforge.net/projects/zbar
+ *------------------------------------------------------------------------*/
+#ifndef _DATABAR_H_
+#define _DATABAR_H_
+
+#define DATABAR_MAX_SEGMENTS 32
+
+/* active DataBar (partial) segment entry */
+typedef struct databar_segment_s {
+    signed finder : 5;          /* finder pattern */
+    unsigned exp : 1;           /* DataBar expanded finder */
+    unsigned color : 1;         /* finder coloring */
+    unsigned side : 1;          /* data character side of finder */
+
+    unsigned partial : 1;       /* unpaired partial segment */
+    unsigned count : 7;         /* times encountered */
+    unsigned epoch : 8;         /* age, in characters scanned */
+    unsigned check : 8;         /* bar checksum */
+    signed short data;          /* decoded character data */
+    unsigned short width;       /* measured width of finder (14 modules) */
+} databar_segment_t;
+
+/* DataBar specific decode state */
+typedef struct databar_decoder_s {
+    unsigned config;            /* decoder configuration flags */
+    unsigned config_exp;
+
+    unsigned csegs : 8;         /* allocated segments */
+    unsigned epoch : 8;         /* current scan */
+
+    databar_segment_t *segs;    /* active segment list */
+    signed char chars[16];      /* outstanding character indices */
+} databar_decoder_t;
+
+/* reset DataBar segment decode state */
+static inline void databar_new_scan (databar_decoder_t *db)
+{
+    int i;
+    for(i = 0; i < 16; i++)
+        if(db->chars[i] >= 0) {
+            databar_segment_t *seg = db->segs + db->chars[i];
+            if(seg->partial)
+                seg->finder = -1;
+            db->chars[i] = -1;
+        }
+}
+
+/* reset DataBar accumulated segments */
+static inline void databar_reset (databar_decoder_t *db)
+{
+    int i, n = db->csegs;
+    databar_new_scan(db);
+    for(i = 0; i < n; i++)
+        db->segs[i].finder = -1;
+}
+
+/* decode DataBar symbols */
+zbar_symbol_type_t _zbar_decode_databar(zbar_decoder_t *dcode);
+
+#endif
diff --git a/zbar/decoder/ean.c b/zbar/decoder/ean.c
--- a/zbar/decoder/ean.c
+++ b/zbar/decoder/ean.c
@@ -1,5 +1,5 @@
 /*------------------------------------------------------------------------
- *  Copyright 2007-2009 (c) Jeff Brown <spadix@users.sourceforge.net>
+ *  Copyright 2007-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
  *
  *  This file is part of the ZBar Bar Code Reader.
  *
@@ -23,12 +23,12 @@
 
 #include <config.h>
 #include <zbar.h>
-#include "decoder.h"
 
 #ifdef DEBUG_EAN
 # define DEBUG_LEVEL (DEBUG_EAN)
 #endif
 #include "debug.h"
+#include "decoder.h"
 
 /* partial decode symbol location */
 typedef enum symbol_partial_e {
@@ -109,25 +109,35 @@ static inline const unsigned char *dspri
 }
 #endif
 
+static inline int check_width (unsigned w0,
+                               unsigned w1)
+{
+    unsigned dw0 = w0;
+    w0 *= 8;
+    w1 *= 8;
+    return(w0 - dw0 <= w1 && w1 <= w0 + dw0);
+}
+
 /* evaluate previous N (>= 2) widths as auxiliary pattern,
  * using preceding 4 as character width
  */
 static inline signed char aux_end (zbar_decoder_t *dcode,
                                    unsigned char fwd)
 {
+    signed char code, i;
+
     /* reference width from previous character */
     unsigned s = calc_s(dcode, 4 + fwd, 4);
 
     /* check quiet zone */
     unsigned qz = get_width(dcode, 0);
-    if(!fwd && qz && qz < s * 3 / 4) {
+    if(!fwd && qz && qz <= s * 3 / 4) {
         dprintf(2, " [invalid quiet]");
         return(-1);
     }
 
     dprintf(2, " (");
-    signed char code = 0;
-    unsigned char i;
+    code = 0;
     for(i = 1 - fwd; i < 3 + fwd; i++) {
         unsigned e = get_width(dcode, i) + get_width(dcode, i + 1);
         dprintf(2, " %d", e);
@@ -147,27 +157,32 @@ static inline signed char aux_end (zbar_
 static inline signed char aux_start (zbar_decoder_t *dcode)
 {
     /* FIXME NB add-on has no guard in reverse */
-    unsigned e2 = get_width(dcode, 5) + get_width(dcode, 6);
+    unsigned e1, e2 = get_width(dcode, 5) + get_width(dcode, 6);
+    unsigned char E1;
+    if(dcode->ean.s4 < 6)
+        return(-1);
     if(decode_e(e2, dcode->ean.s4, 7)) {
         dprintf(2, " [invalid any]");
         return(/*FIXME (get_color(dcode) == ZBAR_SPACE) ? STATE_ADDON : */-1);
     }
 
-    unsigned e1 = get_width(dcode, 4) + get_width(dcode, 5);
-    unsigned char E1 = decode_e(e1, dcode->ean.s4, 7);
+    e1 = get_width(dcode, 4) + get_width(dcode, 5);
+    E1 = decode_e(e1, dcode->ean.s4, 7);
 
     if(get_color(dcode) == ZBAR_BAR) {
         /* check for quiet-zone */
         unsigned qz = get_width(dcode, 7);
-        if(!qz || qz >= dcode->ean.s4 * 3 / 4) {
+        if(!qz || qz > dcode->ean.s4 * 3 / 4) {
             if(!E1) {
                 dprintf(2, " [valid normal]");
                 return(0); /* normal symbol start */
             }
+#if 0
             else if(E1 == 1) {
                 dprintf(2, " [valid add-on]");
                 return(STATE_ADDON); /* add-on symbol start */
             }
+#endif
         }
         dprintf(2, " [invalid start]");
         return(-1);
@@ -176,7 +191,9 @@ static inline signed char aux_start (zba
     if(!E1) {
         /* attempting decode from SPACE => validate center guard */
         unsigned e3 = get_width(dcode, 6) + get_width(dcode, 7);
-        if(!decode_e(e3, dcode->ean.s4, 7)) {
+        unsigned e4 = get_width(dcode, 7) + get_width(dcode, 8);
+        if(!decode_e(e3, dcode->ean.s4, 7) &&
+           !decode_e(e4, dcode->ean.s4, 7)) {
             dprintf(2, " [valid center]");
             return(0); /* start after center guard */
         }
@@ -188,6 +205,8 @@ static inline signed char aux_start (zba
 /* attempt to decode previous 4 widths (2 bars and 2 spaces) as a character */
 static inline signed char decode4 (zbar_decoder_t *dcode)
 {
+    signed char code;
+
     /* calculate similar edge measurements */
     unsigned e1 = ((get_color(dcode) == ZBAR_BAR)
                    ? get_width(dcode, 0) + get_width(dcode, 1)
@@ -195,9 +214,12 @@ static inline signed char decode4 (zbar_
     unsigned e2 = get_width(dcode, 1) + get_width(dcode, 2);
     dprintf(2, "\n        e1=%d e2=%d", e1, e2);
 
+    if(dcode->ean.s4 < 6)
+        return(-1);
+
     /* create compacted encoding for direct lookup */
-    signed char code = ((decode_e(e1, dcode->ean.s4, 7) << 2) |
-                        decode_e(e2, dcode->ean.s4, 7));
+    code = ((decode_e(e1, dcode->ean.s4, 7) << 2) |
+             decode_e(e2, dcode->ean.s4, 7));
     if(code < 0)
         return(-1);
     dprintf(2, " code=%x", code);
@@ -209,15 +231,16 @@ static inline signed char decode4 (zbar_
        E1E2 == 44 (1010)
      */
     if((1 << code) & 0x0660) {
+        unsigned char mid, alt;
         /* use sum of bar widths */
         unsigned d2 = ((get_color(dcode) == ZBAR_BAR)
                        ? get_width(dcode, 0) + get_width(dcode, 2)
                        : get_width(dcode, 1) + get_width(dcode, 3));
         d2 *= 7;
-        unsigned char mid = (((1 << code) & 0x0420)
+        mid = (((1 << code) & 0x0420)
                              ? 3     /* E1E2 in 33,44 */
                              : 4);   /* E1E2 in 34,43 */
-        unsigned char alt = d2 > (mid * dcode->ean.s4);
+        alt = d2 > (mid * dcode->ean.s4);
         if(alt)
             code = ((code >> 1) & 3) | 0x10; /* compress code space */
         dprintf(2, " (d2=%d(%d) alt=%d)", d2, mid * dcode->ean.s4, alt);
@@ -245,6 +268,7 @@ static inline zbar_symbol_type_t ean_par
     if(!par == fwd) {
         /* reverse sampled digits */
         unsigned char tmp = pass->raw[1];
+        pass->state |= STATE_REV;
         pass->raw[1] = pass->raw[4];
         pass->raw[4] = tmp;
         tmp = pass->raw[2];
@@ -292,8 +316,9 @@ static inline zbar_symbol_type_t ean_par
         return(ZBAR_NONE);
 
     if(!par == fwd) {
+        unsigned char i;
+        pass->state |= STATE_REV;
         /* reverse sampled digits */
-        unsigned char i;
         for(i = 1; i < 4; i++) {
             unsigned char tmp = pass->raw[i];
             pass->raw[i] = pass->raw[7 - i];
@@ -324,33 +349,52 @@ static inline zbar_symbol_type_t ean_par
 static inline zbar_symbol_type_t decode_pass (zbar_decoder_t *dcode,
                                               ean_pass_t *pass)
 {
+    unsigned char idx, fwd;
     pass->state++;
-    unsigned char idx = pass->state & STATE_IDX;
-    unsigned char fwd = pass->state & 1;
+    idx = pass->state & STATE_IDX;
+    fwd = pass->state & 1;
 
     if(get_color(dcode) == ZBAR_SPACE &&
        (idx == 0x10 || idx == 0x11) &&
        TEST_CFG(dcode->ean.ean8_config, ZBAR_CFG_ENABLE) &&
        !aux_end(dcode, fwd)) {
+        zbar_symbol_type_t part;
         dprintf(2, " fwd=%x", fwd);
-        zbar_symbol_type_t part = ean_part_end4(pass, fwd);
+        part = ean_part_end4(pass, fwd);
+        if(part)
+            dcode->ean.direction = (pass->state & STATE_REV) != 0;
         pass->state = -1;
         return(part);
     }
 
     if(!(idx & 0x03) && idx <= 0x14) {
+        signed char code = -1;
+        unsigned w = pass->width;
         if(!dcode->ean.s4)
             return(0);
         /* validate guard bars before decoding first char of symbol */
         if(!pass->state) {
             pass->state = aux_start(dcode);
+            pass->width = dcode->ean.s4;
             if(pass->state < 0)
                 return(0);
             idx = pass->state & STATE_IDX;
         }
-        signed char code = decode4(dcode);
-        if(code < 0)
+        else {
+            w = check_width(w, dcode->ean.s4);
+            if(w)
+                pass->width = (pass->width + dcode->ean.s4 * 3) / 4;
+        }
+
+        if(w)
+            code = decode4(dcode);
+        else
+            dprintf(2, " [bad width]");
+
+        if(code < 0 && idx != 0x10)
             pass->state = -1;
+        else if(code < 0)
+            pass->raw[5] = 0xff;
         else {
             dprintf(2, "\n        raw[%x]=%02x =>", idx >> 2,
                     digits[(unsigned char)code]);
@@ -367,8 +411,10 @@ static inline zbar_symbol_type_t decode_
        (idx == 0x18 || idx == 0x19)) {
         zbar_symbol_type_t part = ZBAR_NONE;
         dprintf(2, " fwd=%x", fwd);
-        if(!aux_end(dcode, fwd))
+        if(!aux_end(dcode, fwd) && pass->raw[5] != 0xff)
             part = ean_part_end7(&dcode->ean, pass, fwd);
+        if(part)
+            dcode->ean.direction = (pass->state & STATE_REV) != 0;
         pass->state = -1;
         return(part);
     }
@@ -379,7 +425,7 @@ static inline signed char ean_verify_che
                                                int n)
 {
     unsigned char chk = 0;
-    unsigned char i;
+    unsigned char i, d;
     for(i = 0; i < n; i++) {
         unsigned char d = ean->buf[i];
         zassert(d < 10, -1, "i=%x d=%x chk=%x %s\n", i, d, chk,
@@ -397,7 +443,7 @@ static inline signed char ean_verify_che
             _zbar_decoder_buf_dump((void*)ean->buf, 18));
     if(chk)
         chk = 10 - chk;
-    unsigned char d = ean->buf[n];
+    d = ean->buf[n];
     zassert(d < 10, -1, "n=%x d=%x chk=%x %s\n", n, d, chk,
             _zbar_decoder_buf_dump((void*)ean->buf, 18));
     if(chk != d) {
@@ -431,10 +477,11 @@ static inline void ean_expand_upce (ean_
                                     ean_pass_t *pass)
 {
     int i = 0;
+    unsigned char decode;
     /* parity encoded digit is checksum */
     ean->buf[12] = pass->raw[i++];
 
-    unsigned char decode = pass->raw[6] & 0xf;
+    decode = pass->raw[6] & 0xf;
     ean->buf[0] = 0;
     ean->buf[1] = 0;
     ean->buf[2] = pass->raw[i++] & 0xf;
@@ -446,17 +493,19 @@ static inline void ean_expand_upce (ean_
     ean->buf[8] = 0;
     ean->buf[9] = (decode < 3) ? pass->raw[i++] & 0xf : 0;
     ean->buf[10] = (decode < 4) ? pass->raw[i++] & 0xf : 0;
-    ean->buf[11] = (decode < 5) ? pass->raw[i++] & 0xf : decode;
+    ean->buf[11] = (decode < 5) ? pass->raw[i] & 0xf : decode;
 }
 
 static inline zbar_symbol_type_t integrate_partial (ean_decoder_t *ean,
                                                     ean_pass_t *pass,
                                                     zbar_symbol_type_t part)
 {
+    signed char i, j, right = !!(part & EAN_RIGHT);
     /* copy raw data into holding buffer */
     /* if same partial is not consistent, reset others */
-    dprintf(2, " integrate part=%x (%s)", part, dsprintbuf(ean));
-    signed char i, j;
+    dprintf(2, " integrate part=%x (%s) w=%d=>%d",
+            part, dsprintbuf(ean), ean->width, pass->width);
+
     if(part & ZBAR_ADDON) {
         /* FIXME TBD */
         for(i = (part == ZBAR_ADDON5) ? 4 : 1; i >= 0; i--) {
@@ -477,7 +526,13 @@ static inline zbar_symbol_type_t integra
             ean->left = ean->right = ean->addon = ZBAR_NONE;
         }
 
-        if(part & EAN_RIGHT) {
+        if((ean->left || ean->right || ean->addon) &&
+           !check_width(ean->width, pass->width)) {
+            dprintf(2, " rst(width %d)", pass->width);
+            ean->left = ean->right = ean->addon = ZBAR_NONE;
+        }
+
+        if(right) {
             part &= ZBAR_SYMBOL;
             j = (part == ZBAR_EAN13) ? 12 : 7;
             for(i = (part == ZBAR_EAN13) ? 6 : 4; i; i--, j--) {
@@ -507,6 +562,7 @@ static inline zbar_symbol_type_t integra
         else /* ZBAR_UPCE */
             ean_expand_upce(ean, pass);
     }
+    ean->width = pass->width;
 
     if((part & ZBAR_SYMBOL) != ZBAR_UPCE) {
         part = (ean->left & ean->right);
@@ -516,9 +572,14 @@ static inline zbar_symbol_type_t integra
 
     if(((part == ZBAR_EAN13 ||
          part == ZBAR_UPCE) && ean_verify_checksum(ean, 12)) ||
-       (part == ZBAR_EAN8 && ean_verify_checksum(ean, 7)))
-        /* invalid parity */
+       (part == ZBAR_EAN8 && ean_verify_checksum(ean, 7))) {
+        /* invalid checksum */
+        if(right)
+            ean->left = ZBAR_NONE;
+        else
+            ean->right = ZBAR_NONE;
         part = ZBAR_NONE;
+    }
 
     if(part == ZBAR_EAN13) {
         /* special case EAN-13 subsets */
@@ -556,7 +617,8 @@ static inline zbar_symbol_type_t integra
     if(part > ZBAR_PARTIAL)
         part |= ean->addon;
 
-    dprintf(2, " %x/%x=%x", ean->left, ean->right, part);
+    dprintf(2, " dir=%d %x/%x=%x",
+            ean->direction, ean->left, ean->right, part);
     return(part);
 }
 
@@ -596,6 +658,8 @@ static inline void postprocess (zbar_dec
             dcode->buf[j] = ean->buf[i] + '0';
     dcode->buflen = j;
     dcode->buf[j] = '\0';
+    dcode->direction = 1 - 2 * ean->direction;
+    dcode->modifiers = 0;
 }
 
 zbar_symbol_type_t _zbar_decode_ean (zbar_decoder_t *dcode)
@@ -603,20 +667,21 @@ zbar_symbol_type_t _zbar_decode_ean (zba
     /* process upto 4 separate passes */
     zbar_symbol_type_t sym = ZBAR_NONE;
     unsigned char pass_idx = dcode->idx & 3;
+    unsigned char i;
 
     /* update latest character width */
     dcode->ean.s4 -= get_width(dcode, 4);
     dcode->ean.s4 += get_width(dcode, 0);
 
-    unsigned char i;
     for(i = 0; i < 4; i++) {
         ean_pass_t *pass = &dcode->ean.pass[i];
         if(pass->state >= 0 ||
            i == pass_idx)
         {
+            zbar_symbol_type_t part;
             dprintf(2, "      ean[%x/%x]: idx=%x st=%d s=%d",
                     pass_idx, i, dcode->idx, pass->state, dcode->ean.s4);
-            zbar_symbol_type_t part = decode_pass(dcode, pass);
+            part = decode_pass(dcode, pass);
             if(part) {
                 /* update accumulated data from new partial decode */
                 sym = integrate_partial(&dcode->ean, pass, part);
@@ -626,7 +691,7 @@ zbar_symbol_type_t _zbar_decode_ean (zba
                     dcode->ean.pass[0].state = dcode->ean.pass[1].state = -1;
                     dcode->ean.pass[2].state = dcode->ean.pass[3].state = -1;
                     if(sym > ZBAR_PARTIAL) {
-                        if(!get_lock(dcode, ZBAR_EAN13))
+                        if(!acquire_lock(dcode, sym))
                             postprocess(dcode, sym);
                         else {
                             dprintf(1, " [locked %d]", dcode->lock);
diff --git a/zbar/decoder/ean.h b/zbar/decoder/ean.h
--- a/zbar/decoder/ean.h
+++ b/zbar/decoder/ean.h
@@ -1,5 +1,5 @@
 /*------------------------------------------------------------------------
- *  Copyright 2007-2009 (c) Jeff Brown <spadix@users.sourceforge.net>
+ *  Copyright 2007-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
  *
  *  This file is part of the ZBar Bar Code Reader.
  *
@@ -26,18 +26,21 @@
 /* state of each parallel decode attempt */
 typedef struct ean_pass_s {
     signed char state;          /* module position of w[idx] in symbol */
+#define STATE_REV   0x80        /*   scan direction reversed */
 #define STATE_ADDON 0x40        /*   scanning add-on */
 #define STATE_IDX   0x1f        /*   element offset into symbol */
+    unsigned width;             /* width of last character */
     unsigned char raw[7];       /* decode in process */
 } ean_pass_t;
 
 /* EAN/UPC specific decode state */
 typedef struct ean_decoder_s {
     ean_pass_t pass[4];         /* state of each parallel decode attempt */
-    zbar_symbol_type_t left;   /* current holding buffer contents */
+    zbar_symbol_type_t left;    /* current holding buffer contents */
     zbar_symbol_type_t right;
     zbar_symbol_type_t addon;
-    unsigned s4;                /* character width */
+    int direction;              /* scan direction */
+    unsigned s4, width;         /* character width */
     signed char buf[18];        /* holding buffer */
 
     signed char enable;
diff --git a/zbar/decoder/i25.c b/zbar/decoder/i25.c
--- a/zbar/decoder/i25.c
+++ b/zbar/decoder/i25.c
@@ -1,5 +1,5 @@
 /*------------------------------------------------------------------------
- *  Copyright 2008-2009 (c) Jeff Brown <spadix@users.sourceforge.net>
+ *  Copyright 2008-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
  *
  *  This file is part of the ZBar Bar Code Reader.
  *
@@ -25,12 +25,12 @@
 #include <string.h>     /* memmove */
 
 #include <zbar.h>
-#include "decoder.h"
 
 #ifdef DEBUG_I25
 # define DEBUG_LEVEL (DEBUG_I25)
 #endif
 #include "debug.h"
+#include "decoder.h"
 
 static inline unsigned char i25_decode1 (unsigned char enc,
                                          unsigned e,
@@ -111,7 +111,7 @@ static inline signed char i25_decode_sta
      * we require 5.25n for w=2n to 6.75n for w=3n
      * (FIXME should really factor in w:n ratio)
      */
-    unsigned quiet = get_width(dcode, i++);
+    unsigned quiet = get_width(dcode, i);
     if(quiet && quiet < dcode25->s10 * 3 / 8) {
         dprintf(3, "      i25: s=%d enc=%x q=%d [invalid qz]\n",
                 dcode25->s10, enc, quiet);
@@ -124,6 +124,21 @@ static inline signed char i25_decode_sta
     return(ZBAR_PARTIAL);
 }
 
+static inline int i25_acquire_lock (zbar_decoder_t *dcode)
+{
+    int i;
+    /* lock shared resources */
+    if(acquire_lock(dcode, ZBAR_I25)) {
+        dcode->i25.character = -1;
+        return(1);
+    }
+
+    /* copy holding buffer */
+    for(i = 4; --i >= 0; )
+        dcode->buf[i] = dcode->i25.buf[i];
+    return(0);
+}
+
 static inline signed char i25_decode_end (zbar_decoder_t *dcode)
 {
     i25_decoder_t *dcode25 = &dcode->i25;
@@ -133,7 +148,8 @@ static inline signed char i25_decode_end
     if((quiet && quiet < dcode25->width * 3 / 8) ||
        decode_e(get_width(dcode, 1), dcode25->width, 45) > 2 ||
        decode_e(get_width(dcode, 2), dcode25->width, 45) > 2) {
-        dprintf(3, " s=%d q=%d [invalid qz]\n", dcode25->width, quiet);
+        dprintf(3, "      i25: s=%d q=%d [invalid qz]\n",
+                dcode25->width, quiet);
         return(ZBAR_NONE);
     }
 
@@ -145,6 +161,11 @@ static inline signed char i25_decode_end
           decode_e(get_width(dcode, 4), dcode25->width, 45) > 2))
         return(ZBAR_NONE);
 
+    if(dcode25->character <= 4 &&
+       i25_acquire_lock(dcode))
+        return(ZBAR_PARTIAL);
+
+    dcode->direction = 1 - 2 * dcode25->direction;
     if(dcode25->direction) {
         /* reverse buffer */
         dprintf(2, " (rev)");
@@ -161,13 +182,14 @@ static inline signed char i25_decode_end
        (CFG(*dcode25, ZBAR_CFG_MAX_LEN) > 0 &&
         dcode25->character > CFG(*dcode25, ZBAR_CFG_MAX_LEN))) {
         dprintf(2, " [invalid len]\n");
-        dcode->lock = 0;
+        release_lock(dcode, ZBAR_I25);
         dcode25->character = -1;
         return(ZBAR_NONE);
     }
 
     dcode->buflen = dcode25->character;
     dcode->buf[dcode25->character] = '\0';
+    dcode->modifiers = 0;
     dprintf(2, " [valid end]\n");
     dcode25->character = -1;
     return(ZBAR_I25);
@@ -197,38 +219,45 @@ zbar_symbol_type_t _zbar_decode_i25 (zba
             (dcode25->direction) ? '<' : '>',
             dcode25->character, dcode25->element);
 
-    /* lock shared resources */
-    if(!dcode25->character && get_lock(dcode, ZBAR_I25)) {
-        dcode25->character = -1;
-        dprintf(2, " [locked %d]\n", dcode->lock);
+    if(dcode25->character == 4 && i25_acquire_lock(dcode))
         return(ZBAR_PARTIAL);
-    }
 
     unsigned char c = i25_decode10(dcode, 1);
     dprintf(2, " c=%x", c);
+    if(c > 9) {
+        dprintf(2, " [aborted]\n");
+        goto reset;
+    }
 
-    if(c > 9 ||
-       ((dcode25->character >= BUFFER_MIN) &&
-        size_buf(dcode, dcode25->character + 2))) {
-        dprintf(2, (c > 9) ? " [aborted]\n" : " [overflow]\n");
-        dcode->lock = 0;
-        dcode25->character = -1;
-        return(ZBAR_NONE);
+    if((dcode25->character >= BUFFER_MIN) &&
+       size_buf(dcode, dcode25->character + 2)) {
+        dprintf(2, " [overflow]\n");
+        goto reset;
     }
-    dcode->buf[dcode25->character++] = c + '0';
+
+    unsigned char *buf;
+    if(dcode25->character >= 4)
+        buf = dcode->buf;
+    else
+        buf = dcode25->buf;
+    buf[dcode25->character++] = c + '0';
 
     c = i25_decode10(dcode, 0);
     dprintf(2, " c=%x", c);
     if(c > 9) {
         dprintf(2, " [aborted]\n");
-        dcode->lock = 0;
-        dcode25->character = -1;
-        return(ZBAR_NONE);
+        goto reset;
     }
     else
         dprintf(2, "\n");
 
-    dcode->buf[dcode25->character++] = c + '0';
+    buf[dcode25->character++] = c + '0';
     dcode25->element = 10;
     return((dcode25->character == 2) ? ZBAR_PARTIAL : ZBAR_NONE);
+
+reset:
+    if(dcode25->character >= 4)
+        release_lock(dcode, ZBAR_I25);
+    dcode25->character = -1;
+    return(ZBAR_NONE);
 }
diff --git a/zbar/decoder/i25.h b/zbar/decoder/i25.h
--- a/zbar/decoder/i25.h
+++ b/zbar/decoder/i25.h
@@ -30,6 +30,7 @@ typedef struct i25_decoder_s {
     int character : 12;         /* character position in symbol */
     unsigned s10;               /* current character width */
     unsigned width;             /* last character width */
+    unsigned char buf[4];       /* initial scan buffer */
 
     unsigned config;
     int configs[NUM_CFGS];      /* int valued configurations */
diff --git a/zbar/decoder/pdf417.c b/zbar/decoder/pdf417.c
--- a/zbar/decoder/pdf417.c
+++ b/zbar/decoder/pdf417.c
@@ -1,5 +1,5 @@
 /*------------------------------------------------------------------------
- *  Copyright 2008-2009 (c) Jeff Brown <spadix@users.sourceforge.net>
+ *  Copyright 2008-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
  *
  *  This file is part of the ZBar Bar Code Reader.
  *
@@ -24,14 +24,14 @@
 #include <config.h>
 
 #include <zbar.h>
-#include "decoder.h"
-
-#include "pdf417_hash.h"
 
 #ifdef DEBUG_PDF417
 # define DEBUG_LEVEL (DEBUG_PDF417)
 #endif
 #include "debug.h"
+#include "decoder.h"
+
+#include "pdf417_hash.h"
 
 #define PDF417_STOP 0xbff
 
@@ -152,7 +152,7 @@ static inline signed char pdf417_decode_
     }
 
     /* lock shared resources */
-    if(get_lock(dcode, ZBAR_PDF417)) {
+    if(acquire_lock(dcode, ZBAR_PDF417)) {
         dprintf(2, " [locked %d]\n", dcode->lock);
         return(0);
     }
@@ -190,7 +190,7 @@ zbar_symbol_type_t _zbar_decode_pdf417 (
 
     if(get_color(dcode) != dcode417->direction) {
         int c = dcode417->character;
-        dcode->lock = 0;
+        release_lock(dcode, ZBAR_PDF417);
         dcode417->character = -1;
         zassert(get_color(dcode) == dcode417->direction, ZBAR_NONE,
                 "color=%x dir=%x char=%d elem=0 %s\n",
@@ -203,7 +203,7 @@ zbar_symbol_type_t _zbar_decode_pdf417 (
        ((dcode417->character >= BUFFER_MIN) &&
         size_buf(dcode, dcode417->character + 1))) {
         dprintf(1, (c < 0) ? " [aborted]\n" : " [overflow]\n");
-        dcode->lock = 0;
+        release_lock(dcode, ZBAR_PDF417);
         dcode417->character = -1;
         return(0);
     }
@@ -213,7 +213,9 @@ zbar_symbol_type_t _zbar_decode_pdf417 (
     if(c == PDF417_STOP) {
         dprintf(1, " [valid stop]");
         /* FIXME check trailing bar and qz */
-        dcode->lock = 0;
+        dcode->direction = 1 - 2 * dcode417->direction;
+        dcode->modifiers = 0;
+        release_lock(dcode, ZBAR_PDF417);
         dcode417->character = -1;
     }
 
diff --git a/zbar/decoder/qr_finder.c b/zbar/decoder/qr_finder.c
--- a/zbar/decoder/qr_finder.c
+++ b/zbar/decoder/qr_finder.c
@@ -1,13 +1,36 @@
+/*------------------------------------------------------------------------
+ *  Copyright 2009-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
+ *
+ *  This file is part of the ZBar Bar Code Reader.
+ *
+ *  The ZBar Bar Code Reader is free software; you can redistribute it
+ *  and/or modify it under the terms of the GNU Lesser Public License as
+ *  published by the Free Software Foundation; either version 2.1 of
+ *  the License, or (at your option) any later version.
+ *
+ *  The ZBar Bar Code Reader is distributed in the hope that it will be
+ *  useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+ *  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Lesser Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser Public License
+ *  along with the ZBar Bar Code Reader; if not, write to the Free
+ *  Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ *  Boston, MA  02110-1301  USA
+ *
+ *  http://sourceforge.net/projects/zbar
+ *------------------------------------------------------------------------*/
+
 #include <config.h>
 #include <assert.h>
 
 #include <zbar.h>
-#include "decoder.h"
 
 #ifdef DEBUG_QR_FINDER
 # define DEBUG_LEVEL (DEBUG_QR_FINDER)
 #endif
 #include "debug.h"
+#include "decoder.h"
 
 /* at this point lengths are all decode unit offsets from the decode edge
  * NB owned by finder
@@ -20,18 +43,20 @@ qr_finder_line *_zbar_decoder_get_qr_fin
 zbar_symbol_type_t _zbar_find_qr (zbar_decoder_t *dcode)
 {
     qr_finder_t *qrf = &dcode->qrf;
+    unsigned s, qz, w;
+    int ei;
 
     /* update latest finder pattern width */
     qrf->s5 -= get_width(dcode, 6);
     qrf->s5 += get_width(dcode, 1);
-    unsigned s = qrf->s5;
+    s = qrf->s5;
 
     if(get_color(dcode) != ZBAR_SPACE || s < 7)
         return(0);
 
     dprintf(2, "    qrf: s=%d", s);
 
-    int ei = decode_e(pair_width(dcode, 1), s, 7);
+    ei = decode_e(pair_width(dcode, 1), s, 7);
     dprintf(2, " %d", ei);
     if(ei)
         goto invalid;
@@ -54,8 +79,8 @@ zbar_symbol_type_t _zbar_find_qr (zbar_d
     /* valid QR finder symbol
      * mark positions needed by decoder
      */
-    unsigned qz = get_width(dcode, 0);
-    unsigned w = get_width(dcode, 1);
+    qz = get_width(dcode, 0);
+    w = get_width(dcode, 1);
     qrf->line.eoffs = qz + (w + 1) / 2;
     qrf->line.len = qz + w + get_width(dcode, 2);
     qrf->line.pos[0] = qrf->line.len + get_width(dcode, 3);
@@ -67,6 +92,8 @@ zbar_symbol_type_t _zbar_find_qr (zbar_d
             qrf->line.boffs, qrf->line.pos[0], qrf->line.len,
             qrf->line.eoffs);
 
+    dcode->direction = 0;
+    dcode->buflen = 0;
     return(ZBAR_QRCODE);
 
 invalid:
diff --git a/zbar/error.c b/zbar/error.c
--- a/zbar/error.c
+++ b/zbar/error.c
@@ -1,5 +1,5 @@
 /*------------------------------------------------------------------------
- *  Copyright 2007-2009 (c) Jeff Brown <spadix@users.sourceforge.net>
+ *  Copyright 2007-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
  *
  *  This file is part of the ZBar Bar Code Reader.
  *
@@ -36,7 +36,7 @@ static const char * const mod_str[] = {
 };
 #define MOD_MAX (strlen(mod_str[ZBAR_MOD_IMAGE_SCANNER]))
 
-static const char const * err_str[] = {
+static const char * const err_str[] = {
     "no error",                 /* OK */
     "out of memory",            /* NOMEM */
     "internal library error",   /* INTERNAL */
@@ -99,32 +99,32 @@ zbar_error_t _zbar_get_error_code (const
 const char *_zbar_error_string (const void *container,
                                 int verbosity)
 {
+    static const char basefmt[] = "%s: zbar %s in %s():\n    %s: ";
     errinfo_t *err = (errinfo_t*)container;
+    const char *sev, *mod, *func, *type;
+    int len;
+
     assert(err->magic == ERRINFO_MAGIC);
 
-    const char *sev;
     if(err->sev >= SEV_FATAL && err->sev <= SEV_NOTE)
         sev = sev_str[err->sev + 2];
     else
         sev = sev_str[1];
 
-    const char *mod;
     if(err->module >= ZBAR_MOD_PROCESSOR &&
        err->module < ZBAR_MOD_UNKNOWN)
         mod = mod_str[err->module];
     else
         mod = mod_str[ZBAR_MOD_UNKNOWN];
 
-    const char *func = (err->func) ? err->func : "<unknown>";
+    func = (err->func) ? err->func : "<unknown>";
 
-    const char *type;
     if(err->type >= 0 && err->type < ZBAR_ERR_NUM)
         type = err_str[err->type];
     else
         type = err_str[ZBAR_ERR_NUM];
 
-    char basefmt[] = "%s: zbar %s in %s():\n    %s: ";
-    int len = SEV_MAX + MOD_MAX + ERR_MAX + strlen(func) + sizeof(basefmt);
+    len = SEV_MAX + MOD_MAX + ERR_MAX + strlen(func) + sizeof(basefmt);
     err->buf = realloc(err->buf, len);
     len = sprintf(err->buf, basefmt, sev, mod, func, type);
     if(len <= 0)
@@ -150,12 +150,14 @@ const char *_zbar_error_string (const vo
             return("<unknown>");
     }
 
+#ifdef HAVE_ERRNO_H
     if(err->type == ZBAR_ERR_SYSTEM) {
-        char sysfmt[] = ": %s (%d)\n";
+        static const char sysfmt[] = ": %s (%d)\n";
         const char *syserr = strerror(err->errnum);
         err->buf = realloc(err->buf, len + strlen(sysfmt) + strlen(syserr));
         len += sprintf(err->buf + len, sysfmt, syserr, err->errnum);
     }
+#endif
 #ifdef _WIN32
     else if(err->type == ZBAR_ERR_WINAPI) {
         char *syserr = NULL;
diff --git a/zbar/error.h b/zbar/error.h
--- a/zbar/error.h
+++ b/zbar/error.h
@@ -1,5 +1,5 @@
 /*------------------------------------------------------------------------
- *  Copyright 2007-2009 (c) Jeff Brown <spadix@users.sourceforge.net>
+ *  Copyright 2007-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
  *
  *  This file is part of the ZBar Bar Code Reader.
  *
@@ -30,7 +30,9 @@
 #include <stdlib.h>
 #include <stdio.h>
 #include <string.h>
-#include <errno.h>
+#ifdef HAVE_ERRNO_H
+# include <errno.h>
+#endif
 #include <assert.h>
 
 #include <zbar.h>
@@ -146,10 +148,12 @@ static inline int err_capture (const voi
 {
     errinfo_t *err = (errinfo_t*)container;
     assert(err->magic == ERRINFO_MAGIC);
+#ifdef HAVE_ERRNO_H
     if(type == ZBAR_ERR_SYSTEM)
         err->errnum = errno;
+#endif
 #ifdef _WIN32
-    else if(type == ZBAR_ERR_WINAPI)
+    if(type == ZBAR_ERR_WINAPI)
         err->errnum = GetLastError();
 #endif
     err->sev = sev;
diff --git a/zbar/image.c b/zbar/image.c
--- a/zbar/image.c
+++ b/zbar/image.c
@@ -1,5 +1,5 @@
 /*------------------------------------------------------------------------
- *  Copyright 2007-2009 (c) Jeff Brown <spadix@users.sourceforge.net>
+ *  Copyright 2007-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
  *
  *  This file is part of the ZBar Bar Code Reader.
  *
@@ -74,6 +74,26 @@ unsigned zbar_image_get_height (const zb
     return(img->height);
 }
 
+void zbar_image_get_size (const zbar_image_t *img,
+                          unsigned *w,
+                          unsigned *h)
+{
+    if(w) *w = img->width;
+    if(h) *h = img->height;
+}
+
+void zbar_image_get_crop (const zbar_image_t *img,
+                          unsigned *x,
+                          unsigned *y,
+                          unsigned *w,
+                          unsigned *h)
+{
+    if(x) *x = img->crop_x;
+    if(y) *y = img->crop_y;
+    if(w) *w = img->crop_w;
+    if(h) *h = img->crop_h;
+}
+
 const void *zbar_image_get_data (const zbar_image_t *img)
 {
     return(img->data);
@@ -100,8 +120,28 @@ void zbar_image_set_size (zbar_image_t *
                           unsigned w,
                           unsigned h)
 {
-    img->width = w;
-    img->height = h;
+    img->crop_x = img->crop_y = 0;
+    img->width = img->crop_w = w;
+    img->height = img->crop_h = h;
+}
+
+void zbar_image_set_crop (zbar_image_t *img,
+                          unsigned x,
+                          unsigned y,
+                          unsigned w,
+                          unsigned h)
+{
+    unsigned img_w = img->width;
+    if(x > img_w) x = img_w;
+    if(x + w > img_w) w = img_w - x;
+    img->crop_x = x;
+    img->crop_w = w;
+
+    unsigned img_h = img->height;
+    if(y > img_h) y = img_h;
+    if(y + h > img_h) h = img_h - y;
+    img->crop_y = y;
+    img->crop_h = h;
 }
 
 inline void zbar_image_free_data (zbar_image_t *img)
@@ -109,9 +149,10 @@ inline void zbar_image_free_data (zbar_i
     if(!img)
         return;
     if(img->src) {
+        zbar_image_t *newimg;
         /* replace video image w/new copy */
         assert(img->refcnt); /* FIXME needs lock */
-        zbar_image_t *newimg = zbar_image_create();
+        newimg = zbar_image_create();
         memcpy(newimg, img, sizeof(zbar_image_t));
         /* recycle video image */
         newimg->cleanup(newimg);
@@ -162,8 +203,7 @@ zbar_image_t *zbar_image_copy (const zba
 {
     zbar_image_t *dst = zbar_image_create();
     dst->format = src->format;
-    dst->width = src->width;
-    dst->height = src->height;
+    _zbar_image_copy_size(dst, src);
     dst->datalen = src->datalen;
     dst->data = malloc(src->datalen);
     assert(dst->data);
@@ -180,11 +220,11 @@ const zbar_symbol_set_t *zbar_image_get_
 void zbar_image_set_symbols (zbar_image_t *img,
                              const zbar_symbol_set_t *syms)
 {
+    if(syms)
+        zbar_symbol_set_ref(syms, 1);
     if(img->syms)
         zbar_symbol_set_ref(img->syms, -1);
     img->syms = (zbar_symbol_set_t*)syms;
-    if(syms)
-        zbar_symbol_set_ref(img->syms, 1);
 }
 
 const zbar_symbol_t *zbar_image_first_symbol (const zbar_image_t *img)
@@ -202,29 +242,34 @@ int zbar_image_write (const zbar_image_t
                       const char *filebase)
 {
     int len = strlen(filebase) + 16;
-    char filename[len];
+    char *filename = malloc(len);
+    int n = 0, rc = 0;
+    FILE *f;
+    zimg_hdr_t hdr;
     strcpy(filename, filebase);
-    int n = 0;
-    if(*(char*)&img->format >= ' ')
+    if((img->format & 0xff) >= ' ')
         n = snprintf(filename, len, "%s.%.4s.zimg",
                      filebase, (char*)&img->format);
     else
         n = snprintf(filename, len, "%s.%08" PRIx32 ".zimg",
                      filebase, img->format);
-    assert(n < len);
-    filename[len] = '\0';
+    assert(n < len - 1);
+    filename[len - 1] = '\0';
 
     zprintf(1, "dumping %.4s(%08" PRIx32 ") image to %s\n",
             (char*)&img->format, img->format, filename);
 
-    FILE *f = fopen(filename, "w");
+    f = fopen(filename, "w");
     if(!f) {
-        int rc = errno;
+#ifdef HAVE_ERRNO_H
+        rc = errno;
         zprintf(1, "ERROR opening %s: %s\n", filename, strerror(rc));
-        return(rc);
+#else
+        rc = 1;
+#endif
+        goto error;
     }
 
-    zimg_hdr_t hdr;
     hdr.magic = 0x676d697a;
     hdr.format = img->format;
     hdr.width = img->width;
@@ -233,12 +278,21 @@ int zbar_image_write (const zbar_image_t
 
     if(fwrite(&hdr, sizeof(hdr), 1, f) != 1 ||
        fwrite(img->data, 1, img->datalen, f) != img->datalen) {
-        int rc = errno;
+#ifdef HAVE_ERRNO_H
+        rc = errno;
         zprintf(1, "ERROR writing %s: %s\n", filename, strerror(rc));
+#else
+        rc = 1;
+#endif
         fclose(f);
-        return(rc);
+        goto error;
     }
-    return(fclose(f));
+
+    rc = fclose(f);
+
+error:
+    free(filename);
+    return(rc);
 }
 
 #ifdef DEBUG_SVG
diff --git a/zbar/image.h b/zbar/image.h
--- a/zbar/image.h
+++ b/zbar/image.h
@@ -1,5 +1,5 @@
 /*------------------------------------------------------------------------
- *  Copyright 2007-2009 (c) Jeff Brown <spadix@users.sourceforge.net>
+ *  Copyright 2007-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
  *
  *  This file is part of the ZBar Bar Code Reader.
  *
@@ -35,10 +35,7 @@
 #include "symbol.h"
 #include "refcnt.h"
 
-/* adapted from v4l2 spec */
-#define fourcc(a, b, c, d)                      \
-    ((uint32_t)(a) | ((uint32_t)(b) << 8) |     \
-     ((uint32_t)(c) << 16) | ((uint32_t)(d) << 24))
+#define fourcc zbar_fourcc
 
 /* unpack size/location of component */
 #define RGB_SIZE(c)   ((c) >> 5)
@@ -65,6 +62,8 @@ struct zbar_image_s {
     unsigned width, height;     /* image size */
     const void *data;           /* image sample data */
     unsigned long datalen;      /* allocated/mapped size of data */
+    unsigned crop_x, crop_y;    /* crop rectangle */
+    unsigned crop_w, crop_h;
     void *userdata;             /* user specified data associated w/image */
 
     /* cleanup handler */
@@ -129,4 +128,15 @@ static inline void _zbar_image_swap_symb
     b->syms = tmp;
 }
 
+static inline void _zbar_image_copy_size (zbar_image_t *dst,
+                                          const zbar_image_t *src)
+{
+    dst->width = src->width;
+    dst->height = src->height;
+    dst->crop_x = src->crop_x;
+    dst->crop_y = src->crop_y;
+    dst->crop_w = src->crop_w;
+    dst->crop_h = src->crop_h;
+}
+
 #endif
diff --git a/zbar/img_scanner.c b/zbar/img_scanner.c
--- a/zbar/img_scanner.c
+++ b/zbar/img_scanner.c
@@ -1,5 +1,5 @@
 /*------------------------------------------------------------------------
- *  Copyright 2007-2009 (c) Jeff Brown <spadix@users.sourceforge.net>
+ *  Copyright 2007-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
  *
  *  This file is part of the ZBar Bar Code Reader.
  *
@@ -22,19 +22,20 @@
  *------------------------------------------------------------------------*/
 
 #include <config.h>
-#include <unistd.h>
+#ifdef HAVE_UNISTD_H
+# include <unistd.h>
+#endif
 #ifdef HAVE_INTTYPES_H
 # include <inttypes.h>
 #endif
 #include <stdlib.h>     /* malloc, free */
-#include <time.h>       /* clock_gettime */
-#include <sys/time.h>   /* gettimeofday */
 #include <string.h>     /* memcmp, memset, memcpy */
 #include <assert.h>
 
 #include <zbar.h>
 #include "error.h"
 #include "image.h"
+#include "timer.h"
 #ifdef ENABLE_QRCODE
 # include "qrcode.h"
 #endif
@@ -50,11 +51,6 @@
 
 /* FIXME cache setting configurability */
 
-/* number of times the same result must be detected
- * in "nearby" images before being reported
- */
-#define CACHE_CONSISTENCY    3 /* images */
-
 /* time interval for which two images are considered "nearby"
  */
 #define CACHE_PROXIMITY   1000 /* ms */
@@ -112,6 +108,7 @@ struct zbar_image_scanner_s {
     /* configuration settings */
     unsigned config;            /* config flags */
     int configs[NUM_SCN_CFGS];  /* int valued configurations */
+    int sym_configs[1][NUM_SYMS]; /* per-symbology configurations */
 
 #ifndef NO_STATS
     int stat_syms_new;
@@ -136,6 +133,8 @@ void _zbar_image_scanner_recycle_syms (z
             sym->next = NULL;
         }
         else {
+            int i;
+            recycle_bucket_t *bucket;
             /* recycle unreferenced symbol */
             if(!sym->data_alloc) {
                 sym->data = NULL;
@@ -149,7 +148,6 @@ void _zbar_image_scanner_recycle_syms (z
                 _zbar_symbol_set_free(sym->syms);
                 sym->syms = NULL;
             }
-            int i;
             for(i = 0; i < RECYCLE_BUCKETS; i++)
                 if(sym->data_alloc < 1 << (i * 2))
                     break;
@@ -160,7 +158,7 @@ void _zbar_image_scanner_recycle_syms (z
                 sym->data_alloc = 0;
                 i = 0;
             }
-            recycle_bucket_t *bucket = &iscn->recycle[i];
+            bucket = &iscn->recycle[i];
             /* FIXME cap bucket fill */
             bucket->nsyms++;
             sym->next = bucket->head;
@@ -196,18 +194,14 @@ inline void zbar_image_scanner_recycle_i
 
     syms = img->syms;
     img->syms = NULL;
-    if(syms && recycle_syms(iscn, syms)) {
+    if(syms && recycle_syms(iscn, syms))
         STAT(img_syms_inuse);
-        syms = iscn->syms;
-    }
     else if(syms) {
         STAT(img_syms_recycle);
 
         /* select one set to resurrect, destroy the other */
-        if(iscn->syms) {
+        if(iscn->syms)
             _zbar_symbol_set_free(syms);
-            syms = iscn->syms;
-        }
         else
             iscn->syms = syms;
     }
@@ -219,12 +213,12 @@ _zbar_image_scanner_alloc_sym (zbar_imag
                                int datalen)
 {
     /* recycle old or alloc new symbol */
+    zbar_symbol_t *sym = NULL;
     int i;
     for(i = 0; i < RECYCLE_BUCKETS - 1; i++)
         if(datalen <= 1 << (i * 2))
             break;
 
-    zbar_symbol_t *sym = NULL;
     for(; i > 0; i--)
         if((sym = iscn->recycle[i].head)) {
             STAT(sym_recycle[i]);
@@ -246,6 +240,7 @@ _zbar_image_scanner_alloc_sym (zbar_imag
     sym->type = type;
     sym->quality = 1;
     sym->npts = 0;
+    sym->orient = ZBAR_ORIENT_UNKNOWN;
     sym->cache_count = 0;
     sym->time = iscn->time;
     assert(!sym->syms);
@@ -295,27 +290,33 @@ static inline void cache_sym (zbar_image
                               zbar_symbol_t *sym)
 {
     if(iscn->enable_cache) {
+        uint32_t age, near_thresh, far_thresh, dup;
         zbar_symbol_t *entry = cache_lookup(iscn, sym);
         if(!entry) {
             /* FIXME reuse sym */
             entry = _zbar_image_scanner_alloc_sym(iscn, sym->type,
                                                   sym->datalen + 1);
+            entry->configs = sym->configs;
+            entry->modifiers = sym->modifiers;
             memcpy(entry->data, sym->data, sym->datalen);
             entry->time = sym->time - CACHE_HYSTERESIS;
-            entry->cache_count = -CACHE_CONSISTENCY;
+            entry->cache_count = 0;
             /* add to cache */
             entry->next = iscn->cache;
             iscn->cache = entry;
         }
 
         /* consistency check and hysteresis */
-        uint32_t age = sym->time - entry->time;
+        age = sym->time - entry->time;
         entry->time = sym->time;
-        int near_thresh = (age < CACHE_PROXIMITY);
-        int far_thresh = (age >= CACHE_HYSTERESIS);
-        int dup = (entry->cache_count >= 0);
-        if((!dup && !near_thresh) || far_thresh)
-            entry->cache_count = -CACHE_CONSISTENCY;
+        near_thresh = (age < CACHE_PROXIMITY);
+        far_thresh = (age >= CACHE_HYSTERESIS);
+        dup = (entry->cache_count >= 0);
+        if((!dup && !near_thresh) || far_thresh) {
+            int type = sym->type;
+            int h = _zbar_get_symbol_hash(type);
+            entry->cache_count = -iscn->sym_configs[0][h];
+        }
         else if(dup || near_thresh)
             entry->cache_count++;
 
@@ -328,9 +329,10 @@ static inline void cache_sym (zbar_image
 void _zbar_image_scanner_add_sym(zbar_image_scanner_t *iscn,
                                  zbar_symbol_t *sym)
 {
+    zbar_symbol_set_t *syms;
     cache_sym(iscn, sym);
 
-    zbar_symbol_set_t *syms = iscn->syms;
+    syms = iscn->syms;
     if(sym->cache_count || !syms->tail) {
         sym->next = syms->head;
         syms->head = sym;
@@ -358,10 +360,12 @@ extern qr_finder_line *_zbar_decoder_get
 
 static inline void qr_handler (zbar_image_scanner_t *iscn)
 {
+    unsigned u;
+    int vert;
     qr_finder_line *line = _zbar_decoder_get_qr_finder_line(iscn->dcode);
     assert(line);
-    unsigned u = zbar_scanner_get_edge(iscn->scn, line->pos[0],
-                                       QR_FINDER_SUBPREC);
+    u = zbar_scanner_get_edge(iscn->scn, line->pos[0],
+                              QR_FINDER_SUBPREC);
     line->boffs = u - zbar_scanner_get_edge(iscn->scn, line->boffs,
                                             QR_FINDER_SUBPREC);
     line->len = zbar_scanner_get_edge(iscn->scn, line->len,
@@ -372,12 +376,12 @@ static inline void qr_handler (zbar_imag
 
     u = QR_FIXED(iscn->umin, 0) + iscn->du * u;
     if(iscn->du < 0) {
-        u -= line->len;
         int tmp = line->boffs;
         line->boffs = line->eoffs;
         line->eoffs = tmp;
+        u -= line->len;
     }
-    int vert = !iscn->dx;
+    vert = !iscn->dx;
     line->pos[vert] = u;
     line->pos[!vert] = QR_FIXED(iscn->v, 1);
 
@@ -389,10 +393,10 @@ static void symbol_handler (zbar_decoder
 {
     zbar_image_scanner_t *iscn = zbar_decoder_get_userdata(dcode);
     zbar_symbol_type_t type = zbar_decoder_get_type(dcode);
-    /* FIXME assert(type == ZBAR_PARTIAL) */
-    /* FIXME debug flag to save/display all PARTIALs */
-    if(type <= ZBAR_PARTIAL)
-        return;
+    int x = 0, y = 0, dir;
+    const char *data;
+    unsigned datalen;
+    zbar_symbol_t *sym;
 
 #ifdef ENABLE_QRCODE
     if(type == ZBAR_QRCODE) {
@@ -403,10 +407,6 @@ static void symbol_handler (zbar_decoder
     assert(type != ZBAR_QRCODE);
 #endif
 
-    const char *data = zbar_decoder_get_data(dcode);
-    unsigned datalen = zbar_decoder_get_data_length(dcode);
-
-    int x = 0, y = 0;
     if(TEST_CFG(iscn, ZBAR_CFG_POSITION)) {
         /* tmp position fixup */
         int w = zbar_scanner_get_width(iscn->scn);
@@ -421,13 +421,23 @@ static void symbol_handler (zbar_decoder
         }
     }
 
+    /* FIXME debug flag to save/display all PARTIALs */
+    if(type <= ZBAR_PARTIAL) {
+        zprintf(256, "partial symbol @(%d,%d)\n", x, y);
+        return;
+    }
+
+    data = zbar_decoder_get_data(dcode);
+    datalen = zbar_decoder_get_data_length(dcode);
+
     /* FIXME need better symbol matching */
-    zbar_symbol_t *sym;
     for(sym = iscn->syms->head; sym; sym = sym->next)
         if(sym->type == type &&
            sym->datalen == datalen &&
            !memcmp(sym->data, data, datalen)) {
             sym->quality++;
+            zprintf(224, "dup symbol @(%d,%d): dup %s: %.20s\n",
+                    x, y, zbar_get_symbol_name(type), data);
             if(TEST_CFG(iscn, ZBAR_CFG_POSITION))
                 /* add new point to existing set */
                 /* FIXME should be polygon */
@@ -436,12 +446,21 @@ static void symbol_handler (zbar_decoder
         }
 
     sym = _zbar_image_scanner_alloc_sym(iscn, type, datalen + 1);
+    sym->configs = zbar_decoder_get_configs(dcode, type);
+    sym->modifiers = zbar_decoder_get_modifiers(dcode);
     /* FIXME grab decoder buffer */
     memcpy(sym->data, data, datalen + 1);
 
     /* initialize first point */
-    if(TEST_CFG(iscn, ZBAR_CFG_POSITION))
+    if(TEST_CFG(iscn, ZBAR_CFG_POSITION)) {
+        zprintf(192, "new symbol @(%d,%d): %s: %.20s\n",
+                x, y, zbar_get_symbol_name(type), data);
         sym_add_point(sym, x, y);
+    }
+
+    dir = zbar_decoder_get_direction(dcode);
+    if(dir)
+        sym->orient = (iscn->dy != 0) + ((iscn->du ^ dir) & 2);
 
     _zbar_image_scanner_add_sym(iscn, sym);
 }
@@ -468,19 +487,24 @@ zbar_image_scanner_t *zbar_image_scanner
     CFG(iscn, ZBAR_CFG_X_DENSITY) = 1;
     CFG(iscn, ZBAR_CFG_Y_DENSITY) = 1;
     zbar_image_scanner_set_config(iscn, 0, ZBAR_CFG_POSITION, 1);
+    zbar_image_scanner_set_config(iscn, 0, ZBAR_CFG_UNCERTAINTY, 2);
+    zbar_image_scanner_set_config(iscn, ZBAR_QRCODE, ZBAR_CFG_UNCERTAINTY, 0);
+    zbar_image_scanner_set_config(iscn, ZBAR_CODE128, ZBAR_CFG_UNCERTAINTY, 0);
+    zbar_image_scanner_set_config(iscn, ZBAR_CODE93, ZBAR_CFG_UNCERTAINTY, 0);
+    zbar_image_scanner_set_config(iscn, ZBAR_CODE39, ZBAR_CFG_UNCERTAINTY, 0);
     return(iscn);
 }
 
 #ifndef NO_STATS
 static inline void dump_stats (const zbar_image_scanner_t *iscn)
 {
+    int i;
     zprintf(1, "symbol sets allocated   = %-4d\n", iscn->stat_syms_new);
     zprintf(1, "    scanner syms in use = %-4d\trecycled  = %-4d\n",
             iscn->stat_iscn_syms_inuse, iscn->stat_iscn_syms_recycle);
     zprintf(1, "    image syms in use   = %-4d\trecycled  = %-4d\n",
             iscn->stat_img_syms_inuse, iscn->stat_img_syms_recycle);
     zprintf(1, "symbols allocated       = %-4d\n", iscn->stat_sym_new);
-    int i;
     for(i = 0; i < RECYCLE_BUCKETS; i++)
         zprintf(1, "     recycled[%d]        = %-4d\n",
                 i, iscn->stat_sym_recycle[i]);
@@ -489,6 +513,7 @@ static inline void dump_stats (const zba
 
 void zbar_image_scanner_destroy (zbar_image_scanner_t *iscn)
 {
+    int i;
     dump_stats(iscn);
     if(iscn->syms) {
         if(iscn->syms->refcnt)
@@ -503,7 +528,6 @@ void zbar_image_scanner_destroy (zbar_im
     if(iscn->dcode)
         zbar_decoder_destroy(iscn->dcode);
     iscn->dcode = NULL;
-    int i;
     for(i = 0; i < RECYCLE_BUCKETS; i++) {
         zbar_symbol_t *sym, *next;
         for(sym = iscn->recycle[i].head; sym; sym = next) {
@@ -536,9 +560,24 @@ int zbar_image_scanner_set_config (zbar_
                                    zbar_config_t cfg,
                                    int val)
 {
-    if(cfg < ZBAR_CFG_POSITION)
+    if(cfg < ZBAR_CFG_UNCERTAINTY)
         return(zbar_decoder_set_config(iscn->dcode, sym, cfg, val));
 
+    if(cfg < ZBAR_CFG_POSITION) {
+        int c, i;
+        if(cfg > ZBAR_CFG_UNCERTAINTY)
+            return(1);
+        c = cfg - ZBAR_CFG_UNCERTAINTY;
+        if(sym > ZBAR_PARTIAL) {
+            i = _zbar_get_symbol_hash(sym);
+            iscn->sym_configs[c][i] = val;
+        }
+        else
+            for(i = 0; i < NUM_SYMS; i++)
+                iscn->sym_configs[c][i] = val;
+        return(0);
+    }
+
     if(sym > ZBAR_PARTIAL)
         return(1);
 
@@ -591,30 +630,28 @@ static inline void quiet_border (zbar_im
 #define movedelta(dx, dy) do {                  \
         x += (dx);                              \
         y += (dy);                              \
-        p += (dx) + ((intptr_t)(dy) * w);       \
+        p += (dx) + ((uintptr_t)(dy) * w);       \
     } while(0);
 
 int zbar_scan_image (zbar_image_scanner_t *iscn,
                      zbar_image_t *img)
 {
+    zbar_symbol_set_t *syms;
+    const uint8_t *data;
+    zbar_scanner_t *scn = iscn->scn;
+    unsigned w, h, cx1, cy1;
+    int density;
+
     /* timestamp image
      * FIXME prefer video timestamp
      */
-#if _POSIX_TIMERS > 0
-    struct timespec abstime;
-    clock_gettime(CLOCK_REALTIME, &abstime);
-    iscn->time = (abstime.tv_sec * 1000) + ((abstime.tv_nsec / 500000) + 1) / 2;
-#else
-    struct timeval abstime;
-    gettimeofday(&abstime, NULL);
-    iscn->time = (abstime.tv_sec * 1000) + ((abstime.tv_usec / 500) + 1) / 2;
-#endif
+    iscn->time = _zbar_timer_now();
 
 #ifdef ENABLE_QRCODE
     _zbar_qr_reset(iscn->qr);
 #endif
 
-    /* get grayscale image, convert if necessary */
+    /* image must be in grayscale format */
     if(img->format != fourcc('Y','8','0','0') &&
        img->format != fourcc('G','R','E','Y'))
         return(-1);
@@ -622,7 +659,7 @@ int zbar_scan_image (zbar_image_scanner_
 
     /* recycle previous scanner and image results */
     zbar_image_scanner_recycle_image(iscn, img);
-    zbar_symbol_set_t *syms = iscn->syms;
+    syms = iscn->syms;
     if(!syms) {
         syms = iscn->syms = _zbar_symbol_set_create();
         STAT(syms_new);
@@ -632,37 +669,43 @@ int zbar_scan_image (zbar_image_scanner_
         zbar_symbol_set_ref(syms, 2);
     img->syms = syms;
 
-    unsigned w = img->width;
-    unsigned h = img->height;
-    const uint8_t *data = img->data;
+    w = img->width;
+    h = img->height;
+    cx1 = img->crop_x + img->crop_w;
+    assert(cx1 <= w);
+    cy1 = img->crop_y + img->crop_h;
+    assert(cy1 <= h);
+    data = img->data;
 
     zbar_image_write_png(img, "debug.png");
     svg_open("debug.svg", 0, 0, w, h);
     svg_image("debug.png", w, h);
 
-    zbar_scanner_t *scn = iscn->scn;
+    zbar_scanner_new_scan(scn);
 
-    int density = CFG(iscn, ZBAR_CFG_Y_DENSITY);
+    density = CFG(iscn, ZBAR_CFG_Y_DENSITY);
     if(density > 0) {
-        svg_group_start("scanner", 0, 1, 1, 0, 0);
         const uint8_t *p = data;
         int x = 0, y = 0;
+
+        int border = (((img->crop_h - 1) % density) + 1) / 2;
+        if(border > img->crop_h / 2)
+            border = img->crop_h / 2;
+        border += img->crop_y;
+        assert(border <= h);
+        svg_group_start("scanner", 0, 1, 1, 0, 0);
         iscn->dy = 0;
 
-        int border = (((h - 1) % density) + 1) / 2;
-        if(border > h / 2)
-            border = h / 2;
-        movedelta(0, border);
+        movedelta(img->crop_x, border);
         iscn->v = y;
 
-        zbar_scanner_new_scan(scn);
-
-        while(y < h) {
+        while(y < cy1) {
+            int cx0 = img->crop_x;;
             zprintf(128, "img_x+: %04d,%04d @%p\n", x, y, p);
             svg_path_start("vedge", 1. / 32, 0, y + 0.5);
             iscn->dx = iscn->du = 1;
-            iscn->umin = 0;
-            while(x < w) {
+            iscn->umin = cx0;
+            while(x < cx1) {
                 uint8_t d = *p;
                 movedelta(1, 0);
                 zbar_scan_y(scn, d);
@@ -673,14 +716,14 @@ int zbar_scan_image (zbar_image_scanner_
 
             movedelta(-1, density);
             iscn->v = y;
-            if(y >= h)
+            if(y >= cy1)
                 break;
 
             zprintf(128, "img_x-: %04d,%04d @%p\n", x, y, p);
             svg_path_start("vedge", -1. / 32, w, y + 0.5);
             iscn->dx = iscn->du = -1;
-            iscn->umin = w;
-            while(x >= 0) {
+            iscn->umin = cx1;
+            while(x >= cx0) {
                 uint8_t d = *p;
                 movedelta(-1, 0);
                 zbar_scan_y(scn, d);
@@ -698,22 +741,25 @@ int zbar_scan_image (zbar_image_scanner_
 
     density = CFG(iscn, ZBAR_CFG_X_DENSITY);
     if(density > 0) {
-        svg_group_start("scanner", 90, 1, -1, 0, 0);
         const uint8_t *p = data;
         int x = 0, y = 0;
 
-        int border = (((w - 1) % density) + 1) / 2;
-        if(border > w / 2)
-            border = w / 2;
-        movedelta(border, 0);
+        int border = (((img->crop_w - 1) % density) + 1) / 2;
+        if(border > img->crop_w / 2)
+            border = img->crop_w / 2;
+        border += img->crop_x;
+        assert(border <= w);
+        svg_group_start("scanner", 90, 1, -1, 0, 0);
+        movedelta(border, img->crop_y);
         iscn->v = x;
 
-        while(x < w) {
+        while(x < cx1) {
+            int cy0 = img->crop_y;
             zprintf(128, "img_y+: %04d,%04d @%p\n", x, y, p);
             svg_path_start("vedge", 1. / 32, 0, x + 0.5);
             iscn->dy = iscn->du = 1;
-            iscn->umin = 0;
-            while(y < h) {
+            iscn->umin = cy0;
+            while(y < cy1) {
                 uint8_t d = *p;
                 movedelta(0, 1);
                 zbar_scan_y(scn, d);
@@ -724,14 +770,14 @@ int zbar_scan_image (zbar_image_scanner_
 
             movedelta(density, -1);
             iscn->v = x;
-            if(x >= w)
+            if(x >= cx1)
                 break;
 
             zprintf(128, "img_y-: %04d,%04d @%p\n", x, y, p);
             svg_path_start("vedge", -1. / 32, h, x + 0.5);
             iscn->dy = iscn->du = -1;
-            iscn->umin = h;
-            while(y >= 0) {
+            iscn->umin = cy1;
+            while(y >= cy0) {
                 uint8_t d = *p;
                 movedelta(0, -1);
                 zbar_scan_y(scn, d);
@@ -757,8 +803,9 @@ int zbar_scan_image (zbar_image_scanner_
        (density == 1 || CFG(iscn, ZBAR_CFG_Y_DENSITY) == 1)) {
         zbar_symbol_t **symp = &syms->head, *sym;
         while((sym = *symp)) {
-            if(sym->type < ZBAR_I25 && sym->type > ZBAR_PARTIAL &&
-               sym->quality < 3) {
+            if(((sym->type < ZBAR_I25 && sym->type > ZBAR_PARTIAL) ||
+                sym->type == ZBAR_DATABAR || sym->type == ZBAR_DATABAR_EXP) &&
+               sym->quality < 4) {
                 /* recycle */
                 *symp = sym->next;
                 syms->nsyms--;
diff --git a/zbar/jpeg.c b/zbar/jpeg.c
--- a/zbar/jpeg.c
+++ b/zbar/jpeg.c
@@ -195,10 +195,16 @@ void _zbar_convert_jpeg_to_y (zbar_image
     jpeg_start_decompress(cinfo);
 
     /* adjust dst image parameters to match(?) decompressor */
-    if(dst->width < cinfo->output_width)
+    if(dst->width < cinfo->output_width) {
         dst->width = cinfo->output_width;
-    if(dst->height < cinfo->output_height)
+        if(dst->crop_x + dst->crop_w > dst->width)
+            dst->crop_w = dst->width - dst->crop_x;
+    }
+    if(dst->height < cinfo->output_height) {
         dst->height = cinfo->output_height;
+        if(dst->crop_y + dst->crop_h > dst->height)
+            dst->crop_h = dst->height - dst->crop_y;
+    }
     unsigned long datalen = (cinfo->output_width *
                              cinfo->output_height *
                              cinfo->out_color_components);
diff --git a/zbar/processor.c b/zbar/processor.c
--- a/zbar/processor.c
+++ b/zbar/processor.c
@@ -1,5 +1,5 @@
 /*------------------------------------------------------------------------
- *  Copyright 2007-2009 (c) Jeff Brown <spadix@users.sourceforge.net>
+ *  Copyright 2007-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
  *
  *  This file is part of the ZBar Bar Code Reader.
  *
@@ -95,11 +95,12 @@ int _zbar_process_image (zbar_processor_
             while(sym) {
                 zbar_symbol_type_t type = zbar_symbol_get_type(sym);
                 int count = zbar_symbol_get_count(sym);
-                zprintf(8, "%s%s: %s (%d pts) (q=%d) (%s)\n",
+                zprintf(8, "%s%s: %s (%d pts) (dir=%d) (q=%d) (%s)\n",
                         zbar_get_symbol_name(type),
                         zbar_get_addon_name(type),
                         zbar_symbol_get_data(sym),
                         zbar_symbol_get_loc_size(sym),
+                        zbar_symbol_get_orientation(sym),
                         zbar_symbol_get_quality(sym),
                         (count < 0) ? "uncertain" :
                         (count > 0) ? "duplicate" : "new");
@@ -288,6 +289,10 @@ void zbar_processor_destroy (zbar_proces
 {
     zbar_processor_init(proc, NULL, 0);
 
+    if(proc->syms) {
+        zbar_symbol_set_ref(proc->syms, -1);
+        proc->syms = NULL;
+    }
     if(proc->scanner) {
         zbar_image_scanner_destroy(proc->scanner);
         proc->scanner = NULL;
diff --git a/zbar/qrcode/qrdec.c b/zbar/qrcode/qrdec.c
--- a/zbar/qrcode/qrdec.c
+++ b/zbar/qrcode/qrdec.c
@@ -3,6 +3,7 @@
    GNU Lesser General Public License as published by the Free Software
    Foundation; either version 2.1 of the License, or (at your option) any later
    version.*/
+#include <config.h>
 #include <stdlib.h>
 #include <limits.h>
 #include <string.h>
@@ -2577,8 +2578,8 @@ static inline void qr_svg_points(const c
                                  qr_point *p,
                                  int n)
 {
+    int i;
     svg_path_start(cls, 1, 0, 0);
-    int i;
     for(i = 0; i < n; i++, p++)
         svg_path_moveto(SVG_ABS, p[0][0], p[0][1]);
     svg_path_end();
@@ -3913,7 +3914,7 @@ int _zbar_qr_decode (qr_reader *reader,
                      zbar_image_scanner_t *iscn,
                      zbar_image_t *img)
 {
-    int nqrdata = 0;
+    int nqrdata = 0, ncenters;
     qr_finder_edge_pt *edge_pts = NULL;
     qr_finder_center *centers = NULL;
 
@@ -3923,7 +3924,7 @@ int _zbar_qr_decode (qr_reader *reader,
 
     svg_group_start("finder", 0, 1. / (1 << QR_FINDER_SUBPREC), 0, 0, 0);
 
-    int ncenters = qr_finder_centers_locate(&centers, &edge_pts, reader, 0, 0);
+    ncenters = qr_finder_centers_locate(&centers, &edge_pts, reader, 0, 0);
 
     zprintf(14, "%dx%d finders, %d centers:\n",
             reader->finder_lines[0].nlines,
diff --git a/zbar/qrcode/qrdectxt.c b/zbar/qrcode/qrdectxt.c
--- a/zbar/qrcode/qrdectxt.c
+++ b/zbar/qrcode/qrdectxt.c
@@ -1,8 +1,9 @@
-/*Copyright (C) 2008-2009  Timothy B. Terriberry (tterribe@xiph.org)
+/*Copyright (C) 2008-2010  Timothy B. Terriberry (tterribe@xiph.org)
   You can redistribute this library and/or modify it under the terms of the
    GNU Lesser General Public License as published by the Free Software
    Foundation; either version 2.1 of the License, or (at your option) any later
    version.*/
+#include <config.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
@@ -50,12 +51,10 @@ int qr_code_data_list_extract_text(const
   const qr_code_data  *qrdata;
   int                  nqrdata;
   unsigned char       *mark;
-  char               **text;
   int                  ntext;
   int                  i;
   qrdata=_qrlist->qrdata;
   nqrdata=_qrlist->nqrdata;
-  text=(char **)malloc(nqrdata*sizeof(*text));
   mark=(unsigned char *)calloc(nqrdata,sizeof(*mark));
   ntext=0;
   /*This is the encoding the standard says is the default.*/
@@ -79,6 +78,10 @@ int qr_code_data_list_extract_text(const
     int                       err;
     int                       j;
     int                       k;
+    zbar_symbol_t *syms = NULL, **sym = &syms;
+    qr_point dir;
+    int horiz;
+
     /*Step 0: Collect the other QR codes belonging to this S-A group.*/
     if(qrdata[i].sa_size){
       unsigned sa_parity;
@@ -138,7 +141,6 @@ int qr_code_data_list_extract_text(const
     enc_list[2]=utf8_cd;
     eci_cd=(iconv_t)-1;
     err=0;
-    zbar_symbol_t *syms = NULL, **sym = &syms;
     for(j = 0; j < sa_size && !err; j++, sym = &(*sym)->next) {
       *sym = _zbar_image_scanner_alloc_sym(iscn, ZBAR_QRCODE, 0);
       (*sym)->datalen = sa_ntext;
@@ -167,6 +169,14 @@ int qr_code_data_list_extract_text(const
       sym_add_point(*sym, qrdataj->bbox[3][0], qrdataj->bbox[3][1]);
       sym_add_point(*sym, qrdataj->bbox[1][0], qrdataj->bbox[1][1]);
 
+      /* approx symbol "up" direction */
+      dir[0] = (qrdataj->bbox[0][0] - qrdataj->bbox[2][0] +
+                qrdataj->bbox[1][0] - qrdataj->bbox[3][0]);
+      dir[1] = (qrdataj->bbox[2][1] - qrdataj->bbox[0][1] +
+                qrdataj->bbox[3][1] - qrdataj->bbox[1][1]);
+      horiz = abs(dir[0]) > abs(dir[1]);
+      (*sym)->orient = horiz + 2 * (dir[1 - horiz] < 0);
+
       for(k=0;k<qrdataj->nentries&&!err;k++){
         size_t              inleft;
         size_t              outleft;
@@ -331,26 +341,27 @@ int qr_code_data_list_extract_text(const
     }
     if(eci_cd!=(iconv_t)-1)iconv_close(eci_cd);
     if(!err){
+      zbar_symbol_t *sa_sym;
       sa_text[sa_ntext++]='\0';
       if(sa_ctext+1>sa_ntext){
         sa_text=(char *)realloc(sa_text,sa_ntext*sizeof(*sa_text));
       }
 
-      zbar_symbol_t *sa_sym;
       if(sa_size == 1)
           sa_sym = syms;
       else {
+          /* cheap out w/axis aligned bbox for now */
+          int xmin = img->width, xmax = -2;
+          int ymin = img->height, ymax = -2;
+
           /* create "virtual" container symbol for composite result */
           sa_sym = _zbar_image_scanner_alloc_sym(iscn, ZBAR_QRCODE, 0);
           sa_sym->syms = _zbar_symbol_set_create();
           sa_sym->syms->head = syms;
 
-          /* cheap out w/axis aligned bbox for now */
-          int xmin = img->width, xmax = -2;
-          int ymin = img->height, ymax = -2;
-
           /* fixup data references */
           for(; syms; syms = syms->next) {
+              int next;
               _zbar_symbol_refcnt(syms, 1);
               if(syms->type == ZBAR_PARTIAL)
                   sa_sym->type = ZBAR_PARTIAL;
@@ -364,7 +375,7 @@ int qr_code_data_list_extract_text(const
                       if(ymax <= u) ymax = u + 1;
                   }
               syms->data = sa_text + syms->datalen;
-              int next = (syms->next) ? syms->next->datalen : sa_ntext;
+              next = (syms->next) ? syms->next->datalen : sa_ntext;
               assert(next > syms->datalen);
               syms->datalen = next - syms->datalen - 1;
           }
diff --git a/zbar/refcnt.c b/zbar/refcnt.c
--- a/zbar/refcnt.c
+++ b/zbar/refcnt.c
@@ -23,7 +23,7 @@
 
 #include "refcnt.h"
 
-#ifdef HAVE_LIBPTHREAD
+#if !defined(_WIN32) && !defined(TARGET_OS_MAC) && defined(HAVE_LIBPTHREAD)
 
 pthread_once_t initialized = PTHREAD_ONCE_INIT;
 pthread_mutex_t _zbar_reflock;
diff --git a/zbar/refcnt.h b/zbar/refcnt.h
--- a/zbar/refcnt.h
+++ b/zbar/refcnt.h
@@ -1,5 +1,5 @@
 /*------------------------------------------------------------------------
- *  Copyright 2007-2009 (c) Jeff Brown <spadix@users.sourceforge.net>
+ *  Copyright 2007-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
  *
  *  This file is part of the ZBar Bar Code Reader.
  *
@@ -29,7 +29,7 @@
 #if defined(_WIN32)
 # include <windows.h>
 
-typedef volatile LONG refcnt_t;  /* FIXME where did volatile come from? */
+typedef LONG refcnt_t;
 
 static inline int _zbar_refcnt (refcnt_t *cnt,
                                 int delta)
@@ -45,6 +45,18 @@ static inline int _zbar_refcnt (refcnt_t
     return(rc);
 }
 
+#elif defined(TARGET_OS_MAC)
+# include <libkern/OSAtomic.h>
+
+typedef int32_t refcnt_t;
+
+static inline int _zbar_refcnt (refcnt_t *cnt,
+                                int delta)
+{
+    int rc = OSAtomicAdd32Barrier(delta, cnt);
+    assert(rc >= 0);
+    return(rc);
+}
 
 #elif defined(HAVE_LIBPTHREAD)
 # include <pthread.h>
diff --git a/zbar/scanner.c b/zbar/scanner.c
--- a/zbar/scanner.c
+++ b/zbar/scanner.c
@@ -1,5 +1,5 @@
 /*------------------------------------------------------------------------
- *  Copyright 2007-2009 (c) Jeff Brown <spadix@users.sourceforge.net>
+ *  Copyright 2007-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
  *
  *  This file is part of the ZBar Bar Code Reader.
  *
@@ -23,6 +23,7 @@
 
 #include <config.h>
 #include <stdlib.h>     /* malloc, free, abs */
+#include <stddef.h>
 #include <string.h>     /* memset */
 
 #include <zbar.h>
@@ -91,7 +92,7 @@ void zbar_scanner_destroy (zbar_scanner_
 
 zbar_symbol_type_t zbar_scanner_reset (zbar_scanner_t *scn)
 {
-    memset(&scn->x, 0, sizeof(zbar_scanner_t) + (void*)scn - (void*)&scn->x);
+    memset(&scn->x, 0, sizeof(zbar_scanner_t) - offsetof(zbar_scanner_t, x));
     scn->y1_thresh = scn->y1_min_thresh;
     if(scn->decoder)
         zbar_decoder_reset(scn->decoder);
@@ -125,14 +126,15 @@ zbar_color_t zbar_scanner_get_color (con
 static inline unsigned calc_thresh (zbar_scanner_t *scn)
 {
     /* threshold 1st to improve noise rejection */
-    unsigned thresh = scn->y1_thresh;
+    unsigned dx, thresh = scn->y1_thresh;
+    unsigned long t;
     if((thresh <= scn->y1_min_thresh) || !scn->width) {
         dprintf(1, " tmin=%d", scn->y1_min_thresh);
         return(scn->y1_min_thresh);
     }
     /* slowly return threshold to min */
-    unsigned dx = (scn->x << ZBAR_FIXED) - scn->last_edge;
-    unsigned long t = thresh * dx;
+    dx = (scn->x << ZBAR_FIXED) - scn->last_edge;
+    t = thresh * dx;
     t /= scn->width;
     t /= ZBAR_SCANNER_THRESH_FADE;
     dprintf(1, " thr=%d t=%ld x=%d last=%d.%d (%d)",
@@ -174,14 +176,15 @@ static inline zbar_symbol_type_t process
 
 inline zbar_symbol_type_t zbar_scanner_flush (zbar_scanner_t *scn)
 {
+    unsigned x;
     if(!scn->y1_sign)
         return(ZBAR_NONE);
 
-    unsigned x = (scn->x << ZBAR_FIXED) + ROUND;
+    x = (scn->x << ZBAR_FIXED) + ROUND;
 
     if(scn->cur_edge != x || scn->y1_sign > 0) {
+        zbar_symbol_type_t edge = process_edge(scn, -scn->y1_sign);
         dprintf(1, "flush0:");
-        zbar_symbol_type_t edge = process_edge(scn, -scn->y1_sign);
         scn->cur_edge = x;
         scn->y1_sign = -scn->y1_sign;
         return(edge);
@@ -203,7 +206,7 @@ zbar_symbol_type_t zbar_scanner_new_scan
     }
 
     /* reset scanner and associated decoder */
-    memset(&scn->x, 0, sizeof(zbar_scanner_t) + (void*)scn - (void*)&scn->x);
+    memset(&scn->x, 0, sizeof(zbar_scanner_t) - offsetof(zbar_scanner_t, x));
     scn->y1_thresh = scn->y1_min_thresh;
     if(scn->decoder)
         zbar_decoder_new_scan(scn->decoder);
@@ -218,6 +221,8 @@ zbar_symbol_type_t zbar_scan_y (zbar_sca
     register int x = scn->x;
     register int y0_1 = scn->y0[(x - 1) & 3];
     register int y0_0 = y0_1;
+    register int y0_2, y0_3, y1_1, y2_1, y2_2;
+    zbar_symbol_type_t edge;
     if(x) {
         /* update weighted moving average */
         y0_0 += ((int)((y - y0_1) * EWMA_WEIGHT)) >> ZBAR_FIXED;
@@ -225,10 +230,10 @@ zbar_symbol_type_t zbar_scan_y (zbar_sca
     }
     else
         y0_0 = y0_1 = scn->y0[0] = scn->y0[1] = scn->y0[2] = scn->y0[3] = y;
-    register int y0_2 = scn->y0[(x - 2) & 3];
-    register int y0_3 = scn->y0[(x - 3) & 3];
+    y0_2 = scn->y0[(x - 2) & 3];
+    y0_3 = scn->y0[(x - 3) & 3];
     /* 1st differential @ x-1 */
-    register int y1_1 = y0_1 - y0_2;
+    y1_1 = y0_1 - y0_2;
     {
         register int y1_2 = y0_2 - y0_3;
         if((abs(y1_1) < abs(y1_2)) &&
@@ -237,13 +242,13 @@ zbar_symbol_type_t zbar_scan_y (zbar_sca
     }
 
     /* 2nd differentials @ x-1 & x-2 */
-    register int y2_1 = y0_0 - (y0_1 * 2) + y0_2;
-    register int y2_2 = y0_1 - (y0_2 * 2) + y0_3;
+    y2_1 = y0_0 - (y0_1 * 2) + y0_2;
+    y2_2 = y0_1 - (y0_2 * 2) + y0_3;
 
     dprintf(1, "scan: x=%d y=%d y0=%d y1=%d y2=%d",
             x, y, y0_1, y1_1, y2_1);
 
-    zbar_symbol_type_t edge = ZBAR_NONE;
+    edge = ZBAR_NONE;
     /* 2nd zero-crossing is 1st local min/max - could be edge */
     if((!y2_1 ||
         ((y2_1 > 0) ? y2_2 < 0 : y2_2 > 0)) &&
@@ -256,6 +261,7 @@ zbar_symbol_type_t zbar_scan_y (zbar_sca
             edge = process_edge(scn, y1_1);
 
         if(y1_rev || (abs(scn->y1_sign) < abs(y1_1))) {
+            int d;
             scn->y1_sign = y1_1;
 
             /* adaptive thresholding */
@@ -266,7 +272,7 @@ zbar_symbol_type_t zbar_scan_y (zbar_sca
                 scn->y1_thresh = scn->y1_min_thresh;
 
             /* update current edge */
-            int d = y2_1 - y2_2;
+            d = y2_1 - y2_2;
             scn->cur_edge = 1 << ZBAR_FIXED;
             if(!d)
                 scn->cur_edge >>= 1;
@@ -298,14 +304,14 @@ void zbar_scanner_get_state (const zbar_
     register int y0_0 = scn->y0[(scn->x - 1) & 3];
     register int y0_1 = scn->y0[(scn->x - 2) & 3];
     register int y0_2 = scn->y0[(scn->x - 3) & 3];
+    zbar_scanner_t *mut_scn;
     if(x) *x = scn->x - 1;
-    if(cur_edge) *cur_edge = scn->cur_edge;
     if(last_edge) *last_edge = scn->last_edge;
     if(y0) *y0 = y0_1;
     if(y1) *y1 = y0_1 - y0_2;
     if(y2) *y2 = y0_0 - (y0_1 * 2) + y0_2;
     /* NB not quite accurate (uses updated x) */
-    zbar_scanner_t *mut_scn = (zbar_scanner_t*)scn;
+    mut_scn = (zbar_scanner_t*)scn;
     if(y1_thresh) *y1_thresh = calc_thresh(mut_scn);
     dprintf(1, "\n");
 }
diff --git a/zbar/symbol.c b/zbar/symbol.c
--- a/zbar/symbol.c
+++ b/zbar/symbol.c
@@ -1,5 +1,5 @@
 /*------------------------------------------------------------------------
- *  Copyright 2007-2009 (c) Jeff Brown <spadix@users.sourceforge.net>
+ *  Copyright 2007-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
  *
  *  This file is part of the ZBar Bar Code Reader.
  *
@@ -39,7 +39,10 @@ const char *zbar_get_symbol_name (zbar_s
     case ZBAR_EAN13: return("EAN-13");
     case ZBAR_ISBN13: return("ISBN-13");
     case ZBAR_I25: return("I2/5");
+    case ZBAR_DATABAR: return("DataBar");
+    case ZBAR_DATABAR_EXP: return("DataBar-Exp");
     case ZBAR_CODE39: return("CODE-39");
+    case ZBAR_CODE93: return("CODE-93");
     case ZBAR_CODE128: return("CODE-128");
     case ZBAR_PDF417: return("PDF417");
     case ZBAR_QRCODE: return("QR-Code");
@@ -56,6 +59,58 @@ const char *zbar_get_addon_name (zbar_sy
     }
 }
 
+const char *zbar_get_config_name (zbar_config_t cfg)
+{
+    switch(cfg) {
+    case ZBAR_CFG_ENABLE: return("ENABLE");
+    case ZBAR_CFG_ADD_CHECK: return("ADD_CHECK");
+    case ZBAR_CFG_EMIT_CHECK: return("EMIT_CHECK");
+    case ZBAR_CFG_ASCII: return("ASCII");
+    case ZBAR_CFG_MIN_LEN: return("MIN_LEN");
+    case ZBAR_CFG_MAX_LEN: return("MAX_LEN");
+    case ZBAR_CFG_UNCERTAINTY: return("UNCERTAINTY");
+    case ZBAR_CFG_POSITION: return("POSITION");
+    case ZBAR_CFG_X_DENSITY: return("X_DENSITY");
+    case ZBAR_CFG_Y_DENSITY: return("Y_DENSITY");
+    default: return("");
+    }
+}
+
+const char *zbar_get_modifier_name (zbar_modifier_t mod)
+{
+    switch(mod) {
+    case ZBAR_MOD_GS1: return("GS1");
+    case ZBAR_MOD_AIM: return("AIM");
+    default: return("");
+    }
+}
+
+const char *zbar_get_orientation_name (zbar_orientation_t orient)
+{
+    switch(orient) {
+    case ZBAR_ORIENT_UP: return("UP");
+    case ZBAR_ORIENT_RIGHT: return("RIGHT");
+    case ZBAR_ORIENT_DOWN: return("DOWN");
+    case ZBAR_ORIENT_LEFT: return("LEFT");
+    default: return("UNKNOWN");
+    }
+}
+
+int _zbar_get_symbol_hash (zbar_symbol_type_t sym)
+{
+    static const signed char hash[0x20] = {
+        0x00, 0x01, 0x0d, 0x0e,   -1,   -1,   -1, 0x09,
+        0x05, 0x06, 0x08,   -1, 0x04, 0x03, 0x07,   -1,
+          -1,   -1,   -1,   -1,   -1,   -1,   -1, 0x02,
+          -1, 0x00, 0x0f, 0x0c, 0x0b, 0x00, 0x0a, 0x00,
+    };
+    int g0 = hash[sym & 0x1f];
+    int g1 = hash[~(sym >> 4) & 0x1f];
+    assert(g0 >= 0 && g1 >= 0);
+    if(g0 < 0 || g1 < 0)
+        return(0);
+    return((g0 + g1) & 0x1f);
+}
 
 void _zbar_symbol_free (zbar_symbol_t *sym)
 {
@@ -82,6 +137,16 @@ zbar_symbol_type_t zbar_symbol_get_type 
     return(sym->type);
 }
 
+unsigned int zbar_symbol_get_configs (const zbar_symbol_t *sym)
+{
+    return(sym->configs);
+}
+
+unsigned int zbar_symbol_get_modifiers (const zbar_symbol_t *sym)
+{
+    return(sym->modifiers);
+}
+
 const char *zbar_symbol_get_data (const zbar_symbol_t *sym)
 {
     return(sym->data);
@@ -125,6 +190,11 @@ int zbar_symbol_get_loc_y (const zbar_sy
         return(-1);
 }
 
+zbar_orientation_t zbar_symbol_get_orientation (const zbar_symbol_t *sym)
+{
+    return(sym->orient);
+}
+
 const zbar_symbol_t *zbar_symbol_next (const zbar_symbol_t *sym)
 {
     return((sym) ? sym->next : NULL);
@@ -142,26 +212,100 @@ const zbar_symbol_t *zbar_symbol_first_c
 }
 
 
-static const char *xmlfmt[] = {
-    "<symbol type='%s' quality='%d'",
-    " count='%d'",
-    "><data><![CDATA[",
-    "]]></data></symbol>",
+unsigned base64_encode (char *dst,
+                        const char *src,
+                        unsigned srclen)
+{
+    static const char alphabet[] =
+        "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
+    char *start = dst;
+    int nline = 19;
+    for(; srclen; srclen -= 3) {
+        unsigned int buf = *(src++) << 16;
+        if(srclen > 1) buf |= *(src++) << 8;
+        if(srclen > 2) buf |= *(src++);
+        *(dst++) = alphabet[(buf >> 18) & 0x3f];
+        *(dst++) = alphabet[(buf >> 12) & 0x3f];
+        *(dst++) = (srclen > 1) ? alphabet[(buf >> 6) & 0x3f] : '=';
+        *(dst++) = (srclen > 2) ? alphabet[buf & 0x3f] : '=';
+        if(srclen < 3) break;
+        if(!--nline) { *(dst++) = '\n'; nline = 19; }
+    }
+    *(dst++) = '\n';
+    *(dst++) = '\0';
+    return(dst - start - 1);
+}
+
+enum {
+    TMPL_START,
+    TMPL_MOD_START, TMPL_MOD_ITEM, TMPL_MOD_END,
+    TMPL_COUNT,
+    TMPL_DATA_START, TMPL_FORMAT, TMPL_CDATA,
+    TMPL_NL,
+    TMPL_END,
 };
 
 /* FIXME suspect... */
+#define MAX_STATIC 256
+#define MAX_MOD (5 * ZBAR_MOD_NUM)
+#define MAX_CFG (10 * ZBAR_CFG_NUM)
 #define MAX_INT_DIGITS 10
 
+#define TMPL_COPY(t) do {             \
+        static const char *_st = (t); \
+        i = strlen(_st);              \
+        memcpy(*buf + n, _st, i + 1); \
+        n += i;                       \
+        assert(n <= maxlen);          \
+    } while(0)
+
+#define TMPL_FMT(t, ...) do {                                 \
+        static const char *_st = (t);                         \
+        i = snprintf(*buf + n, maxlen - n, _st, __VA_ARGS__); \
+        assert(i > 0);                                        \
+        n += i;                                               \
+        assert(n <= maxlen);                                  \
+    } while(0)
+
 char *zbar_symbol_xml (const zbar_symbol_t *sym,
                        char **buf,
                        unsigned *len)
 {
+    unsigned int datalen, maxlen;
+    int i, n = 0;
+
     const char *type = zbar_get_symbol_name(sym->type);
-    /* FIXME binary data */
-    unsigned datalen = strlen(sym->data);
-    unsigned maxlen = (strlen(xmlfmt[0]) + strlen(xmlfmt[1]) +
-                       strlen(xmlfmt[2]) + strlen(xmlfmt[3]) +
-                       strlen(type) + datalen + MAX_INT_DIGITS + 1);
+    const char *orient = zbar_get_orientation_name(sym->orient);
+
+    /* check for binary data */
+    unsigned char *data = (unsigned char*)sym->data;
+    char binary = ((data[0] == 0xff && data[1] == 0xfe) ||
+                   (data[0] == 0xfe && data[1] == 0xff) ||
+                   !strncmp(sym->data, "<?xml", 5));
+    for(i = 0; !binary && i < sym->datalen; i++) {
+        unsigned char c = sym->data[i];
+        binary = ((c < 0x20 && ((~0x00002600 >> c) & 1)) ||
+                  (c >= 0x7f && c < 0xa0) ||
+                  (c == ']' && i + 2 < sym->datalen &&
+                   sym->data[i + 1] == ']' &&
+                   sym->data[i + 2] == '>'));
+    }
+
+    datalen = strlen(sym->data);
+    if(binary)
+        datalen = (sym->datalen + 2) / 3 * 4 + sym->datalen / 57 + 3;
+
+    maxlen = (MAX_STATIC + strlen(type) + strlen(orient) +
+              datalen + MAX_INT_DIGITS + 1);
+    unsigned int mods = sym->modifiers;
+    if(mods)
+        maxlen += MAX_MOD;
+    unsigned int cfgs = sym->configs & ~(1 << ZBAR_CFG_ENABLE);
+    if(cfgs)
+        maxlen += MAX_CFG;
+    if(binary)
+        maxlen += MAX_INT_DIGITS;
+
     if(!*buf || (*len < maxlen)) {
         if(*buf)
             free(*buf);
@@ -170,32 +314,50 @@ char *zbar_symbol_xml (const zbar_symbol
         *len = maxlen;
     }
 
-    int n = snprintf(*buf, maxlen, xmlfmt[0], type, sym->quality);
-    assert(n > 0);
+    TMPL_FMT("<symbol type='%s' quality='%d' orientation='%s'",
+             type, sym->quality, orient);
+
+    if(mods) {
+        int j;
+        TMPL_COPY(" modifiers='");
+        for(j = 0; mods && j < ZBAR_MOD_NUM; j++, mods >>= 1)
+            if(mods & 1)
+                TMPL_FMT("%s ", zbar_get_modifier_name(j));
+        /* cleanup trailing space */
+        n--;
+        TMPL_COPY("'");
+    }
+
+    if(cfgs) {
+        int j;
+        TMPL_COPY(" configs='");
+        for(j = 0; cfgs && j < ZBAR_CFG_NUM; j++, cfgs >>= 1)
+            if(cfgs & 1)
+                TMPL_FMT("%s ", zbar_get_config_name(j));
+        /* cleanup trailing space */
+        n--;
+        TMPL_COPY("'");
+    }
+
+    if(sym->cache_count)
+        TMPL_FMT(" count='%d'", sym->cache_count);
+
+    TMPL_COPY("><data");
+    if(binary)
+        TMPL_FMT(" format='base64' length='%d'", sym->datalen);
+    TMPL_COPY("><![CDATA[");
+
+    if(!binary) {
+        memcpy(*buf + n, sym->data, sym->datalen + 1);
+        n += sym->datalen;
+    }
+    else {
+        TMPL_COPY("\n");
+        n += base64_encode(*buf + n, sym->data, sym->datalen);
+    }
     assert(n <= maxlen);
 
-    if(sym->cache_count) {
-        int i = snprintf(*buf + n, maxlen - n, xmlfmt[1], sym->cache_count);
-        assert(i > 0);
-        n += i;
-        assert(n <= maxlen);
-    }
-
-    int i = strlen(xmlfmt[2]);
-    memcpy(*buf + n, xmlfmt[2], i + 1);
-    n += i;
-    assert(n <= maxlen);
-
-    /* FIXME binary data */
-    /* FIXME handle "]]>" */
-    strncpy(*buf + n, sym->data, datalen + 1);
-    n += datalen;
-    assert(n <= maxlen);
-
-    i = strlen(xmlfmt[3]);
-    memcpy(*buf + n, xmlfmt[3], i + 1);
-    n += i;
-    assert(n <= maxlen);
+    TMPL_COPY("]]></data></symbol>");
 
     *len = n;
     return(*buf);
@@ -242,3 +404,9 @@ zbar_symbol_set_first_symbol (const zbar
         return(sym->next);
     return(syms->head);
 }
+
+const zbar_symbol_t*
+zbar_symbol_set_first_unfiltered (const zbar_symbol_set_t *syms)
+{
+    return(syms->head);
+}
diff --git a/zbar/symbol.h b/zbar/symbol.h
--- a/zbar/symbol.h
+++ b/zbar/symbol.h
@@ -1,5 +1,5 @@
 /*------------------------------------------------------------------------
- *  Copyright 2007-2009 (c) Jeff Brown <spadix@users.sourceforge.net>
+ *  Copyright 2007-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
  *
  *  This file is part of the ZBar Bar Code Reader.
  *
@@ -27,6 +27,8 @@
 #include <zbar.h>
 #include "refcnt.h"
 
+#define NUM_SYMS  16
+
 typedef struct point_s {
     int x, y;
 } point_t;
@@ -40,6 +42,8 @@ struct zbar_symbol_set_s {
 
 struct zbar_symbol_s {
     zbar_symbol_type_t type;    /* symbol type */
+    unsigned int configs;       /* symbology boolean config bitmask */
+    unsigned int modifiers;     /* symbology modifier bitmask */
     unsigned int data_alloc;    /* allocation size of data */
     unsigned int datalen;       /* length of binary symbol data */
     char *data;                 /* symbol data */
@@ -47,6 +51,7 @@ struct zbar_symbol_s {
     unsigned pts_alloc;         /* allocation size of pts */
     unsigned npts;              /* number of points in location polygon */
     point_t *pts;               /* list of points in location polygon */
+    zbar_orientation_t orient;  /* coarse orientation */
 
     refcnt_t refcnt;            /* reference count */
     zbar_symbol_t *next;        /* linked list of results (or siblings) */
@@ -56,6 +61,8 @@ struct zbar_symbol_s {
     int quality;                /* relative symbol reliability metric */
 };
 
+extern int _zbar_get_symbol_hash(zbar_symbol_type_t);
+
 extern void _zbar_symbol_free(zbar_symbol_t*);
 
 extern zbar_symbol_set_t *_zbar_symbol_set_create(void);
diff --git a/zbar/timer.h b/zbar/timer.h
--- a/zbar/timer.h
+++ b/zbar/timer.h
@@ -1,5 +1,5 @@
 /*------------------------------------------------------------------------
- *  Copyright 2007-2009 (c) Jeff Brown <spadix@users.sourceforge.net>
+ *  Copyright 2007-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
  *
  *  This file is part of the ZBar Bar Code Reader.
  *
@@ -24,7 +24,9 @@
 #define _ZBAR_TIMER_H_
 
 #include <time.h>
-#include <sys/time.h>   /* gettimeofday */
+#ifdef HAVE_SYS_TIME_H
+# include <sys/time.h>   /* gettimeofday */
+#endif
 
 /* platform timer abstraction
  *
@@ -41,6 +43,13 @@
 
 typedef struct timespec zbar_timer_t;
 
+static inline int _zbar_timer_now ()
+{
+    struct timespec now;
+    clock_gettime(CLOCK_REALTIME, &now);
+    return(now.tv_sec * 1000 + now.tv_nsec / 1000000);
+}
+
 static inline zbar_timer_t *_zbar_timer_init (zbar_timer_t *timer,
                                               int delay)
 {
@@ -56,13 +65,14 @@ static inline zbar_timer_t *_zbar_timer_
 
 static inline int _zbar_timer_check (zbar_timer_t *timer)
 {
+    struct timespec now;
+    int delay;
     if(!timer)
         return(-1);
 
-    struct timespec now;
     clock_gettime(CLOCK_REALTIME, &now);
-    int delay = ((timer->tv_sec - now.tv_sec) * 1000 +
-                 (timer->tv_nsec - now.tv_nsec) / 1000000);
+    delay = ((timer->tv_sec - now.tv_sec) * 1000 +
+             (timer->tv_nsec - now.tv_nsec) / 1000000);
     return((delay >= 0) ? delay : 0);
 }
 
@@ -73,6 +83,11 @@ static inline int _zbar_timer_check (zba
 
 typedef DWORD zbar_timer_t;
 
+static inline int _zbar_timer_now ()
+{
+    return(timeGetTime());
+}
+
 static inline zbar_timer_t *_zbar_timer_init (zbar_timer_t *timer,
                                               int delay)
 {
@@ -85,18 +100,26 @@ static inline zbar_timer_t *_zbar_timer_
 
 static inline int _zbar_timer_check (zbar_timer_t *timer)
 {
+    int delay;
     if(!timer)
         return(INFINITE);
 
-    int delay = *timer - timeGetTime();
+    delay = *timer - timeGetTime();
     return((delay >= 0) ? delay : 0);
 }
 
 
-#else
+#elif defined(HAVE_SYS_TIME_H)
 
 typedef struct timeval zbar_timer_t;
 
+static inline int _zbar_timer_now ()
+{
+    struct timeval now;
+    gettimeofday(&now, NULL);
+    return(now.tv_sec * 1000 + now.tv_usec / 1000);
+}
+
 static inline zbar_timer_t *_zbar_timer_init (zbar_timer_t *timer,
                                               int delay)
 {
@@ -112,15 +135,17 @@ static inline zbar_timer_t *_zbar_timer_
 
 static inline int _zbar_timer_check (zbar_timer_t *timer)
 {
+    struct timeval now;
     if(!timer)
         return(-1);
 
-    struct timeval now;
     gettimeofday(&now, NULL);
     return((timer->tv_sec - now.tv_sec) * 1000 +
            (timer->tv_usec - now.tv_usec) / 1000);
 }
 
+#else
+# error "unable to find a timer interface"
 #endif
 
 #endif
diff --git a/zbar/video.c b/zbar/video.c
--- a/zbar/video.c
+++ b/zbar/video.c
@@ -1,5 +1,5 @@
 /*------------------------------------------------------------------------
- *  Copyright 2007-2009 (c) Jeff Brown <spadix@users.sourceforge.net>
+ *  Copyright 2007-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
  *
  *  This file is part of the ZBar Bar Code Reader.
  *
@@ -58,6 +58,7 @@ static void _zbar_video_recycle_shadow (
 zbar_video_t *zbar_video_create ()
 {
     zbar_video_t *vdo = calloc(1, sizeof(zbar_video_t));
+    int i;
     if(!vdo)
         return(NULL);
     err_init(&vdo->err, ZBAR_MOD_VIDEO);
@@ -73,7 +74,6 @@ zbar_video_t *zbar_video_create ()
         return(NULL);
     }
 
-    int i;
     for(i = 0; i < ZBAR_VIDEO_IMAGES_MAX; i++) {
         zbar_image_t *img = vdo->images[i] = zbar_image_create();
         if(!img) {
@@ -97,7 +97,7 @@ void zbar_video_destroy (zbar_video_t *v
         int i;
         for(i = 0; i < ZBAR_VIDEO_IMAGES_MAX; i++)
             if(vdo->images[i])
-                free(vdo->images[i]);
+                _zbar_image_free(vdo->images[i]);
         free(vdo->images);
     }
     while(vdo->shadow_image) {
@@ -130,6 +130,8 @@ void zbar_video_destroy (zbar_video_t *v
 int zbar_video_open (zbar_video_t *vdo,
                      const char *dev)
 {
+    char *ldev = NULL;
+    int rc;
     zbar_video_enable(vdo, 0);
     video_lock(vdo);
     if(vdo->intf != VIDEO_INVALID) {
@@ -145,7 +147,6 @@ int zbar_video_open (zbar_video_t *vdo,
     if(!dev)
         return(0);
 
-    char *ldev = NULL;
     if((unsigned char)dev[0] < 0x10) {
         /* default linux device, overloaded for other platforms */
         int id = dev[0];
@@ -153,7 +154,7 @@ int zbar_video_open (zbar_video_t *vdo,
         ldev[10] = '0' + id;
     }
 
-    int rc = _zbar_video_open(vdo, dev);
+    rc = _zbar_video_open(vdo, dev);
 
     if(ldev)
         free(ldev);
@@ -227,12 +228,12 @@ uint32_t zbar_video_get_format (const zb
 
 static inline int video_init_images (zbar_video_t *vdo)
 {
-    
+    int i;
     assert(vdo->datalen);
     if(vdo->iomode != VIDEO_MMAP) {
         assert(!vdo->buf);
         vdo->buflen = vdo->num_images * vdo->datalen;
-        vdo->buf = malloc(vdo->buflen);
+        vdo->buf = calloc(1, vdo->buflen);
         if(!vdo->buf)
             return(err_capture(vdo, SEV_FATAL, ZBAR_ERR_NOMEM, __func__,
                                "unable to allocate image buffers"));
@@ -240,16 +241,14 @@ static inline int video_init_images (zba
                 (vdo->iomode == VIDEO_READWRITE) ? "READ" : "USERPTR",
                 vdo->buflen);
     }
-    int i;
     for(i = 0; i < vdo->num_images; i++) {
         zbar_image_t *img = vdo->images[i];
         img->format = vdo->format;
-        img->width = vdo->width;
-        img->height = vdo->height;
+        zbar_image_set_size(img, vdo->width, vdo->height);
         if(vdo->iomode != VIDEO_MMAP) {
+            unsigned long offset = i * vdo->datalen;
             img->datalen = vdo->datalen;
-            unsigned long offset = i * vdo->datalen;
-            img->data = vdo->buf + offset;
+            img->data = (uint8_t*)vdo->buf + offset;
             zprintf(2, "    [%02d] @%08lx\n", i, offset);
         }
     }
@@ -259,6 +258,9 @@ static inline int video_init_images (zba
 int zbar_video_init (zbar_video_t *vdo,
                      unsigned long fmt)
 {
+#ifdef HAVE_LIBJPEG
+    const zbar_format_def_t *vidfmt;
+#endif
     if(vdo->initialized)
         /* FIXME re-init different format? */
         return(err_capture(vdo, SEV_ERROR, ZBAR_ERR_INVALID, __func__,
@@ -270,8 +272,9 @@ int zbar_video_init (zbar_video_t *vdo,
     if(video_init_images(vdo))
         return(-1);
 #ifdef HAVE_LIBJPEG
-    const zbar_format_def_t *vidfmt = _zbar_format_lookup(fmt);
+    vidfmt = _zbar_format_lookup(fmt);
     if(vidfmt && vidfmt->group == ZBAR_FMT_JPEG) {
+        zbar_image_t *img;
         /* prepare for decoding */
         if(!vdo->jpeg)
             vdo->jpeg = _zbar_jpeg_decomp_create();
@@ -279,10 +282,9 @@ int zbar_video_init (zbar_video_t *vdo,
             zbar_image_destroy(vdo->jpeg_img);
 
         /* create intermediate image for decoder to use*/
-        zbar_image_t *img = vdo->jpeg_img = zbar_image_create();
+        img = vdo->jpeg_img = zbar_image_create();
         img->format = fourcc('Y','8','0','0');
-        img->width = vdo->width;
-        img->height = vdo->height;
+        zbar_image_set_size(img, vdo->width, vdo->height);
         img->datalen = vdo->width * vdo->height;
     }
 #endif
@@ -333,6 +335,9 @@ int zbar_video_enable (zbar_video_t *vdo
 
 zbar_image_t *zbar_video_next_image (zbar_video_t *vdo)
 {
+    unsigned frame;
+    zbar_image_t *img;
+
     if(video_lock(vdo))
         return(NULL);
     if(!vdo->active) {
@@ -340,8 +345,8 @@ zbar_image_t *zbar_video_next_image (zba
         return(NULL);
     }
 
-    unsigned frame = vdo->frame++;
-    zbar_image_t *img = vdo->dq(vdo);
+    frame = vdo->frame++;
+    img = vdo->dq(vdo);
     if(img) {
         img->seq = frame;
         if(vdo->num_images < 2) {
@@ -362,8 +367,7 @@ zbar_image_t *zbar_video_next_image (zba
                 /* recycle the shadow images */
 
                 img->format = vdo->format;
-                img->width = vdo->width;
-                img->height = vdo->height;
+                zbar_image_set_size(img, vdo->width, vdo->height);
                 img->datalen = vdo->datalen;
                 img->data = malloc(vdo->datalen);
             }
diff --git a/zbar/window.c b/zbar/window.c
--- a/zbar/window.c
+++ b/zbar/window.c
@@ -1,5 +1,5 @@
 /*------------------------------------------------------------------------
- *  Copyright 2007-2009 (c) Jeff Brown <spadix@users.sourceforge.net>
+ *  Copyright 2007-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
  *
  *  This file is part of the ZBar Bar Code Reader.
  *
@@ -23,8 +23,11 @@
 
 #include "window.h"
 #include "image.h"
+#include "timer.h"
 #include <time.h>       /* clock_gettime */
-#include <sys/time.h>   /* gettimeofday */
+#ifdef HAVE_SYS_TIME_H
+# include <sys/time.h>   /* gettimeofday */
+#endif
 
 zbar_window_t *zbar_window_create ()
 {
@@ -117,20 +120,11 @@ static inline int window_draw_overlay (z
 
     if(w->overlay >= 2) {
         /* calculate/display frame rate */
-        unsigned long time;
-#if _POSIX_TIMERS > 0
-        struct timespec abstime;
-        clock_gettime(CLOCK_REALTIME, &abstime);
-        time = (abstime.tv_sec * 1000) + ((abstime.tv_nsec / 500000) + 1) / 2;
-#else
-        struct timeval abstime;
-        gettimeofday(&abstime, NULL);
-        time = (abstime.tv_sec * 1000) + ((abstime.tv_usec / 500) + 1) / 2;
-#endif
-        point_t p = { -8, -1 };
-        char text[32];
+        unsigned long time = _zbar_timer_now();
         if(w->time) {
             int avg = w->time_avg = (w->time_avg + time - w->time) / 2;
+            point_t p = { -8, -1 };
+            char text[32];
             sprintf(text, "%d.%01d fps", 1000 / avg, (10000 / avg) % 10);
             _zbar_window_draw_text(w, 3, p, text);
         }
@@ -141,6 +135,8 @@ static inline int window_draw_overlay (z
 
 inline int zbar_window_redraw (zbar_window_t *w)
 {
+    int rc = 0;
+    zbar_image_t *img;
     if(window_lock(w))
         return(-1);
     if(!w->display || _zbar_window_begin(w)) {
@@ -148,8 +144,7 @@ inline int zbar_window_redraw (zbar_wind
         return(-1);
     }
 
-    int rc = 0;
-    zbar_image_t *img = w->image;
+    img = w->image;
     if(w->init && w->draw_image && img) {
         int format_change = (w->src_format != img->format &&
                              w->format != img->format);
@@ -163,6 +158,7 @@ inline int zbar_window_redraw (zbar_wind
         }
 
         if(!rc && (format_change || !w->scaled_size.x || !w->dst_width)) {
+            point_t size = { w->width, w->height };
             zprintf(24, "init: src=%.4s(%08x) %dx%d dst=%.4s(%08x) %dx%d\n",
                     (char*)&w->src_format, w->src_format,
                     w->src_width, w->src_height,
@@ -173,7 +169,6 @@ inline int zbar_window_redraw (zbar_wind
                 w->src_height = img->height;
             }
 
-            point_t size = { w->width, w->height };
             if(size.x > w->max_width)
                 size.x = w->max_width;
             if(size.y > w->max_height)
@@ -226,9 +221,10 @@ inline int zbar_window_redraw (zbar_wind
         }
 
         if(!rc) {
+            point_t org;
             rc = w->draw_image(w, img);
 
-            point_t org = w->scaled_offset;
+            org = w->scaled_offset;
             if(org.x > 0) {
                 point_t p = { 0, org.y };
                 point_t s = { org.x, w->scaled_size.y };
@@ -300,9 +296,10 @@ void zbar_window_set_overlay (zbar_windo
 int zbar_window_get_overlay (const zbar_window_t *w)
 {
     zbar_window_t *ncw = (zbar_window_t*)w;
+    int lvl;
     if(window_lock(ncw))
         return(-1);
-    int lvl = w->overlay;
+    lvl = w->overlay;
     (void)window_unlock(ncw);
     return(lvl);
 }
diff --git a/zbarcam/zbarcam.c b/zbarcam/zbarcam.c
--- a/zbarcam/zbarcam.c
+++ b/zbarcam/zbarcam.c
@@ -105,17 +105,27 @@ static void data_handler (zbar_image_t *
         if(type == ZBAR_PARTIAL)
             continue;
 
-        if(!format)
-            printf("%s%s:%s\n",
-                   zbar_get_symbol_name(type), zbar_get_addon_name(type),
-                   zbar_symbol_get_data(sym));
-        else if(format == RAW)
-            printf("%s\n", zbar_symbol_get_data(sym));
+        if(!format) {
+            printf("%s:", zbar_get_symbol_name(type));
+            if(fwrite(zbar_symbol_get_data(sym),
+                      zbar_symbol_get_data_length(sym),
+                      1, stdout) != 1)
+                continue;
+        }
+        else if(format == RAW) {
+            if(fwrite(zbar_symbol_get_data(sym),
+                      zbar_symbol_get_data_length(sym),
+                      1, stdout) != 1)
+                continue;
+        }
         else if(format == XML) {
             if(!n)
                 printf("<index num='%u'>\n", zbar_image_get_sequence(img));
-            printf("%s\n", zbar_symbol_xml(sym, &xml_buf, &xml_len));
+            zbar_symbol_xml(sym, &xml_buf, &xml_len);
+            if(fwrite(xml_buf, xml_len, 1, stdout) != 1)
+                continue;
         }
+        printf("\n");
         n++;
     }
 
diff --git a/zbarcam/zbarcam.rc b/zbarcam/zbarcam.rc
--- a/zbarcam/zbarcam.rc
+++ b/zbarcam/zbarcam.rc
@@ -19,7 +19,7 @@ VS_VERSION_INFO VERSIONINFO
 
             VALUE "FileDescription", "Scan bar codes from video devices"
 
-            VALUE "LegalCopyright", "Copyright 2007-2009 (c) Jeff Brown <spadix@users.sourceforge.net>"
+            VALUE "LegalCopyright", "Copyright 2007-2010 (c) Jeff Brown <spadix@users.sourceforge.net>"
         }
     }
     BLOCK "VarFileInfo" {
diff --git a/zbarimg/Makefile.am.inc b/zbarimg/Makefile.am.inc
--- a/zbarimg/Makefile.am.inc
+++ b/zbarimg/Makefile.am.inc
@@ -12,10 +12,10 @@ endif
 
 EXTRA_DIST += test/barcodetest.py
 
-check-local:
+check-images: zbarimg/zbarimg
 	$(PYTHON) $(srcdir)/test/barcodetest.py
 
-regress:
+regress-images: zbarimg/zbarimg
 	suite='$(ZBAR_TESTS)'; \
 	if test "x$$suite" = "x"; then suite='http://zbar.sf.net/test'; fi ; \
 	$(PYTHON) $(srcdir)/test/barcodetest.py $$suite
diff --git a/zbarimg/zbarimg.c b/zbarimg/zbarimg.c
--- a/zbarimg/zbarimg.c
+++ b/zbarimg/zbarimg.c
@@ -1,5 +1,5 @@
 /*------------------------------------------------------------------------
- *  Copyright 2007-2009 (c) Jeff Brown <spadix@users.sourceforge.net>
+ *  Copyright 2007-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
  *
  *  This file is part of the ZBar Bar Code Reader.
  *
@@ -45,7 +45,7 @@
  *  how does MagickGetAuthenticImagePixels fit in?)
  * ref http://bugs.gentoo.org/247292
  */
-#if MagickLibVersion < 0x645
+#if MagickLibVersion <= 0x645
 # define MagickExportImagePixels MagickGetImagePixels
 #endif
 
@@ -76,8 +76,8 @@ static const char *warning_not_found =
     "  things to check:\n"
     "    - is the barcode type supported?"
     "  currently supported symbologies are:\n"
-    "      EAN/UPC (EAN-13, EAN-8, UPC-A, UPC-E, ISBN-10, ISBN-13),\n"
-    "      Code 128, Code 39 and Interleaved 2 of 5\n"
+    "      EAN/UPC (EAN-13, EAN-8, UPC-A, UPC-E, ISBN-10, ISBN-13), Code 128,\n"
+    "      Code 93, Code 39, DataBar, DataBar Expanded, and Interleaved 2 of 5\n"
     "    - is the barcode large enough in the image?\n"
     "    - is the barcode mostly in focus?\n"
     "    - is there sufficient contrast/illumination?\n"
@@ -137,7 +137,7 @@ static int scan_image (const char *filen
 
         zbar_image_t *zimage = zbar_image_create();
         assert(zimage);
-        zbar_image_set_format(zimage, *(unsigned long*)"Y800");
+        zbar_image_set_format(zimage, zbar_fourcc('Y','8','0','0'));
 
         int width = MagickGetImageWidth(images);
         int height = MagickGetImageHeight(images);
@@ -165,23 +165,30 @@ static int scan_image (const char *filen
         const zbar_symbol_t *sym = zbar_image_first_symbol(zimage);
         for(; sym; sym = zbar_symbol_next(sym)) {
             zbar_symbol_type_t typ = zbar_symbol_get_type(sym);
+            unsigned len = zbar_symbol_get_data_length(sym);
             if(typ == ZBAR_PARTIAL)
                 continue;
-            else if(!xmllvl)
-                printf("%s%s:%s\n",
-                       zbar_get_symbol_name(typ),
-                       zbar_get_addon_name(typ),
-                       zbar_symbol_get_data(sym));
-            else if(xmllvl < 0)
-                printf("%s\n", zbar_symbol_get_data(sym));
+            else if(xmllvl <= 0) {
+                if(!xmllvl)
+                    printf("%s:", zbar_get_symbol_name(typ));
+                if(len &&
+                   fwrite(zbar_symbol_get_data(sym), len, 1, stdout) != 1) {
+                    exit_code = 1;
+                    return(-1);
+                }
+            }
             else {
                 if(xmllvl < 3) {
                     xmllvl++;
                     printf("<index num='%u'>\n", seq);
                 }
                 zbar_symbol_xml(sym, &xmlbuf, &xmlbuflen);
-                printf("%s\n", xmlbuf);
+                if(fwrite(xmlbuf, xmlbuflen, 1, stdout) != 1) {
+                    exit_code = 1;
+                    return(-1);
+                }
             }
+            printf("\n");
             found++;
             num_symbols++;
         }
diff --git a/zbarimg/zbarimg.rc b/zbarimg/zbarimg.rc
--- a/zbarimg/zbarimg.rc
+++ b/zbarimg/zbarimg.rc
@@ -19,7 +19,7 @@ VS_VERSION_INFO VERSIONINFO
 
             VALUE "FileDescription", "Scan bar codes from image files"
 
-            VALUE "LegalCopyright", "Copyright 2007-2009 (c) Jeff Brown <spadix@users.sourceforge.net>"
+            VALUE "LegalCopyright", "Copyright 2007-2010 (c) Jeff Brown <spadix@users.sourceforge.net>"
         }
     }
     BLOCK "VarFileInfo" {
