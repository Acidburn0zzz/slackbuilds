From 56c87e83f85e1c850702557936421f8181a30481 Mon Sep 17 00:00:00 2001
From: Markus Steinborn <gnugv_maintainer@yahoo.de>
Date: Sat, 24 Apr 2010 16:53:10 +0200
Subject: [PATCH] Xaw3d-1.5E-thumb.patch

---
 xc/lib/Xaw3d/AsciiSink.c  |    6 +-
 xc/lib/Xaw3d/Form.c       |    2 +-
 xc/lib/Xaw3d/Layout.c     |    2 +-
 xc/lib/Xaw3d/MultiSink.c  |    6 +-
 xc/lib/Xaw3d/Paned.c      |   27 ++-
 xc/lib/Xaw3d/Panner.c     |    2 +-
 xc/lib/Xaw3d/Scrollbar.c  |  627 +++++++++++++++++++++++++++++++-------------
 xc/lib/Xaw3d/Scrollbar.h  |    6 +
 xc/lib/Xaw3d/ScrollbarP.h |    7 +-
 xc/lib/Xaw3d/SimpleMenu.c |    3 +-
 xc/lib/Xaw3d/SmeThreeD.c  |   20 +-
 xc/lib/Xaw3d/SmeThreeD.h  |    3 +
 xc/lib/Xaw3d/SmeThreeDP.h |    1 +
 xc/lib/Xaw3d/StripChart.c |   43 ++--
 xc/lib/Xaw3d/Text.c       |    6 +-
 xc/lib/Xaw3d/TextAction.c |    1 +
 xc/lib/Xaw3d/TextPop.c    |    3 +-
 xc/lib/Xaw3d/ThreeD.c     |   19 +-
 xc/lib/Xaw3d/ThreeD.h     |    3 +
 xc/lib/Xaw3d/ThreeDP.h    |    1 +
 xc/lib/Xaw3d/Toggle.c     |    3 +-
 xc/lib/Xaw3d/Viewport.c   |    6 +-
 xc/lib/Xaw3d/XawI18n.c    |    3 +
 xc/lib/Xaw3d/XawI18n.h    |    2 +
 xc/lib/Xaw3d/XawIm.c      |    5 +-
 25 files changed, 565 insertions(+), 242 deletions(-)

diff --git a/xc/lib/Xaw3d/AsciiSink.c b/xc/lib/Xaw3d/AsciiSink.c
index b427c80..2ebd952 100644
--- a/xc/lib/Xaw3d/AsciiSink.c
+++ b/xc/lib/Xaw3d/AsciiSink.c
@@ -174,13 +174,14 @@ unsigned char c;
 	return 0;
     }
 
-    if ( (nonPrinting = (c < (unsigned char) XawSP)) )
+    if ( (nonPrinting = (c < (unsigned char) XawSP)) ) {
 	if (sink->ascii_sink.display_nonprinting)
 	    c += '@';
 	else {
 	    c = XawSP;
 	    nonPrinting = False;
 	}
+    }
 
     if (font->per_char &&
 	    (c >= font->min_char_or_byte2 && c <= font->max_char_or_byte2))
@@ -661,12 +662,13 @@ short *tabs;
   XA_FIGURE_WIDTH = XInternAtom(XtDisplayOfObject(w), "FIGURE_WIDTH", FALSE);
   if ( (XA_FIGURE_WIDTH != None) && 
        ( (!XGetFontProperty(font, XA_FIGURE_WIDTH, &figure_width)) ||
-	 (figure_width == 0)) ) 
+	 (figure_width == 0)) ) {
     if (font->per_char && font->min_char_or_byte2 <= '$' &&
 	font->max_char_or_byte2 >= '$')
       figure_width = font->per_char['$' - font->min_char_or_byte2].width;
     else
       figure_width = font->max_bounds.width;
+  }
 
   if (tab_count > sink->text_sink.tab_count) {
     sink->text_sink.tabs = (Position *)
diff --git a/xc/lib/Xaw3d/Form.c b/xc/lib/Xaw3d/Form.c
index c4eae4b..d628618 100644
--- a/xc/lib/Xaw3d/Form.c
+++ b/xc/lib/Xaw3d/Form.c
@@ -780,7 +780,7 @@ static XtGeometryResult PreferredGeometry( widget, request, reply  )
     reply->width = w->form.preferred_width;
     reply->height = w->form.preferred_height;
     reply->request_mode = CWWidth | CWHeight;
-    if (  request->request_mode & (CWWidth | CWHeight) ==
+    if ( (request->request_mode & (CWWidth | CWHeight)) ==
 	    (CWWidth | CWHeight)
 	  && request->width == reply->width
 	  && request->height == reply->height)
diff --git a/xc/lib/Xaw3d/Layout.c b/xc/lib/Xaw3d/Layout.c
index dd4b253..497b9c2 100644
--- a/xc/lib/Xaw3d/Layout.c
+++ b/xc/lib/Xaw3d/Layout.c
@@ -539,7 +539,7 @@ Evaluate (l, box, expr, natural)
     ExprPtr	    expr;
     double	    natural;
 {
-    double	left, right, down;
+    double	left = 0.0, right = 0.0, down = 0.0;
     Widget	widget;
     SubInfoPtr	info;
 
diff --git a/xc/lib/Xaw3d/MultiSink.c b/xc/lib/Xaw3d/MultiSink.c
index 204470f..d8aac3f 100644
--- a/xc/lib/Xaw3d/MultiSink.c
+++ b/xc/lib/Xaw3d/MultiSink.c
@@ -204,12 +204,13 @@ CharWidth (w, x, c)
 	return 0;
     }
 
-    if (XwcTextEscapement (fontset, &c, 1) == 0)
+    if (XwcTextEscapement (fontset, &c, 1) == 0) {
 	if (sink->multi_sink.display_nonprinting)
 	    c = _Xaw_atowc('@');
 	else {
 	    c = _Xaw_atowc(XawSP);
 	}
+    }
 
     /*
      * if more efficiency(suppose one column is one ASCII char)
@@ -731,12 +732,13 @@ SetTabs( w, tab_count, tabs )
   XA_FIGURE_WIDTH = XInternAtom(XtDisplayOfObject(w), "FIGURE_WIDTH", FALSE);
   if ( (XA_FIGURE_WIDTH != None) && 
        ( (!XGetFontProperty(font, XA_FIGURE_WIDTH, &figure_width)) ||
-	 (figure_width == 0)) ) 
+	 (figure_width == 0)) ) {
     if (font->per_char && font->min_char_or_byte2 <= '$' &&
 	font->max_char_or_byte2 >= '$')
       figure_width = font->per_char['$' - font->min_char_or_byte2].width;
     else
       figure_width = font->max_bounds.width;
+  }
 
   if (tab_count > sink->text_sink.tab_count) {
     sink->text_sink.tabs = (Position *)
diff --git a/xc/lib/Xaw3d/Paned.c b/xc/lib/Xaw3d/Paned.c
index babd492..adbbc77 100644
--- a/xc/lib/Xaw3d/Paned.c
+++ b/xc/lib/Xaw3d/Paned.c
@@ -1157,12 +1157,14 @@ PanedWidget pw;
    managedP = managed_grips = (WidgetList) XtMalloc(alloc_size);
    unmanagedP = unmanaged_grips = (WidgetList) XtMalloc(alloc_size);
 
-   ForAllChildren(pw, childP) 
-       if (IsPane(*childP) && HasGrip(*childP))
+   ForAllChildren(pw, childP) {
+       if (IsPane(*childP) && HasGrip(*childP)) {
 	   if ( XtIsManaged(*childP) ) 
 	       *managedP++ = PaneInfo(*childP)->grip;
 	   else
 	       *unmanagedP++ = PaneInfo(*childP)->grip;
+       }
+   }
    
    if (managedP != managed_grips) {
        *unmanagedP++ = *--managedP;   /* Last grip is never managed */
@@ -1194,11 +1196,12 @@ Widget child;
      
     XtSetArg(arglist[num_args], XtNtranslations, pw->paned.grip_translations);
     num_args++;
-    if ( (cursor = pw->paned.grip_cursor) == None )
+    if ( (cursor = pw->paned.grip_cursor) == None ) {
         if (IsVert(pw))
 	    cursor = pw->paned.v_grip_cursor;
 	else
 	    cursor = pw->paned.h_grip_cursor;
+    }
 
     XtSetArg(arglist[num_args], XtNcursor, cursor);
     num_args++;
@@ -1310,11 +1313,12 @@ PanedWidget pw;
 	Arg arglist[1];
 	Cursor cursor;
       
-	if ( (cursor = pw->paned.grip_cursor) == None )
+	if ( (cursor = pw->paned.grip_cursor) == None ) {
 	    if ( IsVert(pw) )
 	        cursor = pw->paned.v_grip_cursor;
 	    else
 	        cursor = pw->paned.h_grip_cursor;
+	}
 
 	if (HasGrip (*childP)) {
 	    XtSetArg(arglist[0], XtNcursor, cursor);
@@ -1489,11 +1493,12 @@ XtWidgetGeometry *request, *reply;
  * a different on_size;
  */
 
-    if (result != XtGeometryNo) 
+    if (result != XtGeometryNo) {
 	if (vert) 
 	    pw->core.height = on_size;
 	else 
 	    pw->core.width = on_size;
+    }
     
     RefigureLocations(pw, PaneIndex(w), AnyPane);
 
@@ -1524,11 +1529,12 @@ XtWidgetGeometry *request, *reply;
  * THEN: set almost
  */
 
-    if ( !((vert ? CWWidth : CWHeight) & mask))
+    if ( !((vert ? CWWidth : CWHeight) & mask)) {
         if (vert) 
 	    request->width = w->core.width;
 	else
 	    request->height = w->core.height;
+    }
 
     almost = GetRequestInfo(request, !vert) != GetRequestInfo(reply, !vert);
     almost |= (GetRequestInfo(request, vert) != GetRequestInfo(reply, vert));
@@ -1673,8 +1679,8 @@ static void ChangeManaged(w)
    ResortChildren(pw);		
 
    pw->paned.num_panes = 0;
-   ForAllChildren(pw, childP) 
-       if ( IsPane(*childP) )
+   ForAllChildren(pw, childP) {
+       if ( IsPane(*childP) ) {
 	   if ( XtIsManaged(*childP) ) {
 	       Pane pane = PaneInfo(*childP);
 	       if (HasGrip(*childP))
@@ -1684,6 +1690,8 @@ static void ChangeManaged(w)
 	   }
 	   else
 	       break;		/* This list is already sorted. */
+       }
+   }
 
    SetChildrenPrefSizes( (PanedWidget) w, size);
 
@@ -1806,7 +1814,7 @@ Cardinal *num_args;
 
     /* Check for change in XtNshowGrip. */
 
-    if (old_pane->show_grip != new_pane->show_grip)
+    if (old_pane->show_grip != new_pane->show_grip) {
         if (new_pane->show_grip == TRUE) {
 	    CreateGrip(new);
 	    if (XtIsRealized(XtParent(new))) {
@@ -1822,6 +1830,7 @@ Cardinal *num_args;
 	    new_pane->grip = NULL;
 	    redisplay = TRUE;
 	}
+    }
 
   /* ||| need to look at position changes */
 
diff --git a/xc/lib/Xaw3d/Scrollbar.c b/xc/lib/Xaw3d/Scrollbar.c
index c105688..0566733 100644
--- a/xc/lib/Xaw3d/Scrollbar.c
+++ b/xc/lib/Xaw3d/Scrollbar.c
@@ -130,14 +130,18 @@ static XtResource resources[] = {
        Offset(scrollbar.thumb), XtRImmediate, (XtPointer) XtUnspecifiedPixmap},
   {XtNforeground, XtCForeground, XtRPixel, sizeof(Pixel),
        Offset(scrollbar.foreground), XtRString, XtDefaultForeground},
+  {XtNscrollbarBackground, XtCScrollbarBackground, XtRPixel, sizeof(Pixel),
+       Offset(scrollbar.background), XtRString, XtDefaultForeground},
   {XtNshown, XtCShown, XtRFloat, sizeof(float),
        Offset(scrollbar.shown), XtRFloat, (XtPointer)&floatZero},
   {XtNtopOfThumb, XtCTopOfThumb, XtRFloat, sizeof(float),
        Offset(scrollbar.top), XtRFloat, (XtPointer)&floatZero},
   {XtNpickTop, XtCPickTop, XtRBoolean, sizeof(Boolean),
-       Offset(scrollbar.pick_top), XtRBoolean, (XtPointer) False},
+       Offset(scrollbar.pick_top), XtRImmediate, (XtPointer) False},
   {XtNminimumThumb, XtCMinimumThumb, XtRDimension, sizeof(Dimension),
-       Offset(scrollbar.min_thumb), XtRImmediate, (XtPointer) 7}
+       Offset(scrollbar.min_thumb), XtRImmediate, (XtPointer) 7},
+  {XtNpushThumb, XtCPushThumb, XtRBoolean, sizeof(Boolean),
+       Offset(scrollbar.push_thumb), XtRImmediate, (XtPointer) True}
 };
 #undef Offset
 
@@ -211,8 +215,7 @@ ScrollbarClassRec scrollbarClassRec = {
     /* change_sensitive	*/	XtInheritChangeSensitive
   },
   { /* threeD fields */
-    /* shadowdraw	*/	XtInheritXaw3dShadowDraw /*,*/
-    /* shadowboxdraw	*/	/*XtInheritXaw3dShadowBoxDraw*/
+    /* shadowdraw	*/	XtInheritXaw3dShadowDraw
   },
   { /* scrollbar fields */
     /* ignore		*/	0
@@ -224,7 +227,7 @@ WidgetClass scrollbarWidgetClass = (WidgetClass)&scrollbarClassRec;
 
 #define NoButton -1
 #define PICKLENGTH(widget, x, y) \
-    ((widget->scrollbar.orientation == XtorientHorizontal) ? x : y)
+    ((widget->scrollbar.orientation == XtorientHorizontal) ? (x) : (y))
 #define MIN(x,y)	((x) < (y) ? (x) : (y))
 #define MAX(x,y)	((x) > (y) ? (x) : (y))
 
@@ -242,6 +245,18 @@ static void ClassInitialize()
 #define MARGIN(sbw) (sbw)->threeD.shadow_width
 #endif
 
+/*
+   Used to swap X and Y coordinates when the scrollbar is horizontal.
+ */
+static void swap(a, b)
+    Dimension *a, *b;
+{
+    Dimension tmp = *a;
+    *a = *b;
+    *b = tmp;
+}
+
+
 /* 
  The original Xaw Scrollbar's FillArea *really* relied on the fact that the 
  server was going to clip at the window boundaries; so the logic was really
@@ -280,11 +295,11 @@ static void FillArea (sbw, top, bottom, fill)
     if (lh <= 0 || lw <= 0) return;
     if (fill) {
 	XFillRectangle(XtDisplay((Widget) sbw), XtWindow((Widget) sbw), 
-			sbw->scrollbar.gc, 
+			sbw->scrollbar.gc,
 			lx, ly, (unsigned int) lw, (unsigned int) lh);
     } else {
 	XClearArea (XtDisplay((Widget) sbw), XtWindow((Widget) sbw), 
-			lx, ly, (unsigned int) lw, (unsigned int) lh, 
+			lx, ly, (unsigned int) lw, (unsigned int) lh,
 			FALSE);
     }
 }
@@ -293,163 +308,375 @@ static void FillArea (sbw, top, bottom, fill)
    sbw->shown.  The old area is erased.  The painting and
    erasing is done cleverly so that no flickering will occur. */
 
-static void PaintThumb (sbw, event)
+static void PaintThumb (sbw, pressed, shadow)
     ScrollbarWidget sbw;
-    XEvent *event; 
+    int pressed, shadow;
 {
-    Dimension s                   = sbw->threeD.shadow_width;
-    Position  oldtop              = sbw->scrollbar.topLoc;
-    Position  oldbot              = oldtop + sbw->scrollbar.shownLength;
-    Dimension margin              = MARGIN (sbw);
-    Dimension tzl                 = sbw->scrollbar.length - margin - margin;
-    Position newtop, newbot;    
-    Position  floor               = sbw->scrollbar.length - margin;
+    Dimension margin, tzl;
+    Position  floor;
+    Position  oldtop = sbw->scrollbar.topLoc;
+    Position  oldbot = oldtop + sbw->scrollbar.shownLength;
+    Position  newtop, newbot;
+    Dimension x, y;				/* upper-left corner of rectangle */
+    Dimension w, h;				/* size of rectangle */
+    Dimension sw = sbw->threeD.shadow_width;
+    Dimension th = sbw->scrollbar.thickness;
+    XPoint    ipt[4],opt[4];			/* inner and outer points of thumb */
+    XPoint    pt[4];				/* points used for drawing */
+    Display  *dpy = XtDisplay (sbw);
+    Window    win = XtWindow (sbw);
+    double    thumb_len;
+
+    margin = MARGIN (sbw);
+    tzl    = sbw->scrollbar.length - 2*margin;
+    floor  = sbw->scrollbar.length - margin;
 
     newtop = margin + (int)(tzl * sbw->scrollbar.top);
-    newbot = newtop + (int)(tzl * sbw->scrollbar.shown);
-    if (sbw->scrollbar.shown < 1.) newbot++;
-    if (newbot < newtop + (int)sbw->scrollbar.min_thumb +
-                        2 * (int)sbw->threeD.shadow_width) 
-      newbot = newtop + sbw->scrollbar.min_thumb +
-                        2 * sbw->threeD.shadow_width;
-    if ( newbot >= floor ) {
-	newtop = floor-(newbot-newtop)+1;
+    thumb_len = tzl * sbw->scrollbar.shown;
+    newbot = newtop + (int)thumb_len;
+    if ((thumb_len - (int)thumb_len) > 0.5) ++newbot;
+
+    if (newbot < newtop + (int)sbw->scrollbar.min_thumb + 2 * (int)sw)
+	newbot = newtop + sbw->scrollbar.min_thumb + 2 * sw;
+
+    if (newbot >= floor) {
+	newtop = floor - (newbot-newtop) + 1;
 	newbot = floor;
     }
 
     sbw->scrollbar.topLoc = newtop;
     sbw->scrollbar.shownLength = newbot - newtop;
+
     if (XtIsRealized ((Widget) sbw)) {
-      /*  3D thumb wanted ?
-       */
-      if (s) 
-	  {
-          if (newtop < oldtop) FillArea(sbw, oldtop, oldtop + s, 0);
-          if (newtop > oldtop) FillArea(sbw, oldtop, MIN(newtop, oldbot), 0);
-          if (newbot < oldbot) FillArea(sbw, MAX(newbot, oldtop), oldbot, 0);
-          if (newbot > oldbot) FillArea(sbw, oldbot - s, oldbot, 0);
-
-          if (sbw->scrollbar.orientation == XtorientHorizontal) 
-	      {
-	      _ShadowSurroundedBox((Widget)sbw, (ThreeDWidget)sbw,
-		  newtop, s, newbot, sbw->core.height - s,
-		  sbw->threeD.relief, TRUE);
-	      }
-	  else 
-	      {
-	      _ShadowSurroundedBox((Widget)sbw, (ThreeDWidget)sbw,
-		  s, newtop, sbw->core.width - s, newbot,
-		  sbw->threeD.relief, TRUE);
-	      }
-	  }
-      else 
-	  {
-	  /* 
-	    Note to Mitch: FillArea is (now) correctly implemented to 
-	    not draw over shadows or the arrows. Therefore setting clipmasks 
-	    doesn't seem to be necessary.  Correct me if I'm wrong!
-	  */
-          if (newtop < oldtop) FillArea(sbw, newtop, MIN(newbot, oldtop), 1);
-          if (newtop > oldtop) FillArea(sbw, oldtop, MIN(newtop, oldbot), 0);
-          if (newbot < oldbot) FillArea(sbw, MAX(newbot, oldtop), oldbot, 0);
-          if (newbot > oldbot) FillArea(sbw, MAX(newtop, oldbot), newbot, 1);
-	  }
+	/* 3D? */
+	if (sw) {
+	    GC top, bot;
+	    GC back = sbw->scrollbar.bgc;
+	    GC fore = sbw->scrollbar.gc;
+
+	    if ((pressed && sbw->scrollbar.push_thumb) ^ sbw->threeD.invert_border) {
+		top = sbw->threeD.bot_shadow_GC;
+		bot = sbw->threeD.top_shadow_GC;
+	    } else {
+		top = sbw->threeD.top_shadow_GC;
+		bot = sbw->threeD.bot_shadow_GC;
+	    }
+
+	    /* the space above the thumb */
+	    x = sw;
+	    y = margin;
+	    w = th - sw * 2;
+	    h = newtop - y;
+	    if (sbw->scrollbar.orientation == XtorientHorizontal) {
+		swap(&x, &y);
+		swap(&w, &h);
+	    }
+	    XFillRectangle(dpy, win, back, x, y, (unsigned int)w, (unsigned int)h);
+
+	    /* the space below the thumb */
+	    x = sw;
+	    y = newbot;
+	    w = th - sw * 2;
+	    h = tzl + margin - newbot;
+	    if (sbw->scrollbar.orientation == XtorientHorizontal) {
+		swap(&x, &y);
+		swap(&w, &h);
+	    }
+	    XFillRectangle(dpy, win, back, x, y, (unsigned int)w, (unsigned int)h);
+
+	    /* Return here if only the shadows should be repainted */
+	    if (shadow) return;
+
+	    /* the thumb itself */
+	    x = sw * 2;
+	    y = newtop + sw;
+	    w = th - sw * 4;
+	    h = newbot - newtop - 2 * sw;
+	    if (sbw->scrollbar.orientation == XtorientHorizontal) {
+		swap(&x, &y);
+		swap(&w, &h);
+	    }
+	    /* we can't use "w > 0" and "h > 0" because they are
+	    usually unsigned quantities */
+	    if (th - sw * 4 > 0 && newbot - newtop - 2 * sw > 0)
+            XFillRectangle(dpy, win, fore, x, y, (unsigned int)w, (unsigned int)h);
+
+	    /* the shades around the thumb
+
+	       o0 +--------------+ o3
+		  |\ i0      i3 /|
+   		  | +----------+ |
+  		  | |          | |
+		  | |          | |
+		  | |          | |
+		  | +----------+ |
+		  |/ i1      i2 \|
+	       o1 +--------------+ o2
+
+	     */
+	    opt[0].x = opt[1].x = sw;
+	    opt[0].y = opt[3].y = newtop;
+	    opt[2].x = opt[3].x = th - sw;
+	    opt[2].y = opt[1].y = newbot;
+
+	    ipt[0].x = ipt[1].x = opt[0].x + sw;
+	    ipt[0].y = ipt[3].y = opt[0].y + sw;
+	    ipt[2].x = ipt[3].x = opt[2].x - sw;
+	    ipt[2].y = ipt[1].y = opt[2].y - sw;
+
+	    /* make sure shades don't overlap */
+	    if (ipt[0].x > ipt[3].x)
+		ipt[3].x = ipt[2].x = ipt[1].x = ipt[0].x = (ipt[0].x + ipt[3].x) / 2;
+	    if (ipt[0].y > ipt[1].y)
+		ipt[3].y = ipt[2].y = ipt[1].y = ipt[0].y = (ipt[0].y + ipt[1].y) / 2;
+	    if (sbw->scrollbar.orientation == XtorientHorizontal) {
+		int n;
+		for (n = 0; n < 4; n++) {
+		    swap(&ipt[n].x, &ipt[n].y);
+		    swap(&opt[n].x, &opt[n].y);
+		}
+	    }
+
+	    /* left */
+	    pt[0] = opt[0];
+	    pt[1] = opt[1];
+	    pt[2] = ipt[1];
+	    pt[3] = ipt[0];
+	    XFillPolygon (dpy, win, top, pt, 4, Convex, CoordModeOrigin);
+
+	    /* top */
+ 	    pt[0] = opt[0];
+	    pt[1] = opt[3];
+	    pt[2] = ipt[3];
+ 	    pt[3] = ipt[0];
+ 	    XFillPolygon (dpy, win, top, pt, 4, Convex, CoordModeOrigin);
+
+	    /* bottom */
+	    pt[0] = opt[1];
+	    pt[1] = opt[2];
+	    pt[2] = ipt[2];
+	    pt[3] = ipt[1];
+	    XFillPolygon (dpy, win, bot, pt, 4, Convex, CoordModeOrigin);
+
+	    /* right */
+	    pt[0] = opt[3];
+	    pt[1] = opt[2];
+	    pt[2] = ipt[2];
+	    pt[3] = ipt[3];
+	    XFillPolygon (dpy, win, bot, pt, 4, Convex, CoordModeOrigin);
+
+
+	} else {
+	    /* Return here if only the shadows should be repainted */
+	    if (shadow) return;
+
+	    /* 
+	     * Note to Mitch: FillArea is (now) correctly implemented to 
+	     * not draw over shadows or the arrows. Therefore setting clipmasks 
+	     * doesn't seem to be necessary.  Correct me if I'm wrong!
+	     */
+            if (newtop < oldtop) FillArea(sbw, newtop, MIN(newbot, oldtop), 1);
+            if (newtop > oldtop) FillArea(sbw, oldtop, MIN(newtop, oldbot), 0);
+            if (newbot < oldbot) FillArea(sbw, MAX(newbot, oldtop), oldbot, 0);
+            if (newbot > oldbot) FillArea(sbw, MAX(newtop, oldbot), newbot, 1);
+	}
     }
 }
 
 #ifdef XAW_ARROW_SCROLLBARS
-static void PaintArrows (sbw)
+static void PaintArrows (sbw, toppressed, botpressed)
     ScrollbarWidget sbw;
+    int toppressed, botpressed;
 {
-    XPoint    pt[20];
-    Dimension s   = sbw->threeD.shadow_width;
-    Dimension t   = sbw->scrollbar.thickness;
-    Dimension l   = sbw->scrollbar.length;
-    Dimension tms = t - s, lms = l - s;
-    Dimension tm1 = t - 1;
-    Dimension lmt = l - t;
-    Dimension lp1 = lmt + 1;
-    Dimension sm1 = s - 1;
-    Dimension t2  = t / 2;
-    Dimension sa30 = (Dimension)(1.732 * s );  /* cotangent of 30 deg */
-    Display   *dpy = XtDisplay (sbw);
-    Window    win = XtWindow (sbw);
-    GC        top = sbw->threeD.top_shadow_GC;
-    GC        bot = sbw->threeD.bot_shadow_GC;
-  
+    XPoint	ipt[6], opt[6];	/* inner and outer points */
+    XPoint	rpt[4];		/* the rectangle around arrows */
+    XPoint	tpt[6];		/* temporary for args to XFillPolygon */
+    Dimension	sw = sbw->threeD.shadow_width;
+    Dimension	th = sbw->scrollbar.thickness;
+    Dimension	len = sbw->scrollbar.length;
+    Display    *dpy = XtDisplay (sbw);
+    Window	win = XtWindow (sbw);
+    GC		top, bot;
+    GC		back = sbw->scrollbar.bgc;
+    GC		fore = sbw->scrollbar.gc;
 
     if (XtIsRealized ((Widget) sbw)) {
 	/* 3D arrows?
          */
-	if (s) {
-	    /* upper/right arrow */
-	    pt[0].x = sm1;         pt[0].y = tm1;
-	    pt[1].x = t2;          pt[1].y = sm1;
-	    pt[2].x = t2;          pt[2].y = s + sa30;
-	    pt[3].x = sm1 + sa30;  pt[3].y = tms - 1;
-
-	    pt[4].x = sm1;         pt[4].y = tm1;
-	    pt[5].x = tms;         pt[5].y = tm1;
-	    pt[6].x = t2;          pt[6].y = sm1;
-	    pt[7].x = t2;          pt[7].y = s + sa30;
-	    pt[8].x = tms - sa30;  pt[8].y = tms - 1;
-	    pt[9].x = sm1 + sa30;  pt[9].y = tms - 1;
-
-	    /* lower/left arrow */
-	    pt[10].x = tms;        pt[10].y = lp1;
-	    pt[11].x = s;          pt[11].y = lp1;
-	    pt[12].x = t2;         pt[12].y = lms;
-	    pt[13].x = t2;         pt[13].y = lms - sa30;
-	    pt[14].x = s + sa30;   pt[14].y = lmt + s + 1;
-	    pt[15].x = tms - sa30; pt[15].y = lmt + s + 1;
-
-	    pt[16].x = tms;        pt[16].y = lp1;
-	    pt[17].x = t2;         pt[17].y = lms;
-	    pt[18].x = t2;         pt[18].y = lms - sa30;
-	    pt[19].x = tms - sa30; pt[19].y = lmt + s + 1;
+	if (sw) {
+	    /*
+		The points are numbered like this:
+
+		r0 +---------+ r3
+		   |    ^ o2 |
+		   |   /|\   |   a = i0
+		   |  /c^ \  |   b = i1
+		   | / / \ \ |   c = i2
+		   |/a<--->b\|
+		o0 +---------+ o1
+		   |         |
+		   |         |
+		o3 +---------+ o4
+		   |\d<--->e/|
+		   | \ \ / / |   d = i3
+		   |  \fv /  |   e = i4
+		   |   \|/   |   f = i5
+		   |    v o5 |
+		r1 +---------+ r2
+	     */
+
+	    rpt[0].x = rpt[1].x = opt[0].x = opt[3].x = sw;
+	    ipt[0].x = ipt[3].x = sw * 2.5;
+	    opt[2].x = opt[5].x = ipt[2].x = ipt[5].x = th / 2;
+	    ipt[1].x = ipt[4].x = th - (int)(sw * 2.5);
+	    rpt[2].x = rpt[3].x = opt[1].x = opt[4].x = th - sw;
+
+	    rpt[0].y = rpt[3].y = opt[2].y = sw;
+	    ipt[2].y = sw * 3.2;
+	    ipt[0].y = ipt[1].y = th - sw;
+	    opt[0].y = opt[1].y = th;
+	    opt[3].y = opt[4].y = len - th;
+	    ipt[3].y = ipt[4].y = len - th + sw;
+	    ipt[5].y = len - (int)(sw * 3.2);
+	    rpt[1].y = rpt[2].y = opt[5].y = len - sw;
+
+            /* some ugly kludges to make them look right */
+	    opt[2].y--;
+	    opt[0].x--;
+	    ipt[2].y--;
+	    ipt[0].x--;
+
+            /* make sure shades don't overlap */
+	    if (ipt[0].x > ipt[1].x) {
+		Dimension tmp = (ipt[0].x + ipt[1].x) / 2;
+		ipt[4].x = ipt[3].x = ipt[1].x = ipt[0].x = tmp;
+	    }
+            if (ipt[0].y < ipt[2].y) {
+		ipt[2].y = ipt[1].y = ipt[0].y = (ipt[0].y + ipt[2].y) / 2;
+		ipt[5].y = ipt[4].y = ipt[3].y = (ipt[3].y + ipt[5].y) / 2;
+            }
 
-	    /* horizontal arrows require that x and y coordinates be swapped */
+            /* horizontal arrows require that x and y coordinates be swapped */
 	    if (sbw->scrollbar.orientation == XtorientHorizontal) {
 		int n;
-		int swap;
-		for (n = 0; n < 20; n++) {
-		    swap = pt[n].x;
-		    pt[n].x = pt[n].y;
-		    pt[n].y = swap;
+		for (n = 0; n < 6; n++) {
+		    swap(&ipt[n].x, &ipt[n].y);
+		    swap(&opt[n].x, &opt[n].y);
 		}
+		for (n = 0; n < 4; n++)
+		swap(&rpt[n].x, &rpt[n].y);
+	    }
+
+	    if (toppressed ^ sbw->threeD.invert_border) {
+		top = sbw->threeD.bot_shadow_GC;
+		bot = sbw->threeD.top_shadow_GC;
+	    } else {
+		top = sbw->threeD.top_shadow_GC;
+		bot = sbw->threeD.bot_shadow_GC;
+	    }
+
+	    /* top-left background */
+	    tpt[0] = rpt[0];
+	    tpt[1] = opt[0];
+	    tpt[2] = opt[2];
+	    XFillPolygon (dpy, win, back, tpt, 3, Convex, CoordModeOrigin);
+
+	    /* top-right background */
+	    tpt[0] = rpt[3];
+	    tpt[1] = opt[2];
+	    tpt[2] = opt[1];
+	    XFillPolygon (dpy, win, back, tpt, 3, Convex, CoordModeOrigin);
+
+	    /* the right shade */
+	    tpt[0] = opt[1];
+	    tpt[1] = opt[2];
+	    tpt[2] = ipt[2];
+	    tpt[3] = ipt[1];
+	    XFillPolygon (dpy, win, bot, tpt, 4, Convex, CoordModeOrigin);
+
+	    /* the left shade */
+	    tpt[0] = opt[2];
+	    tpt[1] = opt[0];
+	    tpt[2] = ipt[0];
+	    tpt[3] = ipt[2];
+	    XFillPolygon (dpy, win, top, tpt, 4, Convex, CoordModeOrigin);
+
+	    /* the bottom shade */
+	    tpt[0] = opt[0];
+	    tpt[1] = opt[1];
+	    tpt[2] = ipt[1];
+	    tpt[3] = ipt[0];
+	    XFillPolygon (dpy, win, bot, tpt, 4, Convex, CoordModeOrigin);
+
+	    /* the arrow itself */
+	    XFillPolygon (dpy, win, fore, ipt, 3, Convex, CoordModeOrigin);
+
+	    if (botpressed ^ sbw->threeD.invert_border) {
+		top = sbw->threeD.bot_shadow_GC;
+		bot = sbw->threeD.top_shadow_GC;
+	    } else {
+		top = sbw->threeD.top_shadow_GC;
+		bot = sbw->threeD.bot_shadow_GC;
 	    }
-	    XFillPolygon (dpy, win, top, pt, 4, Complex, CoordModeOrigin);
-	    XFillPolygon (dpy, win, bot, pt + 4, 6, Complex, CoordModeOrigin);
-	    XFillPolygon (dpy, win, top, pt + 10, 6, Complex, CoordModeOrigin);
-	    XFillPolygon (dpy, win, bot, pt + 16, 4, Complex, CoordModeOrigin);
+
+	    /* bottom-left background */
+	    tpt[0] = rpt[1];
+	    tpt[1] = opt[5];
+	    tpt[2] = opt[3];
+	    XFillPolygon (dpy, win, back, tpt, 3, Convex, CoordModeOrigin);
+
+	    /* bottom-right background */
+	    tpt[0] = rpt[2];
+	    tpt[1] = opt[4];
+	    tpt[2] = opt[5];
+	    XFillPolygon (dpy, win, back, tpt, 3, Convex, CoordModeOrigin);
+
+	    /* the left shade */
+	    tpt[0] = opt[3];
+	    tpt[1] = opt[5];
+	    tpt[2] = ipt[5];
+	    tpt[3] = ipt[3];
+	    XFillPolygon (dpy, win, top, tpt, 4, Convex, CoordModeOrigin);
+
+	    /* the right shade */
+	    tpt[0] = opt[5];
+	    tpt[1] = opt[4];
+	    tpt[2] = ipt[4];
+	    tpt[3] = ipt[5];
+	    XFillPolygon (dpy, win, bot, tpt, 4, Convex, CoordModeOrigin);
+
+	    /* the top shade */
+	    tpt[0] = opt[4];
+	    tpt[1] = opt[3];
+	    tpt[2] = ipt[3];
+	    tpt[3] = ipt[4];
+	    XFillPolygon (dpy, win, top, tpt, 4, Convex, CoordModeOrigin);
+
+	    /* the arrow itself */
+	    XFillPolygon (dpy, win, fore, ipt+3, 3, Convex, CoordModeOrigin);
 
 	} else {
-	    pt[0].x = 0;      pt[0].y = tm1;
-	    pt[1].x = t;      pt[1].y = tm1;
-	    pt[2].x = t2;     pt[2].y = 0;
-      
-	    pt[3].x = 0;      pt[3].y = lp1;
-	    pt[4].x = t;      pt[4].y = lp1;
-	    pt[5].x = t2;     pt[5].y = l;
+
+	    tpt[0] = opt[0];
+	    tpt[1] = opt[1];
+	    tpt[2] = opt[2];
+	    tpt[3] = opt[3];
+	    tpt[4] = opt[4];
+	    tpt[5] = opt[5];
 
 	    /* horizontal arrows require that x and y coordinates be swapped */
 	    if (sbw->scrollbar.orientation == XtorientHorizontal) {
 		int n;
-		int swap;
-		for (n = 0; n < 6; n++) {
-		    swap = pt[n].x;
-		    pt[n].x = pt[n].y;
-		    pt[n].y = swap;
-		}
+		for (n = 0; n < 6; n++)
+		    swap(&tpt[n].x, &tpt[n].y);
 	    }
+
 	    /* draw the up/left arrow */
-	    XFillPolygon (dpy, win, sbw->scrollbar.gc, 
-			  pt, 3, 
-			  Convex, CoordModeOrigin);
+	    XFillPolygon (dpy, win, fore, tpt, 3, Convex, CoordModeOrigin);
+
 	    /* draw the down/right arrow */
-	    XFillPolygon (dpy, win, sbw->scrollbar.gc, 
-			  pt+3, 3, 
-			  Convex, CoordModeOrigin);
+	    XFillPolygon (dpy, win, fore, tpt+3, 3, Convex, CoordModeOrigin);
+
 	}
     }
 }
@@ -469,12 +696,13 @@ static void Destroy (w)
 	XtRemoveTimeOut (sbw->scrollbar.timer_id);
 #endif
     XtReleaseGC (w, sbw->scrollbar.gc);
+    XtReleaseGC (w, sbw->scrollbar.bgc);
 }
 
 /*	Function Name: CreateGC
  *	Description: Creates the GC.
  *	Arguments: w - the scrollbar widget.
- *	Returns: none. 
+ *	Returns: none.
  */
 
 static void CreateGC (w)
@@ -485,9 +713,22 @@ static void CreateGC (w)
     XtGCMask mask;
     unsigned int depth = 1;
 
+    /* make GC for scrollbar background */
+    if (sbw->threeD.be_nice_to_cmap ||
+	DefaultDepthOfScreen (XtScreen(w)) == 1) {
+	mask = GCTile | GCFillStyle;
+	gcValues.tile = sbw->threeD.bot_shadow_pxmap;
+	gcValues.fill_style = FillTiled;
+    } else {
+	mask = GCForeground;
+	gcValues.foreground = sbw->scrollbar.background;
+    }
+    sbw->scrollbar.bgc = XtGetGC(w, mask, &gcValues);
+
+    /* make GC for scrollbar foreground */
     if (sbw->scrollbar.thumb == XtUnspecifiedPixmap) {
-        sbw->scrollbar.thumb = XmuCreateStippledPixmap (XtScreen(w), 
-					(Pixel) 1, (Pixel) 0, depth);
+        sbw->scrollbar.thumb = XmuCreateStippledPixmap (XtScreen(w),
+					(Pixel) 0, (Pixel) 0, depth);
     } else if (sbw->scrollbar.thumb != None) {
 	Window root;
 	int x, y;
@@ -518,6 +759,9 @@ static void CreateGC (w)
     /* the creation should be non-caching, because */
     /* we now set and clear clip masks on the gc returned */
     sbw->scrollbar.gc = XtGetGC (w, mask, &gcValues);
+    gcValues.foreground = sbw->scrollbar.foreground;
+    gcValues.background = sbw->core.background_pixel;
+    mask = GCForeground | GCBackground;
 }
 
 static void SetDimensions (sbw)
@@ -581,10 +825,10 @@ static void Realize (w, valueMask, attributes)
 
     XtVaSetValues (w, XtNcursor, sbw->scrollbar.inactiveCursor, NULL);
 #endif
-    /* 
-     * The Simple widget actually stuffs the value in the valuemask. 
+    /*
+     * The Simple widget actually stuffs the value in the valuemask.
      */
-    
+
     (*scrollbarWidgetClass->core_class.superclass->core_class.realize)
 	(w, valueMask, attributes);
 }
@@ -617,8 +861,10 @@ static Boolean SetValues (current, request, desired, args, num_args)
     if (XtIsRealized (desired)) {
 	if (sbw->scrollbar.foreground != dsbw->scrollbar.foreground ||
 	    sbw->core.background_pixel != dsbw->core.background_pixel ||
-	    sbw->scrollbar.thumb != dsbw->scrollbar.thumb) {
+	    sbw->scrollbar.thumb != dsbw->scrollbar.thumb ||
+	    sbw->scrollbar.background != dsbw->scrollbar.background) {
 	    XtReleaseGC (desired, sbw->scrollbar.gc);
+	    XtReleaseGC (desired, sbw->scrollbar.bgc);
 	    CreateGC (desired);
 	    redraw = TRUE;
 	}
@@ -667,11 +913,15 @@ static void Redisplay (w, event, region)
 	XRectInRegion (region, x, y, width, height) != RectangleOut) {
 	/* Forces entire thumb to be painted. */
 	sbw->scrollbar.topLoc = -(sbw->scrollbar.length + 1);
-	PaintThumb (sbw, event); 
+	PaintThumb (sbw, 0, 0); 
+    } else {
+	/* Redraw the surounding shadows of the thumb */
+	PaintThumb (sbw, 0, 1); 
     }
+
 #ifdef XAW_ARROW_SCROLLBARS
     /* we'd like to be region aware here!!!! */
-    PaintArrows (sbw);
+    PaintArrows (sbw, 0, 0);
 #endif
 
 }
@@ -688,23 +938,23 @@ static Boolean CompareEvents (oldEvent, newEvent)
 
     switch (newEvent->type) {
     case MotionNotify:
-	Check(xmotion.state); 
+	Check(xmotion.state);
 	break;
     case ButtonPress:
     case ButtonRelease:
 	Check(xbutton.state);
-	Check(xbutton.button); 
+	Check(xbutton.button);
 	break;
     case KeyPress:
     case KeyRelease:
 	Check(xkey.state);
-	Check(xkey.keycode); 
+	Check(xkey.keycode);
 	break;
     case EnterNotify:
     case LeaveNotify:
 	Check(xcrossing.mode);
 	Check(xcrossing.detail);
-	Check(xcrossing.state); 
+	Check(xcrossing.state);
 	break;
     }
 #undef Check
@@ -753,23 +1003,23 @@ static void ExtractPosition (event, x, y)
 {
     switch( event->type ) {
     case MotionNotify:
-	*x = event->xmotion.x;	 
-	*y = event->xmotion.y;	  
+	*x = event->xmotion.x;
+	*y = event->xmotion.y;
 	break;
     case ButtonPress:
     case ButtonRelease:
-	*x = event->xbutton.x;   
-	*y = event->xbutton.y;   
+	*x = event->xbutton.x;
+	*y = event->xbutton.y;
 	break;
     case KeyPress:
     case KeyRelease:
-	*x = event->xkey.x;      
-	*y = event->xkey.y;	  
+	*x = event->xkey.x;
+	*y = event->xkey.y;
 	break;
     case EnterNotify:
     case LeaveNotify:
-	*x = event->xcrossing.x; 
-	*y = event->xcrossing.y; 
+	*x = event->xcrossing.x;
+	*y = event->xcrossing.y;
 	break;
     default:
 	*x = 0; *y = 0;
@@ -792,7 +1042,8 @@ static void HandleThumb (w, event, params, num_params)
     /* also call Move and Notify if we're already in continuous scroll mode */
     if (sbw->scrollbar.scroll_mode == 2 ||
 	(PICKLENGTH (sbw,x,y) >= sbw->scrollbar.topLoc &&
-	PICKLENGTH (sbw,x,y) <= sbw->scrollbar.topLoc + sbw->scrollbar.shownLength)){
+	 PICKLENGTH (sbw,x,y) <= (sbw->scrollbar.topLoc +
+				  sbw->scrollbar.shownLength))){
 	XtCallActionProc(w, "MoveThumb", event, params, *num_params);
 	XtCallActionProc(w, "NotifyThumb", event, params, *num_params);
     }
@@ -812,8 +1063,8 @@ static void RepeatNotify (client_data, idp)
     call_data = MAX (A_FEW_PIXELS, sbw->scrollbar.length / 20);
     if (sbw->scrollbar.scroll_mode == 1)
 	call_data = -call_data;
-    XtCallCallbacks((Widget)sbw, XtNscrollProc, (XtPointer) call_data);
-    sbw->scrollbar.timer_id = 
+    XtCallCallbacks((Widget)sbw, XtNscrollProc, (XtPointer)(long)call_data);
+    sbw->scrollbar.timer_id =
     XtAppAddTimeOut(XtWidgetToApplicationContext((Widget)sbw),
 		    (unsigned long) 150,
 		    RepeatNotify,
@@ -833,7 +1084,7 @@ static void StartScroll (w, event, params, num_params )
     char direction;
 
     if (sbw->scrollbar.direction != 0) return; /* if we're already scrolling */
-    if (*num_params > 0) 
+    if (*num_params > 0)
 	direction = *params[0];
     else
 	direction = 'C';
@@ -842,24 +1093,24 @@ static void StartScroll (w, event, params, num_params )
 
     switch (direction) {
     case 'B':
-    case 'b':	
+    case 'b':
 	cursor = (sbw->scrollbar.orientation == XtorientVertical)
 			? sbw->scrollbar.downCursor
-			: sbw->scrollbar.rightCursor; 
+			: sbw->scrollbar.rightCursor;
 	break;
     case 'F':
     case 'f':
 	cursor = (sbw->scrollbar.orientation == XtorientVertical)
 			? sbw->scrollbar.upCursor
-			: sbw->scrollbar.leftCursor; 
+			: sbw->scrollbar.leftCursor;
 	break;
     case 'C':
     case 'c':
 	cursor = (sbw->scrollbar.orientation == XtorientVertical)
 			? sbw->scrollbar.rightCursor
-			: sbw->scrollbar.upCursor; 
+			: sbw->scrollbar.upCursor;
 	break;
-    default:	
+    default:
 	return; /* invalid invocation */
     }
     XtVaSetValues (w, XtNcursor, cursor, NULL);
@@ -881,7 +1132,7 @@ static int InRange(num, small, big)
 #endif
 
 /*
- * Same as above, but for floating numbers. 
+ * Same as above, but for floating numbers.
  */
 
 static float FloatInRange(num, small, big)
@@ -895,15 +1146,15 @@ static float FloatInRange(num, small, big)
 static void NotifyScroll (w, event, params, num_params)
     Widget w;
     XEvent *event;
-    String *params;		
-    Cardinal *num_params;	
+    String *params;
+    Cardinal *num_params;
 {
     ScrollbarWidget sbw = (ScrollbarWidget) w;
     int call_data;
     Position x, y;
 
     if (sbw->scrollbar.scroll_mode == 2  /* if scroll continuous */
-	|| LookAhead (w, event)) 
+	|| LookAhead (w, event))
 	return;
 
     ExtractPosition (event, &x, &y);
@@ -911,33 +1162,36 @@ static void NotifyScroll (w, event, params, num_params)
     if (PICKLENGTH (sbw,x,y) < sbw->scrollbar.thickness) {
 	/* handle first arrow zone */
 	call_data = -MAX (A_FEW_PIXELS, sbw->scrollbar.length / 20);
-	XtCallCallbacks (w, XtNscrollProc, (XtPointer)(call_data));
+	XtCallCallbacks (w, XtNscrollProc, (XtPointer)(long)call_data);
 	/* establish autoscroll */
-	sbw->scrollbar.timer_id = 
+	sbw->scrollbar.timer_id =
 	    XtAppAddTimeOut (XtWidgetToApplicationContext (w),
 				(unsigned long) 300, RepeatNotify, (XtPointer)w);
 	sbw->scrollbar.scroll_mode = 1;
+	PaintArrows (sbw, 1, 0);
     } else if (PICKLENGTH (sbw,x,y) > sbw->scrollbar.length - sbw->scrollbar.thickness) {
 	/* handle last arrow zone */
 	call_data = MAX (A_FEW_PIXELS, sbw->scrollbar.length / 20);
-	XtCallCallbacks (w, XtNscrollProc, (XtPointer)(call_data));
+	XtCallCallbacks (w, XtNscrollProc, (XtPointer)(long)call_data);
 	/* establish autoscroll */
 	sbw->scrollbar.timer_id =
-	    XtAppAddTimeOut (XtWidgetToApplicationContext (w), 
+	    XtAppAddTimeOut (XtWidgetToApplicationContext (w),
 				(unsigned long) 300, RepeatNotify, (XtPointer)w);
 	sbw->scrollbar.scroll_mode = 3;
+	PaintArrows (sbw, 0, 1);
     } else if (PICKLENGTH (sbw, x, y) < sbw->scrollbar.topLoc) {
 	/* handle zone "above" the thumb */
-	call_data = - sbw->scrollbar.length;
-	XtCallCallbacks (w, XtNscrollProc, (XtPointer)(call_data));
+	call_data = - (sbw->scrollbar.length);
+	XtCallCallbacks (w, XtNscrollProc, (XtPointer)(long)call_data);
     } else if (PICKLENGTH (sbw, x, y) > sbw->scrollbar.topLoc + sbw->scrollbar.shownLength) {
 	/* handle zone "below" the thumb */
 	call_data = sbw->scrollbar.length;
-	XtCallCallbacks (w, XtNscrollProc, (XtPointer)(call_data));
-    } else 
-	{
+	XtCallCallbacks (w, XtNscrollProc, (XtPointer)(long)call_data);
+    } else {
 	/* handle the thumb in the motion notify action */
-	}
+	/* but we need to re-paint it "pressed in" here */
+	PaintThumb (sbw, 1, 0);
+    }
     return;
 }
 #else /* XAW_ARROW_SCROLLBARS */
@@ -954,7 +1208,7 @@ static void NotifyScroll (w, event, params, num_params)
 
     if (sbw->scrollbar.direction == 0) return; /* if no StartScroll */
     if (LookAhead (w, event)) return;
-    if (*num_params > 0) 
+    if (*num_params > 0)
 	style = *params[0];
     else
 	style = 'P';
@@ -963,24 +1217,24 @@ static void NotifyScroll (w, event, params, num_params)
     case 'P':    /* Proportional */
     case 'p':
 	ExtractPosition (event, &x, &y);
-	call_data = 
-	    InRange (PICKLENGTH (sbw, x, y), 0, (int) sbw->scrollbar.length); 
+	call_data =
+	    InRange (PICKLENGTH (sbw, x, y), 0, (int) sbw->scrollbar.length);
 	break;
 
     case 'F':    /* FullLength */
-    case 'f':    
-	call_data = sbw->scrollbar.length; 
+    case 'f':
+	call_data = sbw->scrollbar.length;
 	break;
     }
     switch (sbw->scrollbar.direction) {
     case 'B':
-    case 'b':    
+    case 'b':
 	call_data = -call_data;
 	/* fall through */
 
     case 'F':
-    case 'f':    
-	XtCallCallbacks (w, XtNscrollProc, (XtPointer)call_data);
+    case 'f':
+	XtCallCallbacks (w, XtNscrollProc, (XtPointer)(long)call_data);
 	break;
 
     case 'C':
@@ -1005,6 +1259,9 @@ static void EndScroll(w, event, params, num_params )
     /* no need to remove any autoscroll timeout; it will no-op */
     /* because the scroll_mode is 0 */
     /* but be sure to remove timeout in destroy proc */
+    /* release all buttons */
+    PaintArrows (sbw, 0, 0);
+    PaintThumb (sbw, 0, 0);
 #else
     XtVaSetValues (w, XtNcursor, sbw->scrollbar.inactiveCursor, NULL);
     XFlush (XtDisplay (w));
@@ -1055,7 +1312,7 @@ static void MoveThumb (w, event, params, num_params)
 #ifdef XAW_ARROW_SCROLLBARS
     if (sbw->scrollbar.scroll_mode != 2 )
       /* initialize picked position */
-      sbw->scrollbar.picked = (FloatInRange( loc, t, t + s ) - t);
+      sbw->scrollbar.picked = (FloatInRange(loc, t, t+s) - t);
 #else
     sbw->scrollbar.picked = 0.5 * s;
 #endif
@@ -1074,7 +1331,7 @@ static void MoveThumb (w, event, params, num_params)
 #ifdef XAW_ARROW_SCROLLBARS
     sbw->scrollbar.scroll_mode = 2; /* indicate continuous scroll */
 #endif
-    PaintThumb (sbw, event);
+    PaintThumb (sbw, 1, 0);
     XFlush (XtDisplay (w));	/* re-draw it before Notifying */
 }
 
@@ -1164,6 +1421,6 @@ void XawScrollbarSetThumb (w, top, shown)
     sbw->scrollbar.shown = (shown > 1.0) ? 1.0 :
 				(shown >= 0.0) ? shown : sbw->scrollbar.shown;
 
-    PaintThumb (sbw, NULL);
+    PaintThumb (sbw, 0, 0);
 }
 
diff --git a/xc/lib/Xaw3d/Scrollbar.h b/xc/lib/Xaw3d/Scrollbar.h
index 2821018..0c84582 100644
--- a/xc/lib/Xaw3d/Scrollbar.h
+++ b/xc/lib/Xaw3d/Scrollbar.h
@@ -94,6 +94,7 @@ SOFTWARE.
  scrollRCursor	     Cursor		Cursor		XC_sb_right_arrow
  scrollUCursor	     Cursor		Cursor		XC_sb_up_arrow
  scrollVCursor	     Cursor		Cursor		XC_sb_v_double_arrow
+ scrollbarBackground ScrollbarBackground Pixel		XtDefaultForeground
  sensitive	     Sensitive		Boolean		True
  shown		     Shown		Float		0.0
  thickness	     Thickness		Dimension	14
@@ -101,6 +102,7 @@ SOFTWARE.
  thumbProc	     Callback		XtCallbackList	NULL
  topOfThumb	     TopOfThumb		Float		0.0
  pickTop	     PickTop		Boolean		False
+ pushThumb	     PushThumb		Boolean		True
  translations	     Translations	TranslationTable see source or doc
  width		     Width		Dimension	thickness or length
  x		     Position		Position	0
@@ -115,11 +117,15 @@ SOFTWARE.
 #define XtCMinimumThumb "MinimumThumb"
 #define XtCShown "Shown"
 #define XtCTopOfThumb "TopOfThumb"
+#define XtCScrollbarBackground "ScrollbarBackground"
 #define XtCPickTop "PickTop"
+#define XtCPushThumb "PushThumb"
 
 #define XtNminimumThumb "minimumThumb"
 #define XtNtopOfThumb "topOfThumb"
+#define XtNscrollbarBackground "scrollbarBackground"
 #define XtNpickTop "pickTop"
+#define XtNpushThumb "pushThumb"
 
 typedef struct _ScrollbarRec	  *ScrollbarWidget;
 typedef struct _ScrollbarClassRec *ScrollbarWidgetClass;
diff --git a/xc/lib/Xaw3d/ScrollbarP.h b/xc/lib/Xaw3d/ScrollbarP.h
index d4c8b72..5573e1d 100644
--- a/xc/lib/Xaw3d/ScrollbarP.h
+++ b/xc/lib/Xaw3d/ScrollbarP.h
@@ -70,6 +70,7 @@ typedef struct {
     XtCallbackList thumbProc;	/* jump (to position) scroll */
     XtCallbackList jumpProc;	/* same as thumbProc but pass data by ref */
     Pixmap	  thumb;	/* thumb color */
+    Pixel 	  background;	/* background color */
 #ifndef XAW_ARROW_SCROLLBARS
     Cursor        upCursor;	/* scroll up cursor */
     Cursor        downCursor;	/* scroll down cursor */
@@ -94,10 +95,12 @@ typedef struct {
     Cursor        inactiveCursor; /* the normal cursor for scrollbar */
     char          direction;	/* a scroll has started; which direction */
 #endif
-    GC		  gc;		/* a (shared) gc */
+    GC		  gc;		/* a (shared) gc for foreground */
+    GC		  bgc;		/* a (shared) gc for background */
     Position	  topLoc;	/* Pixel that corresponds to top */
     Dimension	  shownLength;	/* Num pixels corresponding to shown */
-    Boolean       pick_top;     /* pick thumb at top or anywhere*/
+    Boolean       pick_top;     /* pick thumb at top or anywhere */
+    Boolean       push_thumb;   /* push thumb in or not */
 
 } ScrollbarPart;
 
diff --git a/xc/lib/Xaw3d/SimpleMenu.c b/xc/lib/Xaw3d/SimpleMenu.c
index 2bf439d..96a1a61 100644
--- a/xc/lib/Xaw3d/SimpleMenu.c
+++ b/xc/lib/Xaw3d/SimpleMenu.c
@@ -547,7 +547,7 @@ Cardinal *num_args;
 	XDefineCursor(XtDisplay(new),
 		      XtWindow(new), smw_new->simple_menu.cursor);
     
-    if (smw_old->simple_menu.label_string !=smw_new->simple_menu.label_string) 
+    if (smw_old->simple_menu.label_string !=smw_new->simple_menu.label_string) {
 	if (smw_new->simple_menu.label_string == NULL)         /* Destroy. */
 	    XtDestroyWidget((Widget) smw_old->simple_menu.label);
 	else if (smw_old->simple_menu.label_string == NULL)    /* Create. */
@@ -558,6 +558,7 @@ Cardinal *num_args;
 	    XtSetArg(arglist[0], XtNlabel, smw_new->simple_menu.label_string);
 	    XtSetValues((Widget) smw_new->simple_menu.label, arglist, ONE);
 	}
+    }
     
     if (smw_old->simple_menu.label_class != smw_new->simple_menu.label_class)
 	XtAppWarning(XtWidgetToApplicationContext(new),
diff --git a/xc/lib/Xaw3d/SmeThreeD.c b/xc/lib/Xaw3d/SmeThreeD.c
index a01023c..ee4374c 100644
--- a/xc/lib/Xaw3d/SmeThreeD.c
+++ b/xc/lib/Xaw3d/SmeThreeD.c
@@ -71,7 +71,9 @@ static XtResource resources[] = {
 	offset(sme_threeD.shadowed), XtRImmediate, (XtPointer) False},
     {XtNborderWidth, XtCBorderWidth, XtRDimension, sizeof(Dimension),
 	XtOffsetOf(RectObjRec,rectangle.border_width), XtRImmediate,
-	(XtPointer)0}
+	(XtPointer)0},
+    {XtNinvertBorder, XtCInvertBorder, XtRBoolean, sizeof(Boolean),
+	offset(sme_threeD.invert_border), XtRImmediate, (XtPointer) False},
 };
 
 #undef offset
@@ -209,7 +211,7 @@ static void AllocTopShadowPixmap (new)
     Display		*dpy = XtDisplayOfObject (new);
     Screen		*scn = XtScreenOfObject (new);
     unsigned long	top_fg_pixel = 0, top_bg_pixel = 0;
-    char		*pm_data;
+    char		*pm_data = NULL;
     Boolean		create_pixmap = FALSE;
 
     /*
@@ -265,7 +267,7 @@ static void AllocBotShadowPixmap (new)
     Display		*dpy = XtDisplayOfObject (new);
     Screen		*scn = XtScreenOfObject (new);
     unsigned long	bot_fg_pixel = 0, bot_bg_pixel = 0;
-    char		*pm_data;
+    char		*pm_data  = NULL;
     Boolean		create_pixmap = FALSE;
 
     if (DefaultDepthOfScreen (scn) == 1) {
@@ -568,8 +570,16 @@ _XawSme3dDrawShadows(gw)
 
 	if (tdo->sme_threeD.shadowed)
 	{
-	    top = tdo->sme_threeD.top_shadow_GC;
-	    bot = tdo->sme_threeD.bot_shadow_GC;
+	    if (tdo->sme_threeD.invert_border)
+	    {
+		bot = tdo->sme_threeD.top_shadow_GC;
+		top = tdo->sme_threeD.bot_shadow_GC;
+	    }
+	    else
+	    {
+		top = tdo->sme_threeD.top_shadow_GC;
+		bot = tdo->sme_threeD.bot_shadow_GC;
+	    }
 	}
 	else
 	    top = bot = tdo->sme_threeD.erase_GC;
diff --git a/xc/lib/Xaw3d/SmeThreeD.h b/xc/lib/Xaw3d/SmeThreeD.h
index b4d458f..bcffb8f 100644
--- a/xc/lib/Xaw3d/SmeThreeD.h
+++ b/xc/lib/Xaw3d/SmeThreeD.h
@@ -50,6 +50,7 @@ SOFTWARE.
  bottomShadowContrast BottomShadowContrast Int           40
  userData             UserData             XtPointer     NULL
  beNiceToColormap     BeNiceToColormap     Boolean       False
+ invertBorder         InvertBorder         Boolean       False
 
 */
 
@@ -67,6 +68,8 @@ SOFTWARE.
 #define XtCBeNiceToColormap "BeNiceToColormap"
 #define XtNbeNiceToColourmap "beNiceToColormap"
 #define XtCBeNiceToColourmap "BeNiceToColormap"
+#define XtNinvertBorder "invertBorder"
+#define XtCInvertBorder "InvertBorder"
 #define XtNuserData "userData"
 #define XtCUserData "UserData"
 
diff --git a/xc/lib/Xaw3d/SmeThreeDP.h b/xc/lib/Xaw3d/SmeThreeDP.h
index a07dd40..15e222a 100644
--- a/xc/lib/Xaw3d/SmeThreeDP.h
+++ b/xc/lib/Xaw3d/SmeThreeDP.h
@@ -47,6 +47,7 @@ typedef struct {
     XtPointer	    user_data;
     Boolean	    be_nice_to_cmap;
     Boolean	    shadowed;
+    Boolean	    invert_border;
   } SmeThreeDPart;
 
 /* Full instance record declaration */
diff --git a/xc/lib/Xaw3d/StripChart.c b/xc/lib/Xaw3d/StripChart.c
index 5344f97..14e808d 100644
--- a/xc/lib/Xaw3d/StripChart.c
+++ b/xc/lib/Xaw3d/StripChart.c
@@ -292,7 +292,7 @@ XtIntervalId *id;		/* unused */
        if (XtIsRealized((Widget)w) && 
 	   w->strip_chart.max_value > w->strip_chart.scale) {
 	   XClearWindow(XtDisplay ((Widget) w), XtWindow ((Widget) w));
-	   w->strip_chart.interval = repaint_window((Widget)w, 0, (int) w->core.width - 2 * s);
+	   w->strip_chart.interval = repaint_window((Widget)w, 0, (int) w->core.width);
 	   (*swclass->threeD_class.shadowdraw) ((Widget) w, 
 						(XEvent *)0, (Region)0, 
 						w->threeD.relief, FALSE);
@@ -346,6 +346,7 @@ int left, width;
     int next = w->strip_chart.interval;
     int scale = w->strip_chart.scale;
     int scalewidth = 0;
+    int margin = w->core.width - s;
 
     /* Compute the minimum scale required to graph the data, but don't go
        lower than min_scale. */
@@ -358,7 +359,7 @@ int left, width;
       w->strip_chart.scale = scale;
       left = 0;
       width = next;				/* check this */
-      scalewidth = w->core.width - 2 * s;
+      scalewidth = w->core.width - 2 * s - 1;
 
       SetPoints(gw);
 
@@ -373,10 +374,18 @@ int left, width;
 	Display *dpy = XtDisplay(gw);
 	Window win = XtWindow(gw);
 
-	width += left - 1;
-	if (!scalewidth) scalewidth = width;
+	if (left < s) left = 0;
+	else left -= s;
+	if (left >= margin) left = margin - 1;
 
-	if (next < (++width - s)) width = next + s;
+	width += (left - 1);
+
+	if (!scalewidth) {
+	    scalewidth = w->core.width - 2 * s - 1;
+	    if (width < scalewidth) scalewidth = width;
+	}
+
+	if (next < ++width) width = next;
 
 	/* Draw data point lines. */
 	for (i = left; i < width; i++) {
@@ -390,7 +399,7 @@ int left, width;
 	}
 
 	/* Draw graph reference lines */
-	for (i = 1; i < w->strip_chart.scale; i++) {
+	if (left <= scalewidth) for (i = 1; i < w->strip_chart.scale; i++) {
             j = i * ((w->core.height - 2 * s) / w->strip_chart.scale);
 	    XDrawLine(dpy, win, w->strip_chart.hiGC, 
 		left + s, j + s, scalewidth + s, j + s);
@@ -415,6 +424,7 @@ Boolean blit;
     double old_max;
     int left, i, j;
     int next = w->strip_chart.interval;
+    int margin = w->core.width - s;
 
     if (!XtIsRealized((Widget) w)) return;
 
@@ -447,7 +457,7 @@ Boolean blit;
 
     if ( ((int) old_max) != ( (int) w->strip_chart.max_value) ) {
       XClearWindow(XtDisplay(w), XtWindow(w));
-      repaint_window((Widget)w, 0, w->core.width - 2 * s);
+      repaint_window((Widget)w, 0, w->core.width);
       return;
     }
 
@@ -466,12 +476,13 @@ Boolean blit;
 	       FALSE);
 
     /* Draw graph reference lines */
-    left = j;
-    for (i = 1; i < w->strip_chart.scale; i++) {
-	j = i * ((w->core.height - 2 * s) / w->strip_chart.scale);
-	XDrawLine(XtDisplay((Widget) w), XtWindow( (Widget) w),
-	    w->strip_chart.hiGC, 
-	    left, j + s, ((int)w->core.width - s - 1), j + s);
+    if ((left = j) < margin) {
+	for (i = 1; i < w->strip_chart.scale; i++) {
+	    j = i * ((w->core.height - 2 * s) / w->strip_chart.scale);
+	    XDrawLine(XtDisplay((Widget) w), XtWindow( (Widget) w),
+		w->strip_chart.hiGC, 
+		left, j + s, margin - 1, j + s);
+	}
     }
     return;
 }
@@ -523,7 +534,7 @@ static Boolean SetValues (current, request, new, args, num_args)
  *	Returns: none.
  */
 
-#define HEIGHT ( (unsigned int) w->core.height)
+#define HEIGHT ( (double)w->core.height - 2.0 * (double)s )
 
 static void
 SetPoints(widget)
@@ -550,7 +561,7 @@ Widget widget;
 
     for (i = 1; i < w->strip_chart.scale; i++) {
 	points[i - 1].x = 0;
-	points[i - 1].y = ( short)(((double)w->core.height - 2.0 * (double) s) / (double) w->strip_chart.scale );
+	points[i - 1].y = (short)(HEIGHT / (double) w->strip_chart.scale);
     }
     points[0].y += (short)s;
 }
diff --git a/xc/lib/Xaw3d/Text.c b/xc/lib/Xaw3d/Text.c
index 32a3f8d..1716890 100644
--- a/xc/lib/Xaw3d/Text.c
+++ b/xc/lib/Xaw3d/Text.c
@@ -1150,11 +1150,12 @@ TextWidget ctx;
 	_XawTextBuildLineTable (ctx, zeroPosition, FALSE);
     }
   }
-  else if (ctx->text.vbar != NULL)
+  else if (ctx->text.vbar != NULL) {
     if (ctx->text.scroll_vert == XawtextScrollWhenNeeded)
       DestroyVScrollBar(ctx);
     else if (ctx->text.scroll_vert == XawtextScrollAlways)
       XawScrollbarSetThumb(ctx->text.vbar, 0.0, 1.0);
+  }
 }
 
 /*
@@ -1182,11 +1183,12 @@ TextWidget ctx;
   else
     widest = ctx->core.width - 2 * s;
   widest /= (last = GetWidestLine(ctx));
-  if (ctx->text.scroll_horiz == XawtextScrollWhenNeeded) 
+  if (ctx->text.scroll_horiz == XawtextScrollWhenNeeded) {
     if (widest < 1.0)
       CreateHScrollBar(ctx);
     else
       DestroyHScrollBar(ctx);
+  }
 
   if ( (ctx->text.hbar == NULL) != temp ) {
     _XawTextBuildLineTable (ctx, ctx->text.lt.top, TRUE);
diff --git a/xc/lib/Xaw3d/TextAction.c b/xc/lib/Xaw3d/TextAction.c
index 65b8539..32c8e51 100644
--- a/xc/lib/Xaw3d/TextAction.c
+++ b/xc/lib/Xaw3d/TextAction.c
@@ -1852,6 +1852,7 @@ Cardinal* num_params;
 {
   TextWidget ctx = (TextWidget) w;
   int mult;
+  int atoi();
 
   if (*num_params != 1) {
       XtAppError( XtWidgetToApplicationContext( w ), 
diff --git a/xc/lib/Xaw3d/TextPop.c b/xc/lib/Xaw3d/TextPop.c
index cf01b4f..ee3e595 100644
--- a/xc/lib/Xaw3d/TextPop.c
+++ b/xc/lib/Xaw3d/TextPop.c
@@ -1064,13 +1064,14 @@ Boolean once_only, show_current;
     else
       XawTextSetInsertionPoint( tw, pos);
 
-    if (once_only) 
+    if (once_only) {
       if (show_current)
 	break;
       else {
 	DoSearch(search);
 	return(TRUE);
       }
+    }
     count++;
   }
 
diff --git a/xc/lib/Xaw3d/ThreeD.c b/xc/lib/Xaw3d/ThreeD.c
index 8166a7c..65251f8 100644
--- a/xc/lib/Xaw3d/ThreeD.c
+++ b/xc/lib/Xaw3d/ThreeD.c
@@ -73,6 +73,8 @@ static XtResource resources[] = {
     {XtNborderWidth, XtCBorderWidth, XtRDimension, sizeof(Dimension),
 	XtOffsetOf(RectObjRec,rectangle.border_width), XtRImmediate,
 	(XtPointer)0},
+    {XtNinvertBorder, XtCInvertBorder, XtRBoolean, sizeof(Boolean),
+	offset(threeD.invert_border), XtRImmediate, (XtPointer) False},
     {XtNrelief, XtCRelief, XtRRelief, sizeof(XtRelief),
 	offset(threeD.relief), XtRString, (XtPointer) defRelief}
 };
@@ -222,14 +224,13 @@ static void AllocTopShadowPixmap (new)
 	if (tdw->core.background_pixel == WhitePixelOfScreen (scn) ||
 	    tdw->core.background_pixel == BlackPixelOfScreen (scn)) {
 	    pm_data = mtshadowpm_bits;
-       	    pm_size = mtshadowpm_size;
-       } else 
+	    pm_size = mtshadowpm_size;
+	} else 
 #endif
-       {
-       	    pm_data = shadowpm_bits;
-            pm_size = shadowpm_size;
-       }
-	
+	{
+	    pm_data = shadowpm_bits;
+	    pm_size = shadowpm_size;
+	}
 	create_pixmap = TRUE;
     } else {
 	pm_size = 0; /* keep gcc happy */
@@ -651,7 +652,7 @@ _Xaw3dDrawShadows (gw, event, region, relief, out)
 	GC		realbot = tdw->threeD.bot_shadow_GC;
 	GC		top, bot;
 
-	if (out) {
+	if ((out ^ tdw->threeD.invert_border)) {
 	    top = tdw->threeD.top_shadow_GC;
 	    bot = tdw->threeD.bot_shadow_GC;
 	} else {
@@ -792,7 +793,7 @@ Boolean out;
 	Window win = XtWindow(gw);
 	GC top, bot;
 
-	if (out)
+	if ((out ^ tdw->threeD.invert_border))
 	{
 	    top = tdw->threeD.top_shadow_GC;
 	    bot = tdw->threeD.bot_shadow_GC;
diff --git a/xc/lib/Xaw3d/ThreeD.h b/xc/lib/Xaw3d/ThreeD.h
index d7cf8e2..a2f6570 100644
--- a/xc/lib/Xaw3d/ThreeD.h
+++ b/xc/lib/Xaw3d/ThreeD.h
@@ -49,6 +49,7 @@ SOFTWARE.
  bottomShadowContrast BottomShadowContrast Int           40
  userData             UserData             XtPointer     NULL
  beNiceToColormap     BeNiceToColormap     Boolean       False
+ invertBorder	      InvertBorder	   Boolean	 False
  relief               Relief               XtRelief      XtReliefRaised
 
 */
@@ -67,6 +68,8 @@ SOFTWARE.
 #define XtCBeNiceToColormap "BeNiceToColormap"
 #define XtNbeNiceToColourmap "beNiceToColormap"
 #define XtCBeNiceToColourmap "BeNiceToColormap"
+#define XtNinvertBorder "invertBorder"
+#define XtCInvertBorder "InvertBorder"
 #define XtNuserData "userData"
 #define XtCUserData "UserData"
 #define XtNrelief "relief"
diff --git a/xc/lib/Xaw3d/ThreeDP.h b/xc/lib/Xaw3d/ThreeDP.h
index 44ccb97..c61bf78 100644
--- a/xc/lib/Xaw3d/ThreeDP.h
+++ b/xc/lib/Xaw3d/ThreeDP.h
@@ -47,6 +47,7 @@ typedef struct {
     GC		bot_shadow_GC;
     XtPointer	user_data;
     Boolean	be_nice_to_cmap;
+    Boolean	invert_border;
     XtRelief	relief;
   } ThreeDPart;
 
diff --git a/xc/lib/Xaw3d/Toggle.c b/xc/lib/Xaw3d/Toggle.c
index 66902c4..bd97876 100644
--- a/xc/lib/Xaw3d/Toggle.c
+++ b/xc/lib/Xaw3d/Toggle.c
@@ -499,10 +499,11 @@ Widget w, radio_group;
   if ( tw->command.set && radio_group != NULL )
     XawToggleUnsetCurrent(radio_group);
 
-  if (radio_group != NULL)
+  if (radio_group != NULL) {
       if ((group = GetRadioGroup(radio_group)) == NULL)
 	  CreateRadioGroup(w, radio_group);
       else AddToRadioGroup(group, w);
+  }
 }
 
 /*	Function Name: XawToggleGetCurrent
diff --git a/xc/lib/Xaw3d/Viewport.c b/xc/lib/Xaw3d/Viewport.c
index b257cd3..813cea6 100644
--- a/xc/lib/Xaw3d/Viewport.c
+++ b/xc/lib/Xaw3d/Viewport.c
@@ -824,17 +824,19 @@ int *clip_width, *clip_height;
         if ( (w->viewport.allowvert || w->viewport.allowhoriz) ) { 
 	    XtQueryGeometry( child, intended, &preferred );
 	  
-	    if ( !(intended->request_mode & CWWidth) )
+	    if ( !(intended->request_mode & CWWidth) ) {
 	        if ( preferred.request_mode & CWWidth )
 		    intended->width = preferred.width;
 		else
 		    intended->width = child->core.width;
+	    }
 
-	    if ( !(intended->request_mode & CWHeight) )
+	    if ( !(intended->request_mode & CWHeight) ) {
 	        if ( preferred.request_mode & CWHeight )
 		    intended->height = preferred.height;
 		else
 		    intended->height = child->core.height;
+	    }
 	}
     }
     else {
diff --git a/xc/lib/Xaw3d/XawI18n.c b/xc/lib/Xaw3d/XawI18n.c
index c911057..9204ff4 100644
--- a/xc/lib/Xaw3d/XawI18n.c
+++ b/xc/lib/Xaw3d/XawI18n.c
@@ -68,6 +68,9 @@ wchar_t _Xaw_atowc(c)
 {
     wchar_t  wc;
     char str[2];
+#ifndef USE_XMBTOWC
+    int mbtowc();
+#endif
 
     str[0] = c;
     str[1] = '\0';
diff --git a/xc/lib/Xaw3d/XawI18n.h b/xc/lib/Xaw3d/XawI18n.h
index b0176bf..9c02c76 100644
--- a/xc/lib/Xaw3d/XawI18n.h
+++ b/xc/lib/Xaw3d/XawI18n.h
@@ -58,10 +58,12 @@ extern int _Xaw_iswspace(wchar_t);
 #endif
 
 #ifdef USE_XWCHAR_STRING
+int _Xwcsncpy(), _Xwcscpy(), _Xwcslen();
 #define wcslen(c) _Xwcslen(c)
 #define wcscpy(d,s) _Xwcscpy(d,s)
 #define wcsncpy(d,s,l) _Xwcsncpy(d,s,l)
 #ifdef USE_XMBTOWC
+int _Xmbtowc();
 #define mbtowc(wc,s,l) _Xmbtowc(wc,s,l)
 #endif
 #endif
diff --git a/xc/lib/Xaw3d/XawIm.c b/xc/lib/Xaw3d/XawIm.c
index a5d0032..2cf2113 100644
--- a/xc/lib/Xaw3d/XawIm.c
+++ b/xc/lib/Xaw3d/XawIm.c
@@ -1080,6 +1080,7 @@ static void SetValues( w, ve, args, num_args )
     XrmResourceList	xrmres;
     int	i;
     XawIcTablePart	*p, save_tbl;
+    void	_XtCopyFromArg();
 
     if ((p = GetIcTable(w, ve)) == NULL) return;
 
@@ -1331,8 +1332,6 @@ static Boolean Initialize( vw, ve )
     VendorShellWidget vw;
     XawVendorShellExtPart* ve;
 {
-    int 	i;
-
     if (!XtIsVendorShell((Widget)vw)) return(FALSE);
     ve->parent = (Widget)vw;
     ve->im.xim = NULL;
@@ -1531,6 +1530,8 @@ _XawImSetValues( inwidg, args, num_args )
     SetFocusValues( inwidg, args, num_args, FALSE );
 }
 
+void _XtCountVaList(), _XtVaToArgList();
+
 void
 #if NeedVarargsPrototypes
 _XawImVASetValues( Widget inwidg, ... )
-- 
1.6.1

