diff -up texk/web2c/pdftexdir/writeimg.c.png15 texk/web2c/pdftexdir/writeimg.c
--- texk/web2c/pdftexdir/writeimg.c.png15	2007-02-04 18:26:47.000000000 -0200
+++ texk/web2c/pdftexdir/writeimg.c	2011-11-11 23:10:10.458705317 -0200
@@ -122,7 +122,7 @@ integer imagecolordepth(integer img)
 {
     switch (img_type(img)) {
     case IMAGE_TYPE_PNG:
-        return png_info(img)->bit_depth;
+        return png_get_bit_depth(png_ptr(img), png_info(img));
     case IMAGE_TYPE_JPG:
         return jpg_ptr(img)->bits_per_component;
     case IMAGE_TYPE_JBIG2:
@@ -364,7 +364,7 @@ void deleteimage(integer img)
         epdf_delete();
         break;
     case IMAGE_TYPE_PNG:
-        xfclose((FILE *) png_ptr(img)->io_ptr, cur_file_name);
+        xfclose((FILE *) png_get_io_ptr(png_ptr(img)), cur_file_name);
         png_destroy_read_struct(&(png_ptr(img)), &(png_info(img)), NULL);
         break;
     case IMAGE_TYPE_JPG:
diff -up texk/web2c/pdftexdir/writepng.c.png15 texk/web2c/pdftexdir/writepng.c
--- texk/web2c/pdftexdir/writepng.c.png15	2006-12-26 21:37:34.000000000 -0200
+++ texk/web2c/pdftexdir/writepng.c	2011-11-11 23:19:59.952378078 -0200
@@ -33,7 +33,7 @@ void read_png_info(integer img)
         pdftex_fail("libpng: png_create_read_struct() failed");
     if ((png_info(img) = png_create_info_struct(png_ptr(img))) == NULL)
         pdftex_fail("libpng: png_create_info_struct() failed");
-    if (setjmp(png_ptr(img)->jmpbuf))
+    if (setjmp(png_jmpbuf(png_ptr(img))))
         pdftex_fail("libpng: internal error");
     png_init_io(png_ptr(img), png_file);
     png_read_info(png_ptr(img), png_info(img));
@@ -43,12 +43,12 @@ void read_png_info(integer img)
     }
     /* alpha channel support  */
     if (fixedpdfminorversion < 4
-        && png_ptr(img)->color_type | PNG_COLOR_MASK_ALPHA)
+        && png_get_color_type(png_ptr(img), png_info(img)) | PNG_COLOR_MASK_ALPHA)
         png_set_strip_alpha(png_ptr(img));
     /* 16bit depth support */
     if (fixedpdfminorversion < 5)
         fixedimagehicolor = 0;
-    if (png_info(img)->bit_depth == 16 && !fixedimagehicolor)
+    if (png_get_bit_depth(png_ptr(img), png_info(img)) == 16 && !fixedimagehicolor)
         png_set_strip_16(png_ptr(img));
     /* gamma support */
     if (fixedimageapplygamma) {
@@ -61,9 +61,9 @@ void read_png_info(integer img)
     /* reset structure */
     png_read_update_info(png_ptr(img), png_info(img));
     /* resolution support */
-    img_width(img) = png_info(img)->width;
-    img_height(img) = png_info(img)->height;
-    if (png_info(img)->valid & PNG_INFO_pHYs) {
+    img_width(img) = png_get_image_width(png_ptr(img), png_info(img));
+    img_height(img) = png_get_image_height(png_ptr(img), png_info(img));
+    if (png_get_valid(png_ptr(img), png_info(img), PNG_INFO_pHYs)) {
         img_xres(img) =
             round(0.0254 *
                   png_get_x_pixels_per_meter(png_ptr(img), png_info(img)));
@@ -71,7 +71,7 @@ void read_png_info(integer img)
             round(0.0254 *
                   png_get_y_pixels_per_meter(png_ptr(img), png_info(img)));
     }
-    switch (png_info(img)->color_type) {
+    switch (png_get_color_type(png_ptr(img), png_info(img))) {
     case PNG_COLOR_TYPE_PALETTE:
         img_color(img) = IMAGE_COLOR_C | IMAGE_COLOR_I;
         break;
@@ -85,7 +85,7 @@ void read_png_info(integer img)
         break;
     default:
         pdftex_fail("unsupported type of color_type <%i>",
-                    png_info(img)->color_type);
+                    png_get_color_type(png_ptr(img), png_info(img)));
     }
 }
 
@@ -111,10 +111,10 @@ void read_png_info(integer img)
 
 
 #define write_noninterlaced(outmac)                    \
-  for (i = 0; i < (int)png_info(img)->height; i++) {   \
+   for (i = 0; (unsigned) i < png_get_image_height(png_ptr(img), png_info(img)); i++) { \
     png_read_row(png_ptr(img), row, NULL);             \
     r = row;                                           \
-    k = png_info(img)->rowbytes;                       \
+    k = png_get_rowbytes(png_ptr(img), png_info(img)); \
     while(k > 0) {                                     \
 	l = (k > pdfbufsize)? pdfbufsize : k;          \
 		pdfroom(l);                            \
@@ -126,9 +126,9 @@ void read_png_info(integer img)
         }
 
 #define write_interlaced(outmac)                       \
-  for (i = 0; i < (int)png_info(img)->height; i++) {   \
+ for (i = 0; (unsigned) i < png_get_image_height(png_ptr(img), png_info(img)); i++) { \
             row = rows[i];                             \
-	    k = png_info(img)->rowbytes;               \
+	    k = png_get_rowbytes(png_ptr(img), png_info(img)); \
 	    while(k > 0) {                             \
 		l = (k > pdfbufsize)? pdfbufsize : k;  \
 		pdfroom(l);                            \
@@ -146,27 +146,29 @@ void write_png_palette(integer img)
     int i, j, k, l;
     png_bytep row, r, *rows;
     integer palette_objnum = 0;
+    png_colorp palette;
+    int num_palette;
     pdfcreateobj(0, 0);
     palette_objnum = objptr;
     if (img_colorspace_ref(img) != 0) {
         pdf_printf("%i 0 R\n", (int) img_colorspace_ref(img));
     } else {
         pdf_printf("[/Indexed /DeviceRGB %i %i 0 R]\n",
-                   (int) (png_info(img)->num_palette - 1),
-                   (int) palette_objnum);
+                   num_palette -1, (int) palette_objnum);
     }
     pdfbeginstream();
-    if (png_info(img)->interlace_type == PNG_INTERLACE_NONE) {
-        row = xtalloc(png_info(img)->rowbytes, png_byte);
+    if (png_get_interlace_type(png_ptr(img), png_info(img)) == PNG_INTERLACE_NONE) {
+        row = xtalloc(png_get_rowbytes(png_ptr(img), png_info(img)), png_byte);
         write_noninterlaced(write_simple_pixel(r));
         xfree(row);
     } else {
-        if (png_info(img)->height * png_info(img)->rowbytes >= 10240000L)
+        if (png_get_image_height(png_ptr(img), png_info(img))
+            * png_get_rowbytes(png_ptr(img), png_info(img)) >= 10240000L)
             pdftex_warn
                 ("large interlaced PNG might cause out of memory (use non-interlaced PNG to fix this)");
-        rows = xtalloc(png_info(img)->height, png_bytep);
-        for (i = 0; (unsigned) i < png_info(img)->height; i++)
-            rows[i] = xtalloc(png_info(img)->rowbytes, png_byte);
+        rows = xtalloc(png_get_image_height(png_ptr(img), png_info(img)), png_bytep);
+        for (i = 0; (unsigned) i < png_get_image_height(png_ptr(img), png_info(img)); i++)
+            rows[i] = xtalloc(png_get_rowbytes(png_ptr(img), png_info(img)), png_byte);
         png_read_image(png_ptr(img), rows);
         write_interlaced(write_simple_pixel(row));
         xfree(rows);
@@ -175,11 +177,11 @@ void write_png_palette(integer img)
     if (palette_objnum > 0) {
         pdfbegindict(palette_objnum, 0);
         pdfbeginstream();
-        for (i = 0; (unsigned) i < png_info(img)->num_palette; i++) {
+        for (i = 0; (unsigned) i < num_palette; i++) {
             pdfroom(3);
-            pdfbuf[pdfptr++] = png_info(img)->palette[i].red;
-            pdfbuf[pdfptr++] = png_info(img)->palette[i].green;
-            pdfbuf[pdfptr++] = png_info(img)->palette[i].blue;
+            pdfbuf[pdfptr++] = palette[i].red;
+            pdfbuf[pdfptr++] = palette[i].green;
+            pdfbuf[pdfptr++] = palette[i].blue;
         }
         pdfendstream();
     }
@@ -195,17 +197,18 @@ void write_png_gray(integer img)
         pdf_puts("/DeviceGray\n");
     }
     pdfbeginstream();
-    if (png_info(img)->interlace_type == PNG_INTERLACE_NONE) {
-        row = xtalloc(png_info(img)->rowbytes, png_byte);
+    if (png_get_interlace_type(png_ptr(img), png_info(img)) == PNG_INTERLACE_NONE) {
+        row = xtalloc(png_get_rowbytes(png_ptr(img), png_info(img)), png_byte);
         write_noninterlaced(write_simple_pixel(r));
         xfree(row);
     } else {
-        if (png_info(img)->height * png_info(img)->rowbytes >= 10240000L)
+        if (png_get_image_height(png_ptr(img), png_info(img))
+            * png_get_rowbytes(png_ptr(img), png_info(img)) >= 10240000L)
             pdftex_warn
                 ("large interlaced PNG might cause out of memory (use non-interlaced PNG to fix this)");
-        rows = xtalloc(png_info(img)->height, png_bytep);
-        for (i = 0; (unsigned) i < png_info(img)->height; i++)
-            rows[i] = xtalloc(png_info(img)->rowbytes, png_byte);
+        rows = xtalloc(png_get_image_height(png_ptr(img), png_info(img)), png_bytep);
+        for (i = 0; (unsigned) i < png_get_image_height(png_ptr(img), png_info(img)); i++)
+            rows[i] = xtalloc(png_get_rowbytes(png_ptr(img), png_info(img)), png_byte);
         png_read_image(png_ptr(img), rows);
         write_interlaced(write_simple_pixel(row));
         xfree(rows);
@@ -232,26 +235,27 @@ void write_png_gray_alpha(integer img)
     pdfcreateobj(0, 0);
     smask_objnum = objptr;
     pdf_printf("/SMask %i 0 R\n", (int) smask_objnum);
-    smask_size = (png_info(img)->rowbytes / 2) * png_info(img)->height;
+    smask_size = (png_get_rowbytes(png_ptr(img), png_info(img)) / 2) * png_get_image_height(png_ptr(img), png_info(img));
     smask = xtalloc(smask_size, png_byte);
     pdfbeginstream();
-    if (png_info(img)->interlace_type == PNG_INTERLACE_NONE) {
-        row = xtalloc(png_info(img)->rowbytes, png_byte);
-        if ((png_info(img)->bit_depth == 16) && fixedimagehicolor) {
+    if (png_get_interlace_type(png_ptr(img), png_info(img)) == PNG_INTERLACE_NONE) {
+        row = xtalloc(png_get_rowbytes(png_ptr(img), png_info(img)), png_byte);
+        if ((png_get_bit_depth(png_ptr(img), png_info(img)) == 16) && fixedimagehicolor) {
             write_noninterlaced(write_gray_pixel_16(r));
         } else {
             write_noninterlaced(write_gray_pixel_8(r));
         }
         xfree(row);
     } else {
-        if (png_info(img)->height * png_info(img)->rowbytes >= 10240000L)
+        if (png_get_image_height(png_ptr(img), png_info(img))
+            * png_get_rowbytes(png_ptr(img), png_info(img)) >= 10240000L)
             pdftex_warn
                 ("large interlaced PNG might cause out of memory (use non-interlaced PNG to fix this)");
-        rows = xtalloc(png_info(img)->height, png_bytep);
-        for (i = 0; (unsigned) i < png_info(img)->height; i++)
-            rows[i] = xtalloc(png_info(img)->rowbytes, png_byte);
+        rows = xtalloc(png_get_image_height(png_ptr(img), png_info(img)), png_bytep);
+        for (i = 0; (unsigned) i < png_get_image_height(png_ptr(img), png_info(img)); i++)
+            rows[i] = xtalloc(png_get_rowbytes(png_ptr(img), png_info(img)), png_byte);
         png_read_image(png_ptr(img), rows);
-        if ((png_info(img)->bit_depth == 16) && fixedimagehicolor) {
+        if ((png_get_bit_depth(png_ptr(img), png_info(img)) == 16) && fixedimagehicolor) {
             write_interlaced(write_gray_pixel_16(row));
         } else {
             write_interlaced(write_gray_pixel_8(row));
@@ -262,12 +266,12 @@ void write_png_gray_alpha(integer img)
     pdfflush();
     /* now write the Smask object */
     if (smask_objnum > 0) {
-        bitdepth = (int) png_info(img)->bit_depth;
+        bitdepth = (int) png_get_image_height(png_ptr(img), png_info(img));
         pdfbegindict(smask_objnum, 0);
         pdf_puts("/Type /XObject\n/Subtype /Image\n");
         pdf_printf("/Width %i\n/Height %i\n/BitsPerComponent %i\n",
-                   (int) png_info(img)->width,
-                   (int) png_info(img)->height,
+                   (int) png_get_image_width(png_ptr(img), png_info(img)),
+                   (int) png_get_image_height(png_ptr(img), png_info(img)),
                    (bitdepth == 16 ? 8 : bitdepth));
         pdf_puts("/ColorSpace /DeviceGray\n");
         pdfbeginstream();
@@ -293,17 +297,18 @@ void write_png_rgb(integer img)
         pdf_puts("/DeviceRGB\n");
     }
     pdfbeginstream();
-    if (png_info(img)->interlace_type == PNG_INTERLACE_NONE) {
-        row = xtalloc(png_info(img)->rowbytes, png_byte);
+    if (png_get_interlace_type(png_ptr(img), png_info(img)) == PNG_INTERLACE_NONE) {
+        row = xtalloc(png_get_rowbytes(png_ptr(img), png_info(img)), png_byte);
         write_noninterlaced(write_simple_pixel(r));
         xfree(row);
     } else {
-        if (png_info(img)->height * png_info(img)->rowbytes >= 10240000L)
+        if (png_get_image_height(png_ptr(img), png_info(img))
+            * png_get_rowbytes(png_ptr(img), png_info(img)) >= 10240000L)
             pdftex_warn
                 ("large interlaced PNG might cause out of memory (use non-interlaced PNG to fix this)");
-        rows = xtalloc(png_info(img)->height, png_bytep);
-        for (i = 0; (unsigned) i < png_info(img)->height; i++)
-            rows[i] = xtalloc(png_info(img)->rowbytes, png_byte);
+        rows = xtalloc(png_get_image_height(png_ptr(img), png_info(img)), png_bytep);
+        for (i = 0; (unsigned) i < png_get_image_height(png_ptr(img), png_info(img)); i++)
+            rows[i] = xtalloc(png_get_rowbytes(png_ptr(img), png_info(img)), png_byte);
         png_read_image(png_ptr(img), rows);
         write_interlaced(write_simple_pixel(row));
         xfree(rows);
@@ -328,26 +333,27 @@ void write_png_rgb_alpha(integer img)
     pdfcreateobj(0, 0);
     smask_objnum = objptr;
     pdf_printf("/SMask %i 0 R\n", (int) smask_objnum);
-    smask_size = (png_info(img)->rowbytes / 2) * png_info(img)->height;
+    smask_size = (png_get_rowbytes(png_ptr(img), png_info(img)) / 2) * png_get_image_height(png_ptr(img), png_info(img));
     smask = xtalloc(smask_size, png_byte);
     pdfbeginstream();
-    if (png_info(img)->interlace_type == PNG_INTERLACE_NONE) {
-        row = xtalloc(png_info(img)->rowbytes, png_byte);
-        if ((png_info(img)->bit_depth == 16) && fixedimagehicolor) {
+    if (png_get_interlace_type(png_ptr(img), png_info(img)) == PNG_INTERLACE_NONE) {
+        row = xtalloc(png_get_rowbytes(png_ptr(img), png_info(img)), png_byte);
+        if ((png_get_bit_depth(png_ptr(img), png_info(img)) == 16) && fixedimagehicolor) {
             write_noninterlaced(write_rgb_pixel_16(r));
         } else {
             write_noninterlaced(write_rgb_pixel_8(r));
         }
         xfree(row);
     } else {
-        if (png_info(img)->height * png_info(img)->rowbytes >= 10240000L)
+        if (png_get_image_height(png_ptr(img), png_info(img))
+            * png_get_rowbytes(png_ptr(img), png_info(img)) >= 10240000L)
             pdftex_warn
                 ("large interlaced PNG might cause out of memory (use non-interlaced PNG to fix this)");
-        rows = xtalloc(png_info(img)->height, png_bytep);
-        for (i = 0; (unsigned) i < png_info(img)->height; i++)
-            rows[i] = xtalloc(png_info(img)->rowbytes, png_byte);
+        rows = xtalloc(png_get_image_height(png_ptr(img), png_info(img)), png_bytep);
+        for (i = 0; (unsigned) i < png_get_image_height(png_ptr(img), png_info(img)); i++)
+            rows[i] = xtalloc(png_get_rowbytes(png_ptr(img), png_info(img)), png_byte);
         png_read_image(png_ptr(img), rows);
-        if ((png_info(img)->bit_depth == 16) && fixedimagehicolor) {
+        if ((png_get_bit_depth(png_ptr(img), png_info(img)) == 16) && fixedimagehicolor) {
             write_interlaced(write_rgb_pixel_16(row));
         } else {
             write_interlaced(write_rgb_pixel_8(row));
@@ -358,12 +364,12 @@ void write_png_rgb_alpha(integer img)
     pdfflush();
     /* now write the Smask object */
     if (smask_objnum > 0) {
-        bitdepth = (int) png_info(img)->bit_depth;
+        bitdepth = (int) png_get_bit_depth(png_ptr(img), png_info(img));
         pdfbegindict(smask_objnum, 0);
         pdf_puts("/Type /XObject\n/Subtype /Image\n");
         pdf_printf("/Width %i\n/Height %i\n/BitsPerComponent %i\n",
-                   (int) png_info(img)->width,
-                   (int) png_info(img)->height,
+                   (int) png_get_image_width(png_ptr(img), png_info(img)),
+                   (int) png_get_image_height(png_ptr(img), png_info(img)),
                    (bitdepth == 16 ? 8 : bitdepth));
         pdf_puts("/ColorSpace /DeviceGray\n");
         pdfbeginstream();
@@ -406,7 +412,7 @@ static int spng_getint(FILE * fp)
 
 void copy_png(integer img)
 {
-    FILE *fp = (FILE *) png_ptr(img)->io_ptr;
+    FILE *fp = (FILE *) png_get_io_ptr(png_ptr(img));
     int i, len, type, streamlength = 0;
     boolean endflag = false;
     int idat = 0;               /* flag to check continuous IDAT chunks sequence */
@@ -430,9 +436,9 @@ void copy_png(integer img)
     pdf_printf("/Length %d\n", streamlength);
     pdf_printf("/Filter /FlateDecode\n");
     pdf_printf("/DecodeParms << ");
-    pdf_printf("/Colors %d ", png_info(img)->color_type == 2 ? 3 : 1);
-    pdf_printf("/Columns %d ", (int) png_info(img)->width);
-    pdf_printf("/BitsPerComponent %i ", (int) png_info(img)->bit_depth);
+    pdf_printf("/Colors %d ", png_get_color_type(png_ptr(img), png_info(img)) == 2 ? 3 : 1);
+    pdf_printf("/Columns %d ", (int) png_get_image_width(png_ptr(img), png_info(img)));
+    pdf_printf("/BitsPerComponent %i ", (int) png_get_image_height(png_ptr(img), png_info(img)));
     pdf_printf("/Predictor %d ", 10);   /* actual predictor defined on line basis */
     pdf_printf(">>\n>>\nstream\n");
     /* 2nd pass to copy data */
@@ -476,13 +482,15 @@ void write_png(integer img)
     double gamma, checked_gamma;
     int i;
     integer palette_objnum = 0;
+    int num_palette;
+    png_colorp palette;
     if (fixedpdfminorversion < 5)
         fixedimagehicolor = 0;
 
     pdf_puts("/Type /XObject\n/Subtype /Image\n");
     pdf_printf("/Width %i\n/Height %i\n/BitsPerComponent %i\n",
-               (int) png_info(img)->width,
-               (int) png_info(img)->height, (int) png_info(img)->bit_depth);
+               (int) png_get_image_width(png_ptr(img), png_info(img)),
+               (int) png_get_image_height(png_ptr(img), png_info(img)), (int) png_get_bit_depth(png_ptr(img), png_info(img)));
     pdf_puts("/ColorSpace ");
     checked_gamma = 1.0;
     if (fixedimageapplygamma) {
@@ -494,22 +502,22 @@ void write_png(integer img)
     }
     /* the switching between |png_info| and |png_ptr| queries has been trial and error.
      */
-    if (fixedpdfminorversion > 1 && png_info(img)->interlace_type == PNG_INTERLACE_NONE && (png_ptr(img)->transformations == 0 || png_ptr(img)->transformations == 0x2000)      /* gamma */
-        &&!(png_ptr(img)->color_type == PNG_COLOR_TYPE_GRAY_ALPHA ||
-            png_ptr(img)->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
-        && (fixedimagehicolor || (png_ptr(img)->bit_depth <= 8))
+    if (fixedpdfminorversion > 1 && png_get_interlace_type(png_ptr(img), png_info(img)) == PNG_INTERLACE_NONE
+    /* gamma */
+        &&!(png_get_color_type(png_ptr(img), png_info(img)) == PNG_COLOR_TYPE_GRAY_ALPHA ||
+            png_get_color_type(png_ptr(img), png_info(img)) == PNG_COLOR_TYPE_RGB_ALPHA)
+        && (fixedimagehicolor || (png_get_bit_depth(png_ptr(img), png_info(img)) <= 8))
         && (checked_gamma <= 1.01 && checked_gamma > 0.99)
         ) {
         if (img_colorspace_ref(img) != 0) {
             pdf_printf("%i 0 R\n", (int) img_colorspace_ref(img));
         } else {
-            switch (png_info(img)->color_type) {
+            switch (png_get_color_type(png_ptr(img), png_info(img))) {
             case PNG_COLOR_TYPE_PALETTE:
                 pdfcreateobj(0, 0);
                 palette_objnum = objptr;
                 pdf_printf("[/Indexed /DeviceRGB %i %i 0 R]\n",
-                           (int) (png_info(img)->num_palette - 1),
-                           (int) palette_objnum);
+                           num_palette -1, (int) palette_objnum);
                 break;
             case PNG_COLOR_TYPE_GRAY:
                 pdf_puts("/DeviceGray\n");
@@ -523,11 +531,11 @@ void write_png(integer img)
         if (palette_objnum > 0) {
             pdfbegindict(palette_objnum, 0);
             pdfbeginstream();
-            for (i = 0; i < png_info(img)->num_palette; i++) {
+            for (i = 0; (unsigned) i < num_palette; i++) {
                 pdfroom(3);
-                pdfbuf[pdfptr++] = png_info(img)->palette[i].red;
-                pdfbuf[pdfptr++] = png_info(img)->palette[i].green;
-                pdfbuf[pdfptr++] = png_info(img)->palette[i].blue;
+                pdfbuf[pdfptr++] = palette[i].red;
+                pdfbuf[pdfptr++] = palette[i].green;
+                pdfbuf[pdfptr++] = palette[i].blue;
             }
             pdfendstream();
         }
@@ -537,23 +545,20 @@ void write_png(integer img)
             if (fixedimageapplygamma &&
                 (checked_gamma > 1.01 || checked_gamma < 0.99))
                 tex_printf("gamma delta=%lf ", checked_gamma);
-            if (png_ptr(img)->transformations != PNG_TRANSFORM_IDENTITY)
-                tex_printf("transform=%lu",
-                           (long) png_ptr(img)->transformations);
-            if ((png_info(img)->color_type != PNG_COLOR_TYPE_GRAY)
-                && (png_info(img)->color_type != PNG_COLOR_TYPE_RGB)
-                && (png_info(img)->color_type != PNG_COLOR_TYPE_PALETTE))
+            if ((png_get_color_type(png_ptr(img), png_info(img)) != PNG_COLOR_TYPE_GRAY)
+                && (png_get_color_type(png_ptr(img), png_info(img)) != PNG_COLOR_TYPE_RGB)
+                && (png_get_color_type(png_ptr(img), png_info(img)) != PNG_COLOR_TYPE_PALETTE))
                 tex_printf("colortype ");
             if (fixedpdfminorversion <= 1)
                 tex_printf("version=%d ", (int) fixedpdfminorversion);
-            if (png_info(img)->interlace_type != PNG_INTERLACE_NONE)
+            if (png_get_interlace_type(png_ptr(img), png_info(img)) != PNG_INTERLACE_NONE)
                 tex_printf("interlaced ");
-            if (png_info(img)->bit_depth > 8)
-                tex_printf("bitdepth=%d ", png_info(img)->bit_depth);
+            if (png_get_bit_depth(png_ptr(img), png_info(img)) > 8)
+                tex_printf("bitdepth=%d ", png_get_bit_depth(png_ptr(img), png_info(img)));
             if (png_get_valid(png_ptr(img), png_info(img), PNG_INFO_tRNS))
                 tex_printf("simple transparancy ");
         }
-        switch (png_info(img)->color_type) {
+        switch (png_get_color_type(png_ptr(img), png_info(img))) {
         case PNG_COLOR_TYPE_PALETTE:
             write_png_palette(img);
             break;
@@ -577,7 +582,7 @@ void write_png(integer img)
             break;
         default:
             pdftex_fail("unsupported type of color_type <%i>",
-                        png_info(img)->color_type);
+                        png_get_color_type(png_ptr(img), png_info(img)));
         }
     }
     pdfflush();
