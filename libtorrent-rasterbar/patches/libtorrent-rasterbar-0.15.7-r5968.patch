diff -up libtorrent-rasterbar-0.15.7/bindings/python/src/torrent_handle.cpp.orig libtorrent-rasterbar-0.15.7/bindings/python/src/torrent_handle.cpp
--- libtorrent-rasterbar-0.15.7/bindings/python/src/torrent_handle.cpp.orig	2011-09-12 22:04:23.145886524 -0300
+++ libtorrent-rasterbar-0.15.7/bindings/python/src/torrent_handle.cpp	2011-09-12 22:05:34.874692588 -0300
@@ -332,6 +332,7 @@ void bind_torrent_handle()
         .def("read_piece", _(&torrent_handle::read_piece))
         .def("set_piece_deadline", _(&torrent_handle::set_piece_deadline)
             , (arg("index"), arg("deadline"), arg("flags") = 0))
+        .def("reset_piece_deadline", _(&torrent_handle::reset_piece_deadline), (arg("index")))
         .def("piece_availability", &piece_availability)
         .def("piece_priority", _(piece_priority0))
         .def("piece_priority", _(piece_priority1))
diff -up libtorrent-rasterbar-0.15.7/include/libtorrent/torrent.hpp.orig libtorrent-rasterbar-0.15.7/include/libtorrent/torrent.hpp
--- libtorrent-rasterbar-0.15.7/include/libtorrent/torrent.hpp.orig	2011-09-12 22:04:31.692076242 -0300
+++ libtorrent-rasterbar-0.15.7/include/libtorrent/torrent.hpp	2011-09-12 22:05:58.716642174 -0300
@@ -281,6 +281,7 @@ namespace libtorrent
 		void file_priorities(std::vector<int>&) const;
 
 		void set_piece_deadline(int piece, int t, int flags);
+		void reset_piece_deadline(int piece);
 		void update_piece_priorities();
 
 		torrent_status status() const;
diff -up libtorrent-rasterbar-0.15.7/include/libtorrent/torrent_handle.hpp.orig libtorrent-rasterbar-0.15.7/include/libtorrent/torrent_handle.hpp
--- libtorrent-rasterbar-0.15.7/include/libtorrent/torrent_handle.hpp.orig	2011-09-12 22:04:38.990530259 -0300
+++ libtorrent-rasterbar-0.15.7/include/libtorrent/torrent_handle.hpp	2011-09-12 22:06:19.947144923 -0300
@@ -396,6 +396,7 @@ namespace libtorrent
 
 		enum deadline_flags { alert_when_available = 1 };
 		void set_piece_deadline(int index, int deadline, int flags = 0) const;
+		void reset_piece_deadline(int index) const;
 
 		void set_priority(int prio) const;
 		
diff -up libtorrent-rasterbar-0.15.7/src/torrent.cpp.orig libtorrent-rasterbar-0.15.7/src/torrent.cpp
--- libtorrent-rasterbar-0.15.7/src/torrent.cpp.orig	2011-07-27 02:33:37.000000000 -0300
+++ libtorrent-rasterbar-0.15.7/src/torrent.cpp	2011-09-12 21:49:02.849796816 -0300
@@ -1357,6 +1357,19 @@ namespace libtorrent
 		for (int i = 0; i < int(m_trackers.size()); ++i)
 		{
 			announce_entry& ae = m_trackers[i];
+#if defined TORRENT_VERBOSE_LOGGING || defined TORRENT_LOGGING
+			char msg[1000];
+			snprintf(msg, sizeof(msg), "*** announce with tracker: considering \"%s\" "
+				"[ announce_to_all_tiers: %d announce_to_all_trackers: %d"
+				" i->tier: %d tier: %d "
+				" is_working: %d fails: %d fail_limit: %d updating: %d"
+				" can_announce: %d sent_announce: %d ]"
+				, ae.url.c_str(), m_settings.announce_to_all_tiers
+				, m_settings.announce_to_all_trackers
+				, ae.tier, tier, ae.is_working(), ae.fails, ae.fail_limit
+				, ae.updating, ae.can_announce(now, is_seed()), sent_announce);
+			debug_log(msg);
+#endif
 			if (m_settings.announce_to_all_tiers
 				&& !m_settings.announce_to_all_trackers
 				&& sent_announce
@@ -1364,18 +1377,12 @@ namespace libtorrent
 				&& tier != INT_MAX)
 				continue;
 
-			if (ae.tier > tier && !m_settings.announce_to_all_tiers) break;
+			if (ae.tier > tier && sent_announce && !m_settings.announce_to_all_tiers) break;
 			if (ae.is_working()) { tier = ae.tier; sent_announce = false; }
 			if (!ae.can_announce(now, is_seed()))
 			{
-				if (ae.is_working())
-				{
-					sent_announce = true; // this counts
-
-					if (!m_settings.announce_to_all_trackers
-						&& !m_settings.announce_to_all_tiers)
-						break;
-				}
+				// this counts
+				if (ae.is_working()) sent_announce = true;
 				continue;
 			}
 			
@@ -1403,8 +1410,8 @@ namespace libtorrent
 			}
 			else
 #endif
-				m_ses.m_tracker_manager.queue_request(m_ses.m_io_service, m_ses.m_half_open, req
-					, tracker_login() , shared_from_this());
+			m_ses.m_tracker_manager.queue_request(m_ses.m_io_service, m_ses.m_half_open, req
+				, tracker_login() , shared_from_this());
 			ae.updating = true;
 			ae.next_announce = now + seconds(20);
 			ae.min_announce = now + seconds(10);
@@ -2554,6 +2561,29 @@ namespace libtorrent
 		std::list<time_critical_piece>::iterator i = std::upper_bound(m_time_critical_pieces.begin()
 			, m_time_critical_pieces.end(), p);
 		m_time_critical_pieces.insert(i, p);
+
+		piece_picker::downloading_piece pi;
+		m_picker->piece_info(piece, pi);
+		if (pi.requested == 0) return;
+		// this means we have outstanding requests (or queued
+		// up requests that haven't been sent yet). Promote them
+		// to deadline pieces immediately
+		std::vector<void*> downloaders;
+		m_picker->get_downloaders(downloaders, piece);
+
+		int block = 0;
+		for (std::vector<void*>::iterator i = downloaders.begin()
+			, end(downloaders.end()); i != end; ++i, ++block)
+		{
+			policy::peer* p = (policy::peer*)*i;
+			if (p == 0 || p->connection == 0) continue;
+			p->connection->make_time_critical(piece_block(piece, block));
+		}
+	}
+
+	void torrent::reset_piece_deadline(int piece)
+	{
+		remove_time_critical_piece(piece);
 	}
 
 	void torrent::remove_time_critical_piece(int piece, bool finished)
@@ -5251,7 +5281,13 @@ namespace libtorrent
 
 	void torrent::update_tracker_timer(ptime now)
 	{
-		if (!m_announcing) return;
+		if (!m_announcing)
+		{
+#if defined TORRENT_VERBOSE_LOGGING || defined TORRENT_LOGGING || defined TORRENT_ERROR_LOGGING
+			debug_log("*** update tracker timer: not announcing");
+#endif
+			return;
+		}
 
 		ptime next_announce = max_time();
 		int tier = INT_MAX;
@@ -5261,6 +5297,18 @@ namespace libtorrent
 		for (std::vector<announce_entry>::iterator i = m_trackers.begin()
 			, end(m_trackers.end()); i != end; ++i)
 		{
+#if defined TORRENT_VERBOSE_LOGGING || defined TORRENT_LOGGING
+			char msg[1000];
+			snprintf(msg, sizeof(msg), "*** update tracker timer: considering \"%s\" "
+				"[ announce_to_all_tiers: %d announce_to_all_trackers: %d"
+				" found_working: %d i->tier: %d tier: %d "
+				" is_working: %d fails: %d fail_limit: %d updating: %d ]"
+				, i->url.c_str(), m_settings.announce_to_all_tiers
+				, m_settings.announce_to_all_trackers, found_working
+				, i->tier, tier, i->is_working(), i->fails, i->fail_limit
+				, i->updating);
+			debug_log(msg);
+#endif
 			if (m_settings.announce_to_all_tiers
 				&& found_working
 				&& i->tier <= tier
@@ -5270,26 +5318,38 @@ namespace libtorrent
 			if (i->tier > tier && !m_settings.announce_to_all_tiers) break;
 			if (i->is_working()) { tier = i->tier; found_working = false; }
 			if (i->fails >= i->fail_limit && i->fail_limit != 0) continue;
-			if (i->updating) { found_working = true; continue; }
-			ptime next_tracker_announce = (std::max)(i->next_announce, i->min_announce);
-			if (!i->updating
-				&& next_tracker_announce < next_announce
-				&& (!found_working || i->is_working()))
-				next_announce = next_tracker_announce;
+			if (i->updating)
+			{
+				found_working = true;
+			}
+			else
+			{
+				ptime next_tracker_announce = (std::max)(i->next_announce, i->min_announce);
+				if (next_tracker_announce < next_announce
+					&& (!found_working || i->is_working()))
+					next_announce = next_tracker_announce;
+			}
 			if (i->is_working()) found_working = true;
-			if (!m_settings.announce_to_all_trackers
+			if (found_working
+				&& !m_settings.announce_to_all_trackers
 				&& !m_settings.announce_to_all_tiers) break;
 		}
 
-		if (next_announce <= now) return;
+#if defined TORRENT_VERBOSE_LOGGING || defined TORRENT_LOGGING
+		char msg[200];
+		snprintf(msg, sizeof(msg), "*** update tracker timer: next_announce < now %d"
+			" m_waiting_tracker: %d next_announce_in: %d"
+			, next_announce <= now, m_waiting_tracker, total_seconds(now - next_announce));
+		debug_log(msg);
+#endif
+		if (next_announce <= now) next_announce = now;
 
 		m_waiting_tracker = true;
 		error_code ec;
 		boost::weak_ptr<torrent> self(shared_from_this());
 
-		// since we don't know if we have to re-issue the async_wait or not
-		// always do it
-//		if (m_tracker_timer.expires_at() <= next_announce) return;
+		// don't re-issue the timer if it's the same expiration time as last time
+		if (m_tracker_timer.expires_at() == next_announce) return;
 
 		m_tracker_timer.expires_at(next_announce, ec);
 		m_tracker_timer.async_wait(boost::bind(&torrent::on_tracker_announce_disp, self, _1));
@@ -5498,8 +5558,6 @@ namespace libtorrent
 		if (!is_finished() && !m_web_seeds.empty() && m_files_checked
 			&& int(m_connections.size()) < m_max_connections
 			&& int(m_ses.m_connections.size()) < m_ses.max_connections())
-			return;
-
 		{
 			// keep trying web-seeds if there are any
 			// first find out which web seeds we are connected to
@@ -5571,6 +5629,9 @@ namespace libtorrent
 	void torrent::request_time_critical_pieces()
 	{
 		// build a list of peers and sort it by download_queue_time
+		// we use this sorted list to determine which peer we should
+		// request a block from. The higher up a peer is in the list,
+		// the sooner we will fully download the block we request.
 		std::vector<peer_connection*> peers;
 		peers.reserve(m_connections.size());
 		std::remove_copy_if(m_connections.begin(), m_connections.end()
@@ -5588,23 +5649,31 @@ namespace libtorrent
 
 		ptime now = time_now();
 
+		// now, iterate over all time critical pieces, in order of importance, and
+		// request them from the peers, in order of responsiveness. i.e. request
+		// the most time critical pieces from the fastest peers.
 		for (std::list<time_critical_piece>::iterator i = m_time_critical_pieces.begin()
 			, end(m_time_critical_pieces.end()); i != end; ++i)
 		{
+			if (peers.empty()) break;
+
 			if (i != m_time_critical_pieces.begin() && i->deadline > now
 				+ m_average_piece_time + m_piece_time_deviation * 4)
 			{
 				// don't request pieces whose deadline is too far in the future
+				// this is one of the termination conditions. We don't want to
+				// send requests for all pieces in the torrent right away
 				break;
 			}
 
-			// loop until every block has been requested from
+			// loop until every block has been requested from this piece (i->piece)
 			do
 			{
 				// pick the peer with the lowest download_queue_time that has i->piece
 				std::vector<peer_connection*>::iterator p = std::find_if(peers.begin(), peers.end()
 					, boost::bind(&peer_connection::has_piece, _1, i->piece));
 
+				// obviously we'll have to skip it if we don't have a peer that has this piece
 				if (p == peers.end()) break;
 				peer_connection& c = **p;
 
@@ -5630,7 +5699,11 @@ namespace libtorrent
 				}
 				else if (!interesting_blocks.empty())
 				{
-					c.add_request(interesting_blocks.front(), peer_connection::req_time_critical);
+					if (!c.add_request(interesting_blocks.front(), peer_connection::req_time_critical))
+					{
+						peers.erase(p);
+						continue;
+					}
 					added_request = true;
 				}
 
@@ -6157,7 +6230,7 @@ namespace libtorrent
 		INVARIANT_CHECK;
 
 #if defined TORRENT_VERBOSE_LOGGING || defined TORRENT_LOGGING || defined TORRENT_ERROR_LOGGING
-		debug_log("*** tracker timed out");
+		debug_log("*** tracker timed out [" + r.url + "]");
 #endif
 
 		if (r.kind == tracker_request::announce_request)
@@ -6166,6 +6239,10 @@ namespace libtorrent
 			if (ae)
 			{
 				ae->failed();
+#if defined TORRENT_VERBOSE_LOGGING || defined TORRENT_LOGGING || defined TORRENT_ERROR_LOGGING
+				debug_log("*** increment tracker fail count ["
+					+ std::string(to_string(ae->fails).elems) + "]");
+#endif
 				int tracker_index = ae - &m_trackers[0];
 				deprioritize_tracker(tracker_index);
 			}
diff -up libtorrent-rasterbar-0.15.7/src/torrent_handle.cpp.orig libtorrent-rasterbar-0.15.7/src/torrent_handle.cpp
--- libtorrent-rasterbar-0.15.7/src/torrent_handle.cpp.orig	2011-09-12 22:04:48.272564099 -0300
+++ libtorrent-rasterbar-0.15.7/src/torrent_handle.cpp	2011-09-12 22:06:53.395059611 -0300
@@ -745,5 +745,11 @@ namespace libtorrent
 		TORRENT_FORWARD(set_piece_deadline(index, deadline, flags));
 	}
 
+	void torrent_handle::reset_piece_deadline(int index) const
+	{
+		INVARIANT_CHECK;
+		TORRENT_FORWARD(reset_piece_deadline(index));
+	}
+
 }
 
