Index: includes/CMakeLists.txt
===================================================================
--- includes/CMakeLists.txt	(révision 1124353)
+++ includes/CMakeLists.txt	(copie de travail)
@@ -969,6 +969,7 @@
   Nepomuk/Resource
   Nepomuk/ResourceManager
   Nepomuk/Tag
+  Nepomuk/TagWidget
   Nepomuk/Variant
   Nepomuk/Thing
   Nepomuk/KRatingWidget
@@ -993,6 +994,7 @@
   Nepomuk/Query/OrTerm
   Nepomuk/Query/Query
   Nepomuk/Query/FileQuery
+  Nepomuk/Query/OptionalTerm
   Nepomuk/Query/QueryParser
   Nepomuk/Query/QueryServiceClient
   Nepomuk/Query/ResourceTerm
Index: includes/Nepomuk/TagWidget
===================================================================
--- includes/Nepomuk/TagWidget	(révision 0)
+++ includes/Nepomuk/TagWidget	(révision 0)
@@ -0,0 +1 @@
+#include "../../nepomuk/tagwidget.h"
Index: includes/Nepomuk/Query/OptionalTerm
===================================================================
--- includes/Nepomuk/Query/OptionalTerm	(révision 0)
+++ includes/Nepomuk/Query/OptionalTerm	(révision 0)
@@ -0,0 +1 @@
+#include "../../../nepomuk/optionalterm.h"
Index: nepomuk/query/optionalterm_p.h
===================================================================
--- nepomuk/query/optionalterm_p.h	(révision 0)
+++ nepomuk/query/optionalterm_p.h	(révision 0)
@@ -0,0 +1,44 @@
+/*
+   This file is part of the Nepomuk KDE project.
+   Copyright (C) 2010 Sebastian Trueg <trueg@kde.org>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) version 3, or any
+   later version accepted by the membership of KDE e.V. (or its
+   successor approved by the membership of KDE e.V.), which shall
+   act as a proxy defined in Section 6 of version 3 of the license.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef _NEPOMUK_QUERY_OPTIONAL_TERM_P_H_
+#define _NEPOMUK_QUERY_OPTIONAL_TERM_P_H_
+
+#include "simpleterm_p.h"
+
+namespace Nepomuk {
+    namespace Query {
+        class OptionalTermPrivate : public SimpleTermPrivate
+        {
+        public:
+            OptionalTermPrivate() {
+                m_type = Term::Optional;
+            }
+
+            TermPrivate* clone() const { return new OptionalTermPrivate( *this ); }
+
+            QString toSparqlGraphPattern( const QString& resourceVarName, QueryBuilderData* qbd ) const;
+            QString toString() const;
+        };
+    }
+}
+
+#endif

Modification de propriétés sur nepomuk/query/optionalterm_p.h
___________________________________________________________________
Ajouté : svn:eol-style
   + native

Index: nepomuk/query/comparisonterm.cpp
===================================================================
--- nepomuk/query/comparisonterm.cpp	(révision 1125741)
+++ nepomuk/query/comparisonterm.cpp	(copie de travail)
@@ -1,6 +1,6 @@
 /*
    This file is part of the Nepomuk KDE project.
-   Copyright (C) 2009 Sebastian Trueg <trueg@kde.org>
+   Copyright (C) 2009-2010 Sebastian Trueg <trueg@kde.org>
 
    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
@@ -53,6 +53,30 @@
             return QString();
         }
     }
+
+    QString varInAggregateFunction( Nepomuk::Query::ComparisonTerm::AggregateFunction f, const QString& varName )
+    {
+        switch( f ) {
+        case Nepomuk::Query::ComparisonTerm::Count:
+            return QString::fromLatin1("count(%1)").arg(varName);
+        case Nepomuk::Query::ComparisonTerm::DistinctCount:
+            return QString::fromLatin1("count(distinct %1)").arg(varName);
+        case Nepomuk::Query::ComparisonTerm::Max:
+            return QString::fromLatin1("max(%1)").arg(varName);
+        case Nepomuk::Query::ComparisonTerm::Min:
+            return QString::fromLatin1("min(%1)").arg(varName);
+        case Nepomuk::Query::ComparisonTerm::Sum:
+            return QString::fromLatin1("sum(%1)").arg(varName);
+        case Nepomuk::Query::ComparisonTerm::DistinctSum:
+            return QString::fromLatin1("sum(distinct %1)").arg(varName);
+        case Nepomuk::Query::ComparisonTerm::Average:
+            return QString::fromLatin1("avg(%1)").arg(varName);
+        case Nepomuk::Query::ComparisonTerm::DistinctAverage:
+            return QString::fromLatin1("avg(distinct %1)").arg(varName);
+        default:
+            return QString();
+        }
+    }
 }
 
 
@@ -63,7 +87,7 @@
     // 1.1. operator =
     //      use a single pattern like: ?r <prop> "value"
     // 1.2. operator :
-    //      use two patterns: ?r <prop> ?v . ?v bif:contains "'value*'"
+    //      use two patterns: ?r <prop> ?v . ?v bif:contains "'value'"
     // 1.3. operator <,>,<=,>=
     //      use two patterns: ?r <prop> ?v . FILTER(?v < value)
     // fail if subterm is not a literal term
@@ -78,7 +102,7 @@
     //        use one pattern and the subpattern: ?r <prop> ?v . subpattern(?v)
     // 2.2. operator :
     // 2.2.1. literal subterm
-    //        use 3 pattern: ?r <prop> ?v . ?v rdfs:label ?l . ?l bif:contains "'value*'"
+    //        use 3 pattern: ?r <prop> ?v . ?v rdfs:label ?l . ?l bif:contains "'value'"
     // 2.2.2. resource subterm
     //        same as =
     // 2.2.3. subterm type and, or, comparision
@@ -87,36 +111,43 @@
     //      fail!
     //
 
-    if ( m_property.literalRangeType().isValid() ) {
+    if ( !m_subTerm.isValid() ) {
+        QString prop = propertyToString( qbd );
+        QString ov = getMainVariableName( qbd );
+        return QString::fromLatin1( "%1 %2 %3 . " )
+            .arg( resourceVarName, prop, ov );
+    }
+
+    else if ( m_property.literalRangeType().isValid() ) {
         if( !m_subTerm.isLiteralTerm() )
             kDebug() << "Incompatible subterm type:" << m_subTerm.type();
         if ( m_comparator == ComparisonTerm::Equal ) {
-            return QString( "%1 %2 %3 . " )
+            return QString::fromLatin1( "%1 %2 %3 . " )
                 .arg( resourceVarName,
-                      Soprano::Node::resourceToN3( m_property.uri() ),
+                      propertyToString( qbd ),
                       Soprano::Node::literalToN3( m_subTerm.toLiteralTerm().value() ) );
         }
         else if ( m_comparator == ComparisonTerm::Contains ) {
-            QString v = qbd->uniqueVarName();
-            return QString( "%1 %2 %3 . %3 bif:contains \"'%4'\" . " )
+            QString v = getMainVariableName(qbd);
+            return QString::fromLatin1( "%1 %2 %3 . %3 bif:contains \"%4\" . " )
                 .arg( resourceVarName,
-                      Soprano::Node::resourceToN3( m_property.uri() ),
+                      propertyToString( qbd ),
                       v,
                       static_cast<const LiteralTermPrivate*>(m_subTerm.toLiteralTerm().d_ptr.constData())->queryText() );
         }
         else if ( m_comparator == ComparisonTerm::Regexp ) {
-            QString v = qbd->uniqueVarName();
-            return QString( "%1 %2 %3 . FILTER(REGEX(STR(%3), '%4', 'i')) . " )
+            QString v = getMainVariableName(qbd);
+            return QString::fromLatin1( "%1 %2 %3 . FILTER(REGEX(STR(%3), '%4', 'i')) . " )
                 .arg( resourceVarName,
-                      Soprano::Node::resourceToN3( m_property.uri() ),
+                      propertyToString( qbd ),
                       v,
                       m_subTerm.toLiteralTerm().value().toString() );
         }
         else {
-            QString v = qbd->uniqueVarName();
-            return QString( "%1 %2 %3 . FILTER(%3%4%5) . " )
+            QString v = getMainVariableName(qbd);
+            return QString::fromLatin1( "%1 %2 %3 . FILTER(%3%4%5) . " )
                 .arg( resourceVarName,
-                      Soprano::Node::resourceToN3( m_property.uri() ),
+                      propertyToString( qbd ),
                       v,
                       comparatorToString( m_comparator ),
                       Soprano::Node::literalToN3(m_subTerm.toLiteralTerm().value()) );
@@ -130,23 +161,33 @@
             kDebug() << "Incompatible property range:" << m_property.range().uri();
 
         //
-        // The core pattern is always the same: we match to resource that have a certain
+        // The core pattern is always the same: we match to resources that have a certain
         // property defined. The value of that property is filled in below.
         //
         QString corePattern;
+        QString subject;
+        QString object;
+        if( m_inverted && !m_subTerm.isLiteralTerm() ) {
+            subject = QLatin1String("%1"); // funny way to have a resulting string which takes only one arg
+            object = resourceVarName;
+        }
+        else {
+            subject = resourceVarName;
+            object = QLatin1String("%1");
+        }
         if( qbd->flags() & Query::HandleInverseProperties &&
             m_property.inverseProperty().isValid() ) {
             corePattern = QString::fromLatin1("{ %1 %2 %3 . } UNION { %3 %4 %1 . } . ")
-                              .arg( resourceVarName,
-                                    Soprano::Node::resourceToN3( m_property.uri() ),
-                                    QLatin1String("%1"), // funny way to have a resulting string which takes only one arg
+                              .arg( subject,
+                                    propertyToString( qbd ),
+                                    object,
                                     Soprano::Node::resourceToN3( m_property.inverseProperty().uri() ) );
         }
         else {
             corePattern = QString::fromLatin1("%1 %2 %3 . ")
-                              .arg( resourceVarName,
-                                    Soprano::Node::resourceToN3( m_property.uri() ),
-                                    QLatin1String("%1") ); // funny way to have a resulting string which takes only one arg
+                              .arg( subject,
+                                    propertyToString( qbd ),
+                                    object );
         }
 
         if ( m_subTerm.isLiteralTerm() ) {
@@ -154,7 +195,7 @@
             // the base of the pattern is always the same: match to resources related to X
             // which has a label that we compare somehow. This label's value will be filled below
             //
-            QString v1 = qbd->uniqueVarName();
+            QString v1 = getMainVariableName(qbd);
             QString v2 = qbd->uniqueVarName();
             QString pattern = QString::fromLatin1( "%1%2 %3 %4 . %3 %5 %6 . " )
                               .arg( corePattern.arg(v1),
@@ -169,7 +210,7 @@
             }
             else if ( m_comparator == ComparisonTerm::Contains ) {
                 QString v3 = qbd->uniqueVarName();
-                return QString::fromLatin1( "%1%2 bif:contains \"'%3'\" . " )
+                return QString::fromLatin1( "%1%2 bif:contains \"%3\" . " )
                     .arg( pattern.arg(v3),
                           v3,
                           static_cast<const LiteralTermPrivate*>(m_subTerm.toLiteralTerm().d_ptr.constData())->queryText() );
@@ -192,7 +233,7 @@
         }
         else {
             // ?r <prop> ?v1 . ?v1 ...
-            QString v = qbd->uniqueVarName();
+            QString v = getMainVariableName(qbd);
             return corePattern.arg(v) + m_subTerm.d_ptr->toSparqlGraphPattern( v, qbd );
         }
     }
@@ -216,19 +257,65 @@
 
 bool Nepomuk::Query::ComparisonTermPrivate::isValid() const
 {
-    return( SimpleTermPrivate::isValid() && m_property.isValid() );
+    // an invalid property will simply match all properties
+    // and an invalid subterm is a wildcard, too
+    // Thus, a ComparisonTerm is always valid
+    return true;
 }
 
 
 QString Nepomuk::Query::ComparisonTermPrivate::toString() const
 {
     return QString( "[%1 %2 %3]" )
-        .arg( Soprano::Node::resourceToN3( m_property.uri() ),
+        .arg( m_property.isValid() ? Soprano::Node::resourceToN3( m_property.uri() ) : QString::fromLatin1("?p"),
               comparatorToString( m_comparator ),
               m_subTerm.d_ptr->toString() );
 }
 
 
+QString Nepomuk::Query::ComparisonTermPrivate::getMainVariableName( QueryBuilderData* qbd ) const
+{
+    QString v;
+    QString sortVar;
+    if( !m_variableName.isEmpty() ) {
+        sortVar = QLatin1String( "?") + m_variableName;
+        if( m_aggregateFunction == ComparisonTerm::NoAggregateFunction ) {
+            v = sortVar;
+            qbd->addCustomVariable( v );
+        }
+        else {
+            // this is a bit hacky as far as the method naming in QueryBuilderData is concerned.
+            // we add a select statement as a variable name.
+            v = qbd->uniqueVarName();
+            QString selectVar = QString::fromLatin1( "%1 as ?%2")
+                                .arg(varInAggregateFunction(m_aggregateFunction, v),
+                                     m_variableName );
+            qbd->addCustomVariable( selectVar );
+        }
+    }
+    else {
+        v = qbd->uniqueVarName();
+        if( m_aggregateFunction == ComparisonTerm::NoAggregateFunction )
+            sortVar = v;
+        else
+            sortVar = varInAggregateFunction(m_aggregateFunction, v);
+    }
+    if( m_sortWeight != 0 ) {
+        qbd->addOrderVariable( sortVar, m_sortWeight, m_sortOrder );
+    }
+    return v;
+}
+
+
+QString Nepomuk::Query::ComparisonTermPrivate::propertyToString( QueryBuilderData* qbd ) const
+{
+    if( m_property.isValid() )
+        return Soprano::Node::resourceToN3( m_property.uri() );
+    else
+        return qbd->uniqueVarName();
+}
+
+
 Nepomuk::Query::ComparisonTerm::ComparisonTerm()
     : SimpleTerm( new ComparisonTermPrivate() )
 {
@@ -289,3 +376,75 @@
     N_D( ComparisonTerm );
     d->m_property = property;
 }
+
+
+void Nepomuk::Query::ComparisonTerm::setVariableName( const QString& name )
+{
+    N_D( ComparisonTerm );
+    d->m_variableName = name;
+}
+
+
+QString Nepomuk::Query::ComparisonTerm::variableName() const
+{
+    N_D_CONST( ComparisonTerm );
+    return d->m_variableName;
+}
+
+
+void Nepomuk::Query::ComparisonTerm::setAggregateFunction( AggregateFunction function )
+{
+    N_D( ComparisonTerm );
+    d->m_aggregateFunction = function;
+}
+
+
+Nepomuk::Query::ComparisonTerm::AggregateFunction Nepomuk::Query::ComparisonTerm::aggregateFunction() const
+{
+    N_D_CONST( ComparisonTerm );
+    return d->m_aggregateFunction;
+}
+
+
+void Nepomuk::Query::ComparisonTerm::setSortWeight( int weight, Qt::SortOrder sortOrder )
+{
+    N_D( ComparisonTerm );
+    d->m_sortWeight = weight;
+    d->m_sortOrder = sortOrder;
+}
+
+
+int Nepomuk::Query::ComparisonTerm::sortWeight() const
+{
+    N_D_CONST( ComparisonTerm );
+    return d->m_sortWeight;
+}
+
+
+Qt::SortOrder Nepomuk::Query::ComparisonTerm::sortOrder() const
+{
+    N_D_CONST( ComparisonTerm );
+    return d->m_sortOrder;
+}
+
+
+bool Nepomuk::Query::ComparisonTerm::isInverted() const
+{
+    N_D_CONST( ComparisonTerm );
+    return d->m_inverted;
+}
+
+
+void Nepomuk::Query::ComparisonTerm::setInverted( bool invert )
+{
+    N_D( ComparisonTerm );
+    d->m_inverted = invert;
+}
+
+
+Nepomuk::Query::ComparisonTerm Nepomuk::Query::ComparisonTerm::inverted() const
+{
+    ComparisonTerm ct( *this );
+    ct.setInverted( !isInverted() );
+    return ct;
+}
Index: nepomuk/query/query.cpp
===================================================================
--- nepomuk/query/query.cpp	(révision 1125741)
+++ nepomuk/query/query.cpp	(copie de travail)
@@ -1,6 +1,6 @@
 /*
    This file is part of the Nepomuk KDE project.
-   Copyright (C) 2008-2009 Sebastian Trueg <trueg@kde.org>
+   Copyright (C) 2008-2010 Sebastian Trueg <trueg@kde.org>
 
    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Library General Public
@@ -50,10 +50,17 @@
 
 #include <kdebug.h>
 
+/*
+## Full Text Score
+## Entity Rank
+## Surfaced via SPARQL
 
+SELECT ?s ?sc  ( <LONG::IRI_RANK> (?s) ) as ?Rank
+WHERE { ?s ?p ?o .
+?o bif:contains 'NEW AND YOR' option (score ?sc). }
+ORDER BY  desc (?
+*/
 
-namespace {
-}
 
 
 QString Nepomuk::Query::QueryPrivate::createFolderFilter( const QString& resourceVarName, QueryBuilderData* qbd ) const
@@ -185,6 +192,13 @@
 }
 
 
+Nepomuk::Query::Query& Nepomuk::Query::Query::operator=( const Term& term )
+{
+    d->m_term = term;
+    return *this;
+}
+
+
 bool Nepomuk::Query::Query::isValid() const
 {
     return d->m_term.isValid();
@@ -203,6 +217,12 @@
 }
 
 
+int Nepomuk::Query::Query::offset() const
+{
+    return d->m_offset;
+}
+
+
 void Nepomuk::Query::Query::setTerm( const Term& term )
 {
     d->m_term = term;
@@ -215,6 +235,12 @@
 }
 
 
+void Nepomuk::Query::Query::setOffset( int offset )
+{
+    d->m_offset = offset;
+}
+
+
 void Nepomuk::Query::Query::addRequestProperty( const RequestProperty& property )
 {
     d->m_requestProperties.append( property );
@@ -254,6 +280,7 @@
 bool Nepomuk::Query::Query::operator==( const Query& other ) const
 {
     return( d->m_limit == other.d->m_limit &&
+            d->m_offset == other.d->m_offset &&
             d->m_term == other.d->m_term &&
             compareQList( d->m_requestProperties, other.d->m_requestProperties ) &&
             compareQList( d->m_includeFolders, other.d->m_includeFolders ) &&
@@ -263,8 +290,7 @@
 
 QString Nepomuk::Query::Query::toSparqlQuery( SparqlFlags flags ) const
 {
-    // optimize whatever we can
-    Term term = QueryPrivate::optimizeTerm( d->m_term );
+    Term term = d->m_term;
 
     // restrict to files if we are a file query
     if( d->m_isFileQuery ) {
@@ -275,24 +301,39 @@
                                       ComparisonTerm( Soprano::Vocabulary::RDF::type(), ResourceTerm(Vocabulary::NFO::Folder()), ComparisonTerm::Equal ) ) );
     }
 
+    // optimize whatever we can
+    term = QueryPrivate::optimizeTerm( term );
+
     // actually build the SPARQL query string
     QueryBuilderData qbd( flags );
-    QString termGraphPattern = term.d_ptr->toSparqlGraphPattern( QLatin1String( "?r" ), &qbd );
-    if( !termGraphPattern.isEmpty() ) {
-        QString query = QString::fromLatin1( "select %1 %2 where { %3 %4 %5 }" )
-                        .arg( flags & CreateCountQuery ? QLatin1String("count(distinct ?r)") : QLatin1String("distinct ?r"),
-                              d->buildRequestPropertyVariableList(),
-                              termGraphPattern,
-                              d->createFolderFilter( QLatin1String( "?r" ), &qbd ),
-                              d->buildRequestPropertyPatterns() );
-        if ( d->m_limit > 0 )
-            query += QString::fromLatin1( " LIMIT %1" ).arg( d->m_limit );
-        return query;
+    QString termGraphPattern;
+    if( term.isValid() ) {
+        termGraphPattern = term.d_ptr->toSparqlGraphPattern( QLatin1String( "?r" ), &qbd );
+        if( termGraphPattern.isEmpty() ) {
+            kDebug() << "Got no valid SPARQL pattern from" << term;
+            return QString();
+        }
     }
     else {
-        kDebug() << "Got no valid SPARQL pattern from" << term;
-        return QString();
+        // create the "all resources query"
+        termGraphPattern = QString::fromLatin1("graph ?g { ?r a ?t . } . ?g a ?gt . ?gt rdfs:subClassOf nrl:InstanceBase . ");
     }
+
+    QString query = QString::fromLatin1( "select %1 %2 %3 where { %4 %5 %6 }" )
+                    .arg( flags & CreateCountQuery ? QLatin1String("count(distinct ?r)") : QLatin1String("distinct ?r"),
+                          d->buildRequestPropertyVariableList(),
+                          qbd.customVariables().join( QLatin1String(" ") ),
+                          termGraphPattern,
+                          d->createFolderFilter( QLatin1String( "?r" ), &qbd ),
+                          d->buildRequestPropertyPatterns() );
+
+    query += qbd.buildOrderString();
+
+    if ( d->m_offset > 0 )
+        query += QString::fromLatin1( " OFFSET %1" ).arg( d->m_offset );
+    if ( d->m_limit > 0 )
+        query += QString::fromLatin1( " LIMIT %1" ).arg( d->m_limit );
+    return query.simplified();
 }
 
 
@@ -323,6 +364,7 @@
 QDebug operator<<( QDebug dbg, const Nepomuk::Query::Query& query )
 {
     dbg << "(Query:           " << query.term() << endl
+        << " Offset:           " << query.offset()
         << " Limit:           " << query.limit() << ")";
     return dbg;
 }
Index: nepomuk/query/literalterm_p.h
===================================================================
--- nepomuk/query/literalterm_p.h	(révision 1125741)
+++ nepomuk/query/literalterm_p.h	(copie de travail)
@@ -1,6 +1,6 @@
 /*
    This file is part of the Nepomuk KDE project.
-   Copyright (C) 2009 Sebastian Trueg <trueg@kde.org>
+   Copyright (C) 2009-2010 Sebastian Trueg <trueg@kde.org>
 
    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
@@ -40,8 +40,7 @@
             QString toSparqlGraphPattern( const QString& resourceVarName, QueryBuilderData* qbd ) const;
             QString toString() const;
 
-            /// The text that is to be used in the bif:contains pattern. A '*' wildcard will be
-            /// added if it does not exist yet.
+            /// The text that is to be used in the bif:contains pattern.
             QString queryText() const;
 
             Soprano::LiteralValue m_value;
Index: nepomuk/query/queryserviceclient_p.h
===================================================================
--- nepomuk/query/queryserviceclient_p.h	(révision 0)
+++ nepomuk/query/queryserviceclient_p.h	(révision 0)
@@ -0,0 +1,49 @@
+/*
+   Copyright (c) 2010 Dario Freddi <drf@kde.org>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) version 3, or any
+   later version accepted by the membership of KDE e.V. (or its
+   successor approved by the membership of KDE e.V.), which shall
+   act as a proxy defined in Section 6 of version 3 of the license.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef _NEPOMUK_QUERY_SERVICE_CLIENT_P_H_
+#define _NEPOMUK_QUERY_SERVICE_CLIENT_P_H_
+
+#include "result.h"
+
+#include <QtCore/QEventLoop>
+#include <QtCore/QTimer>
+
+namespace {
+
+    class NepomukResultListEventLoop : public QEventLoop
+    {
+        Q_OBJECT
+        public:
+            NepomukResultListEventLoop(Nepomuk::Query::QueryServiceClient *parent);
+            virtual ~NepomukResultListEventLoop();
+
+            QList<Nepomuk::Query::Result> result() const;
+
+        public Q_SLOTS:
+            void addEntries(const QList<Nepomuk::Query::Result> &entries);
+
+        private:
+            QList<Nepomuk::Query::Result> m_result;
+    };
+
+}
+
+#endif

Modification de propriétés sur nepomuk/query/queryserviceclient_p.h
___________________________________________________________________
Ajouté : svn:eol-style
   + native

Index: nepomuk/query/term.h
===================================================================
--- nepomuk/query/term.h	(révision 1125741)
+++ nepomuk/query/term.h	(copie de travail)
@@ -38,6 +38,7 @@
         class OrTerm;
         class ComparisonTerm;
         class ResourceTypeTerm;
+        class OptionalTerm;
 
         class TermPrivate;
 
@@ -116,7 +117,16 @@
                  *
                  * \sa NegationTerm
                  */
-                Negation
+                Negation,
+
+                /**
+                 * An optional term which marks its sub term as optional.
+                 *
+                 * \sa OptionalTerm
+                 *
+                 * \since 4.5
+                 */
+                Optional
             };
 
             /**
@@ -166,6 +176,13 @@
             bool isNegationTerm() const;
 
             /**
+             * \return \p true if this term is a OptionalTerm.
+             *
+             * \since 4.5
+             */
+            bool isOptionalTerm() const;
+
+            /**
              * \return \p true if this term is an AndTerm.
              */
             bool isAndTerm() const;
@@ -210,6 +227,16 @@
             NegationTerm toNegationTerm() const;
 
             /**
+             * Interpret this term as a OptionalTerm.
+             *
+             * \return A copy of this term if its type
+             * is Optional, a new OptionalTerm otherwise.
+             *
+             * \since 4.5
+             */
+            OptionalTerm toOptionalTerm() const;
+
+            /**
              * Interpret this term as a AndTerm.
              *
              * \return A copy of this term if its type
@@ -269,6 +296,17 @@
             NegationTerm& toNegationTerm();
 
             /**
+             * Convert this term into a OptionalTerm.
+             * If type is not Optional it will be changed
+             * and the result is a new OptionalTerm.
+             *
+             * \return A reference to this term as a OptionalTerm.
+             *
+             * \since 4.5
+             */
+            OptionalTerm& toOptionalTerm();
+
+            /**
              * Convert this term into a AndTerm.
              * If type is not And it will be changed
              * and the result is a new AndTerm.
@@ -326,6 +364,7 @@
             friend class OrTermPrivate;
             friend class ComparisonTermPrivate;
             friend class NegationTermPrivate;
+            friend class OptionalTermPrivate;
             friend class Query;
             /** \endcond */
         };
Index: nepomuk/query/optionalterm.h
===================================================================
--- nepomuk/query/optionalterm.h	(révision 0)
+++ nepomuk/query/optionalterm.h	(révision 0)
@@ -0,0 +1,81 @@
+/*
+   This file is part of the Nepomuk KDE project.
+   Copyright (C) 2010 Sebastian Trueg <trueg@kde.org>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) version 3, or any
+   later version accepted by the membership of KDE e.V. (or its
+   successor approved by the membership of KDE e.V.), which shall
+   act as a proxy defined in Section 6 of version 3 of the license.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef _NEPOMUK_QUERY_OPTIONAL_TERM_H_
+#define _NEPOMUK_QUERY_OPTIONAL_TERM_H_
+
+#include "simpleterm.h"
+
+#include "nepomukquery_export.h"
+
+namespace Nepomuk {
+    namespace Query {
+        /**
+         * \class OptionalTerm optionalterm.h Nepomuk/Query/OptionalTerm
+         *
+         * \brief Make a term optional.
+         *
+         * %OptionalTerm can be used to mark another term as optional.
+         * This is mostly useful with subterms of type ComparisonTerm
+         * (or an AndTerm combining ComparisonTerms) which either have
+         * additional bindings (ComparisonTerm::setVariableName()) or
+         * a specified sort weight (ComparisonTerm::setSortWeight()).
+         *
+         * \author Sebastian Trueg <trueg@kde.org>
+         *
+         * \since 4.5
+         */
+        class NEPOMUKQUERY_EXPORT OptionalTerm : public SimpleTerm
+        {
+        public:
+            /**
+             * Default constructor: creates an invalid optional term.
+             */
+            OptionalTerm();
+
+            /**
+             * Copy constructor.
+             */
+            OptionalTerm( const OptionalTerm& term );
+
+            /**
+             * Destructor.
+             */
+            ~OptionalTerm();
+
+            /**
+             * Assignment operator.
+             */
+            OptionalTerm& operator=( const OptionalTerm& term );
+
+            /**
+             * Mark \p term as optional. This method will encasulate
+             * \p term in an OptionalTerm except if \p term is already
+             * of type OptionalTerm.
+             *
+             * \return The optional term.
+             */
+            static Term optionalizeTerm( const Term& term );
+        };
+    }
+}
+
+#endif

Modification de propriétés sur nepomuk/query/optionalterm.h
___________________________________________________________________
Ajouté : svn:eol-style
   + native

Index: nepomuk/query/result.h
===================================================================
--- nepomuk/query/result.h	(révision 1125741)
+++ nepomuk/query/result.h	(copie de travail)
@@ -1,6 +1,6 @@
 /*
    This file is part of the Nepomuk KDE project.
-   Copyright (C) 2008-2009 Sebastian Trueg <trueg@kde.org>
+   Copyright (C) 2008-2010 Sebastian Trueg <trueg@kde.org>
 
    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Library General Public
@@ -26,12 +26,14 @@
 #include <QtCore/QHash>
 
 #include <Soprano/Statement>
+#include <Soprano/BindingSet>
 
 #include "nepomukquery_export.h"
 
 namespace Nepomuk {
 
     class Resource;
+    class Variant;
     namespace Types {
         class Property;
     }
@@ -45,6 +47,9 @@
          * A search via QueryServiceClient returns a set of Result object. A result consists
          * of a Nepomuk::Resource and an optional score.
          *
+         * Additional bindings (variable values) as requested via ComparisonTerm::setVariableName()
+         * can be retrieved using additionalBinding().
+         *
          * \author Sebastian Trueg <trueg@kde.org>
          *
          * \since 4.4
@@ -124,11 +129,54 @@
             /**
              * Retrieve value of request property \p property.
              *
-             * \sa requestProperties, addRequestProperty
+             * \sa additionalBinding, requestProperties, addRequestProperty
              */
             Soprano::Node requestProperty( const Types::Property& property ) const;
 
             /**
+             * Set the additional bindings a query returned besides the result
+             * itself and the request properties.
+             *
+             * Normally there is no need to call this method as the query service
+             * does set the bindings.
+             *
+             * \since 4.5
+             */
+            void setAdditionalBindings( const Soprano::BindingSet& bindings );
+
+            /**
+             * Retrieve the set of additional bindings as set via setAdditionalBindings().
+             * Normally one would use additionalBinding() instead.
+             *
+             * \since 4.5
+             */
+            Soprano::BindingSet additionalBindings() const;
+
+            /**
+             * Retrieve an additional binding as returned by the query. Typically
+             * these bindings are created via ComparisonTerm::setVariableName().
+             * But they could also stem from custom SPARQL queries. A simple
+             * example would be:
+             *
+             * \code
+             * select ?r ?rating where { ?r nao:numericRating ?rating . }
+             * \endcode
+             *
+             * Here \p ?r would be used as the result's resource while
+             * \p ?rating could be accessed via
+             *
+             * \code
+             * additionalBinding( QLatin1String("rating") );
+             * \endcode
+             *
+             * If for some reason one needs the plain binding values one
+             * could use additionalBinding().
+             *
+             * \since 4.5
+             */
+            Variant additionalBinding( const QString& name ) const;
+
+            /**
              * Comparison operator
              */
             bool operator==( const Result& ) const;
Index: nepomuk/query/comparisonterm_p.h
===================================================================
--- nepomuk/query/comparisonterm_p.h	(révision 1125741)
+++ nepomuk/query/comparisonterm_p.h	(copie de travail)
@@ -29,10 +29,17 @@
 
 namespace Nepomuk {
     namespace Query {
+
+        class QueryBuilderData;
+
         class ComparisonTermPrivate : public SimpleTermPrivate
         {
         public:
-            ComparisonTermPrivate() {
+            ComparisonTermPrivate()
+                : m_aggregateFunction(ComparisonTerm::NoAggregateFunction),
+                  m_sortWeight(0),
+                  m_sortOrder(Qt::AscendingOrder),
+                  m_inverted(false) {
                 m_type = Term::Comparison;
             }
 
@@ -43,8 +50,26 @@
             QString toSparqlGraphPattern( const QString& resourceVarName, QueryBuilderData* qbd ) const;
             QString toString() const;
 
+            /**
+             * return m_variableName and register it with qbd
+             * or ask the latter to create a new variable.
+             */
+            QString getMainVariableName( QueryBuilderData* qbd ) const;
+
+            /**
+             * return the N3 form of m_property or a new variable
+             * in case m_property is invalid.
+             */
+            QString propertyToString( QueryBuilderData* qbd ) const;
+
             Types::Property m_property;
             ComparisonTerm::Comparator m_comparator;
+
+            QString m_variableName;
+            ComparisonTerm::AggregateFunction m_aggregateFunction;
+            int m_sortWeight;
+            Qt::SortOrder m_sortOrder;
+            bool m_inverted;
         };
     }
 }
Index: nepomuk/query/queryparser.h
===================================================================
--- nepomuk/query/queryparser.h	(révision 1125741)
+++ nepomuk/query/queryparser.h	(copie de travail)
@@ -99,6 +99,31 @@
             ~QueryParser();
 
             /**
+             * Flags to change the behaviour of the parser.
+             *
+             * \since 4.5
+             */
+            enum ParserFlag {
+                /**
+                 * No flags. Default for parse()
+                 */
+                NoParserFlags = 0x0,
+
+                /**
+                 * Make each full text term use a '*' wildcard
+                 * to match longer strings ('foobar' is matched
+                 * by 'foob*').
+                 *
+                 * Be aware that the query engine needs at least
+                 * 4 chars to do globbing though.
+                 *
+                 * This is disabled by default.
+                 */
+                QueryTermGlobbing = 0x1
+            };
+            Q_DECLARE_FLAGS( ParserFlags, ParserFlag )
+
+            /**
              * Parse a user query.
              *
              * \return The parsed query or an invalid Query object
@@ -107,6 +132,19 @@
             Query parse( const QString& query ) const;
 
             /**
+             * Parse a user query.
+             *
+             * \param query The query string to parse
+             * \param flags a set of flags influencing the parsing process.
+             *
+             * \return The parsed query or an invalid Query object
+             * in case the parsing failed.
+             *
+             * \since 4.5
+             */
+            Query parse( const QString& query, ParserFlags flags ) const;
+
+            /**
              * Try to match a field name as used in a query string to actual
              * properties.
              *
@@ -140,4 +178,6 @@
     }
 }
 
+Q_DECLARE_OPERATORS_FOR_FLAGS( Nepomuk::Query::QueryParser::ParserFlags )
+
 #endif
Index: nepomuk/query/query_p.h
===================================================================
--- nepomuk/query/query_p.h	(révision 1125741)
+++ nepomuk/query/query_p.h	(copie de travail)
@@ -40,6 +40,7 @@
         public:
             QueryPrivate()
                 : m_limit( 0 ),
+                  m_offset( 0 ),
                   m_isFileQuery( false ) {
             }
 
@@ -54,6 +55,7 @@
 
             Term m_term;
             int m_limit;
+            int m_offset;
 
             QList<Query::RequestProperty> m_requestProperties;
 
Index: nepomuk/query/literalterm.h
===================================================================
--- nepomuk/query/literalterm.h	(révision 1125741)
+++ nepomuk/query/literalterm.h	(copie de travail)
@@ -62,6 +62,23 @@
          * The example above will match all resources that have a property with a value containing
          * the string "nepomuk".
          *
+         * \section literalterm_examples Examples
+         *
+         * <pre>LiteralTerm("nepomuk")</pre> searches for the term "nepomuk".
+         *
+         * <pre>LiteralTerm("'nepomuk*'")</pre> searches for the terms starting with "nepomuk".
+         *
+         * <pre>LiteralTerm("'nepomuk kde'")</pre> searches for the term "nepomuk kde".
+         *
+         * <pre>LiteralTerm("'nepomuk* kde'")</pre> searches for terms matching "nepomuk* kde".
+         *
+         * %LiteralTerm always tries to normalize the query terms as best as possible. This includes
+         * automatically adding quotes as needed.
+         *
+         * \warning Be aware that the examples above apply to using %LiteralTerm as a stand-alone term
+         * or in a ComparisonTerm::Contains term. When using ComparisonTerm::Regexp the test as specified
+         * will be used as-is to create the regular expression.
+         *
          * \author Sebastian Trueg <trueg@kde.org>
          *
          * \since 4.4
Index: nepomuk/query/querybuilderdata_p.h
===================================================================
--- nepomuk/query/querybuilderdata_p.h	(révision 1125741)
+++ nepomuk/query/querybuilderdata_p.h	(copie de travail)
@@ -24,6 +24,7 @@
 
 #include <QtCore/QString>
 #include <QtCore/QLatin1String>
+#include <QtCore/QSet>
 
 #include "query.h"
 
@@ -41,13 +42,69 @@
                 return m_flags;
             }
 
+            /// used by different implementations of TermPrivate::toSparqlGraphPattern and Query::toSparqlQuery
             inline QString uniqueVarName() {
                 return QLatin1String( "?v" ) + QString::number( ++m_varNameCnt );
             }
 
+            /// used by ComparisonTerm to add variable names set via ComparisonTerm::setVariableName
+            inline void addCustomVariable( const QString& name ) {
+                m_customVariables << name;
+            }
+
+            /// used by Query::toSparqlQuery
+            inline QStringList customVariables() const {
+                return m_customVariables.toList();
+            }
+
+            struct OrderVariable {
+                OrderVariable(int w, const QString& n, Qt::SortOrder o)
+                    : weight(w),
+                      name(n),
+                      sortOrder(o) {
+                }
+                int weight;
+                QString name;
+                Qt::SortOrder sortOrder;
+            };
+
+            /// used by ComparisonTerm to add sorting variables (names include the '?')
+            inline void addOrderVariable( const QString& name, int weight, Qt::SortOrder order ) {
+                int i = 0;
+                while( i < m_orderVariables.count() &&
+                       m_orderVariables[i].weight > weight )
+                    ++i;
+                m_orderVariables.insert( i, OrderVariable( weight, name, order ) );
+            }
+
+            /// used by Query::toSparqlQuery
+            inline QString buildOrderString() const {
+                if( m_orderVariables.isEmpty() )
+                    return QString();
+                QString s = QLatin1String(" ORDER BY ");
+                for( int i = 0; i < m_orderVariables.count(); ++i ) {
+                    if( m_orderVariables[i].sortOrder == Qt::DescendingOrder )
+                        s += QLatin1String("DESC ");
+                    else
+                        s += QLatin1String("ASC ");
+                    s += QString::fromLatin1("( %1 )").arg(m_orderVariables[i].name);
+                    s += ' ';
+                }
+                return s;
+            }
+
         private:
+            /// a running counter for unique variable names
             int m_varNameCnt;
-            Query::SparqlFlags m_flags;
+
+            /// copy of the flags as set in Query::toSparqlQuery
+            const Query::SparqlFlags m_flags;
+
+            /// custom variables that have been added via ComparisonTerm::setVariableName
+            QSet<QString> m_customVariables;
+
+            /// variables that are used for sorting set via ComparisonTerm::setSortWeight
+            QList<OrderVariable> m_orderVariables;
         };
     }
 }
Index: nepomuk/query/queryserviceclient.h
===================================================================
--- nepomuk/query/queryserviceclient.h	(révision 1125741)
+++ nepomuk/query/queryserviceclient.h	(copie de travail)
@@ -48,6 +48,9 @@
          * track. One instance may also be reused for subsequent queries if further updates
          * of the persistent query are not necessary.
          *
+         * For quick queries which do not require any updates one of the static query methods
+         * can be used: syncQuery(), syncSparqlQuery(), or syncDesktopQuery().
+         *
          * \author Sebastian Trueg <trueg@kde.org>
          *
          * \since 4.4
@@ -74,6 +77,62 @@
              */
             static bool serviceAvailable();
 
+            /**
+             * Start a query using the Nepomuk query service.
+             *
+             * A local event loop will be started to block the method
+             * call until all results have been listed, and results will be
+             * returned. You can check if the query was successful through
+             * the \p ok pointer.
+             *
+             * If updates to the query results are required an instance of QueryServiceClient
+             * should be created and one of the non-static query methods be used.
+             *
+             * \param query the query to perform.
+             * \param ok a valid boolean pointer, which will be set to \p true
+             * if the query service was found and the query was started, \p false otherwise.
+             * If you don't want to track errors, you can pass a null pointer instead.
+             *
+             * \return a list of \p Result for the given query.
+             *
+             * \sa query(const Query&)
+             *
+             * \since 4.5
+             */
+            static QList<Nepomuk::Query::Result> syncQuery( const Query& query, bool *ok = 0 );
+
+            /**
+             * \overload
+             *
+             * \param query a SPARQL query which binds results to variable \p 'r'.
+             * \param ok a valid boolean pointer, which will be set to \p true
+             * if the query service was found and the query was started, \p false otherwise.
+             * If you don't want to track errors, you can pass a null pointer instead.
+             * \param requestPropertyMap An optional mapping of variable binding names in \p query
+             * to their corresponding properties. For details see sparqlQuery.
+             *
+             * \sa sparqlQuery(const Query&)
+             *
+             * \since 4.5
+             */
+            static QList<Nepomuk::Query::Result> syncSparqlQuery( const QString& query,
+                            const Nepomuk::Query::RequestPropertyMap& requestPropertyMap = Nepomuk::Query::RequestPropertyMap(),
+                            bool *ok = 0 );
+
+            /**
+             * \overload
+             *
+             * \param query a desktop query string which can be parsed by QueryParser.
+             * \param ok a valid boolean pointer, which will be set to \p true
+             * if the query service was found and the query was started, \p false otherwise.
+             * If you don't want to track errors, you can pass a null pointer instead.
+             *
+             * \sa desktopQuery(const QString&)
+             *
+             * \since 4.5
+             */
+            static QList<Nepomuk::Query::Result> syncDesktopQuery( const QString& query, bool *ok = 0 );
+
         public Q_SLOTS:
             /**
              * Start a query using the Nepomuk query service.
Index: nepomuk/query/CMakeLists.txt
===================================================================
--- nepomuk/query/CMakeLists.txt	(révision 1125741)
+++ nepomuk/query/CMakeLists.txt	(copie de travail)
@@ -8,10 +8,11 @@
   ${NEPOMUK_INCLUDE_DIR}
   ${CMAKE_CURRENT_SOURCE_DIR}/..
   ${CMAKE_CURRENT_SOURCE_DIR}/../core
-  ${CMAKE_CURRENT_SOURCE_DIR}/../core/ontology
+  ${CMAKE_CURRENT_SOURCE_DIR}/../core/types
 )
 
 add_definitions (${QT_DEFINITIONS} ${KDE4_DEFINITIONS})
+add_definitions(-DDISABLE_NEPOMUK_LEGACY=1)
 
 set(nepomukquery_SRC
   term.cpp
@@ -24,6 +25,7 @@
   resourceterm.cpp
   literalterm.cpp
   resourcetypeterm.cpp
+  optionalterm.cpp
   query.cpp
   query_p.cpp
   filequery.cpp
@@ -74,6 +76,7 @@
   resourceterm.h
   literalterm.h
   resourcetypeterm.h
+  optionalterm.h
   query.h
   filequery.h
   result.h
Index: nepomuk/query/dbusoperators.cpp
===================================================================
--- nepomuk/query/dbusoperators.cpp	(révision 1125741)
+++ nepomuk/query/dbusoperators.cpp	(copie de travail)
@@ -26,6 +26,7 @@
 #include "property.h"
 
 #include <Soprano/Node>
+#include <Soprano/BindingSet>
 
 
 void Nepomuk::Query::registerDBusTypes()
@@ -45,10 +46,12 @@
 
     arg.beginStructure();
 
+    // resource URI and score
     arg << QString::fromAscii( result.resource().resourceUri().toEncoded() ) << result.score();
 
     arg.beginMap( QVariant::String, qMetaTypeId<Soprano::Node>() );
 
+    // request properties
     QHash<Nepomuk::Types::Property, Soprano::Node> rp = result.requestProperties();
     for ( QHash<Nepomuk::Types::Property, Soprano::Node>::const_iterator it = rp.constBegin(); it != rp.constEnd(); ++it ) {
         arg.beginMapEntry();
@@ -56,6 +59,15 @@
         arg.endMapEntry();
     }
 
+    // additional bindings (the hacked version to make sure we do not change the signature. It would probably
+    // not be a big deal to change it but neither is this hack)
+    const Soprano::BindingSet additionalBindings = result.additionalBindings();
+    foreach( const QString& binding, additionalBindings.bindingNames() ) {
+        arg.beginMapEntry();
+        arg << (QLatin1String("|") + binding) << additionalBindings[binding]; // we use some char which is very invalid in URIs
+        arg.endMapEntry();
+    }
+
     arg.endMap();
 
     arg.endStructure();
@@ -73,6 +85,7 @@
     arg.beginStructure();
     QString uri;
     double score = 0.0;
+    Soprano::BindingSet additionalBindings;
 
     arg >> uri >> score;
     result = Nepomuk::Query::Result( QUrl::fromEncoded( uri.toAscii() ), score );
@@ -84,12 +97,17 @@
         arg.beginMapEntry();
         arg >> rs >> node;
         arg.endMapEntry();
-        result.addRequestProperty( QUrl::fromEncoded( rs.toAscii() ), node );
+        if( rs.startsWith(QLatin1String("|")) )
+            additionalBindings.insert( rs.mid(1), node );
+        else
+            result.addRequestProperty( QUrl::fromEncoded( rs.toAscii() ), node );
     }
     arg.endMap();
 
     arg.endStructure();
 
+    result.setAdditionalBindings( additionalBindings );
+
     return arg;
 }
 
Index: nepomuk/query/test/queryparsertest.cpp
===================================================================
--- nepomuk/query/test/queryparsertest.cpp	(révision 1125741)
+++ nepomuk/query/test/queryparsertest.cpp	(copie de travail)
@@ -1,6 +1,6 @@
 /*
    This file is part of the Nepomuk KDE project.
-   Copyright (C) 2009 Sebastian Trueg <trueg@kde.org>
+   Copyright (C) 2009-2010 Sebastian Trueg <trueg@kde.org>
 
    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
@@ -30,18 +30,72 @@
 #include "comparisonterm.h"
 
 #include <QtTest>
+#include <qtest_kde.h>
 
+#include "ktempdir.h"
+
 #include <Soprano/LiteralValue>
 #include <Soprano/Node>
+#include <Soprano/StorageModel>
+#include <Soprano/Backend>
+#include <Soprano/PluginManager>
 #include <Soprano/Vocabulary/NAO>
+#include <Soprano/Vocabulary/NRL>
+#include <Soprano/Vocabulary/RDF>
+#include <Soprano/Vocabulary/RDFS>
+#include <Soprano/Vocabulary/XMLSchema>
 
 #include "property.h"
+#include "resourcemanager.h"
 
-
 Q_DECLARE_METATYPE( Nepomuk::Query::Query )
 
 using namespace Nepomuk::Query;
 
+void QueryParserTest::initTestCase()
+{
+    // we need to use a Virtuoso model as tmp model since redland misses important SPARQL features
+    // that are used by libnepomuk below
+    const Soprano::Backend* backend = Soprano::PluginManager::instance()->discoverBackendByName( "virtuosobackend" );
+    QVERIFY( backend );
+    m_storageDir = new KTempDir();
+    m_model = backend->createModel( Soprano::BackendSettings() << Soprano::BackendSetting(Soprano::BackendOptionStorageDir, m_storageDir->name()) );
+    QVERIFY( m_model );
+
+    // we create one fake ontology
+    QUrl graph("graph:/onto");
+    m_model->addStatement( graph, Soprano::Vocabulary::RDF::type(), Soprano::Vocabulary::NRL::Ontology(), graph );
+
+    m_model->addStatement( QUrl("onto:/label"), Soprano::Vocabulary::RDF::type(), Soprano::Vocabulary::RDF::Property(), graph );
+    m_model->addStatement( QUrl("onto:/label"), Soprano::Vocabulary::RDFS::label(), Soprano::LiteralValue::createPlainLiteral("label"), graph );
+    m_model->addStatement( QUrl("onto:/label"), Soprano::Vocabulary::RDFS::range(), Soprano::Vocabulary::XMLSchema::string(), graph );
+
+    m_model->addStatement( QUrl("onto:/hasTag"), Soprano::Vocabulary::RDF::type(), Soprano::Vocabulary::RDF::Property(), graph );
+    m_model->addStatement( QUrl("onto:/hasTag"), Soprano::Vocabulary::RDFS::label(), Soprano::LiteralValue::createPlainLiteral("has tag"), graph );
+    m_model->addStatement( QUrl("onto:/hasTag"), Soprano::Vocabulary::RDFS::range(), QUrl("onto:/Tag"), graph );
+
+    m_model->addStatement( QUrl("onto:/tag"), Soprano::Vocabulary::RDF::type(), Soprano::Vocabulary::RDF::Property(), graph );
+    m_model->addStatement( QUrl("onto:/tag"), Soprano::Vocabulary::RDFS::label(), Soprano::LiteralValue::createPlainLiteral("hastag"), graph );
+    m_model->addStatement( QUrl("onto:/tag"), Soprano::Vocabulary::RDFS::range(), QUrl("onto:/Tag"), graph );
+
+    m_model->addStatement( QUrl("onto:/Tag"), Soprano::Vocabulary::RDF::type(), Soprano::Vocabulary::RDFS::Class(), graph );
+
+    m_model->addStatement( QUrl("onto:/int"), Soprano::Vocabulary::RDF::type(), Soprano::Vocabulary::RDF::Property(), graph );
+    m_model->addStatement( QUrl("onto:/int"), Soprano::Vocabulary::RDFS::label(), Soprano::LiteralValue::createPlainLiteral("int value"), graph );
+    m_model->addStatement( QUrl("onto:/int"), Soprano::Vocabulary::RDFS::range(), Soprano::Vocabulary::XMLSchema::integer(), graph );
+
+    Nepomuk::ResourceManager::instance()->setOverrideMainModel( m_model );
+}
+
+
+void QueryParserTest::cleanupTestCase()
+{
+    Nepomuk::ResourceManager::instance()->setOverrideMainModel( 0 );
+    delete m_model;
+    delete m_storageDir;
+}
+
+
 void QueryParserTest::testQueryParser_data()
 {
     QTest::addColumn<QString>( "queryString" );
@@ -49,36 +103,38 @@
 
     // simple literal queries
     QTest::newRow( "simple literal query" ) << QString( "Hello" ) << Query( LiteralTerm( "Hello" ) );
-    QTest::newRow( "literal with spaces query" ) << QString( "'Hello World'" ) << Query( LiteralTerm( "Hello World" ) );
+    QTest::newRow( "literal with spaces without quotes" ) << QString( "Hello World" ) << Query( AndTerm( LiteralTerm("Hello"), LiteralTerm("World" ) ) );
+    QTest::newRow( "literal with spaces with quotes" ) << QString( "'Hello World'" ) << Query( LiteralTerm( "Hello World" ) );
 
     // comparison queries
-#ifdef MAKE_OR_QUERIES_WITH_PROPERTIES_IN_THEM
     QTest::newRow( "simple field query" )    << QString( "hastag:nepomuk" )
-                                             << Query( ComparisonTerm( Soprano::Vocabulary::NAO::hasTag(), LiteralTerm( "nepomuk" ) ) );
-    QTest::newRow( "simple property query" ) << QString( "%1:nepomuk" ).arg( Soprano::Node::resourceToN3( Soprano::Vocabulary::NAO::hasTag() ) )
-                                             << Query( ComparisonTerm( Soprano::Vocabulary::NAO::hasTag(), LiteralTerm( "nepomuk" ) ) );
+                                             << Query( OrTerm( ComparisonTerm( QUrl("onto:/hasTag"), LiteralTerm( "nepomuk" ) ),
+                                                               ComparisonTerm( QUrl("onto:/tag"), LiteralTerm( "nepomuk" ) ) ) );
+    QTest::newRow( "simple property query" ) << QString( "<onto:/hasTag>:nepomuk" )
+                                             << Query( ComparisonTerm( QUrl("onto:/hasTag"), LiteralTerm( "nepomuk" ) ) );
 #ifdef QUERY_PARSER_SUPPORTS_RESOURCE_VALUES
     QTest::newRow( "resource field query" )  << QString( "hastag:<nepomuk:/Nepomuk>" )
                                              << Query( ComparisonTerm( "hastag", ResourceTerm( QUrl( "nepomuk:/Nepomuk" ) ) ) );
 #endif
     QTest::newRow( "nested resource query" ) << QString( "hastag:(label:nepomuk)" )
-                                             << Query( ComparisonTerm( Soprano::Vocabulary::NAO::hasTag(), LiteralTerm( "nepomuk" ) ) );
-                                             << Query( ComparisonTerm( "hastag", ComparisonTerm( "label", LiteralTerm( "nepomuk" ) ) ) );
-#endif
+                                             << Query( OrTerm( ComparisonTerm( QUrl("onto:/hasTag"), ComparisonTerm( QUrl("onto:/label"), LiteralTerm( "nepomuk" ) ) ),
+                                                               ComparisonTerm( QUrl("onto:/tag"), ComparisonTerm( QUrl("onto:/label"), LiteralTerm( "nepomuk" ) ) ) ) );
+    QTest::newRow( "int property query" ) << QString( "'int value':42" )
+                                          << Query( ComparisonTerm( QUrl("onto:/int"), LiteralTerm( 42 ) ) );
+    QTest::newRow( "int property query 2" ) << QString( "int:\"42\"" )
+                                            << Query( ComparisonTerm( QUrl("onto:/int"), LiteralTerm( 42 ) ) );
 
 
     // negation
     QTest::newRow( "simple negation" ) << QString( "-Hello" ) << Query( NegationTerm::negateTerm( LiteralTerm( "Hello" ) ) );
-#ifdef MAKE_OR_QUERIES_WITH_PROPERTIES_IN_THEM
-    QTest::newRow( "field negation" ) << QString( "-hastag:nepomuk" ) << Query( NegationTerm::negateTerm( ComparisonTerm( "hastag", LiteralTerm( "nepomuk" ) ) ) );
-#endif
+    QTest::newRow( "field negation" ) << QString( "-label:nepomuk" ) << Query( NegationTerm::negateTerm( ComparisonTerm( QUrl("onto:/label"), LiteralTerm( "nepomuk" ) ) ) );
 
     // and query
-    QTest::newRow( "and: two literals" )          << QString( "Hello World" ) << Query( AndTerm( QList<Term>() << LiteralTerm( "Hello" ) << LiteralTerm( "World" ) ) );
-    QTest::newRow( "and: two literals with AND" ) << QString( "Hello AND World" ) << Query( AndTerm( QList<Term>() << LiteralTerm( "Hello" ) << LiteralTerm( "World" ) ) );
+    QTest::newRow( "and: two literals" )          << QString( "Hello World" ) << Query( AndTerm( LiteralTerm( "Hello" ), LiteralTerm( "World" ) ) );
+    QTest::newRow( "and: two literals with AND" ) << QString( "Hello AND World" ) << Query( AndTerm( LiteralTerm( "Hello" ), LiteralTerm( "World" ) ) );
 
     // or queries
-    QTest::newRow( "or: two literals" )          << QString( "Hello OR World" ) << Query( OrTerm( QList<Term>() << LiteralTerm( "Hello" ) << LiteralTerm( "World" ) ) );
+    QTest::newRow( "or: two literals" )          << QString( "Hello OR World" ) << Query( OrTerm( LiteralTerm( "Hello" ), LiteralTerm( "World" ) ) );
 }
 
 
@@ -87,16 +143,42 @@
     QFETCH( QString, queryString );
     QFETCH( Nepomuk::Query::Query, query );
 
-    qDebug() << "Wanted query:" << query;
-
     Query q = QueryParser::parseQuery( queryString );
 
-    qDebug() << "Parsed query:" << q;
+//    qDebug() << "Wanted query:" << query;
+//    qDebug() << "Parsed query:" << q;
 
     QCOMPARE( q, query );
 }
 
 
-QTEST_MAIN( QueryParserTest )
+void QueryParserTest::testQueryParserWithGlobbing_data()
+{
+    QTest::addColumn<QString>( "queryString" );
+    QTest::addColumn<Nepomuk::Query::Query>( "query" );
 
+    // simple literal queries
+    QTest::newRow( "simple literal query" ) << QString( "Hello" ) << Query( LiteralTerm( "Hello*" ) );
+    QTest::newRow( "simple literal query" ) << QString( "\"Hello\"" ) << Query( LiteralTerm( "Hello" ) );
+    QTest::newRow( "literal with spaces without quotes" ) << QString( "Hello World" ) << Query( AndTerm( LiteralTerm("Hello*"), LiteralTerm("World*" ) ) );
+    QTest::newRow( "literal with spaces with quotes" ) << QString( "'Hello World'" ) << Query( LiteralTerm( "Hello World" ) );
+}
+
+
+void QueryParserTest::testQueryParserWithGlobbing()
+{
+    QFETCH( QString, queryString );
+    QFETCH( Nepomuk::Query::Query, query );
+
+    QueryParser p;
+    Query q = p.parse( queryString, QueryParser::QueryTermGlobbing );
+
+//     qDebug() << "Wanted query:" << query;
+//     qDebug() << "Parsed query:" << q;
+
+    QCOMPARE( q, query );
+}
+
+QTEST_KDEMAIN_CORE( QueryParserTest )
+
 #include "queryparsertest.moc"
Index: nepomuk/query/test/querytest.cpp
===================================================================
--- nepomuk/query/test/querytest.cpp	(révision 1125741)
+++ nepomuk/query/test/querytest.cpp	(copie de travail)
@@ -1,6 +1,6 @@
 /*
    This file is part of the Nepomuk KDE project.
-   Copyright (C) 2009 Sebastian Trueg <trueg@kde.org>
+   Copyright (C) 2009-2010 Sebastian Trueg <trueg@kde.org>
 
    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
@@ -30,7 +30,12 @@
 #include "negationterm.h"
 #include "comparisonterm.h"
 #include "resourcetypeterm.h"
+#include "optionalterm.h"
 #include "nie.h"
+#include "nfo.h"
+#include "nco.h"
+#include "pimo.h"
+#include "property.h"
 
 #include <QtTest>
 
@@ -38,8 +43,10 @@
 #include <Soprano/Node>
 #include <Soprano/Vocabulary/NAO>
 #include <Soprano/Vocabulary/RDFS>
+#include <Soprano/Vocabulary/XMLSchema>
 
 #include <kdebug.h>
+#include <qtest_kde.h>
 
 Q_DECLARE_METATYPE( Nepomuk::Query::Query )
 
@@ -54,10 +61,25 @@
 
     QTest::newRow( "simple literal query" )
         << Query( LiteralTerm( "Hello" ) )
-        << QString::fromLatin1( "select distinct ?r where { { ?r ?v1 ?v2 . ?v2 bif:contains \"'Hello*'\" . } UNION { ?r ?v1 ?v3 . ?v3 ?v4 ?v2 . ?v4 %1 %2 . ?v2 bif:contains \"'Hello*'\" . } . }" )
+        << QString::fromLatin1( "select distinct ?r where { { ?r ?v1 ?v2 . ?v2 bif:contains \"Hello\" . } UNION { ?r ?v1 ?v3 . ?v3 ?v4 ?v2 . ?v4 %1 %2 . ?v2 bif:contains \"Hello\" . } . }" )
         .arg( Soprano::Node::resourceToN3(Soprano::Vocabulary::RDFS::subPropertyOf()),
               Soprano::Node::resourceToN3(Soprano::Vocabulary::RDFS::label()) );
 
+    QString helloWorldQuery = QString::fromLatin1( "select distinct ?r where { { ?r ?v1 ?v2 . ?v2 bif:contains \"'Hello World'\" . } "
+                                                   "UNION "
+                                                   "{ ?r ?v1 ?v3 . ?v3 ?v4 ?v2 . ?v4 %1 %2 . ?v2 bif:contains \"'Hello World'\" . } . }" )
+                              .arg( Soprano::Node::resourceToN3(Soprano::Vocabulary::RDFS::subPropertyOf()),
+                                    Soprano::Node::resourceToN3(Soprano::Vocabulary::RDFS::label()) );
+    QTest::newRow( "simple literal query with space" )
+        << Query( LiteralTerm( "Hello World" ) )
+        << helloWorldQuery;
+    QTest::newRow( "simple literal query with space and quotes" )
+        << Query( LiteralTerm( "'Hello World'" ) )
+        << helloWorldQuery;
+    QTest::newRow( "simple literal query with space and quotes" )
+        << Query( LiteralTerm( "\"Hello World\"" ) )
+        << helloWorldQuery;
+
     QTest::newRow( "type query" )
         << Query( ResourceTypeTerm( Soprano::Vocabulary::NAO::Tag() ) )
         << QString::fromLatin1("select distinct ?r where { ?r a ?v1 . ?v1 %1 %2 . }")
@@ -73,7 +95,7 @@
 
     QTest::newRow( "hastag with literal term" )
         << Query( ComparisonTerm( Soprano::Vocabulary::NAO::hasTag(), LiteralTerm( QLatin1String("nepomuk")) ) )
-        << QString::fromLatin1("select distinct ?r where { ?r %1 ?v1 . ?v1 ?v2 ?v3 . ?v2 %2 %3 . ?v3 bif:contains \"'nepomuk*'\" . }")
+        << QString::fromLatin1("select distinct ?r where { ?r %1 ?v1 . ?v1 ?v2 ?v3 . ?v2 %2 %3 . ?v3 bif:contains \"nepomuk\" . }")
         .arg(Soprano::Node::resourceToN3(Soprano::Vocabulary::NAO::hasTag()))
         .arg(Soprano::Node::resourceToN3(Soprano::Vocabulary::RDFS::subPropertyOf()))
         .arg(Soprano::Node::resourceToN3(Soprano::Vocabulary::RDFS::label()));
@@ -87,6 +109,238 @@
         << Query( NegationTerm::negateTerm(ComparisonTerm( Soprano::Vocabulary::NAO::hasTag(), ResourceTerm( QUrl("nepomuk:/res/foobar") ) )))
         << QString::fromLatin1("select distinct ?r where { OPTIONAL { ?v1 %1 <nepomuk:/res/foobar> . FILTER(?v1=?r) . } . FILTER(!BOUND(?v1)) . }")
         .arg(Soprano::Node::resourceToN3(Soprano::Vocabulary::NAO::hasTag()));
+
+    QTest::newRow( "comparators <" )
+        << Query( ComparisonTerm( Soprano::Vocabulary::NAO::numericRating(), LiteralTerm(4), ComparisonTerm::Smaller ) )
+        << QString::fromLatin1("select distinct ?r where { ?r %1 ?v1 . FILTER(?v1<\"4\"^^%2) . }")
+        .arg(Soprano::Node::resourceToN3(Soprano::Vocabulary::NAO::numericRating()),
+             Soprano::Node::resourceToN3(Soprano::Vocabulary::XMLSchema::xsdInt()) );
+
+    QTest::newRow( "comparators <=" )
+        << Query( ComparisonTerm( Soprano::Vocabulary::NAO::numericRating(), LiteralTerm(4), ComparisonTerm::SmallerOrEqual ) )
+        << QString::fromLatin1("select distinct ?r where { ?r %1 ?v1 . FILTER(?v1<=\"4\"^^%2) . }")
+        .arg(Soprano::Node::resourceToN3(Soprano::Vocabulary::NAO::numericRating()),
+             Soprano::Node::resourceToN3(Soprano::Vocabulary::XMLSchema::xsdInt()) );
+
+    QTest::newRow( "comparators >" )
+        << Query( ComparisonTerm( Soprano::Vocabulary::NAO::numericRating(), LiteralTerm(4), ComparisonTerm::Greater ) )
+        << QString::fromLatin1("select distinct ?r where { ?r %1 ?v1 . FILTER(?v1>\"4\"^^%2) . }")
+        .arg(Soprano::Node::resourceToN3(Soprano::Vocabulary::NAO::numericRating()),
+             Soprano::Node::resourceToN3(Soprano::Vocabulary::XMLSchema::xsdInt()) );
+
+    QTest::newRow( "comparators >=" )
+        << Query( ComparisonTerm( Soprano::Vocabulary::NAO::numericRating(), LiteralTerm(4), ComparisonTerm::GreaterOrEqual ) )
+        << QString::fromLatin1("select distinct ?r where { ?r %1 ?v1 . FILTER(?v1>=\"4\"^^%2) . }")
+        .arg(Soprano::Node::resourceToN3(Soprano::Vocabulary::NAO::numericRating()),
+             Soprano::Node::resourceToN3(Soprano::Vocabulary::XMLSchema::xsdInt()) );
+
+    QTest::newRow( "inverted comparisonterm" )
+        << Query( ComparisonTerm( Soprano::Vocabulary::NAO::hasTag(), ResourceTerm( QUrl("nepomuk:/res/foobar") ) ).inverted() )
+        << QString::fromLatin1("select distinct ?r where { <nepomuk:/res/foobar> %1 ?r . }")
+        .arg(Soprano::Node::resourceToN3(Soprano::Vocabulary::NAO::hasTag()));
+
+    QTest::newRow( "optional term" )
+        << Query(OptionalTerm::optionalizeTerm(ComparisonTerm( Soprano::Vocabulary::NAO::hasTag(), ResourceTerm( QUrl("nepomuk:/res/foobar") ) )))
+        << QString::fromLatin1("select distinct ?r where { OPTIONAL { ?r %1 <nepomuk:/res/foobar> . } }")
+        .arg(Soprano::Node::resourceToN3(Soprano::Vocabulary::NAO::hasTag()));
+
+    QTest::newRow( "and term" )
+        << Query( AndTerm( ComparisonTerm( Soprano::Vocabulary::NAO::numericRating(), LiteralTerm(4), ComparisonTerm::Greater ),
+                           ComparisonTerm( Soprano::Vocabulary::NAO::hasTag(), ResourceTerm(QUrl("nepomuk:/test")) ) ) )
+        << QString::fromLatin1("select distinct ?r where { { ?r %1 ?v1 . FILTER(?v1>\"4\"^^%2) . ?r %3 <nepomuk:/test> . } . }")
+        .arg(Soprano::Node::resourceToN3(Soprano::Vocabulary::NAO::numericRating()),
+             Soprano::Node::resourceToN3(Soprano::Vocabulary::XMLSchema::xsdInt()),
+             Soprano::Node::resourceToN3(Soprano::Vocabulary::NAO::hasTag()));
+
+    ComparisonTerm setVarNameTerm1( Soprano::Vocabulary::NAO::hasTag(), ResourceTypeTerm( Soprano::Vocabulary::NAO::Tag() ) );
+    setVarNameTerm1.setVariableName("myvar");
+    QTest::newRow( "set variable name 1" )
+        << Query( setVarNameTerm1 )
+        << QString::fromLatin1("select distinct ?r ?myvar where { ?r %1 ?myvar . ?myvar a ?v1 . ?v1 %2 %3 . }")
+        .arg(Soprano::Node::resourceToN3(Soprano::Vocabulary::NAO::hasTag()),
+             Soprano::Node::resourceToN3(Soprano::Vocabulary::RDFS::subClassOf()),
+             Soprano::Node::resourceToN3(Soprano::Vocabulary::NAO::Tag()));
+
+    ComparisonTerm setVarNameTerm2( Soprano::Vocabulary::NAO::hasTag(), LiteralTerm( "nepomuk" ) );
+    setVarNameTerm2.setVariableName( "myvar" );
+    QTest::newRow( "set variable name 2" )
+        << Query( setVarNameTerm2 )
+        << QString::fromLatin1("select distinct ?r ?myvar where { ?r %1 ?myvar . ?myvar ?v1 ?v2 . ?v1 %2 %3 . ?v2 bif:contains \"nepomuk\" . }")
+        .arg(Soprano::Node::resourceToN3(Soprano::Vocabulary::NAO::hasTag()),
+             Soprano::Node::resourceToN3(Soprano::Vocabulary::RDFS::subPropertyOf()),
+             Soprano::Node::resourceToN3(Soprano::Vocabulary::RDFS::label()));
+
+    ComparisonTerm setVarNameTerm3( Soprano::Vocabulary::NAO::numericRating(), LiteralTerm(4), ComparisonTerm::Smaller );
+    setVarNameTerm3.setVariableName("myvar");
+    QTest::newRow( "set variable name 3" )
+        << Query( setVarNameTerm3 )
+        << QString::fromLatin1("select distinct ?r ?myvar where { ?r %1 ?myvar . FILTER(?myvar<\"4\"^^%2) . }")
+        .arg(Soprano::Node::resourceToN3(Soprano::Vocabulary::NAO::numericRating()),
+             Soprano::Node::resourceToN3(Soprano::Vocabulary::XMLSchema::xsdInt()) );
+
+    ComparisonTerm setVarNameTerm4( Soprano::Vocabulary::NAO::numericRating(), LiteralTerm(4), ComparisonTerm::Smaller );
+    setVarNameTerm3.setVariableName("myvar" );
+    setVarNameTerm3.setAggregateFunction(ComparisonTerm::Count);
+    QTest::newRow( "set variable name 4 (with aggregate function count)" )
+        << Query( setVarNameTerm3 )
+        << QString::fromLatin1("select distinct ?r count(?v1) as ?myvar where { ?r %1 ?v1 . FILTER(?v1<\"4\"^^%2) . }")
+        .arg(Soprano::Node::resourceToN3(Soprano::Vocabulary::NAO::numericRating()),
+             Soprano::Node::resourceToN3(Soprano::Vocabulary::XMLSchema::xsdInt()) );
+
+    ComparisonTerm orderByTerm1( Soprano::Vocabulary::NAO::numericRating(), LiteralTerm(4), ComparisonTerm::Smaller );
+    orderByTerm1.setSortWeight( 1 );
+    QTest::newRow( "order by 1" )
+        << Query( orderByTerm1 )
+        << QString::fromLatin1("select distinct ?r where { ?r %1 ?v1 . FILTER(?v1<\"4\"^^%2) . } ORDER BY ASC ( ?v1 )")
+        .arg(Soprano::Node::resourceToN3(Soprano::Vocabulary::NAO::numericRating()),
+             Soprano::Node::resourceToN3(Soprano::Vocabulary::XMLSchema::xsdInt()) );
+
+    orderByTerm1.setSortWeight( 1, Qt::DescendingOrder );
+    QTest::newRow( "order by 2" )
+        << Query( orderByTerm1 )
+        << QString::fromLatin1("select distinct ?r where { ?r %1 ?v1 . FILTER(?v1<\"4\"^^%2) . } ORDER BY DESC ( ?v1 )")
+        .arg(Soprano::Node::resourceToN3(Soprano::Vocabulary::NAO::numericRating()),
+             Soprano::Node::resourceToN3(Soprano::Vocabulary::XMLSchema::xsdInt()) );
+
+    ComparisonTerm orderByTerm2( Soprano::Vocabulary::NAO::prefLabel(), LiteralTerm("hello") );
+    orderByTerm2.setSortWeight( 2 );
+
+    QTest::newRow( "order by 3" )
+        << Query( AndTerm( orderByTerm1, orderByTerm2 ) )
+        << QString::fromLatin1("select distinct ?r where { { ?r %1 ?v1 . FILTER(?v1<\"4\"^^%2) . ?r %3 ?v2 . ?v2 bif:contains \"hello\" . } . } ORDER BY ASC ( ?v2 ) DESC ( ?v1 )")
+        .arg(Soprano::Node::resourceToN3(Soprano::Vocabulary::NAO::numericRating()),
+             Soprano::Node::resourceToN3(Soprano::Vocabulary::XMLSchema::xsdInt()),
+             Soprano::Node::resourceToN3(Soprano::Vocabulary::NAO::prefLabel()) );
+
+    orderByTerm1.setVariableName("myvar");
+    QTest::newRow( "order by 4" )
+        << Query( orderByTerm1 )
+        << QString::fromLatin1("select distinct ?r ?myvar where { ?r %1 ?myvar . FILTER(?myvar<\"4\"^^%2) . } ORDER BY DESC ( ?myvar )")
+        .arg(Soprano::Node::resourceToN3(Soprano::Vocabulary::NAO::numericRating()),
+             Soprano::Node::resourceToN3(Soprano::Vocabulary::XMLSchema::xsdInt()) );
+
+    QTest::newRow( "ComparisonTerm with invalid property" )
+        << Query( ComparisonTerm( Nepomuk::Types::Property(), ResourceTerm( QUrl("nepomuk:/res/foobar") ) ))
+        << QString::fromLatin1("select distinct ?r where { ?r ?v1 <nepomuk:/res/foobar> . }");
+
+    QTest::newRow( "ComparisonTerm with invalid subterm" )
+        << Query( ComparisonTerm( Soprano::Vocabulary::NAO::hasTag(), Term() ) )
+        << QString::fromLatin1("select distinct ?r where { ?r %1 ?v1 . }")
+        .arg(Soprano::Node::resourceToN3(Soprano::Vocabulary::NAO::hasTag()));
+
+    QTest::newRow( "ComparisonTerm with invalid property and subterm" )
+        << Query( ComparisonTerm( Nepomuk::Types::Property(), Term() ) )
+        << QString::fromLatin1("select distinct ?r where { ?r ?v1 ?v2 . }");
+
+    ComparisonTerm orderByTerm5( Soprano::Vocabulary::NAO::numericRating(), Term() );
+    orderByTerm5.setSortWeight( 1 );
+    orderByTerm5.setAggregateFunction( ComparisonTerm::Max );
+    QTest::newRow( "order by 5 (with aggregate function and invalid subterm)" )
+        << Query( orderByTerm5 )
+        << QString::fromLatin1("select distinct ?r where { ?r %1 ?v1 . } ORDER BY ASC ( max(?v1) )")
+        .arg(Soprano::Node::resourceToN3(Soprano::Vocabulary::NAO::numericRating()) );
+
+    orderByTerm5.setVariableName( "myvar" );
+    QTest::newRow( "order by 5 (with aggregate function and invalid subterm and varname)" )
+        << Query( orderByTerm5 )
+        << QString::fromLatin1("select distinct ?r max(?v1) as ?myvar where { ?r %1 ?v1 . } ORDER BY ASC ( ?myvar )")
+        .arg(Soprano::Node::resourceToN3(Soprano::Vocabulary::NAO::numericRating()) );
+
+    orderByTerm5.setVariableName( QString() );
+    orderByTerm5.setAggregateFunction( ComparisonTerm::DistinctCount );
+    QTest::newRow( "order by 5 (with aggregate function and invalid subterm and varname)" )
+        << Query( orderByTerm5 )
+        << QString::fromLatin1("select distinct ?r where { ?r %1 ?v1 . } ORDER BY ASC ( count(distinct ?v1) )")
+        .arg(Soprano::Node::resourceToN3(Soprano::Vocabulary::NAO::numericRating()) );
+
+
+    //
+    // A more complex example
+    //
+    QUrl res("nepomuk:/res/foobar");
+    AndTerm mainTerm;
+    OrTerm typeOr;
+    typeOr.addSubTerm( ResourceTypeTerm( Nepomuk::Vocabulary::NFO::RasterImage() ) );
+    typeOr.addSubTerm( ResourceTypeTerm( Nepomuk::Vocabulary::NFO::Audio() ) );
+    mainTerm.addSubTerm( typeOr );
+    mainTerm.addSubTerm( NegationTerm::negateTerm( ComparisonTerm( Nepomuk::Types::Property(), ResourceTerm( res ) ).inverted() ) );
+
+    // an empty comparisonterm results in "?r ?v1 ?v2"
+    ComparisonTerm ct;
+
+    // change the var name: "?r ?v1 ?cnt"
+    ct.setVariableName( "cnt" );
+    ct.setAggregateFunction( ComparisonTerm::Count );
+
+    // by default all have 0, Query::toSparqlQuery will add ORDER BY for all ComparisonTerm with sortweight != 0
+    ct.setSortWeight( 1, Qt::DescendingOrder );
+
+    mainTerm.addSubTerm(ct.inverted());
+
+    QString sparql = QString::fromLatin1("select distinct ?r count(?v6) as ?cnt where { { "
+                                         "{ ?r a ?v1 . ?v1 %1 %2 . } UNION { ?r a ?v2 . ?v2 %1 %3 . } . "
+                                         "OPTIONAL { <nepomuk:/res/foobar> ?v4 ?v3 . FILTER(?v3=?r) . } . FILTER(!BOUND(?v3)) . "
+                                         "?r ?v5 ?v6 . } . } ORDER BY DESC ( ?cnt )")
+                     .arg(Soprano::Node::resourceToN3(Soprano::Vocabulary::RDFS::subClassOf()),
+                          Soprano::Node::resourceToN3(Nepomuk::Vocabulary::NFO::RasterImage()),
+                          Soprano::Node::resourceToN3(Nepomuk::Vocabulary::NFO::Audio()));
+
+    QTest::newRow( "a complex one" )
+        << Query( mainTerm )
+        << sparql;
+
+#if 0
+// subquery to match grouding occurrences of nepomuk:/TEST
+    ComparisonTerm goterm( Nepomuk::Vocabulary::PIMO::groundingOccurrence(),
+                           ResourceTerm( Nepomuk::Resource( QUrl("nepomuk:/TEST")) ) );
+    goterm.setInverted(true);
+
+// combine that with only nco:PersonContacts
+    AndTerm pcgoterm( ResourceTypeTerm( Nepomuk::Vocabulary::NCO::PersonContact() ),
+                      goterm );
+
+// now look for im accounts of those grounding occurrences (pcgoterm will become the subject of this comparison,
+// thus the comparison will match the im accounts)
+    ComparisonTerm impcgoterm( Nepomuk::Vocabulary::NCO::hasIMAccount(),
+                               pcgoterm );
+    impcgoterm.setInverted(true);
+
+// now look for all buddies of the accounts
+    ComparisonTerm buddyTerm( QUrl("http://kde.org/telepathy#isBuddyOf")/*Nepomuk::Vocabulary::Telepathy::isBuddyOf()*/,
+                              impcgoterm );
+
+// set the name of the variable (i.e. the buddies) to be able to match it later
+    buddyTerm.setVariableName("t");
+
+// same comparison, other property, but use the same variable name to match them
+    ComparisonTerm ppterm( QUrl("http://kde.org/telepathy#publishesPresenceTo")/*Nepomuk::Vocabulary::Telepathy::publishesPresenceTo()*/,
+                           ResourceTypeTerm( Nepomuk::Vocabulary::NCO::IMAccount() ) );
+    ppterm.setVariableName("t");
+
+// combine both to complete the matching of the im account ?account
+    AndTerm accountTerm( ResourceTypeTerm( Nepomuk::Vocabulary::NCO::IMAccount() ),
+                         buddyTerm,
+                         ppterm );
+
+// match the account and select it for the results
+    ComparisonTerm imaccountTerm( Nepomuk::Vocabulary::NCO::hasIMAccount(), accountTerm );
+    imaccountTerm.setVariableName("account");
+
+// and finally the exclusion of those person contacts that already have a pimo person attached
+    ComparisonTerm personTerm( Nepomuk::Vocabulary::PIMO::groundingOccurrence(),
+                               ResourceTypeTerm( Nepomuk::Vocabulary::PIMO::Person() ) );
+    personTerm.setInverted(true);
+
+// and all combined
+    Query theQuery( AndTerm( ResourceTypeTerm( Nepomuk::Vocabulary::NCO::PersonContact() ),
+                             imaccountTerm,
+                             NegationTerm::negateTerm(personTerm)) );
+
+
+    QTest::newRow( "and term" )
+        << theQuery
+        << QString::fromLatin1("");
+#endif
 }
 
 
@@ -95,6 +349,7 @@
     QFETCH( Nepomuk::Query::Query, query );
     QFETCH( QString, queryString );
 
+//    kDebug() << query.toSparqlQuery();
     QCOMPARE( query.toSparqlQuery().simplified(), queryString );
 }
 
@@ -123,6 +378,6 @@
     QVERIFY(optimized.isLiteralTerm());
 }
 
-QTEST_MAIN( QueryTest )
+QTEST_KDEMAIN_CORE( QueryTest )
 
 #include "querytest.moc"
Index: nepomuk/query/test/queryparsertest.h
===================================================================
--- nepomuk/query/test/queryparsertest.h	(révision 1125741)
+++ nepomuk/query/test/queryparsertest.h	(copie de travail)
@@ -1,6 +1,6 @@
 /*
    This file is part of the Nepomuk KDE project.
-   Copyright (C) 2009 Sebastian Trueg <trueg@kde.org>
+   Copyright (C) 2009-2010 Sebastian Trueg <trueg@kde.org>
 
    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
@@ -23,14 +23,25 @@
 #define _NEPOMUK_QUERY_PARSER_TEST_H_
 
 #include <QtCore/QObject>
+#include "ktempdir.h"
 
+#include <Soprano/Model>
+
 class QueryParserTest : public QObject
 {
     Q_OBJECT
 
 private Q_SLOTS:
+    void initTestCase();
+    void cleanupTestCase();
     void testQueryParser_data();
     void testQueryParser();
+    void testQueryParserWithGlobbing_data();
+    void testQueryParserWithGlobbing();
+
+private:
+    KTempDir* m_storageDir;
+    Soprano::Model* m_model;
 };
 
 #endif
Index: nepomuk/query/test/CMakeLists.txt
===================================================================
--- nepomuk/query/test/CMakeLists.txt	(révision 1125741)
+++ nepomuk/query/test/CMakeLists.txt	(copie de travail)
@@ -2,8 +2,10 @@
 
 include_directories(${CMAKE_CURRENT_SOURCE_DIR}/..)
 
+add_definitions(-DDISABLE_NEPOMUK_LEGACY=1)
+
 kde4_add_unit_test(queryparsertest NOGUI queryparsertest.cpp)
-target_link_libraries(queryparsertest nepomukquery
+target_link_libraries(queryparsertest nepomuk nepomukquery
   ${QT_QTTEST_LIBRARY}
   ${SOPRANO_LIBRARIES}
   ${KDE4_KDECORE_LIBS}
@@ -12,6 +14,8 @@
 set(querytest_SRC querytest.cpp ../query_p.cpp)
 soprano_add_ontology(querytest_SRC "${SHAREDDESKTOPONTOLOGIES_ROOT_DIR}/nie/nie.trig" "NIE" "Nepomuk::Vocabulary" "trig")
 soprano_add_ontology(querytest_SRC "${SHAREDDESKTOPONTOLOGIES_ROOT_DIR}/nie/nfo.trig" "NFO" "Nepomuk::Vocabulary" "trig")
+soprano_add_ontology(querytest_SRC "${SHAREDDESKTOPONTOLOGIES_ROOT_DIR}/nie/nco.trig" "NCO" "Nepomuk::Vocabulary" "trig")
+soprano_add_ontology(querytest_SRC "${SHAREDDESKTOPONTOLOGIES_ROOT_DIR}/pimo/pimo.trig" "PIMO" "Nepomuk::Vocabulary" "trig")
 kde4_add_unit_test(querytest NOGUI ${querytest_SRC})
 target_link_libraries(querytest nepomuk nepomukquery
   ${QT_QTTEST_LIBRARY}
Index: nepomuk/query/term.cpp
===================================================================
--- nepomuk/query/term.cpp	(révision 1125741)
+++ nepomuk/query/term.cpp	(copie de travail)
@@ -24,6 +24,7 @@
 #include "andterm.h"
 #include "orterm.h"
 #include "negationterm.h"
+#include "optionalterm.h"
 #include "comparisonterm.h"
 #include "resourcetypeterm.h"
 #include "literalterm_p.h"
@@ -31,6 +32,7 @@
 #include "andterm_p.h"
 #include "orterm_p.h"
 #include "negationterm_p.h"
+#include "optionalterm_p.h"
 #include "comparisonterm_p.h"
 #include "resourcetypeterm_p.h"
 
@@ -101,6 +103,12 @@
 }
 
 
+bool Nepomuk::Query::Term::isOptionalTerm() const
+{
+    return type() == Optional;
+}
+
+
 bool Nepomuk::Query::Term::isAndTerm() const
 {
     return type() == And;
@@ -153,6 +161,15 @@
 }
 
 
+Nepomuk::Query::OptionalTerm Nepomuk::Query::Term::toOptionalTerm() const
+{
+    if ( isOptionalTerm() )
+        return *static_cast<const OptionalTerm*>( this );
+    else
+        return OptionalTerm();
+}
+
+
 Nepomuk::Query::AndTerm Nepomuk::Query::Term::toAndTerm() const
 {
     if ( isAndTerm() )
@@ -212,6 +229,12 @@
 }
 
 
+Nepomuk::Query::OptionalTerm& Nepomuk::Query::Term::toOptionalTerm()
+{
+    CONVERT_AND_RETURN( OptionalTerm );
+}
+
+
 Nepomuk::Query::AndTerm& Nepomuk::Query::Term::toAndTerm()
 {
     CONVERT_AND_RETURN( AndTerm );
Index: nepomuk/query/comparisonterm.h
===================================================================
--- nepomuk/query/comparisonterm.h	(révision 1125741)
+++ nepomuk/query/comparisonterm.h	(copie de travail)
@@ -1,6 +1,6 @@
 /*
    This file is part of the Nepomuk KDE project.
-   Copyright (C) 2009 Sebastian Trueg <trueg@kde.org>
+   Copyright (C) 2009-2010 Sebastian Trueg <trueg@kde.org>
 
    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
@@ -38,21 +38,31 @@
          * \brief A term matching the value of a property.
          *
          * The %ComparisonTerm is the most important term in the query API. It can be
-         * used to match the values of properties. As such it consists of a property(),
-         * a comparator() and a subTerm().
+         * used to match the values of properties. As such its core components are
+         * a property(), a comparator() (see Comparator for details) and a subTerm().
+         * The latter can be any other term including AndTerm, OrTerm, or even an invalid
+         * term. The matching is done as follows:
          *
-         * The latter can be any other term including AndTerm and OrTerm. The matching
-         * is done in one of two ways:
-         *
          * \li A LiteralTerm as subTerm() is directly matched to the value of a literal
          * property (see also Nepomuk::Types::Property::literalRangeType()) or to the
          * labels of related resources in case of a property that has a resource range.
+         * \li An invalid sub term simply matches any resource or value, effectively
+         * acting as a wildcard.
          * \li Any other term type will be used as a sort of subquery to match the
          * related resources. This means that the property() needs to have a resource
          * range.
          *
-         * For more details see the Comparator enumeration.
+         * In addition to these basic features %ComparisonTerm has a few tricks up its
+         * sleeve:
          *
+         * \li By forcing the variable name via setVariableName() it is possible to
+         * include a value matched by the term in the resulting SPARQL query (Query::toSparqlQuery())
+         * or accessing it via Result::additionalBinding().
+         * \li It is possible to set an aggregate function via setAggregateFunction()
+         * to count or sum up the results instead of returning the actual values.
+         * \li Using setSortWeight() the sorting of the results in the final query
+         * can be influenced in a powerful way - especially when combined with setAggregateFunction().
+         *
          * \author Sebastian Trueg <trueg@kde.org>
          *
          * \since 4.4
@@ -105,8 +115,77 @@
             };
 
             /**
-             * Default constructor: creates an invalid comparison term.
+             * Aggregate functions which can be applied to a comparison term to influence
+             * the value they return.
+             *
+             * \sa setAggregateFunction()
+             *
+             * \since 4.5
              */
+            enum AggregateFunction {
+                /**
+                 * Do not use any aggregate function.
+                 */
+                NoAggregateFunction = 0,
+
+                /**
+                 * Count the number of matching results instead
+                 * of returning the results themselves.
+                 * For counting the results of a complete query use
+                 * Query::CreateCountQuery.
+                 */
+                Count,
+
+                /**
+                 * The same as Count except that no two similar results
+                 * are counted twice.
+                 */
+                DistinctCount,
+
+                /**
+                 * Return the maximum value of all results instead
+                 * of the results themselves.
+                 * Does only make sense for numerical values.
+                 */
+                Max,
+
+                /**
+                 * Return the minimum value of all results instead
+                 * of the results themselves.
+                 * Does only make sense for numerical values.
+                 */
+                Min,
+
+                /**
+                 * Return the sum of all result values instead
+                 * of the results themselves.
+                 * Does only make sense for numerical values.
+                 */
+                Sum,
+
+                /**
+                 * The same as Sum except that no two similar results
+                 * are added twice.
+                 */
+                DistinctSum,
+
+                /**
+                 * Return the average value of all results instead
+                 * of the results themselves.
+                 * Does only make sense for numerical values.
+                 */
+                Average,
+
+                /**
+                 * The same as Average except that no two similar results
+                 * are counted twice.
+                 */
+                DistinctAverage
+            };
+
+            /**
+             * Default constructor: creates a comparison term that matches all properties.
+             */
             ComparisonTerm();
 
             /**
@@ -115,9 +194,9 @@
             ComparisonTerm( const ComparisonTerm& term );
 
             /**
-             * Default constructor.
+             * Convinience constructor which covers most simple use cases.
              *
-             * \param property The property that should be matched.
+             * \param property The property that should be matched. An invalid property will act as a wildcard.
              * \param term The sub term to match to.
              * \param comparator The Comparator to use for comparison. Not all Comparators make sense
              * with all sub term types.
@@ -143,6 +222,7 @@
 
             /**
              * A property used for ComparisonTerm Terms.
+             * An invalid property will act as a wildcard.
              *
              * \sa setProperty
              */
@@ -155,11 +235,183 @@
 
             /**
              * Set the property for ComparisonTerm
-             * Terms.
+             * Terms. An invalid property will act as a wildcard.
              *
              * \sa property
              */
             void setProperty( const Types::Property& );
+
+            /**
+             * Set the variable name that is to be used for the
+             * variable to match to. The variable will then be added
+             * to the set of variables returned in the results and can
+             * be read via Result::additionalBinding(). Setting
+             * the variable name can be seen as a less restricted variant
+             * of Query::addRequestProperty().
+             *
+             * When manually setting the variable name on more
+             * than one ComparisonTerm there is no guarantee for the
+             * uniqueness of variable names anymore which can result
+             * in unwanted query results. However, this can also be
+             * used deliberately in case one needs to compare the
+             * same variable twice:
+             *
+             * \code
+             * ComparisonTerm ct1( prop1, Term() );
+             * ComparisonTerm ct1( prop2, Term() );
+             * ct1.setVariableName( "myvar" );
+             * ct2.setVariableName( "myvar" );
+             * \endcode
+             *
+             * The above example would result in a SPARQL query
+             * pattern along the lines of
+             *
+             * \code
+             * ?r <prop1> ?myVar .
+             * ?r <prop2> ?myVar .
+             * \endcode
+             *
+             * Be aware that the variable name does not apply
+             * to sub terms of types ResourceTerm or LiteralTerm.
+             * In those cases the value will be ignored. The only exception
+             * are LiteralTerm sub terms that are compared other than
+             * with equals.
+             *
+             * \param name The name of the variable to be used when requesting
+             * the binding via Result::additionalBinding()
+             *
+             * \sa Result::additionalBinding(), Query::HandleInverseProperties, \ref examples_query
+             *
+             * \since 4.5
+             */
+            void setVariableName( const QString& name );
+
+            /**
+             * The variable name set in setVariableName() or an empty
+             * string if none has been set.
+             *
+             * \sa setVariableName()
+             *
+             * \since 4.5
+             */
+            QString variableName() const;
+
+            /**
+             * Set an aggregate function which changes the
+             * result. The typical usage is to count the results instead of actually
+             * returning them. For counting the results of a complete query use
+             * Query::CreateCountQuery.
+             *
+             * \sa aggregateFunction()
+             *
+             * \since 4.5
+             */
+            void setAggregateFunction( AggregateFunction function );
+
+            /**
+             * The aggregate function to be used with the additional binding set in
+             * setVariableName().
+             *
+             * \sa setAggregateFunction()
+             *
+             * \since 4.5
+             */
+            AggregateFunction aggregateFunction() const;
+
+            /**
+             * Set the sort weight of this property. By default all ComparisonTerms have
+             * a weight of 0 which means that they are ignored for sorting. By setting \p
+             * weight to a value different from 0 (typically higher than 0) the comparison
+             * subterm will be used for sorting.
+             *
+             * Be aware that as with the variableName() sorting does not apply to sub
+             * terms of types ResourceTerm or LiteralTerm.
+             * In those cases the value will be ignored. The only exception
+             * are LiteralTerm sub terms that are compared other than
+             * with equals.
+             *
+             * \param weight The new sort weight. If different from 0 this term will be
+             * used for sorting in the Query.
+             * \param sortOrder The sort order to use for this term.
+             *
+             * \sa sortWeight()
+             *
+             * \since 4.5
+             */
+            void setSortWeight( int weight, Qt::SortOrder sortOrder = Qt::AscendingOrder );
+
+            /**
+             * \return The sort weight as set in setSortWeight() or 0 if
+             * sorting is disabled for this term.
+             *
+             * \since 4.5
+             */
+            int sortWeight() const;
+
+            /**
+             * \return The sort order as set in setSortWeight().
+             *
+             * \since 4.5
+             */
+            Qt::SortOrder sortOrder() const;
+
+            /**
+             * \return \p true if the comparison is inverted.
+             * \sa setInverted
+             *
+             * \since 4.5
+             */
+            bool isInverted() const;
+
+            /**
+             * Invert the comparison, i.e. make the subterm the subject
+             * of the term and match to objects of the term.
+             *
+             * A typical example would be:
+             *
+             * \code
+             * ComparisonTerm term( Soprano::Vocabulary::NAO::hasTag(),
+             *                      ResourceTerm( somefile ) );
+             * term.setInverted(true);
+             * \endcode
+             *
+             * which would yield a query like the following:
+             *
+             * \code
+             * select ?r where { <somefile> nao:hasTag ?r . }
+             * \endcode
+             *
+             * to get all tags attached to a file.
+             *
+             * Be aware that this does only make sense with
+             * sub terms that match to resources. When using
+             * LiteralTerm as a sub term \p invert is ignored.
+             *
+             * \sa inverted()
+             *
+             * \since 4.5
+             */
+            void setInverted( bool invert );
+
+            /**
+             * Create an inverted copy of this %ComparisonTerm.
+             * This is a convenience method to allow inline creation of
+             * inverted comparison terms when creating queries in a
+             * single line of code.
+             *
+             * Be aware that calling this method twice wil result in
+             * a non-inverted comparison term:
+             *
+             * \code
+             * // always true:
+             * (term.inverted().inverted() == term);
+             * \endcode
+             *
+             * \sa setInverted()
+             *
+             * \since 4.5
+             */
+            ComparisonTerm inverted() const;
         };
     }
 }
Index: nepomuk/query/query.h
===================================================================
--- nepomuk/query/query.h	(révision 1125741)
+++ nepomuk/query/query.h	(copie de travail)
@@ -100,6 +100,15 @@
             Query& operator=( const Query& );
 
             /**
+             * Assignment operator. Assigns \p term to
+             * this query without changing any other
+             * properties.
+             *
+             * \since 4.5
+             */
+            Query& operator=( const Term& term );
+
+            /**
              * \return \p true if the query is valid, i.e.
              * it has a valid term().
              */
@@ -109,18 +118,27 @@
              * The root term of the query.
              * This can be any type of term.
              *
-             * \sa setTerm
+             * \sa setTerm()
              */
             Term term() const;
 
             /**
              * The maximum number of results that this query should yield.
              *
-             * \sa setLimit
+             * \sa setLimit()
              */
             int limit() const;
 
             /**
+             * The first result that should be retrieved.
+             *
+             * \sa setOffset()
+             *
+             * \since 4.5
+             */
+            int offset() const;
+
+            /**
              * Set the root term of the query.
              *
              * \sa term
@@ -136,6 +154,14 @@
             void setLimit( int );
 
             /**
+             * The first result that should be retrieved. This can be combined
+             * with setLimit() to do paged results.
+             *
+             * \since 4.5
+             */
+            void setOffset( int offset );
+
+            /**
              * \class RequestProperty query.h Nepomuk/Query/Query
              *
              * \brief A request property can be added to a Query to retrieve
@@ -201,7 +227,10 @@
              *
              * \param property The requested property.
              *
-             * \sa setRequestProperties, requestProperties
+             * ComparisonTerm::setVariableName() provides a more flexible (but also
+             * slightly more complicated) way to select additional results.
+             *
+             * \sa setRequestProperties, requestProperties, ComparisonTerm::setVariableName()
              */
             void addRequestProperty( const RequestProperty& property );
 
@@ -210,7 +239,10 @@
              *
              * \param properties The requested properties.
              *
-             * \sa addRequestProperty, requestProperties
+             * ComparisonTerm::setVariableName() provides a more flexible (but also
+             * slightly more complicated) way to select additional results.
+             *
+             * \sa addRequestProperty, requestProperties, ComparisonTerm::setVariableName()
              */
             void setRequestProperties( const QList<RequestProperty>& properties );
 
Index: nepomuk/query/optionalterm.cpp
===================================================================
--- nepomuk/query/optionalterm.cpp	(révision 0)
+++ nepomuk/query/optionalterm.cpp	(révision 0)
@@ -0,0 +1,73 @@
+/*
+   This file is part of the Nepomuk KDE project.
+   Copyright (C) 2010 Sebastian Trueg <trueg@kde.org>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) version 3, or any
+   later version accepted by the membership of KDE e.V. (or its
+   successor approved by the membership of KDE e.V.), which shall
+   act as a proxy defined in Section 6 of version 3 of the license.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include "optionalterm.h"
+#include "optionalterm_p.h"
+#include "querybuilderdata_p.h"
+
+QString Nepomuk::Query::OptionalTermPrivate::toSparqlGraphPattern( const QString& resourceVarName, QueryBuilderData* qbd ) const
+{
+    return QString( "OPTIONAL { %1} " )
+        .arg( m_subTerm.d_ptr->toSparqlGraphPattern( resourceVarName, qbd ) );
+}
+
+
+QString Nepomuk::Query::OptionalTermPrivate::toString() const
+{
+    return QString( "[OPTIONAL %1]" ).arg( m_subTerm.d_ptr->toString() );
+}
+
+
+Nepomuk::Query::OptionalTerm::OptionalTerm()
+    : SimpleTerm( new OptionalTermPrivate() )
+{
+}
+
+
+Nepomuk::Query::OptionalTerm::OptionalTerm( const OptionalTerm& term )
+    : SimpleTerm( term )
+{
+}
+
+
+Nepomuk::Query::OptionalTerm::~OptionalTerm()
+{
+}
+
+
+Nepomuk::Query::OptionalTerm& Nepomuk::Query::OptionalTerm::operator=( const OptionalTerm& term )
+{
+    d_ptr = term.d_ptr;
+    return *this;
+}
+
+
+Nepomuk::Query::Term Nepomuk::Query::OptionalTerm::optionalizeTerm( const Term& term )
+{
+    if ( !term.isOptionalTerm() ) {
+        OptionalTerm ot;
+        ot.setSubTerm(term);
+        return ot;
+    }
+    else {
+        return term;
+    }
+}

Modification de propriétés sur nepomuk/query/optionalterm.cpp
___________________________________________________________________
Ajouté : svn:eol-style
   + native

Index: nepomuk/query/result.cpp
===================================================================
--- nepomuk/query/result.cpp	(révision 1125741)
+++ nepomuk/query/result.cpp	(copie de travail)
@@ -1,6 +1,6 @@
 /*
    This file is part of the Nepomuk KDE project.
-   Copyright (C) 2008-2009 Sebastian Trueg <trueg@kde.org>
+   Copyright (C) 2008-2010 Sebastian Trueg <trueg@kde.org>
 
    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Library General Public
@@ -18,6 +18,7 @@
  */
 
 #include "result.h"
+#include "variant.h"
 
 #include <QtCore/QSharedData>
 
@@ -25,6 +26,7 @@
 #include "property.h"
 
 #include <Soprano/Node> // for qHash( QUrl() )
+#include <Soprano/BindingSet>
 
 
 class Nepomuk::Query::Result::Private : public QSharedData
@@ -33,6 +35,7 @@
     Resource resource;
     double score;
     QHash<Types::Property, Soprano::Node> requestProperties;
+    Soprano::BindingSet additionalBindings;
 };
 
 
@@ -116,6 +119,24 @@
 }
 
 
+void Nepomuk::Query::Result::setAdditionalBindings( const Soprano::BindingSet& bindings )
+{
+    d->additionalBindings = bindings;
+}
+
+
+Soprano::BindingSet Nepomuk::Query::Result::additionalBindings() const
+{
+    return d->additionalBindings;
+}
+
+
+Nepomuk::Variant Nepomuk::Query::Result::additionalBinding( const QString& name ) const
+{
+    return Variant::fromNode( d->additionalBindings.value(name) );
+}
+
+
 bool Nepomuk::Query::Result::operator==( const Result& other ) const
 {
     if ( d->resource != other.d->resource ||
@@ -138,5 +159,5 @@
             return false;
         }
     }
-    return true;
+    return d->additionalBindings == other.d->additionalBindings;
 }
Index: nepomuk/query/queryparser.cpp
===================================================================
--- nepomuk/query/queryparser.cpp	(révision 1125741)
+++ nepomuk/query/queryparser.cpp	(copie de travail)
@@ -1,6 +1,6 @@
 /*
    This file is part of the Nepomuk KDE project.
-   Copyright (C) 2007-2009 Sebastian Trueg <trueg@kde.org>
+   Copyright (C) 2007-2010 Sebastian Trueg <trueg@kde.org>
 
    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Library General Public
@@ -106,12 +106,16 @@
         }
     }
 
-    QString stripQuotes( const QString& s ) {
+    QString stripQuotes( const QString& s, bool* hadQuotes = 0 ) {
         if ( s[0] == '\'' ||
              s[0] == '\"' ) {
+            if( hadQuotes )
+                *hadQuotes = true;
             return s.mid( 1 ).left( s.length()-2 );
         }
         else {
+            if( hadQuotes )
+                *hadQuotes = false;
             return s;
         }
     }
@@ -125,7 +129,9 @@
         }
     }
 
-    Soprano::LiteralValue createLiteral( const QString& s ) {
+    Soprano::LiteralValue createLiteral( const QString& s_, bool globbing ) {
+        bool hadQuotes = false;
+        QString s = stripQuotes( s_, &hadQuotes );
         bool b = false;
         int i = s.toInt( &b );
         if ( b )
@@ -133,10 +139,17 @@
         double d = s.toDouble( &b );
         if ( b )
             return Soprano::LiteralValue( d );
-        return s;
+
+        //
+        // we can only do query term globbing for strings longer than 3 chars
+        //
+        if( !hadQuotes && globbing && s.length() > 3 && !s.endsWith('*') && !s.endsWith('?') )
+            return s + '*';
+        else
+            return s;
     }
 
-    bool positiveTerm( const QString& s) {
+    bool positiveTerm( const QString& s ) {
         if(s.isEmpty())
             return true;
         else if(s == "+")
@@ -411,6 +424,12 @@
 
 Nepomuk::Query::Query Nepomuk::Query::QueryParser::parse( const QString& query ) const
 {
+    return parse( query, NoParserFlags );
+}
+
+
+Nepomuk::Query::Query Nepomuk::Query::QueryParser::parse( const QString& query, ParserFlags flags ) const
+{
     // TODO: a "real" parser which can handle all of the Xesam user language
     //       This one for example does not handle nesting at all.
 
@@ -446,7 +465,7 @@
                 kDebug() << "matched property term at" << pos << s_propertyRx.cap( 0 );
                 ComparisonTerm ct;
                 ct.setProperty( tryToBeIntelligentAboutParsingUrl( s_propertyRx.cap( 2 ) ) );
-                ct.setSubTerm( LiteralTerm( createLiteral( stripQuotes( s_propertyRx.cap( 4 ) ) ) ) );
+                ct.setSubTerm( LiteralTerm( createLiteral( s_propertyRx.cap( 4 ), flags&QueryTermGlobbing ) ) );
                 QString comparator = s_propertyRx.cap( 3 );
                 ct.setComparator( fieldTypeRelationFromString( comparator ) );
                 pos += s_propertyRx.matchedLength();
@@ -472,7 +491,7 @@
                 QString comparator = s_fieldFieldRx.cap( 4 );
                 ct.setComparator( fieldTypeRelationFromString( comparator ) );
                 ct.setSubTerm( ComparisonTerm( QUrl(stripQuotes( s_fieldFieldRx.cap( 5 ) )),
-                                               LiteralTerm( s_fieldFieldRx.cap( 8 ) ),
+                                               LiteralTerm( createLiteral( s_fieldFieldRx.cap( 8 ), flags&QueryTermGlobbing ) ),
                                                fieldTypeRelationFromString( s_fieldFieldRx.cap( 7 ) ) ) );
                 pos += s_fieldFieldRx.matchedLength();
 
@@ -499,7 +518,7 @@
                 else {
                     ComparisonTerm ct;
                     ct.setProperty( QUrl( stripQuotes( s_fieldRx.cap( 2 ) ) ) );
-                    ct.setSubTerm( LiteralTerm( createLiteral( stripQuotes( s_fieldRx.cap( 5 ) ) ) ) );
+                    ct.setSubTerm( LiteralTerm( createLiteral( s_fieldRx.cap( 5 ), flags&QueryTermGlobbing ) ) );
                     QString comparator = s_fieldRx.cap( 4 );
                     ct.setComparator( fieldTypeRelationFromString( comparator ) );
                     pos += s_fieldRx.matchedLength();
@@ -515,7 +534,7 @@
             }
 
             else if ( s_plainTermRx.indexIn( query, pos ) == pos ) {
-                QString value = stripQuotes( s_plainTermRx.cap( 2 ) );
+                QString value = s_plainTermRx.cap( 2 );
                 if ( d->orKeywords.contains( value.toLower() ) ) {
                     inOrBlock = true;
                 }
@@ -524,7 +543,7 @@
                 }
                 else {
                     kDebug() << "matched literal at" << pos << value;
-                    term = LiteralTerm( Soprano::LiteralValue( value ) );
+                    term = LiteralTerm( createLiteral( value, flags&QueryTermGlobbing ) );
                     if ( !positiveTerm(s_plainTermRx.cap( 1 ) ) ) {
                         term = NegationTerm::negateTerm( term );
                     }
Index: nepomuk/query/literalterm.cpp
===================================================================
--- nepomuk/query/literalterm.cpp	(révision 1125741)
+++ nepomuk/query/literalterm.cpp	(copie de travail)
@@ -1,6 +1,6 @@
 /*
    This file is part of the Nepomuk KDE project.
-   Copyright (C) 2009 Sebastian Trueg <trueg@kde.org>
+   Copyright (C) 2009-2010 Sebastian Trueg <trueg@kde.org>
 
    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
@@ -56,9 +56,9 @@
     QString v3 = qbd->uniqueVarName();
     QString v4 = qbd->uniqueVarName();
     // { ?r ?v1 ?v2 . ?v2 bif:contains XXX . } UNION { ?r ?v1 ?v3 . ?v3 ?v4 ?v2 . ?v4 rdfs:subPropertyOf rdfs:label . ?v2 bif:contains XXX . } .
-    return QString::fromLatin1( "{ %1 %2 %3 . %3 bif:contains \"'%4'\" . } "
+    return QString::fromLatin1( "{ %1 %2 %3 . %3 bif:contains \"%4\" . } "
                                 "UNION "
-                                "{ %1 %2 %5 . %5 %6 %3 . %6 %7 %8 . %3 bif:contains \"'%4'\" . } . " )
+                                "{ %1 %2 %5 . %5 %6 %3 . %6 %7 %8 . %3 bif:contains \"%4\" . } . " )
         .arg( resourceVarName,
               v1,
               v2,
@@ -78,15 +78,42 @@
 
 QString Nepomuk::Query::LiteralTermPrivate::queryText() const
 {
-    // Virtuoso 6 has a min of 4 leading chars before a wildcard.
-    // Thus, we do not use one with less chars.
+    //
+    // we try to be a little smart about creating the query text
+    // by following a few simple rules:
+    //
+    // 1. multiple terms need to be enclosed in quotes
+    // 2. quotes in search terms are not handled. replace them with spaces
+    // 3. replace double quotes with single quotes
+    // [4. wildcards can only be used if they are preceeded by at least 4 chars]
+    //
 
-    QString s = m_value.toString();
-     if( s.length() > 3 &&
-         !s.endsWith(QLatin1String("*")) &&
-         !s.endsWith(QLatin1String("?")) ) {
-        s += QLatin1String("*");
+    QString s = m_value.toString().simplified();
+    if( s.isEmpty() )
+        return s;
+
+    bool haveQuotes = false;
+
+    // strip quotes
+    if( s[0] == '"' || s[0] == '\'' ) {
+        haveQuotes = true;
+        s = s.mid(1);
     }
+    if( !s.isEmpty() &&
+        ( s[s.length()-1] == '"' || s[s.length()-1] == '\'' ) ) {
+        haveQuotes = true;
+        s.truncate(s.length()-1);
+    }
+
+    // replace quotes with spaces
+    s.replace( '"', ' ' );
+    s.replace( '\'', ' ' );
+
+    bool needQuotes = s.contains( ' ' ) || s.contains( '*' ) || s.contains( '?' );
+
+    if( needQuotes || haveQuotes )
+        s = '\'' + s + '\'';
+
     return s;
 }
 
Index: nepomuk/query/queryserviceclient.cpp
===================================================================
--- nepomuk/query/queryserviceclient.cpp	(révision 1125741)
+++ nepomuk/query/queryserviceclient.cpp	(copie de travail)
@@ -19,6 +19,7 @@
 */
 
 #include "queryserviceclient.h"
+#include "queryserviceclient_p.h"
 #include "dbusoperators_p.h"
 #include "result.h"
 #include "query.h"
@@ -60,6 +61,28 @@
         }
         return encodedRps;
     }
+
+    NepomukResultListEventLoop::NepomukResultListEventLoop(Nepomuk::Query::QueryServiceClient* parent)
+        : QEventLoop(parent)
+    {
+        connect(parent, SIGNAL(newEntries(QList<Nepomuk::Query::Result>)),
+                this, SLOT(addEntries(QList<Nepomuk::Query::Result>)));
+    }
+
+    NepomukResultListEventLoop::~NepomukResultListEventLoop()
+    {
+    }
+
+    void NepomukResultListEventLoop::addEntries(const QList< Nepomuk::Query::Result >& entries)
+    {
+        m_result << entries;
+    }
+
+    QList< Nepomuk::Query::Result > NepomukResultListEventLoop::result() const
+    {
+        return m_result;
+    }
+
 }
 
 
@@ -211,6 +234,28 @@
 }
 
 
+QList< Nepomuk::Query::Result > Nepomuk::Query::QueryServiceClient::syncQuery(const Query& q, bool* ok)
+{
+    QueryServiceClient qsc;
+    if( qsc.query( q ) ) {
+        NepomukResultListEventLoop loop(&qsc);
+        qsc.d->loop = &loop;
+        loop.exec();
+        qsc.d->loop = 0;
+        if (ok) {
+            *ok = true;
+        }
+        return loop.result();
+    }
+    else {
+        if (ok) {
+            *ok = false;
+        }
+        return QList< Nepomuk::Query::Result >();
+    }
+}
+
+
 bool Nepomuk::Query::QueryServiceClient::blockingSparqlQuery( const QString& q, const QHash<QString, Nepomuk::Types::Property>& requestPropertyMap )
 {
     if( sparqlQuery( q, requestPropertyMap ) ) {
@@ -226,6 +271,30 @@
 }
 
 
+QList< Nepomuk::Query::Result > Nepomuk::Query::QueryServiceClient::syncSparqlQuery(const QString& q,
+                                                    const QHash<QString, Nepomuk::Types::Property>& requestPropertyMap,
+                                                    bool *ok)
+{
+    QueryServiceClient qsc;
+    if( qsc.sparqlQuery( q, requestPropertyMap ) ) {
+        NepomukResultListEventLoop loop(&qsc);
+        qsc.d->loop = &loop;
+        loop.exec();
+        qsc.d->loop = 0;
+        if (ok) {
+            *ok = true;
+        }
+        return loop.result();
+    }
+    else {
+        if (ok) {
+            *ok = false;
+        }
+        return QList< Nepomuk::Query::Result >();
+    }
+}
+
+
 bool Nepomuk::Query::QueryServiceClient::blockingDesktopQuery( const QString& q )
 {
     if( desktopQuery( q ) ) {
@@ -241,6 +310,28 @@
 }
 
 
+QList< Nepomuk::Query::Result > Nepomuk::Query::QueryServiceClient::syncDesktopQuery(const QString& q, bool* ok)
+{
+    QueryServiceClient qsc;
+    if( qsc.desktopQuery( q ) ) {
+        NepomukResultListEventLoop loop(&qsc);
+        qsc.d->loop = &loop;
+        loop.exec();
+        qsc.d->loop = 0;
+        if (ok) {
+            *ok = true;
+        }
+        return loop.result();
+    }
+    else {
+        if (ok) {
+            *ok = false;
+        }
+        return QList< Nepomuk::Query::Result >();
+    }
+}
+
+
 void Nepomuk::Query::QueryServiceClient::close()
 {
     if ( d->queryInterface ) {
@@ -260,3 +351,4 @@
 }
 
 #include "queryserviceclient.moc"
+#include "queryserviceclient_p.moc"
Index: nepomuk/core/resourcemanager_p.h
===================================================================
--- nepomuk/core/resourcemanager_p.h	(révision 1125741)
+++ nepomuk/core/resourcemanager_p.h	(copie de travail)
@@ -120,7 +120,7 @@
         QList<ResourceData*> allResourceDataWithProperty( const QUrl& _uri, const Variant& v );
 
         void _k_storageServiceInitialized( bool );
-        void _k_dbusServiceOwnerChanged( const QString& name, const QString& oldOwner, const QString& newOwner );
+        void _k_dbusServiceUnregistered( const QString& serviceName );
 
     private:
         QUrl m_mainContext;
Index: nepomuk/core/variant.h
===================================================================
--- nepomuk/core/variant.h	(révision 1125741)
+++ nepomuk/core/variant.h	(copie de travail)
@@ -28,6 +28,10 @@
 #include <QtCore/QUrl>
 #include <QtCore/QVariant>
 
+namespace Soprano {
+    class Node;
+}
+
 namespace Nepomuk {
 
     class Resource;
@@ -35,7 +39,7 @@
     /**
      * \class Variant variant.h Nepomuk/Variant
      *
-     * The %Nepomuk Variant extends over QVariant by introducing
+     * \brief The %Nepomuk Variant extends over QVariant by introducing
      * direct support for Resource embedding, automatic list conversion
      * and a restricted set of supported types.
      *
@@ -348,6 +352,13 @@
          */
         static Variant fromString( const QString& value, int type );
 
+        /**
+         * Create a Variant object from a Soprano::Node.
+         *
+         * \since 4.5
+         */
+        static Variant fromNode( const Soprano::Node& node );
+
     private:
         class Private;
         Private* const d;
Index: nepomuk/core/resourcedata.cpp
===================================================================
--- nepomuk/core/resourcedata.cpp	(révision 1125741)
+++ nepomuk/core/resourcedata.cpp	(copie de travail)
@@ -29,6 +29,7 @@
 #include "pimo.h"
 #include "nepomukmainmodel.h"
 #include "dbusconnectionpool.h"
+#include "class.h"
 
 #include <Soprano/Statement>
 #include <Soprano/StatementIterator>
@@ -39,8 +40,6 @@
 #include <Soprano/Vocabulary/Xesam>
 #include <Soprano/Vocabulary/NAO>
 
-#include "ontology/class.h"
-
 #include <QtCore/QFile>
 #include <QtCore/QDateTime>
 #include <QtCore/QMutexLocker>
@@ -56,25 +55,6 @@
 #define MAINMODEL m_rm->resourceFilterModel
 
 
-static Nepomuk::Variant nodeToVariant( const Soprano::Node& node )
-{
-    //
-    // We cannot put in Resource objects here since then nie:url file:/ URLs would
-    // get converted back to the actual resource URIs which would be useless.
-    // That is why Variant treats QUrl and Resource pretty much as similar.
-    //
-    if ( node.isResource() ) {
-        return Nepomuk::Variant( node.uri() );
-    }
-    else if ( node.isLiteral() ) {
-        return Nepomuk::Variant( node.literal().variant() );
-    }
-    else {
-        return Nepomuk::Variant();
-    }
-}
-
-
 Nepomuk::ResourceData::ResourceData( const QUrl& uri, const QString& uriOrId, const QUrl& type, ResourceManagerPrivate* rm )
     : m_kickoffId( uriOrId ),
       m_kickoffUri( uri ),
@@ -86,6 +66,12 @@
       m_groundingOccurence(0),
       m_rm(rm)
 {
+    if( uri.isValid() )
+        m_rm->m_uriKickoffData.insert( uri, this );
+    else if( !uriOrId.isEmpty() )
+        m_rm->m_idKickoffData.insert( uriOrId, this );
+
+
     if( m_mainType.isEmpty() ) {
         m_mainType = Soprano::Vocabulary::RDFS::Resource();
     }
@@ -191,7 +177,7 @@
 
     // reset all variables
     m_uri = QUrl();
-    m_fileUrl = KUrl();
+    m_nieUrl = KUrl();
     m_kickoffId.truncate(0);
     m_kickoffUri = QUrl();
     m_cache.clear();
@@ -202,7 +188,7 @@
     m_groundingOccurence = 0;
 
     // when we are being deleted the value of m_mainType is not important
-    // andmore. Also since ResourceManager is a global static it might be
+    // anymore. Also since ResourceManager is a global static it might be
     // deleted after the global static behind Soprano::Vocabulary::RDFS
     // which results in a crash.
     if( !isDelete )
@@ -226,12 +212,36 @@
     if( m_proxyData )
         return m_proxyData->hasProperty( uri );
 
-    if ( determineUri() ) {
-        return MAINMODEL->containsAnyStatement( Soprano::Statement( m_uri, uri, Soprano::Node() ) );
-    }
-    else {
+    if( !load() )
         return false;
+
+    QHash<QUrl, Variant>::const_iterator it = m_cache.constFind( uri );
+    if( it == m_cache.constEnd() )
+        return false;
+
+    return true;
+}
+
+
+bool Nepomuk::ResourceData::hasProperty( const QUrl& p, const Variant& v )
+{
+    if( m_proxyData )
+        return m_proxyData->hasProperty( p, v );
+
+    if( !load() )
+        return false;
+
+    QHash<QUrl, Variant>::const_iterator it = m_cache.constFind( p );
+    if( it == m_cache.constEnd() )
+        return false;
+
+    QList<Variant> thisVals = it.value().toVariantList();
+    QList<Variant> vals = v.toVariantList();
+    Q_FOREACH( const Variant& val, vals ) {
+        if( !thisVals.contains(val) )
+            return false;
     }
+    return true;
 }
 
 
@@ -293,7 +303,7 @@
 
 //         while ( it.next() ) {
 //             Statement statement = *it;
-//             v.append( nodeToVariant( statement.object() ) );
+//             v.append( Variant::fromNode( statement.object() ) );
 //         }
 //         it.close();
 //     }
@@ -331,9 +341,10 @@
         }
 
         // the only situation in which determineUri keeps the kickoff URI is for file URLs.
-        if ( m_fileUrl.isValid() ) {
-            statements.append( Statement( m_uri, Nepomuk::Vocabulary::NIE::url(), m_fileUrl ) );
-            if ( m_mainType == Soprano::Vocabulary::RDFS::Resource() ) {
+        if ( m_nieUrl.isValid() ) {
+            statements.append( Statement( m_uri, Nepomuk::Vocabulary::NIE::url(), m_nieUrl ) );
+            if ( m_nieUrl.isLocalFile() &&
+                 m_mainType == Soprano::Vocabulary::RDFS::Resource() ) {
                 m_mainType = Nepomuk::Vocabulary::NFO::FileDataObject();
             }
         }
@@ -426,9 +437,9 @@
                 }
                 else {
                     if ( p == Nepomuk::Vocabulary::NIE::url() ) {
-                        m_fileUrl = o.uri();
+                        m_nieUrl = o.uri();
                     }
-                    m_cache[p].append( nodeToVariant( o ) );
+                    m_cache[p].append( Variant::fromNode( o ) );
                 }
             }
 
@@ -621,7 +632,7 @@
         // 2.2.1.2. it points to a file on a removable device for which we have a filex:/ URL
         //          -> use the r in r nie:url filex:/...
         // 2.2.1.3. it is a file which is not an object in some nie:url relation
-        //          -> create new random m_uri and use kickoffUriOrId() as m_fileUrl
+        //          -> create new random m_uri and use kickoffUriOrId() as m_nieUrl
         //
         QMutexLocker lock(&m_determineUriMutex);
 
@@ -677,7 +688,7 @@
                     }
                     else {
                         m_uri = uri;
-                        m_fileUrl = m_kickoffUri;
+                        m_nieUrl = m_kickoffUri;
                     }
                     it.close();
                 }
@@ -705,12 +716,16 @@
                         m_uri = resourceUri;
                     }
 
-                    m_fileUrl = m_kickoffUri;
+                    m_nieUrl = m_kickoffUri;
                 }
-                else {
-                    // for everything else we simply use the kickoff URI as resource URI
+                else if( m_kickoffUri.scheme() == QLatin1String("nepomuk") ) {
+                    // for nepomuk URIs we simply use the kickoff URI as resource URI
                     m_uri = m_kickoffUri;
                 }
+                else {
+                    // for everything else we use m_kickoffUri as nie:url with a new random m_uri
+                    m_nieUrl = m_kickoffUri;
+                }
             }
 
             else {
@@ -724,11 +739,12 @@
             if( !m_uri.isEmpty() ) {
                 QMutexLocker rmlock(&m_rm->mutex);
 
-                if( !m_rm->m_initializedData.contains( m_uri ) ) {
+                ResourceDataHash::iterator it = m_rm->m_initializedData.find(m_uri);
+                if( it == m_rm->m_initializedData.end() ) {
                     m_rm->m_initializedData.insert( m_uri, this );
                 }
                 else {
-                    m_proxyData = m_rm->m_initializedData.value( m_uri );
+                    m_proxyData = it.value();
                     m_proxyData->ref();
                 }
             }
Index: nepomuk/core/resourcemanager.h
===================================================================
--- nepomuk/core/resourcemanager.h	(révision 1125741)
+++ nepomuk/core/resourcemanager.h	(copie de travail)
@@ -32,10 +32,6 @@
 }
 
 namespace Nepomuk {
-    namespace Middleware {
-	class Registry;
-    }
-
     class Resource;
     class Variant;
     class ResourceManagerHelper;
@@ -259,7 +255,7 @@
         ResourceManagerPrivate* const d;
 
         Q_PRIVATE_SLOT( d, void _k_storageServiceInitialized(bool) )
-        Q_PRIVATE_SLOT( d, void _k_dbusServiceOwnerChanged(QString, QString, QString) )
+        Q_PRIVATE_SLOT( d, void _k_dbusServiceUnregistered(QString) )
     };
 }
 
Index: nepomuk/core/CMakeLists.txt
===================================================================
--- nepomuk/core/CMakeLists.txt	(révision 1125741)
+++ nepomuk/core/CMakeLists.txt	(copie de travail)
@@ -6,6 +6,7 @@
   ${nepomuk_SOURCE_DIR}
   ${CMAKE_SOURCE_DIR}/nepomuk/
   ${nepomukcore_SOURCE_DIR}
+  ${nepomukcore_SOURCE_DIR}/types
   ${kdecore_SOURCE_DIR}/utils
   ${CMAKE_SOURCE_DIR}
   ${KDE4_INCLUDES}
@@ -26,26 +27,27 @@
   ui/ktagcloudwidget.cpp
   ui/kblocklayout.cpp
   ui/kmetadatatagcloud.cpp
-  ui/kmetadatatagwidget.cpp
-  ui/kautoscrollarea.cpp
   ui/ktagdisplaywidget.cpp
   ui/kratingpainter.cpp
   ui/nepomukmassupdatejob.cpp
+  ui/tagwidget.cpp
+  ui/kedittagsdialog.cpp
+  ui/tagcheckbox.cpp
   resource.cpp
   thing.cpp
   tag.cpp
-  ontology/entity.cpp
-  ontology/ontology.cpp
-  ontology/class.cpp
-  ontology/property.cpp
-  ontology/literal.cpp
-  ontology/ontologyloader.cpp
-  ontology/ontologymanager.cpp
-  ontology/nepomukontologyloader.cpp
-  ontology/fileontologyloader.cpp
-  ontology/desktopontologyloader.cpp
-  ontology/global.cpp
-  ontology/entitymanager.cpp
+  types/entity.cpp
+  types/ontology.cpp
+  types/class.cpp
+  types/property.cpp
+  types/literal.cpp
+  types/ontologyloader.cpp
+  types/ontologymanager.cpp
+  types/nepomukontologyloader.cpp
+  types/fileontologyloader.cpp
+  types/desktopontologyloader.cpp
+  types/global.cpp
+  types/entitymanager.cpp
   nepomukservice.cpp
   graphwrapper.cpp
 )
@@ -54,6 +56,7 @@
 soprano_add_ontology(nepomuk_LIB_SRCS "${SHAREDDESKTOPONTOLOGIES_ROOT_DIR}/nie/nfo.trig" "NFO" "Nepomuk::Vocabulary" "trig")
 soprano_add_ontology(nepomuk_LIB_SRCS "${SHAREDDESKTOPONTOLOGIES_ROOT_DIR}/nie/nco.trig" "NCO" "Nepomuk::Vocabulary" "trig")
 soprano_add_ontology(nepomuk_LIB_SRCS "${SHAREDDESKTOPONTOLOGIES_ROOT_DIR}/pimo/pimo.trig" "PIMO" "Nepomuk::Vocabulary" "trig")
+soprano_add_ontology(nepomuk_LIB_SRCS "${SHAREDDESKTOPONTOLOGIES_ROOT_DIR}/nepomuk/nuao.trig" "NUAO" "Nepomuk::Vocabulary" "trig")
 
 kde4_add_library(nepomuk SHARED ${nepomuk_LIB_SRCS})
 
@@ -94,5 +97,5 @@
 )
 
 add_subdirectory(ui)
-add_subdirectory(ontology)
+add_subdirectory(types)
 add_subdirectory(test)
Index: nepomuk/core/resource.h
===================================================================
--- nepomuk/core/resource.h	(révision 1125741)
+++ nepomuk/core/resource.h	(copie de travail)
@@ -34,6 +34,9 @@
     class Variant;
     class Tag;
     class Thing;
+    namespace Types {
+        class Property;
+    }
 
     enum ErrorCode {
         NoError = 0,
@@ -334,6 +337,13 @@
         bool hasProperty( const QUrl& uri ) const;
 
         /**
+         * Check if the resource has a property \p p with value \p v.
+         *
+         * \since 4.5
+         */
+        bool hasProperty( const Types::Property& p, const Variant& v ) const;
+
+        /**
          * \deprecated use hasProperty( const QUrl& ) const
          */
         KDE_DEPRECATED bool hasProperty( const QString& uri ) const;
@@ -659,7 +669,7 @@
 
         /**
          * Get property 'Symbol'. Each resource can have a symbol assigned.
-         * For now this is a simple string which can either be the patch to
+         * For now this is a simple string which can either be the path to
          * an actual pixmap file or just the name of an icon as defined by
          * the freedesktop.org standard.
          */
@@ -667,7 +677,7 @@
 
         /**
          * Set property 'Symbol'. Each resource can have a symbol assigned.
-         * For now this is a simple string which can either be the patch to
+         * For now this is a simple string which can either be the path to
          * an actual pixmap file or just the name of an icon as defined by
          * the freedesktop.org standard.
          */
@@ -676,7 +686,7 @@
         /**
          * Add a value to property 'Symbol'. Each resource can have a symbol
          * assigned. For now this is a simple string which can either be
-         * the patch to an actual pixmap file or just the name of an icon as
+         * the path to an actual pixmap file or just the name of an icon as
          * defined by the freedesktop.org standard.
          */
         void addSymbol( const QString& value );
@@ -709,6 +719,23 @@
          */
         static QList<Resource> allResources();
 
+        /**
+         * \return The usage count stored for this resource.
+         *
+         * \sa increaseUsageCount()
+         *
+         * \since 4.5
+         */
+        int usageCount() const;
+
+        /**
+         * Increase the usage count of this resource and also
+         * update the last used date to the current date and time.
+         *
+         * \since 4.5
+         */
+        void increaseUsageCount();
+
     private:
         ResourceData* m_data;
 
Index: nepomuk/core/test/resourcetest.cpp
===================================================================
--- nepomuk/core/test/resourcetest.cpp	(révision 1125741)
+++ nepomuk/core/test/resourcetest.cpp	(copie de travail)
@@ -293,6 +293,11 @@
         QCOMPARE( fileRes.resourceUri(), fileRes3.resourceUri() );
 
         tmpFile1ResUri = fileRes.resourceUri();
+
+        // make sure even the string constructor will find the resource again with
+        Resource fileRes4( KUrl(tmpFile1ResUri).url() );
+        fileRes4.setRating(4);
+        QCOMPARE( fileRes4.resourceUri(), tmpFile1ResUri );
     }
 
     // clear cache to be sure we call ResourceData::determineUri
@@ -338,8 +343,6 @@
 
     // clear cache to be sure we do not reuse the cache
     ResourceManager::instance()->clearCache();
-
-
 }
 
 QTEST_KDEMAIN(ResourceTest, NoGUI)
Index: nepomuk/core/nepomukservice.cpp
===================================================================
--- nepomuk/core/nepomukservice.cpp	(révision 1125741)
+++ nepomuk/core/nepomukservice.cpp	(copie de travail)
@@ -17,7 +17,7 @@
 */
 
 #include "nepomukservice.h"
-#include "nepomukmainmodel.h"
+#include "resourcemanager.h"
 
 #include <QtCore/QTimer>
 
@@ -25,7 +25,6 @@
 class Nepomuk::Service::Private
 {
 public:
-    MainModel* model;
 };
 
 
@@ -33,7 +32,6 @@
     : QObject( parent ),
       d( new Private() )
 {
-    d->model = 0;
     if ( !delayedInitialization ) {
         setServiceInitialized( true );
     }
@@ -42,17 +40,13 @@
 
 Nepomuk::Service::~Service()
 {
-    delete d->model;
     delete d;
 }
 
 
 Soprano::Model* Nepomuk::Service::mainModel()
 {
-    if ( !d->model ) {
-        d->model = new MainModel( this );
-    }
-    return d->model;
+    return ResourceManager::instance()->mainModel();
 }
 
 
Index: nepomuk/core/resourcemanager.cpp
===================================================================
--- nepomuk/core/resourcemanager.cpp	(révision 1125741)
+++ nepomuk/core/resourcemanager.cpp	(copie de travail)
@@ -25,10 +25,9 @@
 #include "nepomukmainmodel.h"
 #include "resource.h"
 #include "resourcefiltermodel.h"
+#include "class.h"
 #include "nie.h"
 
-#include "ontology/class.h"
-
 #include <kglobal.h>
 #include <kdebug.h>
 #include <krandom.h>
@@ -45,6 +44,7 @@
 #include <QtCore/QUuid>
 #include <QtDBus/QDBusConnection>
 #include <QtDBus/QDBusConnectionInterface>
+#include <QtDBus/QDBusServiceWatcher>
 
 using namespace Soprano;
 
@@ -85,7 +85,6 @@
 
     if( it == end ) {
         ResourceData* d = new ResourceData( url, QString(), type, this );
-        m_uriKickoffData.insert( url, d );
 //         kDebug() << "--------------------------- Created new ResourceData:" << *d;
         return d;
     }
@@ -113,7 +112,6 @@
     KickoffDataHash::iterator it = m_idKickoffData.find( uriOrId );
     if( it == m_idKickoffData.end() ) {
         ResourceData* d = new ResourceData( QUrl(), uriOrId, type, this );
-        m_idKickoffData.insert( uriOrId, d );
         return d;
     }
     else {
@@ -241,10 +239,9 @@
 }
 
 
-void Nepomuk::ResourceManagerPrivate::_k_dbusServiceOwnerChanged( const QString& name, const QString&, const QString& newOwner )
+void Nepomuk::ResourceManagerPrivate::_k_dbusServiceUnregistered( const QString& serviceName )
 {
-    if( name == QLatin1String("org.kde.NepomukStorage") &&
-        newOwner.isEmpty() ) {
+    if( serviceName == QLatin1String("org.kde.NepomukStorage") ) {
         kDebug() << "Nepomuk Storage service went down.";
         emit m_manager->nepomukSystemStopped();
     }
@@ -270,10 +267,14 @@
                                            this,
                                            SLOT(_k_storageServiceInitialized(bool)) );
 
-    // connect to the ownerChanged signal to be able to connect the nepomukSystemStopped
+    // connect to the serviceUnregistered signal to be able to connect the nepomukSystemStopped
     // signal once the storage service goes away
-    connect( QDBusConnection::sessionBus().interface(), SIGNAL(serviceOwnerChanged(QString, QString, QString)),
-             this, SLOT(_k_dbusServiceOwnerChanged(QString, QString, QString)) );
+    QDBusServiceWatcher *watcher = new QDBusServiceWatcher( QLatin1String("org.kde.NepomukStorage"),
+                                                            QDBusConnection::sessionBus(),
+                                                            QDBusServiceWatcher::WatchForUnregistration,
+                                                            this );
+    connect( watcher, SIGNAL(serviceUnregistered(QString)),
+             this, SLOT(_k_dbusServiceUnregistered(QString)) );
 
     init();
 }
@@ -356,7 +357,7 @@
 
 QList<Nepomuk::Resource> Nepomuk::ResourceManager::allResourcesOfType( const QUrl& type )
 {
-    QList<Resource> l;
+    QSet<Resource> set;
 
     if( !type.isEmpty() ) {
         // check local data
@@ -364,8 +365,7 @@
         for( QList<ResourceData*>::iterator rdIt = localData.begin();
              rdIt != localData.end(); ++rdIt ) {
             Resource res( *rdIt );
-            if( !l.contains( res ) )
-                l.append( res );
+            set.insert(res);
         }
 
 //        kDebug() << " added local resources: " << l.count();
@@ -376,14 +376,13 @@
         while( it.next() ) {
             Statement s = *it;
             Resource res( s.subject().uri() );
-            if( !l.contains( res ) )
-                l.append( res );
+            set.insert(res);
         }
 
 //        kDebug() << " added remote resources: " << l.count();
     }
 
-    return l;
+    return set.toList();
 }
 
 
@@ -413,7 +412,7 @@
 
 QList<Nepomuk::Resource> Nepomuk::ResourceManager::allResourcesWithProperty( const QUrl& uri, const Variant& v )
 {
-    QList<Resource> l;
+    QSet<Resource> set;
 
     if( v.isList() ) {
         kDebug() << "(ResourceManager::allResourcesWithProperty) list values not supported.";
@@ -423,7 +422,7 @@
         QList<ResourceData*> localData = d->allResourceDataWithProperty( uri, v );
         for( QList<ResourceData*>::iterator rdIt = localData.begin();
              rdIt != localData.end(); ++rdIt ) {
-            l.append( Resource( *rdIt ) );
+            set.insert( Resource( *rdIt ) );
         }
 
         // check remote data
@@ -441,12 +440,11 @@
         while( it.next() ) {
             Statement s = *it;
             Resource res( s.subject().uri() );
-            if( !l.contains( res ) )
-                l.append( res );
+            set.insert( res );
         }
     }
 
-    return l;
+    return set.toList();
 }
 
 
@@ -519,12 +517,14 @@
 {
     QMutexLocker lock( &d->mutex );
 
-    d->overrideModel = model;
-    d->resourceFilterModel->setParentModel( model ? model : d->mainModel );
+    if( model != d->resourceFilterModel ) {
+        d->overrideModel = model;
+        d->resourceFilterModel->setParentModel( model ? model : d->mainModel );
 
-    // clear cache to make sure we do not mix data
-    Q_FOREACH( ResourceData* data, d->allResourceData()) {
-        data->invalidateCache();
+        // clear cache to make sure we do not mix data
+        Q_FOREACH( ResourceData* data, d->allResourceData()) {
+            data->invalidateCache();
+        }
     }
 }
 
Index: nepomuk/core/types/ontology_p.h
===================================================================
--- nepomuk/core/types/ontology_p.h	(révision 0)
+++ nepomuk/core/types/ontology_p.h	(révision 0)
@@ -0,0 +1,76 @@
+/* This file is part of the Nepomuk-KDE libraries
+   Copyright (c) 2007 Sebastian Trueg <trueg@kde.org>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public License
+   along with this library; see the file COPYING.LIB.  If not, write to
+   the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.
+*/
+
+#ifndef _NEPOMUK_ONTOLOGY_PRIVATE_H_
+#define _NEPOMUK_ONTOLOGY_PRIVATE_H_
+
+#include "entity_p.h"
+#include "class.h"
+#include "property.h"
+
+#include <QtCore/QList>
+#include <QtCore/QUrl>
+#include <QtCore/QSharedData>
+
+namespace Nepomuk {
+    namespace Types {
+        class Class;
+        class Property;
+
+        class OntologyPrivate : public EntityPrivate
+        {
+        public:
+            OntologyPrivate( const QUrl& uri = QUrl() );
+
+            QList<Class> classes;
+            QList<Property> properties;
+
+            // -1 - unknown
+            // 0  - no
+            // 1  - yes
+            int entitiesAvailable;
+
+            bool addProperty( const QUrl& property, const Soprano::Node& value );
+            bool addAncestorProperty( const QUrl& ancestorResource, const QUrl& property );
+
+            void initEntities();
+            bool loadEntities();
+
+            void reset( bool recursive );
+        };
+    }
+}
+
+
+#include "ontology.h"
+namespace Nepomuk {
+
+    class Class;
+    class Property;
+
+    class Ontology::Private : public QSharedData
+    {
+    public:
+        QUrl uri;
+        QHash<QUrl, const Class*> classes;
+        QHash<QUrl, const Property*> properties;
+    };
+}
+
+#endif

Modification de propriétés sur nepomuk/core/types/ontology_p.h
___________________________________________________________________
Ajouté : svn:eol-style
   + native

Index: nepomuk/core/types/nepomukontologyloader.cpp
===================================================================
--- nepomuk/core/types/nepomukontologyloader.cpp	(révision 0)
+++ nepomuk/core/types/nepomukontologyloader.cpp	(révision 0)
@@ -0,0 +1,74 @@
+/* This file is part of the Nepomuk-KDE libraries
+    Copyright (c) 2007 Sebastian Trueg <trueg@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+*/
+
+#include "nepomukontologyloader.h"
+#include "global.h"
+
+#include <Soprano/Statement>
+#include <Soprano/Model>
+#include <Soprano/QueryResultIterator>
+#include <Soprano/Client/DBusModel>
+#include <Soprano/Client/DBusClient>
+
+#include <QtCore/QDebug>
+
+
+class Nepomuk::NepomukOntologyLoader::Private
+{
+public:
+    Private()
+        : client("org.kde.NepomukServer") {
+    }
+    Soprano::Client::DBusClient client;
+};
+
+
+Nepomuk::NepomukOntologyLoader::NepomukOntologyLoader()
+    : OntologyLoader(),
+      d( new Private() )
+{
+}
+
+
+Nepomuk::NepomukOntologyLoader::~NepomukOntologyLoader()
+{
+    delete d;
+}
+
+
+QList<Soprano::Statement> Nepomuk::NepomukOntologyLoader::loadOntology( const QUrl& uri )
+{
+    QList<Soprano::Statement> sl;
+
+    if ( Soprano::Model* model = d->client.createModel( "main" ) ) {
+        // get the complete named graph describing the ontology
+        Soprano::QueryResultIterator it = model->executeQuery( QString( "construct {?s ?p ?o} "
+                                                                        "where { GRAPH <%1> { ?s ?p ?o } . }" )
+                                                               .arg( uri.toString() ),
+                                                               Soprano::Query::QUERY_LANGUAGE_SPARQL );
+        while ( it.next() ) {
+            sl.append( it.currentStatement() );
+        }
+    }
+    else {
+        qDebug() << "(NepomukOntologyLoader) could not find ontology statements for " << uri;
+    }
+
+    return sl;
+}

Modification de propriétés sur nepomuk/core/types/nepomukontologyloader.cpp
___________________________________________________________________
Ajouté : svn:eol-style
   + native

Index: nepomuk/core/types/entity_p.h
===================================================================
--- nepomuk/core/types/entity_p.h	(révision 0)
+++ nepomuk/core/types/entity_p.h	(révision 0)
@@ -0,0 +1,89 @@
+/* This file is part of the Nepomuk-KDE libraries
+    Copyright (c) 2007-2009 Sebastian Trueg <trueg@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+*/
+
+#ifndef _NEPOMUK_ENTITY_PRIVATE_H_
+#define _NEPOMUK_ENTITY_PRIVATE_H_
+
+#include "entity.h"
+
+#include <QtCore/QHash>
+#include <QtCore/QString>
+#include <QtCore/QUrl>
+#include <QtGui/QIcon>
+#include <QtCore/QSharedData>
+#include <QtCore/QMutex>
+
+namespace Nepomuk {
+    namespace Types {
+        class EntityPrivate : public QSharedData
+        {
+        public:
+            EntityPrivate( const QUrl& uri = QUrl() );
+            virtual ~EntityPrivate() {}
+
+            QMutex mutex;
+
+            QUrl uri;
+            QString label;
+            QString comment;
+            QString l10nLabel;
+            QString l10nComment;
+
+            QIcon icon;
+
+            // -1 - unknown
+            // 0  - no
+            // 1  - yes
+            int available;
+            int ancestorsAvailable;
+
+            void init();
+            void initAncestors();
+
+            virtual bool addProperty( const QUrl& property, const Soprano::Node& value ) = 0;
+            virtual bool addAncestorProperty( const QUrl& ancestorResource, const QUrl& property ) = 0;
+
+            virtual void reset( bool recursive );
+
+        protected:
+            virtual bool load();
+            virtual bool loadAncestors();
+        };
+    }
+}
+
+
+
+class Nepomuk::Entity::Private : public QSharedData
+{
+public:
+    Private()
+	: ontology( 0 ) {
+    }
+
+    const Ontology* ontology;
+
+    QUrl uri;
+    QString label;
+    QString comment;
+    QHash<QString, QString> l10nLabels;
+    QHash<QString, QString> l10nComments;
+};
+
+#endif

Modification de propriétés sur nepomuk/core/types/entity_p.h
___________________________________________________________________
Ajouté : svn:eol-style
   + native

Index: nepomuk/core/types/global.cpp
===================================================================
--- nepomuk/core/types/global.cpp	(révision 0)
+++ nepomuk/core/types/global.cpp	(révision 0)
@@ -0,0 +1,38 @@
+/* This file is part of the Nepomuk-KDE libraries
+    Copyright (c) 2007 Sebastian Trueg <trueg@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+*/
+
+#include "global.h"
+
+#include <kdebug.h>
+#include <kglobal.h>
+
+
+QUrl Nepomuk::extractNamespace( const QUrl& url )
+{
+    QByteArray s = url.toEncoded();
+    int pos = s.lastIndexOf( '#' );
+    if ( pos == -1 ) {
+        pos = s.lastIndexOf( '/' );
+    }
+    if ( pos == -1 ) {
+        kError() << " Failed to extract namespace from " << url << endl;
+        return QUrl();
+    }
+    return QUrl::fromEncoded( s.left( pos+1 ) );
+}

Modification de propriétés sur nepomuk/core/types/global.cpp
___________________________________________________________________
Ajouté : svn:eol-style
   + native

Index: nepomuk/core/types/fileontologyloader.cpp
===================================================================
--- nepomuk/core/types/fileontologyloader.cpp	(révision 0)
+++ nepomuk/core/types/fileontologyloader.cpp	(révision 0)
@@ -0,0 +1,108 @@
+/* This file is part of the Nepomuk-KDE libraries
+    Copyright (c) 2007 Sebastian Trueg <trueg@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+*/
+
+#include "fileontologyloader.h"
+
+#include <soprano/soprano.h>
+
+#include <QtCore/QDebug>
+#include <QtCore/QFile>
+
+
+class Nepomuk::FileOntologyLoader::Private
+{
+public:
+    Private()
+        : serialization( Soprano::SerializationUnknown ) {
+    }
+
+    QString filename;
+    Soprano::RdfSerialization serialization;
+};
+
+
+Nepomuk::FileOntologyLoader::FileOntologyLoader()
+    : OntologyLoader(),
+      d( new Private() )
+{
+}
+
+
+Nepomuk::FileOntologyLoader::FileOntologyLoader( const QString& filename, Soprano::RdfSerialization serialization )
+    : OntologyLoader(),
+      d( new Private() )
+{
+    setFileName( filename );
+    setSerialization( serialization );
+}
+
+
+Nepomuk::FileOntologyLoader::~FileOntologyLoader()
+{
+    delete d;
+}
+
+
+void Nepomuk::FileOntologyLoader::setFileName( const QString& filename )
+{
+    d->filename = filename;
+}
+
+
+void Nepomuk::FileOntologyLoader::setSerialization( Soprano::RdfSerialization s )
+{
+    d->serialization = s;
+}
+
+
+QString Nepomuk::FileOntologyLoader::fileName() const
+{
+    return d->filename;
+}
+
+
+QList<Soprano::Statement> Nepomuk::FileOntologyLoader::loadOntology( const QUrl& url )
+{
+    QString filename;
+
+    if ( d->filename.isEmpty() ) {
+        // FIXME: use KIO or is QT sufficient? Actually how about NetAccess and a temp file?
+        qDebug() << "(FileOntologyLoader) remote support not implemented yet.";
+        return QList<Soprano::Statement>();
+    }
+    else {
+        filename = d->filename;
+    }
+
+    QList<Soprano::Statement> sl;
+
+    QFile f( filename );
+    if ( f.open( QIODevice::ReadOnly ) ) {
+        // TODO: how can we check if the requested onto is really defined in this file?
+        const Soprano::Parser* rdfParser = Soprano::PluginManager::instance()->discoverParserForSerialization( d->serialization );
+        if ( rdfParser ) {
+            sl = rdfParser->parseFile( d->filename, url, d->serialization ).allStatements();
+        }
+    }
+    else {
+        qDebug() << "(FileOntologyLoader) failed to open " << filename;
+    }
+
+    return sl;
+}

Modification de propriétés sur nepomuk/core/types/fileontologyloader.cpp
___________________________________________________________________
Ajouté : svn:eol-style
   + native

Index: nepomuk/core/types/ontologymanager.cpp
===================================================================
--- nepomuk/core/types/ontologymanager.cpp	(révision 0)
+++ nepomuk/core/types/ontologymanager.cpp	(révision 0)
@@ -0,0 +1,343 @@
+/* This file is part of the Nepomuk-KDE libraries
+    Copyright (c) 2007 Sebastian Trueg <trueg@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+*/
+
+#include "ontologymanager.h"
+#include "nepomukontologyloader.h"
+#include "desktopontologyloader.h"
+#include "ontology.h"
+#include "ontology_p.h"
+#include "class_p.h"
+#include "property_p.h"
+#include "entity_p.h"
+#include "global.h"
+
+#include <Soprano/Statement>
+#include <Soprano/Vocabulary/RDFS>
+#include <Soprano/Vocabulary/XMLSchema>
+
+#include <QtCore/QDebug>
+
+
+using namespace Soprano;
+
+class Nepomuk::OntologyManager::Private
+{
+public:
+    Private( OntologyManager* manager )
+        : userOntologyLoader( 0 ),
+          desktopOntologyLoader( 0 ),
+          nepomukOntologyLoader( 0 ),
+          m_manager( manager ) {
+    }
+
+    OntologyLoader* userOntologyLoader;
+    DesktopOntologyLoader* desktopOntologyLoader;
+    NepomukOntologyLoader* nepomukOntologyLoader;
+
+    // cache
+    QHash<QUrl, Ontology> ontoCache;
+    QHash<QUrl, Class> classCache;
+    QHash<QUrl, Property> propertyCache;
+
+    /**
+     * Find a class in the cache.
+     *
+     * \param recurse if true the method will try loading dependancies (i.e.
+     * other ontologies to fulfill the requirement
+     */
+    Class* findClass( const QUrl& uri, bool recurse = false ) {
+        QHash<QUrl, Class>::iterator it = classCache.find( uri );
+        if ( it != classCache.end() ) {
+            return &it.value();
+        }
+        else {
+            if ( recurse ) {
+                // try loading the ontology containing the class
+                QUrl parentNs = extractNamespace( uri );
+                if ( m_manager->getOntology( parentNs ) ) {
+                    return findClass( uri );
+                }
+            }
+            return 0;
+        }
+    }
+
+    /**
+     * Find a property in the cache.
+     *
+     * \param recurse if true the method will try loading dependancies (i.e.
+     * other ontologies to fulfill the requirement
+     */
+    Property* findProperty( const QUrl& uri, bool recurse = false ) {
+        QHash<QUrl, Property>::iterator it = propertyCache.find( uri );
+        if ( it != propertyCache.end() ) {
+            return &it.value();
+        }
+        else {
+            if ( recurse ) {
+                // try loading the ontology containing the property
+                QUrl parentNs = extractNamespace( uri );
+                if ( m_manager->getOntology( parentNs ) ) {
+                    return findProperty( uri );
+                }
+            }
+            return 0;
+        }
+    }
+
+private:
+    OntologyManager* m_manager;
+};
+
+
+Nepomuk::OntologyManager* Nepomuk::OntologyManager::instance()
+{
+    static OntologyManager* s_instance = 0;
+    if ( !s_instance ) {
+        s_instance = new OntologyManager();
+    }
+
+    return s_instance;
+}
+
+
+Nepomuk::OntologyManager::OntologyManager()
+    : d( new Private( this ) )
+{
+}
+
+
+Nepomuk::OntologyManager::~OntologyManager()
+{
+    delete d->userOntologyLoader;
+    delete d->desktopOntologyLoader;
+    delete d->nepomukOntologyLoader;
+    delete d;
+}
+
+
+void Nepomuk::OntologyManager::setOntologyLoader( OntologyLoader* loader )
+{
+    if ( d->userOntologyLoader != loader ) {
+        delete d->userOntologyLoader;
+    }
+    d->userOntologyLoader = loader;
+}
+
+
+const Nepomuk::Ontology* Nepomuk::OntologyManager::getOntology( const QUrl& uri )
+{
+    // if the ontology is already in the cache return it
+    //
+    QHash<QUrl, Ontology>::const_iterator it = d->ontoCache.constFind( uri );
+    if ( it != d->ontoCache.constEnd() ) {
+        return &it.value();
+    }
+
+    // if not in the cache, try loading it
+    //
+    else {
+        QList<Statement> sl;
+        if ( !d->userOntologyLoader ) {
+            if ( !d->desktopOntologyLoader ) {
+                d->desktopOntologyLoader = new DesktopOntologyLoader();
+            }
+            if ( !d->nepomukOntologyLoader ) {
+                d->nepomukOntologyLoader = new NepomukOntologyLoader();
+            }
+
+            // we prefer the NepomukOntologyLoader since it does not parse
+            // anything
+            sl = d->nepomukOntologyLoader->loadOntology( uri );
+            if ( sl.isEmpty() ) {
+                sl = d->desktopOntologyLoader->loadOntology( uri );
+            }
+        }
+        else {
+            sl = d->userOntologyLoader->loadOntology( uri );
+        }
+
+        if ( !sl.isEmpty() ) {
+            qDebug() << "(Nepomuk::OntologyManager) Found ontology " << uri << endl;
+            return constructOntology( uri, sl );
+        }
+        else {
+            // loading failed, i.e. ontology not stored.
+            //
+            qDebug() << "(Nepomuk::OntologyManager) Could not find ontology " << uri << endl;
+            return 0;
+        }
+    }
+}
+
+
+Nepomuk::Ontology* Nepomuk::OntologyManager::constructOntology( const QUrl& ontoUri, const QList<Statement>& sl )
+{
+    Ontology& ont = d->ontoCache[ ontoUri ];
+    ont.d->uri = ontoUri;
+
+    // FIXME: Is it possible to define classes and properties with different namespaces in one file?
+    //        Should we check the namespaces of the resources and if necessary create multiple Ontology
+    //        instances?
+
+    // step 1: collect all classes and properties
+    for ( QList<Statement>::const_iterator it = sl.constBegin(); it != sl.constEnd(); ++it ) {
+        const Statement& s = *it;
+        QUrl subjectUri( s.subject().uri() );
+        if( s.predicate().uri().toString().endsWith( "#type" ) ) {
+            if ( s.object().uri().toString().endsWith( "#Class" ) ) {
+                d->classCache.insert( subjectUri, Class() );
+                Class* c = &d->classCache[ subjectUri ];
+                Entity* entity = static_cast<Entity*>( c );
+                entity->d->uri = subjectUri;
+                entity->d->ontology = &ont;
+                ont.d->classes.insert( subjectUri, c );
+            }
+            else if ( s.object().uri().toString().endsWith( "#Property" ) ) {
+                d->propertyCache.insert( subjectUri, Property() );
+                Property* p = &d->propertyCache[ subjectUri ];
+                Entity* entity = static_cast<Entity*>( p );
+                entity->d->uri = subjectUri;
+                entity->d->ontology = &ont;
+                ont.d->properties.insert( subjectUri, p );
+            }
+            else {
+                qDebug() << "(OntologyManager) unknown type in ontology: " << s.object().uri();
+            }
+        }
+    }
+
+    // step 2: construct the classes and properties
+    for ( QList<Statement>::const_iterator it = sl.constBegin(); it != sl.constEnd(); ++it ) {
+        const Statement& s = *it;
+
+        // build the objects in the cache. If the ontology references another ontology try loading that one
+        // BIG PROBLEM: reverse dependancies of ontologies.
+        // If one ontology depends on another one which in turn depends on the first one. It should work
+        // since the first step already went through and thus, the class and property bodies have been created.
+
+        const QUrl& subjectUri = s.subject().uri();
+        Class* currentClass = d->findClass( subjectUri );
+        Property* currentProperty = ( currentClass ? ( Property* )0 : d->findProperty( subjectUri ) );
+        Entity* currentEntity = currentClass;
+        if ( !currentEntity ) {
+            currentEntity = currentProperty;
+        }
+
+        if ( !currentClass && !currentProperty ) {
+            qDebug() << "(OntologyManager) invalid ontology statement: " << s;
+            d->ontoCache.remove( ontoUri );
+            return 0;
+        }
+
+        if( s.predicate().uri().toString().endsWith( "#subClassOf" ) ) {
+            Class* parent = d->findClass( s.object().uri(), true );
+            if ( !parent ) {
+                qDebug() << "(OntologyManager) unable to load dependancy for: " << s;
+            }
+            else {
+                currentClass->d->parents.append( parent );
+                parent->d->children.append( currentClass );
+            }
+        }
+
+        if( s.predicate().uri().toString().endsWith( "#subPropertyOf" ) ) {
+            Property* parent = d->findProperty( s.object().uri(), true );
+            if ( !parent ) {
+                qDebug() << "(OntologyManager) unable to load dependancy for: " << s;
+            }
+            else {
+                currentProperty->d->parents.append( parent );
+                parent->d->children.append( currentProperty );
+            }
+        }
+
+        else if( s.predicate().toString().endsWith( "#domain" ) ) {
+            Class* domain = d->findClass( s.object().uri(), true );
+            if ( !domain ) {
+                qDebug() << "(OntologyManager) unable to load dependancy for: " << s;
+            }
+            else {
+                currentProperty->d->domain = domain;
+                domain->d->domainOf.insert( subjectUri, currentProperty );
+            }
+        }
+
+        else if( s.predicate().toString().endsWith( "#range" ) ) {
+            if ( s.object().toString().startsWith( Soprano::Vocabulary::XMLSchema::xsdNamespace().toString() ) ) {
+                currentProperty->d->literalRange = Literal( s.object().literal().toString() );
+            }
+            else {
+                Class* range = d->findClass( s.object().uri(), true );
+                if ( range ) {
+                    currentProperty->d->range = range;
+                    range->d->rangeOf.insert( subjectUri, currentProperty );
+                }
+                else {
+                    qDebug() << "(OntologyManager) unable to load dependancy for: " << s;
+                }
+            }
+        }
+
+        else if( s.predicate().toString().endsWith( "#minCardinality" ) ) {
+            currentProperty->d->minCardinality = s.object().literal().toInt();
+        }
+
+        else if( s.predicate().toString().endsWith( "#maxCardinality" ) ) {
+            currentProperty->d->maxCardinality = s.object().literal().toInt();
+        }
+
+        else if ( s.predicate().toString().endsWith( "#cardinality" ) ) {
+            currentProperty->d->cardinality = s.object().literal().toInt();
+        }
+
+        else if ( s.predicate().toString().endsWith( "#inverseProperty" ) ) {
+            Property* inverse = d->findProperty( s.object().toString(), true );
+            if ( !inverse ) {
+                qDebug() << "(OntologyManager) failed to load inverse property: " << s;
+                d->ontoCache.remove( ontoUri );
+                return 0;
+            }
+            currentProperty->d->inverse = inverse;
+            inverse->d->inverse = currentProperty;
+        }
+
+        // load l10n'ed comments
+        else if( s.predicate() == Soprano::Vocabulary::RDFS::comment() ) {
+            if ( s.object().language().isEmpty() ) {
+                currentEntity->d->comment = s.object().toString();
+            }
+            else {
+                currentEntity->d->l10nComments[s.object().language()] = s.object().toString();
+            }
+        }
+
+        // load l10n'ed labels
+        else if( s.predicate() == Soprano::Vocabulary::RDFS::label() ) {
+            if ( s.object().language().isEmpty() ) {
+                currentEntity->d->label = s.object().toString();
+            }
+            else {
+                currentEntity->d->l10nLabels[s.object().language()] = s.object().toString();
+            }
+        }
+    }
+
+    return &ont;
+}

Modification de propriétés sur nepomuk/core/types/ontologymanager.cpp
___________________________________________________________________
Ajouté : svn:eol-style
   + native

Index: nepomuk/core/types/ontologyloader.h
===================================================================
--- nepomuk/core/types/ontologyloader.h	(révision 0)
+++ nepomuk/core/types/ontologyloader.h	(révision 0)
@@ -0,0 +1,60 @@
+/* This file is part of the Nepomuk-KDE libraries
+    Copyright (c) 2007 Sebastian Trueg <trueg@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+*/
+
+#ifndef _NEPOMUK_ONTOLOGY_LOADER_H_
+#define _NEPOMUK_ONTOLOGY_LOADER_H_
+
+#include <QtCore/QUrl>
+
+#include "nepomuk_export.h"
+
+namespace Soprano {
+    class Statement;
+}
+
+namespace Nepomuk {
+    
+    /**
+     * An OntologyLoader provides the statements that make up an ontology
+     * for the OntologyManager to create the ontology classes and properties.
+     *
+     * Typical implementations read RDF statements from RDF files or from the
+     * Nepomuk-KDE RDF store.
+     *
+     * \deprecated Ontologies should now be handled using the classes
+     * in the Nepomuk::Types namespace.
+     */
+    class KDE_DEPRECATED NEPOMUK_EXPORT OntologyLoader
+    {
+    public:
+	virtual ~OntologyLoader();
+
+        // FIXME: use StatementIterator
+	virtual QList<Soprano::Statement> loadOntology( const QUrl& url ) = 0;
+
+    protected:
+	OntologyLoader();
+
+    private:
+	class Private;
+	Private* const d;
+    };
+}
+
+#endif

Modification de propriétés sur nepomuk/core/types/ontologyloader.h
___________________________________________________________________
Ajouté : svn:eol-style
   + native

Index: nepomuk/core/types/entitymanager.cpp
===================================================================
--- nepomuk/core/types/entitymanager.cpp	(révision 0)
+++ nepomuk/core/types/entitymanager.cpp	(révision 0)
@@ -0,0 +1,131 @@
+/* This file is part of the Nepomuk-KDE libraries
+    Copyright (c) 2007 Sebastian Trueg <trueg@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+*/
+
+#include "entitymanager.h"
+#include "class_p.h"
+#include "property_p.h"
+#include "ontology_p.h"
+
+#include "../resourcemanager.h"
+
+#include <QtCore/QMutexLocker>
+
+Q_GLOBAL_STATIC( Nepomuk::Types::EntityManager, entityManager )
+
+Nepomuk::Types::EntityManager::EntityManager()
+{
+}
+
+
+Nepomuk::Types::EntityPrivate* Nepomuk::Types::EntityManager::findEntity( const QUrl& uri ) const
+{
+    if ( ClassPrivate* cp = findClass( uri ) ) {
+        return cp;
+    }
+    else if ( PropertyPrivate* pp = findProperty( uri ) ) {
+        return pp;
+    }
+    else if ( OntologyPrivate* op = findOntology( uri ) ) {
+        return op;
+    }
+    else {
+        return 0;
+    }
+}
+
+
+Nepomuk::Types::ClassPrivate* Nepomuk::Types::EntityManager::findClass( const QUrl& uri ) const
+{
+    QHash<QUrl, QExplicitlySharedDataPointer<ClassPrivate> >::const_iterator it = m_classMap.constFind( uri );
+    if ( it != m_classMap.end() ) {
+        return it.value().data();
+    }
+    return 0;
+}
+
+
+Nepomuk::Types::PropertyPrivate* Nepomuk::Types::EntityManager::findProperty( const QUrl& uri ) const
+{
+    QHash<QUrl, QExplicitlySharedDataPointer<PropertyPrivate> >::const_iterator it = m_propertyMap.constFind( uri );
+    if ( it != m_propertyMap.end() ) {
+        return it.value().data();
+    }
+    return 0;
+}
+
+
+Nepomuk::Types::OntologyPrivate* Nepomuk::Types::EntityManager::findOntology( const QUrl& uri ) const
+{
+    QHash<QUrl, QExplicitlySharedDataPointer<OntologyPrivate> >::const_iterator it = m_ontologyMap.constFind( uri );
+    if ( it != m_ontologyMap.end() ) {
+        return it.value().data();
+    }
+    return 0;
+}
+
+
+Nepomuk::Types::ClassPrivate* Nepomuk::Types::EntityManager::getClass( const QUrl& uri )
+{
+    QMutexLocker lock( &m_mutex );
+
+    if ( ClassPrivate* cp = findClass( uri ) ) {
+        return cp;
+    }
+    else {
+        QExplicitlySharedDataPointer<ClassPrivate> scp( new ClassPrivate( uri ) );
+        m_classMap.insert( uri, scp );
+        return scp.data();
+    }
+}
+
+
+Nepomuk::Types::PropertyPrivate* Nepomuk::Types::EntityManager::getProperty( const QUrl& uri )
+{
+    QMutexLocker lock( &m_mutex );
+
+    if ( PropertyPrivate* pp = findProperty( uri ) ) {
+        return pp;
+    }
+    else {
+        QExplicitlySharedDataPointer<PropertyPrivate> cp( new PropertyPrivate( uri ) );
+        m_propertyMap.insert( uri, cp );
+        return cp.data();
+    }
+}
+
+
+Nepomuk::Types::OntologyPrivate* Nepomuk::Types::EntityManager::getOntology( const QUrl& uri )
+{
+    QMutexLocker lock( &m_mutex );
+
+    if ( OntologyPrivate* op = findOntology( uri ) ) {
+        return op;
+    }
+    else {
+        QExplicitlySharedDataPointer<OntologyPrivate> cp( new OntologyPrivate( uri ) );
+        m_ontologyMap.insert( uri, cp );
+        return cp.data();
+    }
+}
+
+
+Nepomuk::Types::EntityManager* Nepomuk::Types::EntityManager::self()
+{
+    return entityManager();
+}

Modification de propriétés sur nepomuk/core/types/entitymanager.cpp
___________________________________________________________________
Ajouté : svn:eol-style
   + native

Index: nepomuk/core/types/property_p.h
===================================================================
--- nepomuk/core/types/property_p.h	(révision 0)
+++ nepomuk/core/types/property_p.h	(révision 0)
@@ -0,0 +1,94 @@
+/* This file is part of the Nepomuk-KDE libraries
+   Copyright (c) 2007 Sebastian Trueg <trueg@kde.org>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public License
+   along with this library; see the file COPYING.LIB.  If not, write to
+   the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.
+*/
+
+#ifndef _NEPOMUK_PROPERTY_PRIVATE_H_
+#define _NEPOMUK_PROPERTY_PRIVATE_H_
+
+#include "entity_p.h"
+#include "property.h"
+#include "literal.h"
+#include "class.h"
+
+#include <QtCore/QVariant>
+#include <QtCore/QSharedData>
+
+namespace Nepomuk {
+    namespace Types {
+        class PropertyPrivate : public EntityPrivate
+        {
+        public:
+            PropertyPrivate( const QUrl& uri = QUrl() );
+
+            Class range;
+            Class domain;
+
+            Literal literalRange;
+
+            Property inverse;
+
+            QList<Property> parents;
+            QList<Property> children;
+
+            int minCardinality;
+            int maxCardinality;
+            int cardinality;
+
+            bool addProperty( const QUrl& property, const Soprano::Node& value );
+            bool addAncestorProperty( const QUrl& ancestorResource, const QUrl& property );
+
+            void reset( bool recursive );
+        };
+    }
+}
+
+
+
+namespace Nepomuk {
+
+    class Class;
+
+    class Property::Private : public QSharedData
+    {
+    public:
+        Private()
+            : range( 0 ),
+            domain( 0 ),
+            inverse( 0 ),
+            minCardinality( -1 ),
+            maxCardinality( -1 ),
+            cardinality( -1 ) {
+	    }
+
+	    const Class* range;
+	    const Class* domain;
+
+	    Literal literalRange;
+
+	    const Property* inverse;
+
+	    QList<const Property*> parents;
+	    QList<const Property*> children;
+
+	    int minCardinality;
+	    int maxCardinality;
+	    int cardinality;
+    };
+}
+
+#endif

Modification de propriétés sur nepomuk/core/types/property_p.h
___________________________________________________________________
Ajouté : svn:eol-style
   + native

Index: nepomuk/core/types/class.h
===================================================================
--- nepomuk/core/types/class.h	(révision 0)
+++ nepomuk/core/types/class.h	(révision 0)
@@ -0,0 +1,400 @@
+/* This file is part of the Nepomuk-KDE libraries
+   Copyright (c) 2007-2009 Sebastian Trueg <trueg@kde.org>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public License
+   along with this library; see the file COPYING.LIB.  If not, write to
+   the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.
+*/
+
+#ifndef _NEPOMUK_CLASS_H_
+#define _NEPOMUK_CLASS_H_
+
+#include <QtCore/QList>
+#include <QtCore/QUrl>
+#include <QtCore/QString>
+#include <QtCore/QSharedData>
+
+#include "entity.h"
+#include "nepomuk_export.h"
+
+
+namespace Nepomuk {
+    namespace Types {
+        class Property;
+
+        /**
+         * \class Class class.h Nepomuk/Types/Class
+         *
+         * \brief A Class is a resource of type rdf:Class.
+         *
+         * Class instances are explicitly shared. Two instances created
+         * with the same uri reference the same data.
+         *
+         * While Resource objects can be changed Class instances are considered
+         * to be static and never changed during their lifetime.
+         *
+         * \author Sebastian Trueg <trueg@kde.org>
+         */
+        class NEPOMUK_EXPORT Class : public Entity
+        {
+            friend class ClassPrivate;
+
+        public:
+            /**
+             * Default constructor. Creates an empty Class.
+             */
+            Class();
+
+            /**
+             * Create the class referred to by \p uri.
+             * The result is either a valid class which could be loaded from the
+             * Nepomuk store or a simple class which only contains the uri.
+             *
+             * Be aware that the data is only loaded once read.
+             *
+             * Subsequent calls result in a simple hash lookup of cached data.
+             */
+            Class( const QUrl& uri );
+
+            /**
+             * Default copy constructor
+             */
+            Class( const Class& );
+
+            /**
+             * Destructor
+             */
+            ~Class();
+
+            /**
+             * Copy operator.
+             */
+            Class& operator=( const Class& );
+
+            /**
+             * A Property has a certain range which is a Class or a Literal.
+             * \return A list of all properties that have this Class as a range.
+             * \sa Property::range()
+             */
+            QList<Property> rangeOf();
+
+            /**
+             * A Property has a certain range which is a Class or a Literal.
+             * \return A list of all properties that have this Class as a range.
+             * \sa Property::range()
+             *
+             * Const version.
+             *
+             * \since 4.4
+             */
+            QList<Property> rangeOf() const;
+
+            /**
+             * A Property has a certain domain which is a Class.
+             * \return A list of all properties that have this Class as a domain.
+             * \sa Property::domain()
+             */
+            QList<Property> domainOf();
+
+            /**
+             * A Property has a certain domain which is a Class.
+             * \return A list of all properties that have this Class as a domain.
+             * \sa Property::domain()
+             *
+             * Const version.
+             *
+             * \since 4.4
+             */
+            QList<Property> domainOf() const;
+
+            /**
+             * Search for a property in the class by its name.
+             * \param name The name of the property.
+             * \return the Property object identified by name or an invalid property if it could not be found.
+             */
+            Property findPropertyByName( const QString& name );
+
+            /**
+             * Search for a property in the class by its name.
+             * \param name The name of the property.
+             * \return the Property object identified by name or an invalid property if it could not be found.
+             *
+             * Const version.
+             *
+             * \since 4.4
+             */
+            Property findPropertyByName( const QString& name ) const;
+
+            /**
+             * Search for a property in the class by its label.
+             * \param label The label of the property (i.e. rdfs:label)
+             * \param language The language in which the label was specified. If empty the default rdfs:label
+             * is returned.
+             * \return the Property object identified by label or an invalid property if it could not be found.
+             */
+            Property findPropertyByLabel( const QString& label, const QString& language = QString() );
+
+            /**
+             * Search for a property in the class by its label.
+             * \param label The label of the property (i.e. rdfs:label)
+             * \param language The language in which the label was specified. If empty the default rdfs:label
+             * is returned.
+             * \return the Property object identified by label or an invalid property if it could not be found.
+             *
+             * Const version.
+             *
+             * \since 4.4
+             */
+            Property findPropertyByLabel( const QString& label, const QString& language = QString() ) const;
+
+            /**
+             * Each class can have multiple parent classes. This method
+             * provides a list of all direct parents.
+             * \return A list of all parent classes of this class.
+             * If the list is emppty it means that the class has no direct
+             * parents, i.e. it is derived from rdf:Resource.
+             * \sa allParentClasses()
+             */
+            QList<Class> parentClasses();
+
+            /**
+             * Each class can have multiple parent classes. This method
+             * provides a list of all direct parents.
+             * \return A list of all parent classes of this class.
+             * If the list is emppty it means that the class has no direct
+             * parents, i.e. it is derived from rdf:Resource.
+             * \sa allParentClasses()
+             *
+             * Const version.
+             *
+             * \since 4.4
+             */
+            QList<Class> parentClasses() const;
+
+            /**
+             * \return A list of all classes that have this class as a parent.
+             * Be aware that this list can never be final since other ontologies
+             * that have not been loaded yet may contain classes that are derived
+             * from this class.
+             */
+            QList<Class> subClasses();
+
+            /**
+             * \return A list of all classes that have this class as a parent.
+             * Be aware that this list can never be final since other ontologies
+             * that have not been loaded yet may contain classes that are derived
+             * from this class.
+             *
+             * Const version.
+             *
+             * \since 4.4
+             */
+            QList<Class> subClasses() const;
+
+            /**
+             * Recursively determines all parent classes of this class, not
+             * only the direct ones.
+             * \return A list of parent classes of this class.
+             * \sa parentClasses()
+             */
+            QList<Class> allParentClasses();
+
+            /**
+             * Recursively determines all parent classes of this class, not
+             * only the direct ones.
+             * \return A list of parent classes of this class.
+             * \sa parentClasses()
+             *
+             * Const version.
+             *
+             * \since 4.4
+             */
+            QList<Class> allParentClasses() const;
+
+            /**
+             * Recursively determines all sub classes of this class, not
+             * only the direct ones.
+             * \return A list of sub classes of this class.
+             * \sa subClasses()
+             */
+            QList<Class> allSubClasses();
+
+            /**
+             * Recursively determines all sub classes of this class, not
+             * only the direct ones.
+             * \return A list of sub classes of this class.
+             * \sa subClasses()
+             *
+             * Const version.
+             *
+             * \since 4.4
+             */
+            QList<Class> allSubClasses() const;
+
+            /**
+             * Check if a class inherits this class. This is a recursive method which
+             * does not only check direct child classes.
+             *
+             * \return true if other is derived from this class, false otherwise.
+             */
+            bool isParentOf( const Class& other );
+
+            /**
+             * Check if a class inherits this class. This is a recursive method which
+             * does not only check direct child classes.
+             *
+             * \return true if other is derived from this class, false otherwise.
+             *
+             * Const version.
+             *
+             * \since 4.4
+             */
+            bool isParentOf( const Class& other ) const;
+
+            /**
+             * Check if this class is derived from another class. This is a recursive method which
+             * does not only check direct child classes.
+             *
+             * \return true if this class is derived from other, false otherwise.
+             */
+            bool isSubClassOf( const Class& other );
+
+            /**
+             * Check if this class is derived from another class. This is a recursive method which
+             * does not only check direct child classes.
+             *
+             * \return true if this class is derived from other, false otherwise.
+             *
+             * Const version.
+             *
+             * \since 4.4
+             */
+            bool isSubClassOf( const Class& other ) const;
+        };
+    }
+}
+
+
+#ifndef DISABLE_NEPOMUK_LEGACY
+
+namespace Nepomuk {
+
+    class Ontology;
+    class Property;
+
+    /**
+     * A Class is a resource of type rdf:Class.
+     *
+     * \deprecated in favor of Nepomuk::Types::Class
+     */
+    class KDE_DEPRECATED NEPOMUK_EXPORT Class : public Entity
+    {
+    public:
+	/**
+	 * Default constructor. Creates an empty Class.
+	 */
+	Class();
+
+	/**
+	 * Default copy constructor
+	 */
+	Class( const Class& );
+
+	/**
+	 * Destructor
+	 */
+	~Class();
+
+	Class& operator=( const Class& );
+
+	// an alternative would be: QList<Property> rangeOf() and QList<Property> domainOf()
+	QList<const Property*> allProperties() const;
+
+	/**
+	 * Search for a property in the class by its name.
+	 * \param name The name of the property.
+	 * \return the Property object identified by name or 0 if the property could not be found.
+	 */
+	const Property* findPropertyByName( const QString& name ) const;
+
+	/**
+	 * Search for a property in the class by its label.
+	 * \param label The label of the property (i.e. rdfs:label)
+	 * \param language The language in which the label was specified. If empty the default rdfs:label
+	 * is returned.
+	 * \return the Property object identified by label or 0 if the property could not be found.
+	 */
+	const Property* findPropertyByLabel( const QString& label, const QString& language = QString() ) const;
+
+	/**
+	 * Search for a property in the class by its name.
+	 * \param uri the URI of the property
+	 * \return the Property object identified by uri or 0 if the property could not be found.
+	 */
+	const Property* findPropertyByUri( const QUrl& uri ) const;
+
+	/**
+	 * Each class can have multiple parent classes.
+	 * \return A list of all parent classes of this class.
+	 * If the list is emppty it means that the class has no direct
+	 * parents, i.e. it is derived from rdf:Resource.
+	 */
+	QList<const Class*> parentClasses() const;
+
+	/**
+	 * \return A list of all classes that have this class as a parent.
+	 * Be aware that this list can never be final since other ontologies
+	 * that have not been loaded yet may contain classes that are derived
+	 * from this class.
+	 */
+	QList<const Class*> subClasses() const;
+
+	/**
+	 * Check if a class inherits this class. This is a recursive method which
+	 * does not only check direct child classes.
+	 *
+	 * \return true if other is derived from this class, false otherwise.
+	 */
+	bool isParentOf( const Class* other ) const;
+
+	/**
+	 * Check if this class is derived from another class. This is a recursive method which
+	 * does not only check direct child classes.
+	 *
+	 * \return true if this class is derived from other, false otherwise.
+	 */
+	bool isSubClassOf( const Class* other ) const;
+
+	/**
+	 * Loads a class actually including the whole ontology
+	 * it is declared in.
+	 *
+	 * Dependancies are resolved automatically if possible.
+	 *
+	 * \return A Class object representing the class identified
+	 * by uri or an invalid Class object if the resource identified
+	 * by uri is either not a class or does not exist.
+	 */
+	static const Class* load( const QUrl& uri );
+
+    private:
+	class Private;
+	QSharedDataPointer<Private> d;
+
+	friend class OntologyManager;
+    };
+}
+
+#endif
+#endif

Modification de propriétés sur nepomuk/core/types/class.h
___________________________________________________________________
Ajouté : svn:eol-style
   + native

Index: nepomuk/core/types/ontology.h
===================================================================
--- nepomuk/core/types/ontology.h	(révision 0)
+++ nepomuk/core/types/ontology.h	(révision 0)
@@ -0,0 +1,238 @@
+/* This file is part of the Nepomuk-KDE libraries
+   Copyright (c) 2007 Sebastian Trueg <trueg@kde.org>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public License
+   along with this library; see the file COPYING.LIB.  If not, write to
+   the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.
+*/
+
+#ifndef _NEPOMUK_ONTOLOGY_H_
+#define _NEPOMUK_ONTOLOGY_H_
+
+#include <QtCore/QList>
+#include <QtCore/QUrl>
+#include <QtCore/QString>
+#include <QtCore/QSharedData>
+
+#include "entity.h"
+#include "nepomuk_export.h"
+
+
+namespace Nepomuk {
+    namespace Types {
+
+        class Class;
+        class Property;
+
+        /**
+         * \class Ontology ontology.h Nepomuk/Types/Ontology
+         *
+         * \brief Represents one ontology.
+         *
+         * \author Sebastian Trueg <trueg@kde.org>
+         */
+        class NEPOMUK_EXPORT Ontology : public Entity
+        {
+        public:
+            /**
+             * Default constructor. Creates an empty Ontology.
+             */
+            Ontology();
+
+            /**
+             * Create the ontology referred to by \p uri.
+             * The result is either a valid ontology which could be loaded from the
+             * Nepomuk store or a simple class which only contains the uri.
+             *
+             * Be aware that the data is only loaded once read.
+             *
+             * Subsequent calls result in a simple hash lookup of cached data.
+             */
+            Ontology( const QUrl& uri );
+
+            /**
+             * Default copy constructor
+             */
+            Ontology( const Ontology& );
+
+            /**
+             * Destructor
+             */
+            ~Ontology();
+
+            Ontology& operator=( const Ontology& );
+
+            /**
+             * All classes defined in this ontology, i.e. its namespace.
+             */
+            QList<Class> allClasses();
+
+            /**
+             * Search for a class in the ontology by its name.
+             * \param name The name of the class.
+             * \return the Class object identified by name or an invalid one if the class could not be found.
+             */
+            Class findClassByName( const QString& name );
+
+            /**
+             * Search for a class in the ontology by its label.
+             * \param label The label of the class (i.e. rdfs:label)
+             * \param language The language in which the label was specified. If empty the default rdfs:label
+             * is returned.
+             * \return the Class object identified by label or an invalid one if the class could not be found.
+             */
+            Class findClassByLabel( const QString& label, const QString& language = QString() );
+
+            /**
+             * A list of all properties defined in this ontology. This does not include properties that use
+             * classes of this ontology but are defined in a different one.
+             */
+            QList<Property> allProperties();
+
+            /**
+             * Search for a property in the ontology by its name.
+             * \param name The name of the property.
+             * \return the Property object identified by name or an invalid one if the property could not be found.
+             */
+            Property findPropertyByName( const QString& name );
+
+            /**
+             * Search for a property in the ontology by its label.
+             * \param label The label of the property (i.e. rdfs:label)
+             * \param language The language in which the label was specified. If empty the default rdfs:label
+             * is returned.
+             * \return the Property object identified by label or an invalid one if the property could not be found.
+             */
+            Property findPropertyByLabel( const QString& label, const QString& language = QString() );
+        };
+    }
+}
+
+
+#ifndef DISABLE_NEPOMUK_LEGACY
+
+namespace Nepomuk {
+
+    class Class;
+    class Property;
+
+    /**
+     * Ontology represents one ontology specified using NRL.
+     *
+     * \deprecated in favor of Nepomuk::Types::Ontology
+     */
+    class KDE_DEPRECATED NEPOMUK_EXPORT Ontology
+    {
+    public:
+	/**
+	 * Default constructor. Creates an empty Ontology.
+	 */
+	Ontology();
+
+	/**
+	 * Default copy constructor
+	 */
+	Ontology( const Ontology& );
+
+	/**
+	 * Destructor
+	 */
+	~Ontology();
+
+	Ontology& operator=( const Ontology& );
+
+	/**
+	 * The URI of the ontology, i.e. its namespace
+	 */
+	QUrl uri() const;
+
+	/**
+	 * All classes defined in this ontology, i.e. its namespace.
+	 */
+	QList<const Class*> allClasses() const;
+
+	/**
+	 * Search for a class in the ontology by its name.
+	 * \param name The name of the class.
+	 * \return the Class object identified by name or 0 if the class could not be found.
+	 */
+	const Class* findClassByName( const QString& name ) const;
+
+	/**
+	 * Search for a class in the ontology by its label.
+	 * \param label The label of the class (i.e. rdfs:label)
+	 * \param language The language in which the label was specified. If empty the default rdfs:label
+	 * is returned.
+	 * \return the Class object identified by label or 0 if the class could not be found.
+	 */
+	const Class* findClassByLabel( const QString& label, const QString& language = QString() ) const;
+
+	/**
+	 * Search for a class in the ontology by its name.
+	 * \param uri the URI of the class
+	 * \return the Class object identified by uri or 0 if the class could not be found.
+	 */
+	const Class* findClassByUri( const QUrl& uri ) const;
+
+        /**
+	 * A list of all properties defined in this ontology. This does not include properties that use
+	 * classes of this ontology but are defined in a different one.
+	 */
+	QList<const Property*> allProperties() const;
+
+	/**
+	 * Search for a property in the ontology by its name.
+	 * \param name The name of the property.
+	 * \return the Property object identified by name or 0 if the property could not be found.
+	 */
+	const Property* findPropertyByName( const QString& name ) const;
+
+	/**
+	 * Search for a property in the ontology by its label.
+	 * \param label The label of the property (i.e. rdfs:label)
+	 * \param language The language in which the label was specified. If empty the default rdfs:label
+	 * is returned.
+	 * \return the Property object identified by label or 0 if the property could not be found.
+	 */
+	const Property* findPropertyByLabel( const QString& label, const QString& language = QString() ) const;
+
+	/**
+	 * Search for a property in the ontology by its name.
+	 * \param uri the URI of the property
+	 * \return the Property object identified by uri or 0 if the property could not be found.
+	 */
+	const Property* findPropertyByUri( const QUrl& uri ) const;
+
+	/**
+	 * Loads an ontology.
+	 *
+	 * Dependancies are resolved automatically if possible.
+	 *
+	 * \return An Ontology object representing the ontology identified
+	 * by uri or an invalid Ontology object if the resource identified
+	 * by uri is either not an ontology or does not exist.
+	 */
+	static const Ontology* load( const QUrl& uri );
+
+    private:
+	class Private;
+	QSharedDataPointer<Private> d;
+
+	friend class OntologyManager;
+    };
+}
+
+#endif // DISABLE_NEPOMUK_LEGACY
+
+#endif

Modification de propriétés sur nepomuk/core/types/ontology.h
___________________________________________________________________
Ajouté : svn:eol-style
   + native

Index: nepomuk/core/types/literal_p.h
===================================================================
--- nepomuk/core/types/literal_p.h	(révision 0)
+++ nepomuk/core/types/literal_p.h	(révision 0)
@@ -0,0 +1,52 @@
+/* This file is part of the Nepomuk-KDE libraries
+    Copyright (c) 2007 Sebastian Trueg <trueg@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+*/
+
+#ifndef _NEPOMUK_LITERAL_PRIVATE_H_
+#define _NEPOMUK_LITERAL_PRIVATE_H_
+
+#include "literal.h"
+
+#include <QtCore/QUrl>
+#include <QtCore/QVariant>
+#include <QtCore/QSharedData>
+
+class Nepomuk::Types::Literal::Private : public QSharedData
+{
+ public:
+    Private()
+	: dataType( QVariant::Invalid ) {
+    }
+
+    QUrl dataTypeUri;
+    QVariant::Type dataType;  
+};
+
+
+class Nepomuk::Literal::Private : public QSharedData
+{
+ public:
+    Private()
+	: dataType( QVariant::Invalid ) {
+    }
+
+    QUrl dataTypeUri;
+    QVariant::Type dataType;  
+};
+
+#endif

Modification de propriétés sur nepomuk/core/types/literal_p.h
___________________________________________________________________
Ajouté : svn:eol-style
   + native

Index: nepomuk/core/types/entity.h
===================================================================
--- nepomuk/core/types/entity.h	(révision 0)
+++ nepomuk/core/types/entity.h	(révision 0)
@@ -0,0 +1,297 @@
+/* This file is part of the Nepomuk-KDE libraries
+   Copyright (c) 2007-2009 Sebastian Trueg <trueg@kde.org>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public License
+   along with this library; see the file COPYING.LIB.  If not, write to
+   the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.
+*/
+
+#ifndef _NEPOMUK_ENTITY_H_
+#define _NEPOMUK_ENTITY_H_
+
+#include <QtCore/QUrl>
+#include <QtCore/QString>
+#include <QtCore/QSharedData>
+#include <QtCore/QHash>
+
+#include <Soprano/Node>
+
+#include <kglobal.h>
+#include <klocale.h>
+
+#include "nepomuk_export.h"
+
+class QIcon;
+
+
+namespace Nepomuk {
+    namespace Types {
+        class EntityPrivate;
+
+        /**
+         * \brief Abstract base class for Class and Property;
+         *
+         * Base class for static ontology entities Class and Property.
+         * It encapsulates the generic labels and comments that both
+         * types have.
+         *
+         * Due to internal optimizations comparing two Entities is much
+         * faster than comparing two QUrl objects.
+         *
+         * \author Sebastian Trueg <trueg@kde.org>
+         */
+        class NEPOMUK_EXPORT Entity
+        {
+        public:
+            /**
+             * Default copy constructor.
+             */
+            Entity( const Entity& );
+
+            /**
+             * Destructor.
+             */
+            virtual ~Entity();
+
+            /**
+             * Copy operator.
+             */
+            Entity& operator=( const Entity& );
+
+            /**
+             * The name of the resource. The name equals the fragment of the
+             * URI.
+             */
+            QString name() const;
+
+            /**
+             * The URI of the resource
+             */
+            QUrl uri() const;
+
+            /**
+             * Retrieve the label of the entity (rdfs:label)
+             *
+             * \param language The code of the language to use. Defaults to the session
+             *                 language configured in KDE. As of KDE 4.3 only the currently
+             *                 configured language is loaded to save memory.
+             *
+             * \return The label translated into \p language or the default fallback label
+             * if no translation is available or the name() if no label could be found
+             * at all.
+             */
+            QString label( const QString& language = KGlobal::locale()->language() );
+
+            /**
+             * Retrieve the label of the entity (rdfs:label)
+             *
+             * \param language The code of the language to use. Defaults to the session
+             *                 language configured in KDE. As of KDE 4.3 only the currently
+             *                 configured language is loaded to save memory.
+             *
+             * \return The label translated into \p language or the default fallback label
+             * if no translation is available or the name() if no label could be found
+             * at all.
+             *
+             * Const version
+             *
+             * \since 4.4
+             */
+            QString label( const QString& language = KGlobal::locale()->language() ) const;
+
+            /**
+             * Retrieve the comment of the entity (rdfs:comment)
+             *
+             * \param language The code of the language to use. Defaults to the session
+             *                 language configured in KDE. As of KDE 4.3 only the currently
+             *                 configured language is loaded to save memory.
+             *
+             * \return The comment translated into \p language or the default fallback comment
+             * if no translation is available or an empty string if no comment could be found
+             * at all.
+             */
+            QString comment( const QString& language = KGlobal::locale()->language() );
+
+            /**
+             * Retrieve the comment of the entity (rdfs:comment)
+             *
+             * \param language The code of the language to use. Defaults to the session
+             *                 language configured in KDE. As of KDE 4.3 only the currently
+             *                 configured language is loaded to save memory.
+             *
+             * \return The comment translated into \p language or the default fallback comment
+             * if no translation is available or an empty string if no comment could be found
+             * at all.
+             *
+             * Const version
+             *
+             * \since 4.4
+             */
+            QString comment( const QString& language = KGlobal::locale()->language() ) const;
+
+            /**
+             * Retrieve the icon stored for the entity (nao:hasSymbol)
+             *
+             * If no symbol is defined for the entity a null icon will be returned.
+             *
+             * \since 4.1
+             */
+            QIcon icon();
+
+            /**
+             * Retrieve the icon stored for the entity (nao:hasSymbol)
+             *
+             * If no symbol is defined for the entity a null icon will be returned.
+             *
+             * Const version.
+             *
+             * \since 4.4
+             */
+            QIcon icon() const;
+
+            /**
+             * Is this a valid Entity, i.e. has it a valid URI.
+             * A valid Entity does not necessarily have a label and a comment, it
+             * does not even have to exist in the Nepomuk store.
+             *
+             * \sa isAvailable
+             */
+            bool isValid() const;
+
+            /**
+             * Is this Entity available locally, i.e. could its properties
+             * be loaded from the Nepomuk store.
+             */
+            bool isAvailable();
+
+            /**
+             * Is this Entity available locally, i.e. could its properties
+             * be loaded from the Nepomuk store.
+             *
+             * Const version.
+             *
+             * \since 4.4
+             */
+            bool isAvailable() const;
+
+            /**
+             * The Types classes are optimized for performance under the
+             * aasumption that ontologies never change during the execution
+             * time of an application.
+             *
+             * Since there might be situations where this does not apply
+             * the internal cache can be reset via this method.
+             *
+             * \param recursive If \p true all related entities will be reset
+             * as well.
+             *
+             * \since 4.1
+             */
+            void reset( bool recursive = false );
+
+            /**
+             * An Entity can be used as a QUrl automagically.
+             */
+            operator QUrl() const { return uri(); }
+
+            /**
+             * Compares two Entity instances by simply comparing their URI.
+             */
+            bool operator==( const Entity& other ) const;
+
+            /**
+             * Compares the Entity with a URI.
+             *
+             * \since 4.5
+             */
+            bool operator==( const QUrl& other ) const;
+
+            /**
+             * Compares two Entity instances by simply comparing their URI.
+             */
+            bool operator!=( const Entity& other ) const;
+
+            /**
+             * Compares the Entity with a URI.
+             *
+             * \since 4.5
+             */
+            bool operator!=( const QUrl& other ) const;
+
+        protected:
+            /**
+             * Create an invalid Entity instance.
+             */
+            Entity();
+
+            QExplicitlySharedDataPointer<EntityPrivate> d;
+        };
+
+        inline uint qHash( const Entity& c )
+        {
+            return qHash( c.uri() );
+        }
+    }
+}
+
+#ifndef DISABLE_NEPOMUK_LEGACY
+
+namespace Nepomuk {
+
+    class Ontology;
+
+    /**
+     * \deprecated in favor of Nepomuk::Types::Entity
+     */
+    class KDE_DEPRECATED NEPOMUK_EXPORT Entity
+    {
+    public:
+        Entity( const Entity& );
+        ~Entity();
+
+        Entity& operator=( const Entity& );
+
+        /**
+         * The ontology in which the resource is defined.
+         */
+        const Ontology* definingOntology() const;
+
+        /**
+         * The name of the resource. The name equals the fragment of the
+         * URI.
+         */
+        QString name() const;
+
+        /**
+         * The URI of the resource
+         */
+        QUrl uri() const;
+
+        QString label( const QString& language = QString() ) const;
+        QString comment( const QString& language = QString() ) const;
+
+    protected:
+        Entity();
+
+    private:
+        class Private;
+        QSharedDataPointer<Private> d;
+
+        friend class OntologyManager;
+    };
+}
+
+#endif // DISABLE_NEPOMUK_LEGACY
+
+#endif // _NEPOMUK_ENTITY_H_

Modification de propriétés sur nepomuk/core/types/entity.h
___________________________________________________________________
Ajouté : svn:eol-style
   + native

Index: nepomuk/core/types/property.h
===================================================================
--- nepomuk/core/types/property.h	(révision 0)
+++ nepomuk/core/types/property.h	(révision 0)
@@ -0,0 +1,428 @@
+/* This file is part of the Nepomuk-KDE libraries
+   Copyright (c) 2007 Sebastian Trueg <trueg@kde.org>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public License
+   along with this library; see the file COPYING.LIB.  If not, write to
+   the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.
+*/
+
+#ifndef _NEPOMUK_PROPERTY_H_
+#define _NEPOMUK_PROPERTY_H_
+
+#include <QtCore/QList>
+#include <QtCore/QUrl>
+#include <QtCore/QString>
+#include <QtCore/QVariant>
+#include <QtCore/QSharedData>
+
+#include "entity.h"
+#include "nepomuk_export.h"
+
+namespace Nepomuk {
+    namespace Types {
+
+        class Class;
+        class Literal;
+
+        /**
+         * \class Property property.h Nepomuk/Types/Property
+         *
+         * \brief A property is a resource of type rdf:Property which relates a domain
+         * with a range. The latter one can be a Literal or a Class.
+         *
+         * Property instances are explicitly shared. Two instances created
+         * with the same uri reference the same data.
+         *
+         * While Resource objects can be changed Property instances are considered
+         * to be static and never changed during their lifetime.
+         *
+         * \author Sebastian Trueg <trueg@kde.org>
+         */
+        class NEPOMUK_EXPORT Property : public Entity
+        {
+        public:
+            /**
+             * Default constructor. Creates an empty Property.
+             */
+            Property();
+
+            /**
+             * Create the property referred to by \p uri.
+             * The result is either a valid property which could be loaded from the
+             * Nepomuk store or a simple property which only contains the uri.
+             *
+             * Be aware that the data is only loaded once read.
+             *
+             * Subsequent calls result in a simple hash lookup of cached data.
+             */
+            Property( const QUrl& uri );
+
+            /**
+             * Default copy constructor
+             */
+            Property( const Property& );
+
+            /**
+             * Destructor
+             */
+            ~Property();
+
+            /**
+             * Copy operator.
+             */
+            Property& operator=( const Property& );
+
+            /**
+             * Each property can have multiple parent properties.
+             * \return A list of all parent properties of this property.
+             * If the list is emppty it means that the property has no direct
+             * parents, i.e. it is derived from rdf:Resource.
+             */
+            QList<Property> parentProperties();
+
+            /**
+             * Each property can have multiple parent properties.
+             * \return A list of all parent properties of this property.
+             * If the list is emppty it means that the property has no direct
+             * parents, i.e. it is derived from rdf:Resource.
+             *
+             * Const version
+             *
+             * \since 4.4
+             */
+            QList<Property> parentProperties() const;
+
+            /**
+             * \return A list of all properties that have this property as a parent.
+             * Be aware that this list can never be final since other ontologies
+             * that have not been loaded yet may contain properties that are derived
+             * from this property.
+             */
+            QList<Property> subProperties();
+
+            /**
+             * \return A list of all properties that have this property as a parent.
+             * Be aware that this list can never be final since other ontologies
+             * that have not been loaded yet may contain properties that are derived
+             * from this property.
+             *
+             * Const version
+             *
+             * \since 4.4
+             */
+            QList<Property> subProperties() const;
+
+            /**
+             * The inverse property (nrl:inverseProperty).
+             * \return A Property instance representing the inverse property of this one
+             * or 0 if none was specified in the ontology.
+             */
+            Property inverseProperty();
+
+            /**
+             * The inverse property (nrl:inverseProperty).
+             * \return A Property instance representing the inverse property of this one
+             * or 0 if none was specified in the ontology.
+             *
+             * Const version
+             *
+             * \since 4.4
+             */
+            Property inverseProperty() const;
+
+            /**
+             * The range of the property.
+             * \return The range of the property or an invalid Class in case
+             * the range of this poperty is a literal.
+             * \sa literalRange
+             */
+            Class range();
+
+            /**
+             * The range of the property.
+             * \return The range of the property or an invalid Class in case
+             * the range of this poperty is a literal.
+             * \sa literalRange
+             *
+             * Const version
+             *
+             * \since 4.4
+             */
+            Class range() const;
+
+            /**
+             * If the rage of this property is a literal (i.e. range returns an invalid Class)
+             * this method provides the literal type.
+             *
+             * \returns the literal type of this property or an empty, invalid Literal
+             * if the range is a Class.
+             *
+             * \sa range
+             */
+            Literal literalRangeType();
+
+            /**
+             * If the rage of this property is a literal (i.e. range returns an invalid Class)
+             * this method provides the literal type.
+             *
+             * \returns the literal type of this property or an empty, invalid Literal
+             * if the range is a Class.
+             *
+             * \sa range
+             *
+             * Const version
+             *
+             * \since 4.4
+             */
+            Literal literalRangeType() const;
+
+            /**
+             * The domain of the property.
+             */
+            Class domain();
+
+            /**
+             * The domain of the property.
+             *
+             * Const version
+             *
+             * \since 4.4
+             */
+            Class domain() const;
+
+            /**
+             * The cardinality of this property as specified by nrl:cardinality.
+             *
+             * \return the cardinality of the property or -1 if none was set.
+             */
+            int cardinality();
+
+            /**
+             * The cardinality of this property as specified by nrl:cardinality.
+             *
+             * \return the cardinality of the property or -1 if none was set.
+             *
+             * Const version
+             *
+             * \since 4.4
+             */
+            int cardinality() const;
+
+            /**
+             * The minimum cardinality of this property as specified by nrl:minCardinality.
+             *
+             * \return the minimum cardinality of the property or -1 if none was set.
+             */
+            int minCardinality();
+
+            /**
+             * The minimum cardinality of this property as specified by nrl:minCardinality.
+             *
+             * \return the minimum cardinality of the property or -1 if none was set.
+             *
+             * Const version
+             *
+             * \since 4.4
+             */
+            int minCardinality() const;
+
+            /**
+             * The maximum cardinality of this property as specified by nrl:maxCardinality.
+             *
+             * \return the maximum cardinality of the property or -1 if none was set.
+             */
+            int maxCardinality();
+
+            /**
+             * The maximum cardinality of this property as specified by nrl:maxCardinality.
+             *
+             * \return the maximum cardinality of the property or -1 if none was set.
+             *
+             * Const version
+             *
+             * \since 4.4
+             */
+            int maxCardinality() const;
+
+            /**
+             * Check if a property inherits this property. This is a recursive method which
+             * does not only check direct child propertyes.
+             *
+             * \return true if other is derived from this property, false otherwise.
+             */
+            bool isParentOf( const Property& other );
+
+            /**
+             * Check if a property inherits this property. This is a recursive method which
+             * does not only check direct child propertyes.
+             *
+             * \return true if other is derived from this property, false otherwise.
+             *
+             * Const version
+             *
+             * \since 4.4
+             */
+            bool isParentOf( const Property& other ) const;
+
+            /**
+             * Check if this property is derived from another property. This is a recursive method which
+             * does not only check direct child propertyes.
+             *
+             * \return true if this property is derived from other, false otherwise.
+             */
+            bool isSubPropertyOf( const Property& other );
+
+            /**
+             * Check if this property is derived from another property. This is a recursive method which
+             * does not only check direct child propertyes.
+             *
+             * \return true if this property is derived from other, false otherwise.
+             *
+             * Const version
+             *
+             * \since 4.4
+             */
+            bool isSubPropertyOf( const Property& other ) const;
+        };
+    }
+}
+
+
+#ifndef DISABLE_NEPOMUK_LEGACY
+
+namespace Nepomuk {
+
+    class Ontology;
+    class Class;
+    class Literal;
+
+    /**
+     * A property is a resource of type rdf:Property which relates a domain
+     * with a range. The latter one can be a literal in addition to a Class.
+     *
+     * \deprecated in favor of Nepomuk::Types::Property
+     */
+    class KDE_DEPRECATED NEPOMUK_EXPORT Property : public Entity
+    {
+    public:
+	/**
+	 * Default constructor. Creates an empty Property.
+	 */
+	Property();
+
+	/**
+	 * Default copy constructor
+	 */
+	Property( const Property& );
+
+	/**
+	 * Destructor
+	 */
+	~Property();
+
+	Property& operator=( const Property& );
+
+	/**
+	 * Each property can have multiple parent properties.
+	 * \return A list of all parent properties of this property.
+	 * If the list is emppty it means that the property has no direct
+	 * parents, i.e. it is derived from rdf:Resource.
+	 */
+	QList<const Property*> parentProperties() const;
+
+	/**
+	 * \return A list of all properties that have this property as a parent.
+	 * Be aware that this list can never be final since other ontologies
+	 * that have not been loaded yet may contain properties that are derived
+	 * from this property.
+	 */
+	QList<const Property*> parentOf() const;
+
+	/**
+	 * The inverse property (nrl:inverseProperty).
+	 * \return A Property instance representing the inverse property of this one
+	 * or 0 if none was specified in the ontology.
+	 */
+	const Property* inverseProperty() const;
+
+	/**
+	 * The range of the property.
+	 * \return The range of the property or an invalid Class in case
+	 * the range of this poperty is a literal.
+	 * \sa literalRange
+	 */
+	const Class* range() const;
+
+	/**
+	 * If the rage of this property is a literal (i.e. range returns 0)
+	 * this method provides the literal type.
+	 *
+	 * \returns the literal type of this property or an empty, invalid Literal
+	 * if the range is a Class.
+	 *
+	 * \sa range
+	 */
+	Literal literalRangeType() const;
+
+	/**
+	 * The domain of the property.
+	 */
+	const Class* domain() const;
+
+	/**
+	 * The cardinality of this property as specified by nrl:cardinality.
+	 *
+	 * \return the cardinality of the property or -1 if none was set.
+	 */
+	int cardinality() const;
+
+	/**
+	 * The minimum cardinality of this property as specified by nrl:minCardinality.
+	 *
+	 * \return the minimum cardinality of the property or -1 if none was set.
+	 */
+	int minCardinality() const;
+
+	/**
+	 * The maximum cardinality of this property as specified by nrl:maxCardinality.
+	 *
+	 * \return the maximum cardinality of the property or -1 if none was set.
+	 */
+	int maxCardinality() const;
+
+	// QString unit() const;
+
+	/**
+	 * Loads a property actually including the whole ontology
+	 * it is declared in.
+	 *
+	 * Dependancies are resolved automatically if possible.
+	 *
+	 * \return A property object representing the property identified
+	 * by uri or an invalid Property object if the resource identified
+	 * by uri is either not a property or does not exist.
+	 */
+	static const Property* load( const QUrl& uri );
+
+    private:
+	class Private;
+	QSharedDataPointer<Private> d;
+
+	friend class OntologyManager;
+    };
+}
+
+#endif // DISABLE_NEPOMUK_LEGACY
+
+#endif // _NEPOMUK_PROPERTY_H_

Modification de propriétés sur nepomuk/core/types/property.h
___________________________________________________________________
Ajouté : svn:eol-style
   + native

Index: nepomuk/core/types/CMakeLists.txt
===================================================================
--- nepomuk/core/types/CMakeLists.txt	(révision 0)
+++ nepomuk/core/types/CMakeLists.txt	(révision 0)
@@ -0,0 +1,18 @@
+project(nepomukcore_onto)
+
+install(FILES
+  entity.h
+  class.h
+  property.h
+  ontology.h
+  literal.h
+  ontologymanager.h
+  ontologyloader.h
+  nepomukontologyloader.h
+  fileontologyloader.h
+  desktopontologyloader.h
+  global.h
+  DESTINATION ${INCLUDE_INSTALL_DIR}/nepomuk COMPONENT Devel
+)
+
+#add_subdirectory(test)

Modification de propriétés sur nepomuk/core/types/CMakeLists.txt
___________________________________________________________________
Ajouté : svn:eol-style
   + native

Index: nepomuk/core/types/test/kontotest.h
===================================================================
--- nepomuk/core/types/test/kontotest.h	(révision 0)
+++ nepomuk/core/types/test/kontotest.h	(révision 0)
@@ -0,0 +1,36 @@
+/* This file is part of the Nepomuk-KDE libraries
+    Copyright (c) 2007 Sebastian Trueg <trueg@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+*/
+
+#ifndef _KONTO_TEST_H_
+#define _KONTO_TEST_H_
+
+#include <QtCore/QObject>
+
+class KontoTest : public QObject
+{
+    Q_OBJECT
+
+private Q_SLOTS:
+    void initTestCase();
+    void testOntology();
+    void testClass();
+    void testProperty();
+};
+
+#endif

Modification de propriétés sur nepomuk/core/types/test/kontotest.h
___________________________________________________________________
Ajouté : svn:eol-style
   + native

Index: nepomuk/core/types/test/desktopontologyloadertest.h
===================================================================
--- nepomuk/core/types/test/desktopontologyloadertest.h	(révision 0)
+++ nepomuk/core/types/test/desktopontologyloadertest.h	(révision 0)
@@ -0,0 +1,35 @@
+/* This file is part of the Nepomuk-KDE libraries
+    Copyright (c) 2007 Sebastian Trueg <trueg@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+*/
+
+#ifndef _KONTO_DESKTOP_ONTOLOGY_LOADER_TEST_H_
+#define _KONTO_DESKTOP_ONTOLOGY_LOADER_TEST_H_
+
+#include <QtCore/QObject>
+
+class DesktopOntologyLoaderTest : public QObject
+{
+    Q_OBJECT
+
+private Q_SLOTS:
+    void initTestCase();
+    void testLoading();
+    void cleanupTestCase();
+};
+
+#endif

Modification de propriétés sur nepomuk/core/types/test/desktopontologyloadertest.h
___________________________________________________________________
Ajouté : svn:eol-style
   + native

Index: nepomuk/core/types/test/entitytest.h
===================================================================
--- nepomuk/core/types/test/entitytest.h	(révision 0)
+++ nepomuk/core/types/test/entitytest.h	(révision 0)
@@ -0,0 +1,35 @@
+/* This file is part of the Nepomuk-KDE libraries
+    Copyright (c) 2007 Sebastian Trueg <trueg@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+*/
+
+#ifndef _ENTITY_TEST_H_
+#define _ENTITY_TEST_H_
+
+#include <QtCore/QObject>
+
+class EntityTest : public QObject
+{
+    Q_OBJECT
+
+private Q_SLOTS:
+    void initTestCase();
+    void testClass();
+    void testProperty();
+};
+
+#endif

Modification de propriétés sur nepomuk/core/types/test/entitytest.h
___________________________________________________________________
Ajouté : svn:eol-style
   + native

Index: nepomuk/core/types/test/kontotest.cpp
===================================================================
--- nepomuk/core/types/test/kontotest.cpp	(révision 0)
+++ nepomuk/core/types/test/kontotest.cpp	(révision 0)
@@ -0,0 +1,180 @@
+/* This file is part of the Nepomuk-KDE libraries
+    Copyright (c) 2007 Sebastian Trueg <trueg@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+*/
+
+#include "kontotest.h"
+#include "../ontologyloader.h"
+#include "../ontologymanager.h"
+#include "../ontology.h"
+#include "../class.h"
+#include "../global.h"
+#include "../property.h"
+
+#include <Soprano/Statement>
+#include <Soprano/Vocabulary/RDF>
+#include <Soprano/Vocabulary/RDFS>
+#include <Soprano/Vocabulary/NRL>
+
+#include <QtTest/QTest>
+#include <QtCore/QCoreApplication>
+
+
+using namespace Nepomuk;
+using namespace Soprano;
+
+class DummyOntologyLoader : public OntologyLoader
+{
+public:
+    QList<Statement> loadOntology( const QUrl& uri )
+    {
+        // create some dummy onto stuff
+        QList<Statement> sl;
+
+        QString ns = uri.toString();
+        if ( !ns.endsWith( "#" ) ) {
+            ns += '#';
+        }
+
+        // one dummy class
+        sl.append( Statement( Node( QUrl( ns + "DummyClass" ) ),
+                              Node( Soprano::Vocabulary::RDF::type() ),
+                              Node( Soprano::Vocabulary::RDFS::Class() ) ) );
+        sl.append( Statement( Node( QUrl( ns + "DummyClass" ) ),
+                              Node( Soprano::Vocabulary::RDFS::label() ),
+                              Node( LiteralValue( "A dummy class" ) ) ) );
+
+        sl.append( Statement( Node( QUrl( ns + "DummySubClass" ) ),
+                              Node( Soprano::Vocabulary::RDF::type() ),
+                              Node( Soprano::Vocabulary::RDFS::Class() ) ) );
+        sl.append( Statement( Node( QUrl( ns + "DummySubClass" ) ),
+                              Node( Soprano::Vocabulary::RDFS::subClassOf() ),
+                              Node( QUrl( ns + "DummyClass" ) ) ) );
+
+        sl.append( Statement( Node( QUrl( ns + "DummySubSubClass" ) ),
+                              Node( Soprano::Vocabulary::RDF::type() ),
+                              Node( Soprano::Vocabulary::RDFS::Class() ) ) );
+        sl.append( Statement( Node( QUrl( ns + "DummySubSubClass" ) ),
+                              Node( Soprano::Vocabulary::RDFS::subClassOf() ),
+                              Node( QUrl( ns + "DummySubClass" ) ) ) );
+
+        // one dummy property
+        sl.append( Statement( Node( QUrl( ns + "hasBrother" ) ),
+                              Node( Soprano::Vocabulary::RDF::type() ),
+                              Node( Soprano::Vocabulary::RDF::Property() ) ) );
+        sl.append( Statement( Node( QUrl( ns + "hasBrother" ) ),
+                              Node( Soprano::Vocabulary::RDFS::domain() ),
+                              Node( QUrl( ns + "DummyClass" ) ) ) );
+        sl.append( Statement( Node( QUrl( ns + "hasBrother" ) ),
+                              Node( Soprano::Vocabulary::RDFS::range() ),
+                              Node( QUrl( ns + "DummyClass" ) ) ) );
+        sl.append( Statement( Node( QUrl( ns + "hasBrother" ) ),
+                              Node( Soprano::Vocabulary::NRL::inverseProperty() ),
+                              Node( QUrl( ns + "isBrotherOf" ) ) ) );
+
+        // and its reverse property
+        sl.append( Statement( Node( QUrl( ns + "isBrotherOf" ) ),
+                              Node( Soprano::Vocabulary::RDF::type() ),
+                              Node( Soprano::Vocabulary::RDF::Property() ) ));
+        sl.append( Statement( Node( QUrl( ns + "isBrotherOf" ) ),
+                              Node( Soprano::Vocabulary::RDFS::domain() ),
+                              Node( QUrl( ns + "DummyClass" ) ) ) );
+        sl.append( Statement( Node( QUrl( ns + "isBrotherOf" ) ),
+                              Node( Soprano::Vocabulary::RDFS::range() ),
+                              Node( QUrl( ns + "DummyClass" ) ) ) );
+        sl.append( Statement( Node( QUrl( ns + "isBrotherOf" ) ),
+                              Node( Soprano::Vocabulary::NRL::inverseProperty() ),
+                              Node( QUrl( ns + "hasBrother" ) ) ) );
+
+        return sl;
+    }
+};
+
+
+void KontoTest::initTestCase()
+{
+    OntologyManager::instance()->setOntologyLoader( new DummyOntologyLoader() );
+}
+
+
+void KontoTest::testOntology()
+{
+    const Ontology* onto = Ontology::load( QUrl( "test" ) );
+    QVERIFY( onto != 0 );
+    QCOMPARE( onto->uri(), QUrl( "test" ) );
+}
+
+
+void KontoTest::testClass()
+{
+    const Ontology* onto = Ontology::load( QUrl( "test" ) );
+
+    QCOMPARE( onto->allClasses().count(), 3 );
+    QVERIFY( onto->findClassByName( "DummyClass" ) != 0 );
+    QVERIFY( onto->findClassByUri( QUrl( "test#DummyClass" ) ) != 0 );
+
+    const Class* dummyClass = Class::load( QUrl( "test#DummyClass" ) );
+    QVERIFY( dummyClass != 0 );
+
+    QCOMPARE( dummyClass->name(), QString( "DummyClass" ) );
+    QCOMPARE( dummyClass->label(), QString( "A dummy class" ) );
+
+    const Class* dummySubClass = onto->findClassByName( "DummySubClass" );
+    const Class* dummySubSubClass = onto->findClassByName( "DummySubSubClass" );
+
+    QVERIFY( dummySubClass != 0 );
+    QVERIFY( dummySubSubClass != 0 );
+    QVERIFY( dummyClass->subClasses().contains( dummySubClass ) );
+    QVERIFY( dummySubClass->subClasses().contains( dummySubSubClass ) );
+    QVERIFY( dummySubClass->parentClasses().contains( dummyClass ) );
+    QVERIFY( dummySubSubClass->parentClasses().contains( dummySubClass ) );
+
+    QVERIFY( dummyClass->isParentOf( dummySubClass ) );
+    QVERIFY( dummyClass->isParentOf( dummySubSubClass ) );
+    QVERIFY( dummySubClass->isParentOf( dummySubSubClass ) );
+    QVERIFY( !dummySubClass->isParentOf( dummyClass ) );
+
+    QVERIFY( dummySubSubClass->isSubClassOf( dummyClass ) );
+    QVERIFY( dummySubSubClass->isSubClassOf( dummySubClass ) );
+    QVERIFY( dummySubClass->isSubClassOf( dummyClass ) );
+    QVERIFY( !dummySubClass->isSubClassOf( dummySubSubClass ) );
+}
+
+
+void KontoTest::testProperty()
+{
+    const Property* hasBrother = Property::load( QUrl( "test#hasBrother" ) );
+    const Property* isBrotherOf = Property::load( QUrl( "test#isBrotherOf" ) );
+
+    QVERIFY( hasBrother != 0 );
+    QVERIFY( isBrotherOf != 0 );
+
+    QCOMPARE( hasBrother->inverseProperty(), isBrotherOf );
+    QCOMPARE( isBrotherOf->inverseProperty(), hasBrother );
+
+    const Class* dummyClass = Class::load( QUrl( "test#DummyClass" ) );
+    QCOMPARE( hasBrother->range(), dummyClass );
+    QCOMPARE( hasBrother->domain(), dummyClass );
+
+    QCOMPARE( isBrotherOf->range(), dummyClass );
+    QCOMPARE( isBrotherOf->domain(), dummyClass );
+}
+
+
+QTEST_MAIN( KontoTest )
+
+#include "kontotest.moc"

Modification de propriétés sur nepomuk/core/types/test/kontotest.cpp
___________________________________________________________________
Ajouté : svn:eol-style
   + native

Index: nepomuk/core/types/test/desktopontologyloadertest.cpp
===================================================================
--- nepomuk/core/types/test/desktopontologyloadertest.cpp	(révision 0)
+++ nepomuk/core/types/test/desktopontologyloadertest.cpp	(révision 0)
@@ -0,0 +1,103 @@
+/* This file is part of the Nepomuk-KDE libraries
+    Copyright (c) 2007 Sebastian Trueg <trueg@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+*/
+
+#include "desktopontologyloadertest.h"
+#include "desktopontologyloader.h"
+
+#include <QtTest/QTest>
+#include <QtCore/QDir>
+#include <QtCore/QFile>
+#include <QtCore/QTextStream>
+#include <QtCore/QList>
+
+#include <kstandarddirs.h>
+#include <kconfiggroup.h>
+#include <kdesktopfile.h>
+#include <kurl.h>
+#include <kio/global.h>
+#include <kio/deletejob.h>
+#include <qtest_kde.h>
+
+#include <Soprano/Statement>
+
+
+void DesktopOntologyLoaderTest::initTestCase()
+{
+    // create our test folder
+    QDir tmpDir( "/tmp" );
+    tmpDir.mkpath( "konto_desktopontologyloader_test/knepomuk/ontologies" );
+    KGlobal::dirs()->addResourceDir( "data", "/tmp/konto_desktopontologyloader_test" );
+
+    // create our little test ontology
+    QFile ontoFile( "/tmp/konto_desktopontologyloader_test/knepomuk/ontologies/test.nrl" );
+    ontoFile.open( QIODevice::WriteOnly );
+    QTextStream ontoStream( &ontoFile );
+
+    // the header
+    ontoStream << "<?xml version='1.0' encoding='UTF-8'?>" << endl
+               << "<!DOCTYPE rdf:RDF [" << endl
+               << "<!ENTITY rdf 'http://www.w3.org/1999/02/22-rdf-syntax-ns#'>" << endl
+               << "<!ENTITY nrl 'http://semanticdesktop.org/ontologies/2006/11/24/nrl#'>" << endl
+               << "<!ENTITY nao 'http://semanticdesktop.org/ontologies/2007/03/31/nao#'>" << endl
+               << "<!ENTITY xsd 'http://www.w3.org/2001/XMLSchema#'>" << endl
+               << "<!ENTITY rdfs 'http://www.w3.org/2000/01/rdf-schema#'>" << endl
+               << "<!ENTITY test 'http://test.org/test#'>" << endl
+               << "]>" << endl
+               << "<rdf:RDF xmlns:rdf=\"&rdf;\" xmlns:rdfs=\"&rdfs;\" xmlns:nrl=\"&nrl;\" xmlns:nao=\"&nao;\" xmlns:xsd=\"&xsd;\">" << endl;
+
+    // one class
+    ontoStream << "<rdf:Description rdf:about=\"&test;Test\">" << endl
+               << "<rdfs:label>test</rdfs:label>" << endl
+               << "<rdf:type rdf:resource=\"&rdfs;Class\"/>" << endl
+               << "</rdf:Description>" << endl;
+
+    // the footer
+    ontoStream << "</rdf:RDF>" << endl;
+
+    KDesktopFile desktopFile( "/tmp/konto_desktopontologyloader_test/knepomuk/ontologies/test.desktop" );
+    KConfigGroup desktopGroup( desktopFile.desktopGroup() );
+    desktopGroup.writeEntry( "Type", "Link" );
+    desktopGroup.writeEntry( "Name", "Test Ontology" );
+    desktopGroup.writeEntry( "MimeType", "text/rdf" );
+    desktopGroup.writeEntry( "Path", "test.nrl" );
+    desktopGroup.writeEntry( "URL", "http://test.org/test" );
+}
+
+
+void DesktopOntologyLoaderTest::testLoading()
+{
+    Nepomuk::DesktopOntologyLoader loader;
+    QList<Soprano::Statement> sl = loader.loadOntology( QUrl( "http://test.org/test" ) );
+    QVERIFY( !sl.isEmpty() );
+    QCOMPARE( sl.count(), 2 );
+}
+
+
+void DesktopOntologyLoaderTest::cleanupTestCase()
+{
+    QFile::remove( "/tmp/konto_desktopontologyloader_test/knepomuk/ontologies/test.desktop" );
+    QFile::remove( "/tmp/konto_desktopontologyloader_test/knepomuk/ontologies/test.nrl" );
+    QDir( "/tmp/konto_desktopontologyloader_test/knepomuk/" ).rmdir( "ontologies" );
+    QDir( "/tmp/konto_desktopontologyloader_test" ).rmdir( "knepomuk" );
+    QDir( "/tmp/" ).rmdir( "konto_desktopontologyloader_test" );
+}
+
+QTEST_KDEMAIN( DesktopOntologyLoaderTest, NoGUI )
+
+#include "desktopontologyloadertest.moc"

Modification de propriétés sur nepomuk/core/types/test/desktopontologyloadertest.cpp
___________________________________________________________________
Ajouté : svn:eol-style
   + native

Index: nepomuk/core/types/test/CMakeLists.txt
===================================================================
--- nepomuk/core/types/test/CMakeLists.txt	(révision 0)
+++ nepomuk/core/types/test/CMakeLists.txt	(révision 0)
@@ -0,0 +1,16 @@
+project(konto_test)
+
+include_directories(
+  ${nepomukcore_SOURCE_DIR}/ontology
+)
+
+include_directories( ${KDE4_KIO_INCLUDES} ${CMAKE_SOURCE_DIR}/konto )
+include_directories( ${QT_INCLUDES} ${SOPRANO_INCLUDE_DIR} )
+set( EXECUTABLE_OUTPUT_PATH ${CMAKE_CURRENT_BINARY_DIR} )
+
+# tests
+# TODO: fix, and turn into kde4_add_unit_test again
+kde4_add_executable(entitytest entitytest.cpp)
+target_link_libraries(entitytest nepomuk ${QT_QTCORE_LIBRARY} ${QT_QTGUI_LIBRARY}
+                                         ${KDE4_KDECORE_LIBS} ${QT_QTTEST_LIBRARY}
+					 ${SOPRANO_LIBRARIES})

Modification de propriétés sur nepomuk/core/types/test/CMakeLists.txt
___________________________________________________________________
Ajouté : svn:eol-style
   + native

Index: nepomuk/core/types/test/entitytest.cpp
===================================================================
--- nepomuk/core/types/test/entitytest.cpp	(révision 0)
+++ nepomuk/core/types/test/entitytest.cpp	(révision 0)
@@ -0,0 +1,92 @@
+/* This file is part of the Nepomuk-KDE libraries
+    Copyright (c) 2007 Sebastian Trueg <trueg@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+*/
+
+#include "entitytest.h"
+#include "../class.h"
+#include "../property.h"
+
+#include <kdebug.h>
+#include <kstandarddirs.h>
+#include <qtest_kde.h>
+#include <QtDBus/QtDBus>
+#include <unistd.h>
+
+#include <Soprano/Vocabulary/RDFS>
+
+using namespace Nepomuk::Types;
+
+static QByteArray origKdeHome;
+
+// Getting the real KDEHOME has to be done before main() overwrites $KDEHOME
+int kInitSocket()
+{
+    origKdeHome = getenv("KDEHOME");
+    return 1;
+}
+Q_CONSTRUCTOR_FUNCTION(kInitSocket)
+
+// Make symlink from ~/.kde-unit-test/share/apps/nepomuk/socket to the real socket for the running server
+void EntityTest::initTestCase()
+{
+    QString realSocket = !origKdeHome.isEmpty() ? QFile::encodeName(origKdeHome) : QDir::homePath() + QLatin1String("/.kde");
+    realSocket += QLatin1String("/share/apps/nepomuk/socket");
+    //kDebug() << realSocket;
+    if (QFile::exists(realSocket)) {
+        const QString socketLink = KGlobal::dirs()->locateLocal( "data", "nepomuk/socket" );
+        //kDebug() << socketLink << realSocket;
+        if (!QFile::exists(socketLink)) {
+            ::symlink(QFile::encodeName(realSocket), QFile::encodeName(socketLink));
+        }
+    }
+}
+
+void EntityTest::testClass()
+{
+    if (!QDBusConnection::sessionBus().interface()->isServiceRegistered("org.kde.nepomuk.services.nepomukstorage")) {
+        QSKIP("nepomuk not running", SkipAll);
+    }
+
+    Class c1( Soprano::Vocabulary::RDFS::Resource() );
+    Class c2( Soprano::Vocabulary::RDFS::Resource() );
+
+    QVERIFY( c1.isValid() );
+    QVERIFY( c2.isValid() );
+
+    QVERIFY( c1.isAvailable() );
+    QVERIFY( c2.isAvailable() );
+
+    QCOMPARE( c1.uri(), c2.uri() );
+    QCOMPARE( c1.name(), c2.name() );
+    QCOMPARE( c1.label(), c2.label() );
+    QCOMPARE( c1.comment(), c2.comment() );
+
+    QVERIFY( !c1.label().isEmpty() );
+
+    qDebug() << c1.label() << c1.comment();
+}
+
+
+void EntityTest::testProperty()
+{
+}
+
+
+QTEST_KDEMAIN(EntityTest, NoGUI)
+
+#include "entitytest.moc"

Modification de propriétés sur nepomuk/core/types/test/entitytest.cpp
___________________________________________________________________
Ajouté : svn:eol-style
   + native

Index: nepomuk/core/types/desktopontologyloader.h
===================================================================
--- nepomuk/core/types/desktopontologyloader.h	(révision 0)
+++ nepomuk/core/types/desktopontologyloader.h	(révision 0)
@@ -0,0 +1,62 @@
+/* This file is part of the Nepomuk-KDE libraries
+    Copyright (c) 2007 Sebastian Trueg <trueg@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+*/
+
+#ifndef _NEPOMUK_DESKTOP_ONTOLOGY_LOADER_H_
+#define _NEPOMUK_DESKTOP_ONTOLOGY_LOADER_H_
+
+#include "ontologyloader.h"
+#include "nepomuk_export.h"
+
+#include <QtCore/QUrl>
+#include <QtCore/QList>
+
+namespace Nepomuk {
+    /**
+     * The DesktopOntologyLoader reads ontologies from the installed
+     * ontologies on the desktop using KStandardDirs.
+     * All possible ontology installation folders are searched for
+     * ontology desktop files.
+     *
+     * \deprecated Ontologies should now be handled using the classes
+     * in the Nepomuk::Types namespace.
+     */
+    class KDE_DEPRECATED NEPOMUK_EXPORT DesktopOntologyLoader : public OntologyLoader
+    {
+    public:
+	DesktopOntologyLoader();
+	~DesktopOntologyLoader();
+
+	/**
+	 * Get a list of all ontology URIs that could be found
+	 * on the system.
+	 */
+	QList<QUrl> allOntologies();
+
+	/**
+	 * reimplemented from OntologyLoader
+	 */
+	QList<Soprano::Statement> loadOntology( const QUrl& url );
+
+    private:
+	class Private;
+	Private* const d;
+    };
+}
+
+#endif

Modification de propriétés sur nepomuk/core/types/desktopontologyloader.h
___________________________________________________________________
Ajouté : svn:eol-style
   + native

Index: nepomuk/core/types/literal.h
===================================================================
--- nepomuk/core/types/literal.h	(révision 0)
+++ nepomuk/core/types/literal.h	(révision 0)
@@ -0,0 +1,125 @@
+/* This file is part of the Nepomuk-KDE libraries
+    Copyright (c) 2007 Sebastian Trueg <trueg@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+*/
+
+#ifndef _NEPOMUK_LITERAL_H_
+#define _NEPOMUK_LITERAL_H_
+
+#include <QtCore/QUrl>
+#include <QtCore/QVariant>
+#include <QtCore/QSharedData>
+
+#include "nepomuk_export.h"
+
+namespace Nepomuk {
+    namespace Types {
+        /**
+         * \class Literal literal.h Nepomuk/Types/Literal
+         *
+         * \brief Defines a literal type based on XML Schema.
+         *
+         * Each valid Literal represents the literal type
+         * as XML Schema URI and as QVariant type.
+         *
+         * \author Sebastian Trueg <trueg@kde.org>
+         */
+        class NEPOMUK_EXPORT Literal
+	{
+	public:
+	    /**
+	     * Default constructor.
+	     * Creates an empty Literal
+	     */
+	    Literal();
+	    Literal( const Literal& );
+	    Literal( const QUrl& dataTypeUri );
+	    ~Literal();
+
+	    Literal& operator=( const Literal& );
+
+	    /**
+	     * The XML Schema type URI.
+	     */
+	    QUrl dataTypeUri() const;
+
+	    /**
+	     * The type converted to a QVariant::Type.
+	     * \return The QVariant::Type that corresponds to the XML Schema type or
+	     * QVariant::Invalid if it could not be matched.
+	     */
+	    QVariant::Type dataType() const;
+
+            /**
+             * Is this a valid Literal, i.e. has it a valid URI.
+             */
+            bool isValid() const;
+
+	private:
+	    class Private;
+	    QExplicitlySharedDataPointer<Private> d;
+	};
+    }
+}
+
+
+#ifndef DISABLE_NEPOMUK_LEGACY
+
+namespace Nepomuk {
+    /**
+     * \brief Defines a literal type based on XML Schema.
+     *
+     * Each valid Literal represents the literal type
+     * as XML Schema URI and as QVariant type.
+     *
+     * \deprecated in favor of Nepomuk::Types::Literal
+     */
+    class KDE_DEPRECATED NEPOMUK_EXPORT Literal
+    {
+    public:
+        /**
+         * Default constructor.
+         * Creates an empty Literal
+         */
+        Literal();
+        Literal( const Literal& );
+        Literal( const QUrl& dataTypeUri );
+        ~Literal();
+
+        Literal& operator=( const Literal& );
+
+        /**
+         * The XML Schema type URI.
+         */
+        const QUrl& dataTypeUri() const;
+
+        /**
+         * The type converted to a QVariant::Type.
+         * \return The QVariant::Type that corresponds to the XML Schema type or
+         * QVariant::Invalid if it could not be matched.
+         */
+        QVariant::Type dataType() const;
+
+    private:
+        class Private;
+        QSharedDataPointer<Private> d;
+    };
+}
+
+#endif // DISABLE_NEPOMUK_LEGACY
+
+#endif

Modification de propriétés sur nepomuk/core/types/literal.h
___________________________________________________________________
Ajouté : svn:eol-style
   + native

Index: nepomuk/core/types/ontologyloader.cpp
===================================================================
--- nepomuk/core/types/ontologyloader.cpp	(révision 0)
+++ nepomuk/core/types/ontologyloader.cpp	(révision 0)
@@ -0,0 +1,35 @@
+/* This file is part of the Nepomuk-KDE libraries
+    Copyright (c) 2007 Sebastian Trueg <trueg@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+*/
+
+#include "ontologyloader.h"
+
+class Nepomuk::OntologyLoader::Private
+{
+};
+
+Nepomuk::OntologyLoader::OntologyLoader()
+    :d( new Private() )
+{
+}
+
+
+Nepomuk::OntologyLoader::~OntologyLoader()
+{
+    delete d;
+}

Modification de propriétés sur nepomuk/core/types/ontologyloader.cpp
___________________________________________________________________
Ajouté : svn:eol-style
   + native

Index: nepomuk/core/types/global.h
===================================================================
--- nepomuk/core/types/global.h	(révision 0)
+++ nepomuk/core/types/global.h	(révision 0)
@@ -0,0 +1,32 @@
+/* This file is part of the Nepomuk-KDE libraries
+    Copyright (c) 2007 Sebastian Trueg <trueg@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+*/
+
+#ifndef _NEPOMUK_GLOBAL_H_
+#define _NEPOMUK_GLOBAL_H_
+
+#include "nepomuk_export.h"
+
+#include <QtCore/QString>
+#include <QtCore/QUrl>
+
+namespace Nepomuk {
+    KDE_DEPRECATED NEPOMUK_EXPORT QUrl extractNamespace( const QUrl& url );
+}
+
+#endif

Modification de propriétés sur nepomuk/core/types/global.h
___________________________________________________________________
Ajouté : svn:eol-style
   + native

Index: nepomuk/core/types/class.cpp
===================================================================
--- nepomuk/core/types/class.cpp	(révision 0)
+++ nepomuk/core/types/class.cpp	(révision 0)
@@ -0,0 +1,658 @@
+/* This file is part of the Nepomuk-KDE libraries
+    Copyright (c) 2007 Sebastian Trueg <trueg@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+*/
+
+#include "class.h"
+#include "class_p.h"
+#include "ontology.h"
+#include "resourcemanager.h"
+#include "property.h"
+#include "entitymanager.h"
+
+#include <QtCore/QList>
+
+#include <kdebug.h>
+
+#include <Soprano/QueryResultIterator>
+#include <Soprano/Model>
+#include <Soprano/Vocabulary/NRL>
+#include <Soprano/Vocabulary/RDFS>
+#include <Soprano/Vocabulary/RDF>
+#include <Soprano/Vocabulary/OWL>
+
+#undef D
+#define D static_cast<Nepomuk::Types::ClassPrivate*>( d.data() )
+
+Nepomuk::Types::ClassPrivate::ClassPrivate( const QUrl& uri )
+    : EntityPrivate( uri ),
+      propertiesAvailable( uri.isValid() ? -1 : 0 )
+{
+}
+
+
+bool Nepomuk::Types::ClassPrivate::load()
+{
+    //
+    // Nearly all here can be done in a very clean way. There is only
+    // one special case: rdfs:Resource, the base class of them all
+    //
+    if ( EntityPrivate::load() ) {
+        // undefined super class means that we are derived from rdfs:Resource directly
+        if ( parents.isEmpty() ) {
+            if ( uri != Soprano::Vocabulary::RDFS::Resource() ) {
+                parents += Soprano::Vocabulary::RDFS::Resource();
+            }
+        }
+        return true;
+    }
+    else {
+        return false;
+    }
+}
+
+
+bool Nepomuk::Types::ClassPrivate::loadAncestors()
+{
+    //
+    // Nearly all here can be done in a very clean way. There is only
+    // one special case: rdfs:Resource, the base class of them all
+    //
+    if ( uri == Soprano::Vocabulary::RDFS::Resource() ) {
+        //
+        // All classes that do not explicetely state a superclass are
+        // derived from rdfs:Resource. This query selects those classes
+        // (might fail on redland though)
+        //
+        Soprano::QueryResultIterator it
+            = ResourceManager::instance()->mainModel()->executeQuery( QString("select distinct ?s where { "
+                                                                              "{ ?s a <%1> . } UNION { ?s a <%2> . } "
+                                                                              "OPTIONAL { graph ?g { ?s <%3> ?ss . } . "
+                                                                              "{ ?g a <%4> . } UNION { ?g a <%5> . } . } . "
+                                                                              "FILTER(!BOUND(?ss)) . }")
+                                                                      .arg( Soprano::Vocabulary::RDFS::Class().toString() )
+                                                                      .arg( Soprano::Vocabulary::OWL::Class().toString() )
+                                                                      .arg( Soprano::Vocabulary::RDFS::subClassOf().toString() )
+                                                                      .arg( Soprano::Vocabulary::NRL::Ontology().toString() )
+                                                                      .arg( Soprano::Vocabulary::NRL::KnowledgeBase().toString() ),
+                                                                      Soprano::Query::QueryLanguageSparql );
+        bool success = false;
+        while ( it.next() ) {
+            success = true;
+            QUrl resUri = it.binding( "s" ).uri();
+            if ( resUri != Soprano::Vocabulary::RDFS::Resource() ) {
+                children.append( resUri );
+            }
+        }
+    }
+
+    return EntityPrivate::loadAncestors();
+}
+
+
+bool Nepomuk::Types::ClassPrivate::addProperty( const QUrl& property, const Soprano::Node& value )
+{
+    if( property == Soprano::Vocabulary::RDFS::subClassOf() ) {
+        parents.append( Class( value.uri() ) );
+        return true;
+    }
+
+    return false;
+}
+
+
+bool Nepomuk::Types::ClassPrivate::addAncestorProperty( const QUrl& ancestorResource, const QUrl& property )
+{
+    if ( property == Soprano::Vocabulary::RDFS::subClassOf() ) {
+        children.append( Class( ancestorResource ) );
+        return true;
+    }
+
+    return false;
+}
+
+
+void Nepomuk::Types::ClassPrivate::initProperties()
+{
+    QMutexLocker lock( &mutex );
+
+    if ( propertiesAvailable < 0 ) {
+        propertiesAvailable = loadProperties() ? 1 : 0;
+    }
+}
+
+
+bool Nepomuk::Types::ClassPrivate::loadProperties()
+{
+    // load domains with a hack to get at least a subset of properties that inherit their domain from parents
+    Soprano::QueryResultIterator it
+        = ResourceManager::instance()->mainModel()->executeQuery( QString("select distinct ?p where { "
+                                                                          "{ ?p <%1> <%2> . } "
+                                                                          "UNION "
+                                                                          "{ ?p <%3> ?p1 . "
+                                                                          "OPTIONAL { ?p <%1> ?undefdom . } . "
+                                                                          "?p1 <%1> <%2> . "
+                                                                          "FILTER(!bound(?undefdom)) . } "
+                                                                          "UNION "
+                                                                          "{ ?p <%3> ?p1 . "
+                                                                          "OPTIONAL { ?p <%1> ?undefdom1 . } . "
+                                                                          "?p1 <%3> ?p2 . "
+                                                                          "OPTIONAL { ?p1 <%1> ?undefdom2 . } . "
+                                                                          "?p2 <%1> <%2> . "
+                                                                          "FILTER(!bound(?undefdom1) && !bound(?undefdom2)) . } "
+                                                                          "}")
+                                                                  .arg( Soprano::Vocabulary::RDFS::domain().toString() )
+                                                                  .arg( QString::fromAscii( uri.toEncoded() ) )
+                                                                  .arg( Soprano::Vocabulary::RDFS::subPropertyOf().toString() ),
+                                                                  Soprano::Query::QueryLanguageSparql );
+
+    // redland cannot handle UNION queries! So fallback to the "old" query
+    if( it.lastError() ) {
+        it = ResourceManager::instance()->mainModel()->executeQuery( QString("select ?p where { "
+                                                                             "?p <%1> <%2> . }")
+                                                                     .arg( Soprano::Vocabulary::RDFS::domain().toString() )
+                                                                     .arg( QString::fromAscii( uri.toEncoded() ) ),
+                                                                     Soprano::Query::QueryLanguageSparql );
+    }
+
+    bool success = false;
+    while ( it.next() ) {
+        success = true;
+        domainOf.append( Property( it.binding( "p" ).uri() ) );
+    }
+
+
+    // load ranges
+    it = ResourceManager::instance()->mainModel()->executeQuery( QString("select ?p where { "
+                                                                          "?p <%1> <%2> . }")
+                                                                  .arg( Soprano::Vocabulary::RDFS::range().toString() )
+                                                                 .arg( QString::fromAscii( uri.toEncoded() ) ),
+                                                                  Soprano::Query::QueryLanguageSparql );
+    while ( it.next() ) {
+        success = true;
+        rangeOf.append( Property( it.binding( "p" ).uri() ) );
+    }
+
+    return success;
+}
+
+
+void Nepomuk::Types::ClassPrivate::reset( bool recursive )
+{
+    EntityPrivate::reset( recursive );
+
+    QMutexLocker lock( &mutex );
+
+    if ( propertiesAvailable != -1 ) {
+        if ( recursive ) {
+            foreach( Property p, domainOf ) {
+                p.reset( true );
+            }
+            foreach( Property p, rangeOf ) {
+                p.reset( true );
+            }
+        }
+
+        domainOf.clear();
+        rangeOf.clear();
+        propertiesAvailable = -1;
+    }
+
+    if ( available != -1 ) {
+        if ( recursive ) {
+            foreach( Class c, parents ) {
+                c.reset( true );
+            }
+        }
+        parents.clear();
+        available = -1;
+    }
+
+    if ( ancestorsAvailable != -1 ) {
+        if ( recursive ) {
+            foreach( Class c, children ) {
+                c.reset( true );
+            }
+        }
+        children.clear();
+        ancestorsAvailable = -1;
+    }
+}
+
+
+QSet<Nepomuk::Types::Class> Nepomuk::Types::ClassPrivate::findParentClasses( ClassPrivate* requestingClass )
+{
+    QSet<Class> allParents;
+
+    for ( QList<Class>::iterator it = parents.begin(); it != parents.end(); ++it ) {
+        ClassPrivate* p = static_cast<Nepomuk::Types::ClassPrivate*>( it->d.data() );
+        if ( p != requestingClass ) {
+            p->init();
+            allParents += p->findParentClasses( requestingClass );
+            allParents += *it;
+        }
+    }
+
+    return allParents;
+}
+
+
+QSet<Nepomuk::Types::Class> Nepomuk::Types::ClassPrivate::findSubClasses( ClassPrivate* requestingClass )
+{
+    QSet<Class> allChildren;
+
+    for ( QList<Class>::iterator it = children.begin(); it != children.end(); ++it ) {
+        ClassPrivate* p = static_cast<Nepomuk::Types::ClassPrivate*>( it->d.data() );
+        if ( p != requestingClass ) {
+            p->initAncestors();
+            allChildren += p->findSubClasses( requestingClass );
+            allChildren += *it;
+        }
+    }
+
+    return allChildren;
+}
+
+
+
+Nepomuk::Types::Class::Class()
+    : Entity()
+{
+    d = 0;
+}
+
+
+Nepomuk::Types::Class::Class( const QUrl& uri )
+    : Entity()
+{
+    d = EntityManager::self()->getClass( uri );
+}
+
+
+Nepomuk::Types::Class::Class( const Class& other )
+    : Entity( other )
+{
+}
+
+
+Nepomuk::Types::Class::~Class()
+{
+}
+
+
+Nepomuk::Types::Class& Nepomuk::Types::Class::operator=( const Class& other )
+{
+    d = other.d;
+    return *this;
+}
+
+
+QList<Nepomuk::Types::Property> Nepomuk::Types::Class::rangeOf()
+{
+    if ( d ) {
+        D->initProperties();
+        return D->rangeOf;
+    }
+    else {
+        return QList<Nepomuk::Types::Property>();
+    }
+}
+
+
+QList<Nepomuk::Types::Property> Nepomuk::Types::Class::rangeOf() const
+{
+    return const_cast<Class*>(this)->rangeOf();
+}
+
+
+QList<Nepomuk::Types::Property> Nepomuk::Types::Class::domainOf()
+{
+    if ( d ) {
+        D->initProperties();
+        return D->domainOf;
+    }
+    else {
+        return QList<Nepomuk::Types::Property>();
+    }
+}
+
+
+QList<Nepomuk::Types::Property> Nepomuk::Types::Class::domainOf() const
+{
+    return const_cast<Class*>(this)->domainOf();
+}
+
+
+Nepomuk::Types::Property Nepomuk::Types::Class::findPropertyByName( const QString& name )
+{
+    if ( d ) {
+        D->initProperties();
+        for ( QList<Property>::const_iterator it = D->domainOf.constBegin();
+              it != D->domainOf.constEnd(); ++it ) {
+            const Property& p = *it;
+            if ( p.name() == name ) {
+                return p;
+            }
+        }
+    }
+
+    return Property();
+}
+
+
+Nepomuk::Types::Property Nepomuk::Types::Class::findPropertyByName( const QString& name ) const
+{
+    return const_cast<Class*>(this)->findPropertyByName(name);
+}
+
+
+Nepomuk::Types::Property Nepomuk::Types::Class::findPropertyByLabel( const QString& label, const QString& language )
+{
+    if ( d ) {
+        D->initProperties();
+        for ( QList<Property>::iterator it = D->domainOf.begin();
+              it != D->domainOf.end(); ++it ) {
+            Property& p = *it;
+            if ( p.label( language ) == label ) {
+                return p;
+            }
+        }
+    }
+
+    return Property();
+}
+
+
+Nepomuk::Types::Property Nepomuk::Types::Class::findPropertyByLabel( const QString& label, const QString& language ) const
+{
+    return const_cast<Class*>(this)->findPropertyByLabel( label, language );
+}
+
+
+QList<Nepomuk::Types::Class> Nepomuk::Types::Class::parentClasses()
+{
+    if ( d ) {
+        D->init();
+        return D->parents;
+    }
+    else {
+        return QList<Nepomuk::Types::Class>();
+    }
+}
+
+
+QList<Nepomuk::Types::Class> Nepomuk::Types::Class::parentClasses() const
+{
+    return const_cast<Class*>(this)->parentClasses();
+}
+
+
+QList<Nepomuk::Types::Class> Nepomuk::Types::Class::subClasses()
+{
+    if ( d ) {
+        D->initAncestors();
+        return D->children;
+    }
+    else {
+        return QList<Nepomuk::Types::Class>();
+    }
+}
+
+
+QList<Nepomuk::Types::Class> Nepomuk::Types::Class::subClasses() const
+{
+    return const_cast<Class*>(this)->subClasses();
+}
+
+
+QList<Nepomuk::Types::Class> Nepomuk::Types::Class::allParentClasses()
+{
+    if ( d ) {
+        D->init();
+        return D->findParentClasses( D ).toList();
+    }
+    else {
+        return QList<Nepomuk::Types::Class>();
+    }
+}
+
+
+QList<Nepomuk::Types::Class> Nepomuk::Types::Class::allParentClasses() const
+{
+    return const_cast<Class*>(this)->allParentClasses();
+}
+
+
+QList<Nepomuk::Types::Class> Nepomuk::Types::Class::allSubClasses()
+{
+    if ( d ) {
+        D->initAncestors();
+        return D->findSubClasses( D ).toList();
+    }
+    else {
+        return QList<Nepomuk::Types::Class>();
+    }
+}
+
+
+QList<Nepomuk::Types::Class> Nepomuk::Types::Class::allSubClasses() const
+{
+    return const_cast<Class*>(this)->allSubClasses();
+}
+
+
+bool Nepomuk::Types::Class::isParentOf( const Class& other )
+{
+    if ( d ) {
+        D->initAncestors();
+
+        if ( D->children.contains( other ) ) {
+            return true;
+        }
+        else {
+            for ( QList<Nepomuk::Types::Class>::iterator it = D->children.begin();
+                  it != D->children.end(); ++it ) {
+                if ( ( *it ).isParentOf( other ) ) {
+                    return true;
+                }
+            }
+        }
+    }
+
+    return false;
+}
+
+
+bool Nepomuk::Types::Class::isParentOf( const Class& other ) const
+{
+    return const_cast<Class*>(this)->isParentOf( other );
+}
+
+
+bool Nepomuk::Types::Class::isSubClassOf( const Class& other )
+{
+    if ( d ) {
+        D->init();
+
+        if ( D->parents.contains( other ) ) {
+            return true;
+        }
+        else {
+            for ( QList<Nepomuk::Types::Class>::iterator it = D->parents.begin();
+                  it != D->parents.end(); ++it ) {
+                if ( ( *it ).isSubClassOf( other ) ) {
+                    return true;
+                }
+            }
+        }
+    }
+
+    return false;
+}
+
+
+bool Nepomuk::Types::Class::isSubClassOf( const Class& other ) const
+{
+    return const_cast<Class*>(this)->isSubClassOf( other );
+}
+
+
+
+
+
+// Start of code for deprecated Class
+// ----------------------------------
+
+#include "global.h"
+#include "ontologymanager.h"
+
+Nepomuk::Class::Class()
+    : Entity()
+{
+    d = new Private();
+}
+
+
+Nepomuk::Class::Class( const Class& other )
+    : Entity( other )
+{
+    d = other.d;
+}
+
+
+Nepomuk::Class::~Class()
+{
+}
+
+
+Nepomuk::Class& Nepomuk::Class::operator=( const Class& other )
+{
+    d = other.d;
+    return *this;
+}
+
+
+QList<const Nepomuk::Property*> Nepomuk::Class::allProperties() const
+{
+    return d->domainOf.values();
+}
+
+
+const Nepomuk::Property* Nepomuk::Class::findPropertyByName( const QString& name ) const
+{
+    for ( QHash<QUrl, const Property*>::const_iterator it = d->domainOf.constBegin();
+          it != d->domainOf.constEnd(); ++it ) {
+        const Property* p = it.value();
+        if ( p->name() == name ) {
+            return p;
+        }
+    }
+
+    return 0;
+}
+
+
+const Nepomuk::Property* Nepomuk::Class::findPropertyByLabel( const QString& label, const QString& language ) const
+{
+    for ( QHash<QUrl, const Property*>::const_iterator it = d->domainOf.constBegin();
+          it != d->domainOf.constEnd(); ++it ) {
+        const Property* p = it.value();
+        if ( p->label( language ) == label ) {
+            return p;
+        }
+    }
+
+    return 0;
+}
+
+
+const Nepomuk::Property* Nepomuk::Class::findPropertyByUri( const QUrl& uri ) const
+{
+    QHash<QUrl, const Property*>::const_iterator it = d->domainOf.find( uri );
+    if ( it != d->domainOf.constEnd() ) {
+        return it.value();
+    }
+    else {
+        return 0;
+    }
+}
+
+
+QList<const Nepomuk::Class*> Nepomuk::Class::parentClasses() const
+{
+    return d->parents;
+}
+
+
+QList<const Nepomuk::Class*> Nepomuk::Class::subClasses() const
+{
+    return d->children;
+}
+
+
+bool Nepomuk::Class::isParentOf( const Class* other ) const
+{
+    if ( d->children.contains( other ) ) {
+        return true;
+    }
+    else {
+        for ( QList<const Nepomuk::Class*>::const_iterator it = d->children.constBegin();
+              it != d->children.constEnd(); ++it ) {
+            if ( ( *it )->isParentOf( other ) ) {
+                return true;
+            }
+        }
+        return false;
+    }
+}
+
+
+bool Nepomuk::Class::isSubClassOf( const Class* other ) const
+{
+    if ( d->parents.contains( other ) ) {
+        return true;
+    }
+    else {
+        for ( QList<const Nepomuk::Class*>::const_iterator it = d->parents.constBegin();
+              it != d->parents.constEnd(); ++it ) {
+            if ( ( *it )->isSubClassOf( other ) ) {
+                return true;
+            }
+        }
+        return false;
+    }
+}
+
+
+const Nepomuk::Class* Nepomuk::Class::load( const QUrl& uri )
+{
+    Q_ASSERT( !uri.isEmpty() );
+
+    QUrl ns = extractNamespace( uri );
+
+    // load the ontology in the cache
+    const Ontology* ont = OntologyManager::instance()->getOntology( ns );
+
+    // return the requested class or an invalid one if the ontology
+    // was not found
+    if ( ont ) {
+        return ont->findClassByUri( uri );
+    }
+    else {
+        return 0;
+    }
+}

Modification de propriétés sur nepomuk/core/types/class.cpp
___________________________________________________________________
Ajouté : svn:eol-style
   + native

Index: nepomuk/core/types/nepomukontologyloader.h
===================================================================
--- nepomuk/core/types/nepomukontologyloader.h	(révision 0)
+++ nepomuk/core/types/nepomukontologyloader.h	(révision 0)
@@ -0,0 +1,45 @@
+/* This file is part of the Nepomuk-KDE libraries
+    Copyright (c) 2007 Sebastian Trueg <trueg@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+*/
+
+#ifndef _NEPOMUK_NEPOMUK_ONTOLOGY_LOADER_H_
+#define _NEPOMUK_NEPOMUK_ONTOLOGY_LOADER_H_
+
+#include "ontologyloader.h"
+#include "nepomuk_export.h"
+
+namespace Nepomuk {
+    /**
+     * \deprecated Ontologies should now be handled using the classes
+     * in the Nepomuk::Types namespace.
+     */
+    class KDE_DEPRECATED NEPOMUK_EXPORT NepomukOntologyLoader : public OntologyLoader
+    {
+    public:
+	NepomukOntologyLoader();
+	~NepomukOntologyLoader();
+
+	QList<Soprano::Statement> loadOntology( const QUrl& url );
+
+    private:
+	class Private;
+	Private* const d;
+    };
+}
+
+#endif

Modification de propriétés sur nepomuk/core/types/nepomukontologyloader.h
___________________________________________________________________
Ajouté : svn:eol-style
   + native

Index: nepomuk/core/types/fileontologyloader.h
===================================================================
--- nepomuk/core/types/fileontologyloader.h	(révision 0)
+++ nepomuk/core/types/fileontologyloader.h	(révision 0)
@@ -0,0 +1,89 @@
+/* This file is part of the Nepomuk-KDE libraries
+    Copyright (c) 2007 Sebastian Trueg <trueg@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+*/
+
+#ifndef _NEPOMUK_FILE_ONTOLOGY_LOADER_H_
+#define _NEPOMUK_FILE_ONTOLOGY_LOADER_H_
+
+#include "ontologyloader.h"
+#include "nepomuk_export.h"
+
+#include <soprano/parser.h>
+#include <soprano/sopranotypes.h>
+
+
+namespace Nepomuk {
+    /**
+     * \deprecated Ontologies should now be handled using the classes
+     * in the Nepomuk::Types namespace.
+     */
+    class KDE_DEPRECATED NEPOMUK_EXPORT FileOntologyLoader : public OntologyLoader
+    {
+    public:
+	/**
+	 * Default constructor.
+	 * Creates a FileOntologyLoader that will try to load the 
+	 * ontology directly from its URL, i.e. the internet.
+	 */
+	FileOntologyLoader();
+
+	/**
+	 * Creates a FileOntologyLoader that will load the 
+	 * ontology from the specified filename.
+	 */
+	explicit FileOntologyLoader( const QString& filename,
+                                     Soprano::RdfSerialization serialization = Soprano::SerializationUnknown );
+
+	/**
+	 * Destructor
+	 */
+	~FileOntologyLoader();
+
+	/**
+	 * Set the filename to be used for reading the ontologies.
+	 * If no filename has been set FileOntologyLoader will try
+	 * load the ontology file from the internet, i.e. directly
+	 * use the ontology URL - NOT IMPLEMENTED YET.
+	 */
+	void setFileName( const QString& filename );
+
+	/**
+	 * The filename that has been set.
+	 * \sa setFileName
+	 * \return The filename set (can be empty)
+	 */
+	QString fileName() const;
+	
+	/**
+	 * Set the serialization that is used in the file.
+	 * Defaults to Soprano::SerializationUnknown
+	 */
+	void setSerialization( Soprano::RdfSerialization );
+
+	/**
+	 * reimplemented from OntologyLoader
+	 */
+	QList<Soprano::Statement> loadOntology( const QUrl& url );
+
+    private:
+	class Private;
+	Private* const d;
+    };
+}
+
+#endif

Modification de propriétés sur nepomuk/core/types/fileontologyloader.h
___________________________________________________________________
Ajouté : svn:eol-style
   + native

Index: nepomuk/core/types/ontology.cpp
===================================================================
--- nepomuk/core/types/ontology.cpp	(révision 0)
+++ nepomuk/core/types/ontology.cpp	(révision 0)
@@ -0,0 +1,361 @@
+/* This file is part of the Nepomuk-KDE libraries
+    Copyright (c) 2007 Sebastian Trueg <trueg@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+*/
+
+#include "ontology.h"
+#include "ontology_p.h"
+#include "class.h"
+#include "property.h"
+#include "entitymanager.h"
+#include "resourcemanager.h"
+
+#include <Soprano/QueryResultIterator>
+#include <Soprano/Model>
+#include <Soprano/Vocabulary/NAO>
+#include <Soprano/Vocabulary/RDFS>
+#include <Soprano/Vocabulary/RDF>
+#include <Soprano/Vocabulary/XMLSchema>
+
+#undef D
+#define D static_cast<Nepomuk::Types::OntologyPrivate*>( d.data() )
+
+Nepomuk::Types::OntologyPrivate::OntologyPrivate( const QUrl& uri )
+    : EntityPrivate( uri ),
+      entitiesAvailable( uri.isValid() ? -1 : 0 )
+{
+}
+
+
+void Nepomuk::Types::OntologyPrivate::initEntities()
+{
+    if ( entitiesAvailable < 0 ) {
+        entitiesAvailable = loadEntities() ? 1 : 0;
+    }
+}
+
+
+bool Nepomuk::Types::OntologyPrivate::loadEntities()
+{
+    // load classes
+    // We use a FILTER(STR(?ns)...) to support both Soprano 2.3 (with plain literals) and earlier (with only typed ones)
+    Soprano::QueryResultIterator it
+        = ResourceManager::instance()->mainModel()->executeQuery( QString("select ?c where { "
+                                                                          "graph ?g { ?c a <%1> . } . "
+                                                                          "?g <%2> ?ns . "
+                                                                          "FILTER(STR(?ns) = \"%3\") . }" )
+                                                                  .arg( Soprano::Vocabulary::RDFS::Class().toString() )
+                                                                  .arg( Soprano::Vocabulary::NAO::hasDefaultNamespace().toString() )
+                                                                  .arg( QString::fromAscii( uri.toEncoded() ) ),
+                                                                  Soprano::Query::QueryLanguageSparql );
+    bool success = false;
+    while ( it.next() ) {
+        success = true;
+        classes.append( Class( it.binding( "c" ).uri() ) );
+    }
+
+
+    // load properties
+    it = ResourceManager::instance()->mainModel()->executeQuery( QString("select ?p where { "
+                                                                         "graph ?g { ?p a <%1> . } . "
+                                                                         "?g <%2> ?ns . "
+                                                                         "FILTER(STR(?ns) = \"%3\") . }" )
+                                                                 .arg( Soprano::Vocabulary::RDF::Property().toString() )
+                                                                 .arg( Soprano::Vocabulary::NAO::hasDefaultNamespace().toString() )
+                                                                 .arg( QString::fromAscii( uri.toEncoded() ) ),
+                                                                 Soprano::Query::QueryLanguageSparql );
+    while ( it.next() ) {
+        success = true;
+        properties.append( Property( it.binding( "p" ).uri() ) );
+    }
+
+    return success;
+}
+
+
+bool Nepomuk::Types::OntologyPrivate::addProperty( const QUrl&, const Soprano::Node& )
+{
+    return false;
+}
+
+
+bool Nepomuk::Types::OntologyPrivate::addAncestorProperty( const QUrl&, const QUrl& )
+{
+    return false;
+}
+
+
+void Nepomuk::Types::OntologyPrivate::reset( bool recursive )
+{
+    EntityPrivate::reset( recursive );
+
+    if ( entitiesAvailable != -1 ) {
+        if ( recursive ) {
+            foreach( Class c, classes ) {
+                c.reset( true );
+            }
+            foreach( Property p, properties ) {
+                p.reset( true );
+            }
+        }
+        classes.clear();
+        properties.clear();
+
+        entitiesAvailable = -1;
+    }
+}
+
+
+
+Nepomuk::Types::Ontology::Ontology()
+{
+    d = new OntologyPrivate();
+}
+
+
+Nepomuk::Types::Ontology::Ontology( const QUrl& uri )
+{
+    d = EntityManager::self()->getOntology( uri );
+}
+
+
+Nepomuk::Types::Ontology::Ontology( const Ontology& other )
+    : Entity( other )
+{
+}
+
+
+Nepomuk::Types::Ontology::~Ontology()
+{
+}
+
+
+Nepomuk::Types::Ontology& Nepomuk::Types::Ontology::operator=( const Ontology& other )
+{
+    d = other.d;
+    return *this;
+}
+
+
+QList<Nepomuk::Types::Class> Nepomuk::Types::Ontology::allClasses()
+{
+    D->initEntities();
+    return D->classes;
+}
+
+
+Nepomuk::Types::Class Nepomuk::Types::Ontology::findClassByName( const QString& name )
+{
+    D->initEntities();
+    for ( QList<Class>::const_iterator it = D->classes.constBegin();
+          it != D->classes.constEnd(); ++it ) {
+        const Class& c = *it;
+        if ( c.name() == name ) {
+            return c;
+        }
+    }
+
+    return Class();
+}
+
+
+Nepomuk::Types::Class Nepomuk::Types::Ontology::findClassByLabel( const QString& label, const QString& language )
+{
+    D->initEntities();
+    for ( QList<Class>::iterator it = D->classes.begin();
+          it != D->classes.end(); ++it ) {
+        Class& c = *it;
+        if ( c.label( language ) == label ) {
+            return c;
+        }
+    }
+
+    return Class();
+}
+
+
+QList<Nepomuk::Types::Property> Nepomuk::Types::Ontology::allProperties()
+{
+    D->initEntities();
+    return D->properties;
+}
+
+
+Nepomuk::Types::Property Nepomuk::Types::Ontology::findPropertyByName( const QString& name )
+{
+    D->initEntities();
+    for ( QList<Property>::const_iterator it = D->properties.constBegin();
+          it != D->properties.constEnd(); ++it ) {
+        const Property& p = *it;
+        if ( p.name() == name ) {
+            return p;
+        }
+    }
+
+    return Property();
+}
+
+
+Nepomuk::Types::Property Nepomuk::Types::Ontology::findPropertyByLabel( const QString& label, const QString& language )
+{
+    D->initEntities();
+    for ( QList<Property>::iterator it = D->properties.begin();
+          it != D->properties.end(); ++it ) {
+        Property& p = *it;
+        if ( p.label( language ) == label ) {
+            return p;
+        }
+    }
+
+    return Property();
+}
+
+
+
+// Start of code for deprecated Ontology
+// -------------------------------------
+#include "global.h"
+#include "ontologymanager.h"
+
+
+Nepomuk::Ontology::Ontology()
+{
+    d = new Private;
+}
+
+
+Nepomuk::Ontology::Ontology( const Ontology& other )
+{
+    d = other.d;
+}
+
+
+Nepomuk::Ontology::~Ontology()
+{
+}
+
+
+Nepomuk::Ontology& Nepomuk::Ontology::operator=( const Ontology& other)
+{
+    d = other.d;
+    return *this;
+}
+
+
+QUrl Nepomuk::Ontology::uri() const
+{
+    return d->uri;
+}
+
+
+QList<const Nepomuk::Class*> Nepomuk::Ontology::allClasses() const
+{
+    return d->classes.values();
+}
+
+
+const Nepomuk::Class* Nepomuk::Ontology::findClassByName( const QString& name ) const
+{
+    for ( QHash<QUrl, const Class*>::const_iterator it = d->classes.constBegin();
+          it != d->classes.constEnd(); ++it ) {
+        const Class* c = it.value();
+        if ( c->name() == name ) {
+            return c;
+        }
+    }
+
+    return 0;
+}
+
+
+const Nepomuk::Class* Nepomuk::Ontology::findClassByLabel( const QString& label, const QString& language ) const
+{
+    for ( QHash<QUrl, const Class*>::const_iterator it = d->classes.constBegin();
+          it != d->classes.constEnd(); ++it ) {
+        const Class* c = it.value();
+        if ( c->label( language ) == label ) {
+            return c;
+        }
+    }
+
+    return 0;
+}
+
+
+const Nepomuk::Class* Nepomuk::Ontology::findClassByUri( const QUrl& uri ) const
+{
+    QHash<QUrl, const Class*>::const_iterator it = d->classes.find( uri );
+    if ( it != d->classes.constEnd() ) {
+        return it.value();
+    }
+    else {
+        return 0;
+    }
+}
+
+
+QList<const Nepomuk::Property*> Nepomuk::Ontology::allProperties() const
+{
+    return d->properties.values();
+}
+
+
+const Nepomuk::Property* Nepomuk::Ontology::findPropertyByName( const QString& name ) const
+{
+    for ( QHash<QUrl, const Property*>::const_iterator it = d->properties.constBegin();
+          it != d->properties.constEnd(); ++it ) {
+        const Property* p = it.value();
+        if ( p->name() == name ) {
+            return p;
+        }
+    }
+
+    return 0;
+}
+
+
+const Nepomuk::Property* Nepomuk::Ontology::findPropertyByLabel( const QString& label, const QString& language ) const
+{
+    for ( QHash<QUrl, const Property*>::const_iterator it = d->properties.constBegin();
+          it != d->properties.constEnd(); ++it ) {
+        const Property* p = it.value();
+        if ( p->label( language ) == label ) {
+            return p;
+        }
+    }
+
+    return 0;
+}
+
+
+const Nepomuk::Property* Nepomuk::Ontology::findPropertyByUri( const QUrl& uri ) const
+{
+    QHash<QUrl, const Property*>::const_iterator it = d->properties.find( uri );
+    if ( it != d->properties.constEnd() ) {
+        return it.value();
+    }
+    else {
+        return 0;
+    }
+}
+
+
+const Nepomuk::Ontology* Nepomuk::Ontology::load( const QUrl& uri )
+{
+    // load the ontology in the cache
+    return OntologyManager::instance()->getOntology( uri );
+}

Modification de propriétés sur nepomuk/core/types/ontology.cpp
___________________________________________________________________
Ajouté : svn:eol-style
   + native

Index: nepomuk/core/types/ontologymanager.h
===================================================================
--- nepomuk/core/types/ontologymanager.h	(révision 0)
+++ nepomuk/core/types/ontologymanager.h	(révision 0)
@@ -0,0 +1,99 @@
+/* This file is part of the Nepomuk-KDE libraries
+    Copyright (c) 2007 Sebastian Trueg <trueg@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+*/
+
+#ifndef _NEPOMUK_ONTOLOGY_MANAGER_H_
+#define _NEPOMUK_ONTOLOGY_MANAGER_H_
+
+#include <QtCore/QUrl>
+
+#include "nepomuk_export.h"
+
+namespace Soprano {
+    class Statement;
+}
+
+namespace Nepomuk {
+
+    class OntologyLoader;
+    class Ontology;
+
+    /**
+     * The OntologyManager is the central ontology cache handler.
+     * It is modeled as a singleton and its instance can be accessed
+     * through OntologyManager::instance.
+     *
+     * \deprecated Ontologies should be handled via the classes in
+     * Nepomuk::Types.
+     */
+    class KDE_DEPRECATED NEPOMUK_EXPORT OntologyManager
+    {
+    public:
+	~OntologyManager();
+
+	static OntologyManager* instance();
+
+	/**
+	 * Set an OntologyLoader to be used to retrieve 
+	 * the RDF statements that make up an ontology.
+	 *
+	 * By default Nepomuk uses a combination of the
+	 * NepomukOntologyLoader and DesktopOntologyLoader
+	 * where the NepomukOntologyLoader is the preferred
+	 * one, i.e. only if it is not able to load the
+	 * ontology DesktopOntologyLoader is used as a fallback.
+	 *
+	 * If an OntologyLoader is set no fallback loader will
+	 * be used. Thus, to force one of the default loaders
+	 * (for example the DesktopOntologyLoader) just do:
+	 *
+	 * \code
+	 * OntologyManager::instance()->setOntologyLoader( new DesktopOntologyLoader() );
+	 * \endcode
+	 *
+	 * OntologyManager will take over ownership of loader.
+	 *
+	 * Overwriting the loader will delete any loader previously
+	 * set via setOntologyLoader.
+	 */
+	void setOntologyLoader( OntologyLoader* loader );
+
+	/**
+	 * Attempt to load the ontology referenced by uri.
+	 * If the manager already has the ontology in the cache
+	 * it is simply returned. Otherwise the manager tries 
+	 * to load the ontology from one of the configured
+	 * OntologyLoader instances.
+	 *
+	 * \return The requested ontology or 0 in case it could
+	 * not be found, i.e. none of the OntologyLoader instances
+	 * could provide the RDF statements making up the ontology.
+	 */
+	const Ontology* getOntology( const QUrl& uri );
+
+    private:
+	OntologyManager();
+
+	Ontology* constructOntology( const QUrl& uri, const QList<Soprano::Statement>& sl );
+
+	class Private;
+	Private* const d;
+    };
+}
+
+#endif

Modification de propriétés sur nepomuk/core/types/ontologymanager.h
___________________________________________________________________
Ajouté : svn:eol-style
   + native

Index: nepomuk/core/types/entitymanager.h
===================================================================
--- nepomuk/core/types/entitymanager.h	(révision 0)
+++ nepomuk/core/types/entitymanager.h	(révision 0)
@@ -0,0 +1,69 @@
+/* This file is part of the Nepomuk-KDE libraries
+   Copyright (c) 2007 Sebastian Trueg <trueg@kde.org>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public License
+   along with this library; see the file COPYING.LIB.  If not, write to
+   the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.
+*/
+
+#ifndef _NEPOMUK_ENTITY_MANAGER_H_
+#define _NEPOMUK_ENTITY_MANAGER_H_
+
+#include <QtCore/QHash>
+#include <QtCore/QUrl>
+#include <QtCore/QSharedData>
+#include <QtCore/QMutex>
+
+
+namespace Soprano {
+    class Statement;
+}
+
+namespace Nepomuk {
+    namespace Types {
+        class EntityPrivate;
+        class ClassPrivate;
+        class PropertyPrivate;
+        class OntologyPrivate;
+
+        /**
+         * Cache for all loaded entities.
+         */
+        class EntityManager
+        {
+        public:
+            EntityManager();
+
+            ClassPrivate* getClass( const QUrl& uri );
+            PropertyPrivate* getProperty( const QUrl& uri );
+            OntologyPrivate* getOntology( const QUrl& uri );
+
+            static EntityManager* self();
+
+        private:
+            EntityPrivate* findEntity( const QUrl& uri ) const;
+            ClassPrivate* findClass( const QUrl& uri ) const;
+            PropertyPrivate* findProperty( const QUrl& uri ) const;
+            OntologyPrivate* findOntology( const QUrl& uri ) const;
+
+            QHash<QUrl, QExplicitlySharedDataPointer<ClassPrivate> > m_classMap;
+            QHash<QUrl, QExplicitlySharedDataPointer<PropertyPrivate> > m_propertyMap;
+            QHash<QUrl, QExplicitlySharedDataPointer<OntologyPrivate> > m_ontologyMap;
+
+            QMutex m_mutex;
+        };
+    }
+}
+
+#endif

Modification de propriétés sur nepomuk/core/types/entitymanager.h
___________________________________________________________________
Ajouté : svn:eol-style
   + native

Index: nepomuk/core/types/entity.cpp
===================================================================
--- nepomuk/core/types/entity.cpp	(révision 0)
+++ nepomuk/core/types/entity.cpp	(révision 0)
@@ -0,0 +1,387 @@
+/* This file is part of the Nepomuk-KDE libraries
+    Copyright (c) 2007-2009 Sebastian Trueg <trueg@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+*/
+
+#include "entity.h"
+#include "entity_p.h"
+#include "resourcemanager.h"
+
+#include <QtCore/QHash>
+#include <QtCore/QMutexLocker>
+
+#include <Soprano/QueryResultIterator>
+#include <Soprano/Model>
+#include <Soprano/Vocabulary/NRL>
+#include <Soprano/Vocabulary/NAO>
+#include <Soprano/Vocabulary/RDFS>
+
+#include <kicon.h>
+
+
+Nepomuk::Types::EntityPrivate::EntityPrivate( const QUrl& uri_ )
+    : uri( uri_ ),
+      available( uri_.isValid() ? -1 : 0 ),
+      ancestorsAvailable( uri_.isValid() ? -1 : 0 )
+{
+}
+
+
+void Nepomuk::Types::EntityPrivate::init()
+{
+    QMutexLocker lock( &mutex );
+
+    if ( available < 0 ) {
+        available = load() ? 1 : 0;
+    }
+}
+
+
+void Nepomuk::Types::EntityPrivate::initAncestors()
+{
+    QMutexLocker lock( &mutex );
+
+    if ( ancestorsAvailable < 0 ) {
+        ancestorsAvailable = loadAncestors() ? 1 : 0;
+    }
+}
+
+
+bool Nepomuk::Types::EntityPrivate::load()
+{
+    Soprano::QueryResultIterator it
+        = ResourceManager::instance()->mainModel()->executeQuery( QString("select ?p ?o where { "
+                                                                          "graph ?g { <%1> ?p ?o . } . "
+                                                                          "{ ?g a <%2> . } UNION { ?g a <%3> . } . }")
+                                                                  .arg( QString::fromAscii( uri.toEncoded() ) )
+                                                                  .arg( Soprano::Vocabulary::NRL::Ontology().toString() )
+                                                                  .arg( Soprano::Vocabulary::NRL::KnowledgeBase().toString() ),
+                                                                  Soprano::Query::QueryLanguageSparql );
+    bool success = false;
+    while ( it.next() ) {
+        success = true;
+        QUrl property = it.binding( "p" ).uri();
+        Soprano::Node value = it.binding( "o" );
+
+        if ( property == Soprano::Vocabulary::RDFS::label() ) {
+            if ( value.language().isEmpty() ) {
+                label = value.toString();
+            }
+            else if( value.language() == KGlobal::locale()->language() ) {
+                l10nLabel = value.toString();
+            }
+        }
+
+        else if ( property == Soprano::Vocabulary::RDFS::comment() ) {
+            if ( value.language().isEmpty() ) {
+                comment = value.toString();
+            }
+            else if( value.language() == KGlobal::locale()->language() ) {
+                l10nComment = value.toString();
+            }
+        }
+
+        else if ( property == Soprano::Vocabulary::NAO::hasSymbol() ) {
+            icon = KIcon( value.toString() );
+        }
+
+        else {
+            addProperty( property, value );
+        }
+    }
+
+    return success;
+}
+
+
+bool Nepomuk::Types::EntityPrivate::loadAncestors()
+{
+    Soprano::QueryResultIterator it
+        = ResourceManager::instance()->mainModel()->executeQuery( QString("select ?s ?p where { "
+                                                                          "graph ?g { ?s ?p <%1> . } . "
+                                                                          "{ ?g a <%2> . } UNION { ?g a <%3> . } . }")
+                                                                  .arg( QString::fromAscii( uri.toEncoded() ) )
+                                                                  .arg( Soprano::Vocabulary::NRL::Ontology().toString() )
+                                                                  .arg( Soprano::Vocabulary::NRL::KnowledgeBase().toString() ),
+                                                                  Soprano::Query::QueryLanguageSparql );
+    bool success = false;
+    while ( it.next() ) {
+        success = true;
+        addAncestorProperty( it.binding( "s" ).uri(), it.binding( "p" ).uri() );
+    }
+
+    return success;
+}
+
+
+
+void Nepomuk::Types::EntityPrivate::reset( bool )
+{
+    QMutexLocker lock( &mutex );
+
+    label.truncate(0);
+    comment.truncate(0);
+    l10nLabel.truncate(0);
+    l10nComment.truncate(0);;
+
+    icon = QIcon();
+
+    available = -1;
+    ancestorsAvailable = -1;
+}
+
+
+Nepomuk::Types::Entity::Entity()
+{
+}
+
+
+Nepomuk::Types::Entity::Entity( const Entity& other )
+{
+    d = other.d;
+}
+
+
+Nepomuk::Types::Entity::~Entity()
+{
+}
+
+
+Nepomuk::Types::Entity& Nepomuk::Types::Entity::operator=( const Entity& other )
+{
+    d = other.d;
+    return *this;
+}
+
+
+QUrl Nepomuk::Types::Entity::uri() const
+{
+    return d ? d->uri : QUrl();
+}
+
+
+QString Nepomuk::Types::Entity::name() const
+{
+    return d ? (d->uri.fragment().isEmpty() ? d->uri.toString().section('/',-1) : d->uri.fragment() ) : QString();
+}
+
+
+QString Nepomuk::Types::Entity::label( const QString& language )
+{
+    if ( d ) {
+        d->init();
+
+        if ( language == KGlobal::locale()->language() &&
+             !d->l10nLabel.isEmpty() ) {
+            return d->l10nLabel;
+        }
+        else if( !d->label.isEmpty() ) {
+            return d->label;
+        }
+        else {
+            return name();
+        }
+    }
+    else {
+        return QString();
+    }
+}
+
+
+QString Nepomuk::Types::Entity::label( const QString& language ) const
+{
+    return const_cast<Entity*>(this)->label( language );
+}
+
+
+QString Nepomuk::Types::Entity::comment( const QString& language )
+{
+    if ( d ) {
+        d->init();
+
+        if ( language == KGlobal::locale()->language() &&
+             !d->l10nComment.isEmpty() ) {
+            return d->l10nComment;
+        }
+        else {
+            return d->comment;
+        }
+    }
+    else {
+        return QString();
+    }
+}
+
+
+QString Nepomuk::Types::Entity::comment( const QString& language ) const
+{
+    return const_cast<Entity*>(this)->comment( language );
+}
+
+
+QIcon Nepomuk::Types::Entity::icon()
+{
+    if ( d ) {
+        d->init();
+
+        return d->icon;
+    }
+    else {
+        return QIcon();
+    }
+}
+
+
+QIcon Nepomuk::Types::Entity::icon() const
+{
+    return const_cast<Entity*>(this)->icon();
+}
+
+
+bool Nepomuk::Types::Entity::isValid() const
+{
+    return d ? d->uri.isValid() : false;
+}
+
+
+bool Nepomuk::Types::Entity::isAvailable()
+{
+    if ( d ) {
+        d->init();
+        return d->available == 1;
+    }
+    else {
+        return false;
+    }
+}
+
+
+bool Nepomuk::Types::Entity::isAvailable() const
+{
+    return const_cast<Entity*>(this)->isAvailable();
+}
+
+
+void Nepomuk::Types::Entity::reset( bool recursive )
+{
+    d->reset( recursive );
+}
+
+
+bool Nepomuk::Types::Entity::operator==( const Entity& other ) const
+{
+    // since we use one instace cache we can improve comparation operations
+    // intensly by not comparing URLs but pointers.
+    return( d.constData() == other.d.constData() );
+}
+
+
+bool Nepomuk::Types::Entity::operator==( const QUrl& other ) const
+{
+    // since we use one instace cache we can improve comparation operations
+    // intensly by not comparing URLs but pointers.
+    return( d.constData()->uri == other );
+}
+
+
+bool Nepomuk::Types::Entity::operator!=( const Entity& other ) const
+{
+    // since we use one instace cache we can improve comparation operations
+    // intensly by not comparing URLs but pointers.
+    return( d.constData() != other.d.constData() );
+}
+
+
+bool Nepomuk::Types::Entity::operator!=( const QUrl& other ) const
+{
+    // since we use one instace cache we can improve comparation operations
+    // intensly by not comparing URLs but pointers.
+    return( d.constData()->uri != other );
+}
+
+
+
+#ifndef DISABLE_NEPOMUK_LEGACY
+
+// Code for old deprecated Entity class
+// -------------------------------------------
+Nepomuk::Entity::Entity()
+{
+    d = new Private();
+}
+
+Nepomuk::Entity::Entity( const Entity& other )
+{
+    d = other.d;
+}
+
+
+Nepomuk::Entity::~Entity()
+{
+}
+
+
+Nepomuk::Entity& Nepomuk::Entity::operator=( const Entity& other )
+{
+    d = other.d;
+    return *this;
+}
+
+
+const Nepomuk::Ontology* Nepomuk::Entity::definingOntology() const
+{
+    return d->ontology;
+}
+
+
+QUrl Nepomuk::Entity::uri() const
+{
+    return d->uri;
+}
+
+
+QString Nepomuk::Entity::name() const
+{
+    return d->uri.fragment();
+}
+
+
+QString Nepomuk::Entity::label( const QString& language ) const
+{
+    QHash<QString, QString>::const_iterator it = d->l10nLabels.find( language );
+    if ( it != d->l10nLabels.constEnd() ) {
+        return it.value();
+    }
+    else {
+        return d->label;
+    }
+}
+
+
+QString Nepomuk::Entity::comment( const QString& language ) const
+{
+    QHash<QString, QString>::const_iterator it = d->l10nComments.find( language );
+    if ( it != d->l10nComments.constEnd() ) {
+        return it.value();
+    }
+    else {
+        return d->comment;
+    }
+}
+
+#endif // DISABLE_NEPOMUK_LEGACY
+

Modification de propriétés sur nepomuk/core/types/entity.cpp
___________________________________________________________________
Ajouté : svn:eol-style
   + native

Index: nepomuk/core/types/README
===================================================================
--- nepomuk/core/types/README	(révision 0)
+++ nepomuk/core/types/README	(révision 0)
@@ -0,0 +1,9 @@
+Konto provides a slightly simplified view on ontologies defined using the NRL 
+ontology description language.
+
+Konto provides three classes: Konto::Ontology, Konto::Class, and Konto::Property
+whiche can be used to explore an ontology including internationalized names and
+comments if available.
+
+The ontologies are read from the Nepomuk RDF data store or the default ontology
+installation folder (see OntologyLoader subclasses).
Index: nepomuk/core/types/property.cpp
===================================================================
--- nepomuk/core/types/property.cpp	(révision 0)
+++ nepomuk/core/types/property.cpp	(révision 0)
@@ -0,0 +1,560 @@
+/* This file is part of the Nepomuk-KDE libraries
+    Copyright (c) 2007 Sebastian Trueg <trueg@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+*/
+
+#include "property.h"
+#include "property_p.h"
+#include "class.h"
+#include "ontology.h"
+#include "literal.h"
+#include "entitymanager.h"
+
+#include <Soprano/Vocabulary/RDFS>
+#include <Soprano/Vocabulary/NRL>
+#include <Soprano/Vocabulary/XMLSchema>
+
+#undef D
+#define D static_cast<Nepomuk::Types::PropertyPrivate*>( d.data() )
+
+Nepomuk::Types::PropertyPrivate::PropertyPrivate( const QUrl& uri )
+    : EntityPrivate( uri ),
+      minCardinality( -1 ),
+      maxCardinality( -1 ),
+      cardinality( -1 )
+{
+}
+
+
+bool Nepomuk::Types::PropertyPrivate::addProperty( const QUrl& property, const Soprano::Node& value )
+{
+    if( property == Soprano::Vocabulary::RDFS::subPropertyOf() ) {
+        parents.append( value.uri() );
+        return true;
+    }
+
+    else if( property == Soprano::Vocabulary::RDFS::domain() ) {
+        domain = value.uri();
+        return true;
+    }
+
+    else if( property == Soprano::Vocabulary::RDFS::range() ) {
+        if ( value.toString().startsWith( Soprano::Vocabulary::XMLSchema::xsdNamespace().toString() ) ) {
+            literalRange = Literal( value.uri() );
+        }
+        else if ( value.uri() == Soprano::Vocabulary::RDFS::Literal()) {
+            literalRange = Literal( value.uri() );
+        }
+        else {
+            range = value.uri();
+        }
+        return true;
+    }
+
+    else if( property == Soprano::Vocabulary::NRL::minCardinality() ) {
+        minCardinality = value.literal().toInt();
+        return true;
+    }
+
+    else if( property == Soprano::Vocabulary::NRL::maxCardinality() ) {
+        maxCardinality = value.literal().toInt();
+        return true;
+    }
+
+    else if ( property == Soprano::Vocabulary::NRL::cardinality() ) {
+        cardinality = value.literal().toInt();
+        return true;
+    }
+
+    else if ( property == Soprano::Vocabulary::NRL::inverseProperty() ) {
+        inverse = value.uri();
+        return true;
+    }
+
+    return false;
+}
+
+
+bool Nepomuk::Types::PropertyPrivate::addAncestorProperty( const QUrl& ancestorResource, const QUrl& property )
+{
+    if( property == Soprano::Vocabulary::RDFS::subPropertyOf() ) {
+        children.append( ancestorResource );
+        return true;
+    }
+    else if ( property == Soprano::Vocabulary::NRL::inverseProperty() ) {
+        inverse = ancestorResource;
+        return true;
+    }
+
+    return false;
+}
+
+
+void Nepomuk::Types::PropertyPrivate::reset( bool recursive )
+{
+    EntityPrivate::reset( recursive );
+
+    QMutexLocker lock( &mutex );
+
+    if ( available != -1 ) {
+        if ( recursive ) {
+            range.reset( true );
+            domain.reset( true );
+            inverse.reset( true );
+            foreach( Property p, parents ) {
+                p.reset( true );
+            }
+        }
+
+        parents.clear();
+        available = -1;
+    }
+
+    if ( ancestorsAvailable != -1 ) {
+        if ( recursive ) {
+            foreach( Property p, children ) {
+                p.reset( true );
+            }
+        }
+
+        children.clear();
+        ancestorsAvailable = -1;
+    }
+}
+
+
+
+Nepomuk::Types::Property::Property()
+    : Entity()
+{
+    d = 0;
+}
+
+
+Nepomuk::Types::Property::Property( const QUrl& uri )
+    : Entity()
+{
+    d = EntityManager::self()->getProperty( uri );
+}
+
+
+Nepomuk::Types::Property::Property( const Property& other )
+    : Entity( other )
+{
+}
+
+
+Nepomuk::Types::Property::~Property()
+{
+}
+
+
+Nepomuk::Types::Property& Nepomuk::Types::Property::operator=( const Property& other )
+{
+    d = other.d;
+    return *this;
+}
+
+
+QList<Nepomuk::Types::Property> Nepomuk::Types::Property::parentProperties()
+{
+    if ( d ) {
+        D->init();
+        return D->parents;
+    }
+    else {
+        return QList<Nepomuk::Types::Property>();
+    }
+}
+
+
+QList<Nepomuk::Types::Property> Nepomuk::Types::Property::parentProperties() const
+{
+    return const_cast<Property*>(this)->parentProperties();
+}
+
+
+QList<Nepomuk::Types::Property> Nepomuk::Types::Property::subProperties()
+{
+    if ( d ) {
+        D->initAncestors();
+        return D->children;
+    }
+    else {
+        return QList<Nepomuk::Types::Property>();
+    }
+}
+
+
+QList<Nepomuk::Types::Property> Nepomuk::Types::Property::subProperties() const
+{
+    return const_cast<Property*>(this)->subProperties();
+}
+
+
+Nepomuk::Types::Property Nepomuk::Types::Property::inverseProperty()
+{
+    if ( d ) {
+        D->init();
+        D->initAncestors();
+        return D->inverse;
+    }
+    else {
+        return Property();
+    }
+}
+
+
+Nepomuk::Types::Property Nepomuk::Types::Property::inverseProperty() const
+{
+    return const_cast<Property*>(this)->inverseProperty();
+}
+
+
+Nepomuk::Types::Class Nepomuk::Types::Property::range()
+{
+    if ( d ) {
+        D->init();
+
+        if( D->range.isValid() ) {
+            return D->range;
+        }
+        else if( !literalRangeType().isValid() ) {
+            // try getting a domain from one of the parent properties
+            for( int i = 0; i < D->parents.count(); ++i ) {
+                Class pr = D->parents[i].range();
+                if( pr.isValid() ) {
+                    return pr;
+                }
+            }
+
+            // if we have no literal range type, we fall back to rdfs:Resource
+            return Class( Soprano::Vocabulary::RDFS::Resource() );
+        }
+        else {
+            // other than domain() we do not use a general fallback since the range
+            // might be a literalRangeType()
+            return Class();
+        }
+    }
+    else {
+        return Class();
+    }
+}
+
+
+Nepomuk::Types::Class Nepomuk::Types::Property::range() const
+{
+    return const_cast<Property*>(this)->range();
+}
+
+
+Nepomuk::Types::Literal Nepomuk::Types::Property::literalRangeType()
+{
+    if ( d ) {
+        D->init();
+
+        if( D->literalRange.isValid() ) {
+            return D->literalRange;
+        }
+        else {
+            // try getting a domain from one of the parent properties
+            // We cannot check the resource range here since that would
+            // result in an endless loop
+            for( int i = 0; i < D->parents.count(); ++i ) {
+                Literal pr = D->parents[i].literalRangeType();
+                if( pr.isValid() ) {
+                    return pr;
+                }
+            }
+
+            // fallback is an invalid range which will then result in
+            // range() returning a valid one
+            return Literal();
+        }
+    }
+    else {
+        return Literal();
+    }
+}
+
+
+Nepomuk::Types::Literal Nepomuk::Types::Property::literalRangeType() const
+{
+    return const_cast<Property*>(this)->literalRangeType();
+}
+
+
+Nepomuk::Types::Class Nepomuk::Types::Property::domain()
+{
+    if ( d ) {
+        D->init();
+
+        if( D->domain.isValid() ) {
+            return D->domain;
+        }
+        else {
+            // try getting a domain from one of the parent properties
+            for( int i = 0; i < D->parents.count(); ++i ) {
+                Class pd = D->parents[i].domain();
+                if( pd.isValid() ) {
+                    return pd;
+                }
+            }
+
+            // fallback: rdfs:Resource
+            return Class( Soprano::Vocabulary::RDFS::Resource() );
+        }
+    }
+    else {
+        return Class();
+    }
+}
+
+
+Nepomuk::Types::Class Nepomuk::Types::Property::domain() const
+{
+    return const_cast<Property*>(this)->domain();
+}
+
+
+int Nepomuk::Types::Property::cardinality()
+{
+    if ( d ) {
+        D->init();
+        return D->cardinality;
+    }
+    else {
+        return -1;
+    }
+}
+
+
+int Nepomuk::Types::Property::cardinality() const
+{
+    return const_cast<Property*>(this)->cardinality();
+}
+
+
+int Nepomuk::Types::Property::minCardinality()
+{
+    if ( d ) {
+        D->init();
+        if ( D->minCardinality > 0 ) {
+            return D->minCardinality;
+        }
+        else {
+            return D->cardinality;
+        }
+    }
+    else {
+        return -1;
+    }
+}
+
+
+int Nepomuk::Types::Property::minCardinality() const
+{
+    return const_cast<Property*>(this)->minCardinality();
+}
+
+
+int Nepomuk::Types::Property::maxCardinality()
+{
+    if ( d ) {
+        D->init();
+        if ( D->maxCardinality > 0 ) {
+            return D->maxCardinality;
+        }
+        else {
+            return D->cardinality;
+        }
+    }
+    else {
+        return -1;
+    }
+}
+
+
+int Nepomuk::Types::Property::maxCardinality() const
+{
+    return const_cast<Property*>(this)->maxCardinality();
+}
+
+
+bool Nepomuk::Types::Property::isParentOf( const Property& other )
+{
+    if ( d ) {
+        D->initAncestors();
+
+        if ( D->children.contains( other ) ) {
+            return true;
+        }
+        else {
+            for ( QList<Nepomuk::Types::Property>::iterator it = D->children.begin();
+                  it != D->children.end(); ++it ) {
+                if ( ( *it ).isParentOf( other ) ) {
+                    return true;
+                }
+            }
+        }
+    }
+
+    return false;
+}
+
+
+bool Nepomuk::Types::Property::isParentOf( const Property& other ) const
+{
+    return const_cast<Property*>(this)->isParentOf( other );
+}
+
+
+bool Nepomuk::Types::Property::isSubPropertyOf( const Property& other )
+{
+    if ( d ) {
+        D->init();
+
+        if ( D->parents.contains( other ) ) {
+            return true;
+        }
+        else {
+            for ( QList<Nepomuk::Types::Property>::iterator it = D->parents.begin();
+                  it != D->parents.end(); ++it ) {
+                if ( ( *it ).isSubPropertyOf( other ) ) {
+                    return true;
+                }
+            }
+        }
+    }
+
+    return false;
+}
+
+
+bool Nepomuk::Types::Property::isSubPropertyOf( const Property& other ) const
+{
+    return const_cast<Property*>(this)->isSubPropertyOf( other );
+}
+
+
+
+#ifndef DISABLE_NEPOMUK_LEGACY
+
+// Start of code for deprecated Property
+// -------------------------------------
+#include "global.h"
+#include "ontologymanager.h"
+
+Nepomuk::Property::Property()
+    : Entity()
+{
+    d = new Private();
+}
+
+
+Nepomuk::Property::Property( const Property& other )
+    : Entity( other )
+{
+    d = other.d;
+}
+
+
+Nepomuk::Property::~Property()
+{
+}
+
+
+Nepomuk::Property& Nepomuk::Property::operator=( const Property& other )
+{
+    d = other.d;
+    return *this;
+}
+
+
+QList<const Nepomuk::Property*> Nepomuk::Property::parentProperties() const
+{
+    return d->parents;
+}
+
+
+QList<const Nepomuk::Property*> Nepomuk::Property::parentOf() const
+{
+    return d->children;
+}
+
+
+const Nepomuk::Property* Nepomuk::Property::inverseProperty() const
+{
+    return d->inverse;
+}
+
+
+const Nepomuk::Class* Nepomuk::Property::range() const
+{
+    return d->range;
+}
+
+
+Nepomuk::Literal Nepomuk::Property::literalRangeType() const
+{
+    return d->literalRange;
+}
+
+
+const Nepomuk::Class* Nepomuk::Property::domain() const
+{
+    return d->domain;
+}
+
+
+int Nepomuk::Property::cardinality() const
+{
+    return d->cardinality;
+}
+
+
+int Nepomuk::Property::minCardinality() const
+{
+    return d->minCardinality;
+}
+
+
+int Nepomuk::Property::maxCardinality() const
+{
+    return d->maxCardinality;
+}
+
+
+const Nepomuk::Property* Nepomuk::Property::load( const QUrl& uri )
+{
+    QUrl ns = extractNamespace( uri );
+
+    // load the ontology in the cache
+    const Ontology* ont = OntologyManager::instance()->getOntology( ns );
+
+    // return the requested class or an invalid one if the ontology
+    // was not found
+    if ( ont ) {
+        return ont->findPropertyByUri( uri );
+    }
+    else {
+        return 0;
+    }
+}
+
+#endif // DISABLE_NEPOMUK_LEGACY

Modification de propriétés sur nepomuk/core/types/property.cpp
___________________________________________________________________
Ajouté : svn:eol-style
   + native

Index: nepomuk/core/types/class_p.h
===================================================================
--- nepomuk/core/types/class_p.h	(révision 0)
+++ nepomuk/core/types/class_p.h	(révision 0)
@@ -0,0 +1,84 @@
+/* This file is part of the Nepomuk-KDE libraries
+    Copyright (c) 2007 Sebastian Trueg <trueg@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+*/
+
+#ifndef _NEPOMUK_CLASS_PRIVATE_H_
+#define _NEPOMUK_CLASS_PRIVATE_H_
+
+#include "entity_p.h"
+#include "class.h"
+#include "property.h"
+
+#include <QtCore/QHash>
+#include <QtCore/QSharedData>
+
+
+namespace Nepomuk {
+    namespace Types {
+        class ClassPrivate : public EntityPrivate
+        {
+        public:
+            ClassPrivate( const QUrl& uri = QUrl() );
+
+            QList<Property> domainOf;
+            QList<Property> rangeOf;
+
+            QList<Class> parents;
+            QList<Class> children;
+
+            // -1 - unknown
+            // 0  - no
+            // 1  - yes
+            int propertiesAvailable;
+
+            bool addProperty( const QUrl& property, const Soprano::Node& value );
+            bool addAncestorProperty( const QUrl& ancestorResource, const QUrl& property );
+
+            void initProperties();
+            bool loadProperties();
+
+            void reset( bool recursive );
+
+            // recursively find all parent or sub classes but stop at requestingClass to avoid endless loops
+            QSet<Class> findParentClasses( ClassPrivate* requestingClass );
+            QSet<Class> findSubClasses( ClassPrivate* requestingClass );
+
+        protected:
+            virtual bool load();
+            virtual bool loadAncestors();
+        };
+    }
+}
+
+
+namespace Nepomuk {
+
+    class Property;
+    
+    class Class::Private : public QSharedData
+    {
+    public:
+        QHash<QUrl, const Property*> domainOf;
+        QHash<QUrl, const Property*> rangeOf;
+
+        QList<const Nepomuk::Class*> parents;
+        QList<const Nepomuk::Class*> children;
+    };
+}
+
+#endif

Modification de propriétés sur nepomuk/core/types/class_p.h
___________________________________________________________________
Ajouté : svn:eol-style
   + native

Index: nepomuk/core/types/desktopontologyloader.cpp
===================================================================
--- nepomuk/core/types/desktopontologyloader.cpp	(révision 0)
+++ nepomuk/core/types/desktopontologyloader.cpp	(révision 0)
@@ -0,0 +1,114 @@
+/* This file is part of the Nepomuk-KDE libraries
+    Copyright (c) 2007 Sebastian Trueg <trueg@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+*/
+
+#include "desktopontologyloader.h"
+#include "fileontologyloader.h"
+
+#include <kstandarddirs.h>
+#include <kdesktopfile.h>
+#include <kconfiggroup.h>
+#include <kdebug.h>
+#include <kglobal.h>
+
+#include <QtCore/QDir>
+
+#include <soprano/statement.h>
+
+struct OntoBuffer
+{
+    QString fileName;
+    Soprano::RdfSerialization serialization;
+};
+
+
+class Nepomuk::DesktopOntologyLoader::Private
+{
+public:
+    Private() {
+    }
+
+    void updateOntologyCache() {
+//        ontoCache.clear();
+
+        QStringList allOntologies = KGlobal::dirs()->findAllResources( "data", "nepomuk/ontologies/*.desktop" );
+        foreach( const QString &ontoDesktopFilePath, allOntologies ) {
+            KDesktopFile ontoDesktopFile( ontoDesktopFilePath );
+
+            if ( ontoDesktopFile.hasLinkType() ) {
+                QUrl uri = ontoDesktopFile.readUrl();
+
+                if ( !ontoCache.contains( uri ) ) {
+                    QString path = ontoDesktopFile.readPath();
+
+                    // make it an absolute path
+                    if ( path[0] != QDir::separator() ) {
+                        path.prepend( ontoDesktopFilePath.section( QDir::separator(),
+                                                                   0, -2,
+                                                                   QString::SectionIncludeLeadingSep|QString::SectionIncludeTrailingSep ) );
+                    }
+
+                    OntoBuffer onto;
+                    onto.fileName = path;
+                    onto.serialization = Soprano::mimeTypeToSerialization( ontoDesktopFile.desktopGroup().readEntry( "MimeType", "application/rdf+xml" ) );
+
+                    kDebug() << "(Nepomuk::DesktopOntologyLoader) found ontology " << uri;
+                    ontoCache.insert( uri, onto );
+                }
+            }
+        }
+    }
+
+    // contains the filename for each cached ontology
+    QHash<QUrl, OntoBuffer> ontoCache;
+};
+
+
+Nepomuk::DesktopOntologyLoader::DesktopOntologyLoader()
+    : OntologyLoader(),
+      d( new Private() )
+{
+}
+
+
+Nepomuk::DesktopOntologyLoader::~DesktopOntologyLoader()
+{
+    delete d;
+}
+
+
+QList<QUrl> Nepomuk::DesktopOntologyLoader::allOntologies()
+{
+    d->updateOntologyCache();
+    return d->ontoCache.keys();
+}
+
+
+QList<Soprano::Statement> Nepomuk::DesktopOntologyLoader::loadOntology( const QUrl& url )
+{
+    d->updateOntologyCache();
+    if ( d->ontoCache.contains( url ) ) {
+        const OntoBuffer& onto = d->ontoCache[url];
+        FileOntologyLoader loader( onto.fileName, onto.serialization );
+        return loader.loadOntology( url );
+    }
+    else {
+        kDebug() << "(Nepomuk::DesktopOntologyLoader) could not find ontology " << url;
+        return QList<Soprano::Statement>();
+    }
+}

Modification de propriétés sur nepomuk/core/types/desktopontologyloader.cpp
___________________________________________________________________
Ajouté : svn:eol-style
   + native

Index: nepomuk/core/types/literal.cpp
===================================================================
--- nepomuk/core/types/literal.cpp	(révision 0)
+++ nepomuk/core/types/literal.cpp	(révision 0)
@@ -0,0 +1,181 @@
+/* This file is part of the Nepomuk-KDE libraries
+    Copyright (c) 2007 Sebastian Trueg <trueg@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+*/
+
+#include "literal.h"
+#include "literal_p.h"
+
+#include <QtCore/QHash>
+#include <QtCore/QVariant>
+
+#include <Soprano/Vocabulary/RDFS>
+
+#include <kglobal.h>
+
+
+namespace {
+typedef QHash<QString, QVariant::Type> XmlSchemaMap;
+
+K_GLOBAL_STATIC(XmlSchemaMap, s_xmlSchemaTypes)
+
+void initXmlSchemaTypes() {
+    if( s_xmlSchemaTypes->isEmpty() ) {
+        s_xmlSchemaTypes->insert( "int", QVariant::Int );
+        s_xmlSchemaTypes->insert( "integer", QVariant::Int );
+        s_xmlSchemaTypes->insert( "negativeInteger", QVariant::Int );
+        s_xmlSchemaTypes->insert( "decimal", QVariant::Int );
+        s_xmlSchemaTypes->insert( "short", QVariant::Int );
+        s_xmlSchemaTypes->insert( "long", QVariant::LongLong );
+        s_xmlSchemaTypes->insert( "unsignedInt", QVariant::UInt );
+        s_xmlSchemaTypes->insert( "unsignedShort", QVariant::UInt );
+        s_xmlSchemaTypes->insert( "unsignedLong", QVariant::ULongLong );
+        s_xmlSchemaTypes->insert( "boolean", QVariant::Bool );
+        s_xmlSchemaTypes->insert( "double", QVariant::Double );
+        s_xmlSchemaTypes->insert( "float", QVariant::Double );
+        s_xmlSchemaTypes->insert( "string", QVariant::String );
+        s_xmlSchemaTypes->insert( "date", QVariant::Date );
+        s_xmlSchemaTypes->insert( "time", QVariant::Time );
+        s_xmlSchemaTypes->insert( "dateTime", QVariant::DateTime );
+        //    s_xmlSchemaTypes->insert( "", QVariant::Url );
+    }
+}
+
+const XmlSchemaMap& xmlSchemaTypes()
+{
+    if(s_xmlSchemaTypes->isEmpty())
+        initXmlSchemaTypes();
+    return *s_xmlSchemaTypes;
+}
+}
+
+
+Nepomuk::Types::Literal::Literal()
+{
+    d = new Private();
+}
+
+
+Nepomuk::Types::Literal::Literal( const Literal& other )
+{
+    d = other.d;
+}
+
+
+Nepomuk::Types::Literal::Literal( const QUrl& dataType )
+{
+    d = new Private();
+    d->dataTypeUri = dataType;
+
+    // now determine the QVariant type
+    initXmlSchemaTypes();
+
+    // check if it is a known type, otherwise leave it as QVariant::Invalid
+    if ( dataType == Soprano::Vocabulary::RDFS::Literal() ) {
+        d->dataType = QVariant::String;
+    }
+    else {
+        QHash<QString, QVariant::Type>::const_iterator it = xmlSchemaTypes().constFind( dataType.fragment() );
+        if ( it != xmlSchemaTypes().constEnd() ) {
+            d->dataType = it.value();
+        }
+    }
+}
+
+
+Nepomuk::Types::Literal::~Literal()
+{
+}
+
+
+Nepomuk::Types::Literal& Nepomuk::Types::Literal::operator=( const Literal& other )
+{
+    d = other.d;
+    return *this;
+}
+
+
+QUrl Nepomuk::Types::Literal::dataTypeUri() const
+{
+    return d->dataTypeUri;
+}
+
+
+QVariant::Type Nepomuk::Types::Literal::dataType() const
+{
+    return d->dataType;
+}
+
+
+bool Nepomuk::Types::Literal::isValid() const
+{
+    return d->dataTypeUri.isValid();
+}
+
+
+
+
+Nepomuk::Literal::Literal()
+{
+    d = new Private();
+}
+
+
+Nepomuk::Literal::Literal( const Literal& other )
+{
+    d = other.d;
+}
+
+
+Nepomuk::Literal::Literal( const QUrl& dataType )
+{
+    d = new Private();
+    d->dataTypeUri = dataType;
+
+    // now determine the QVariant type
+    initXmlSchemaTypes();
+
+    // check if it is a known type, otherwise leave it as QVariant::Invalid
+    QHash<QString, QVariant::Type>::const_iterator it = xmlSchemaTypes().constFind( dataType.fragment() );
+    if ( it != xmlSchemaTypes().constEnd() ) {
+        d->dataType = it.value();
+    }
+}
+
+
+Nepomuk::Literal::~Literal()
+{
+}
+
+
+Nepomuk::Literal& Nepomuk::Literal::operator=( const Literal& other )
+{
+    d = other.d;
+    return *this;
+}
+
+
+const QUrl& Nepomuk::Literal::dataTypeUri() const
+{
+    return d->dataTypeUri;
+}
+
+
+QVariant::Type Nepomuk::Literal::dataType() const
+{
+    return d->dataType;
+}

Modification de propriétés sur nepomuk/core/types/literal.cpp
___________________________________________________________________
Ajouté : svn:eol-style
   + native

Index: nepomuk/core/resourcedata.h
===================================================================
--- nepomuk/core/resourcedata.h	(révision 1125741)
+++ nepomuk/core/resourcedata.h	(copie de travail)
@@ -82,6 +82,8 @@
 
         bool hasProperty( const QUrl& uri );
 
+        bool hasProperty( const QUrl& p, const Variant& v );
+
         /**
          * Does also check for subClass relations.
          */
@@ -175,7 +177,7 @@
         KUrl m_uri;
 
         /// the URL of file resources
-        KUrl m_fileUrl;
+        KUrl m_nieUrl;
 
         QUrl m_mainType;
         QList<QUrl> m_types;
Index: nepomuk/core/resource.cpp
===================================================================
--- nepomuk/core/resource.cpp	(révision 1125741)
+++ nepomuk/core/resource.cpp	(copie de travail)
@@ -26,9 +26,11 @@
 #include "tag.h"
 #include "pimo.h"
 #include "thing.h"
+#include "property.h"
 #include "nfo.h"
 #include "nie.h"
 #include "nco.h"
+#include "nuao.h"
 
 #include <klocale.h>
 #include <kdebug.h>
@@ -36,6 +38,8 @@
 #include <Soprano/Vocabulary/NAO>
 #include <Soprano/Vocabulary/Xesam>
 #include <Soprano/Vocabulary/RDFS>
+#include <Soprano/Model>
+#include <Soprano/QueryResultIterator>
 
 #include <kmimetype.h>
 
@@ -262,6 +266,12 @@
 }
 
 
+bool Nepomuk::Resource::hasProperty( const Types::Property& p, const Variant& v ) const
+{
+    return m_data ? m_data->hasProperty( p.uri(), v ) : false;
+}
+
+
 bool Nepomuk::Resource::hasProperty( const QString& uri ) const
 {
     return hasProperty( QUrl( uri ) );
@@ -353,6 +363,7 @@
 }
 
 
+// KDE 4.5: cache this one in ResourceData
 QString Nepomuk::Resource::genericLabel() const
 {
     QString label = this->label();
@@ -858,6 +869,23 @@
 }
 
 
+int Nepomuk::Resource::usageCount() const
+{
+    return property( Vocabulary::NUAO::usageCount() ).toInt();
+}
+
+
+void Nepomuk::Resource::increaseUsageCount()
+{
+    int cnt = 0;
+    if( hasProperty( Vocabulary::NUAO::usageCount() ) )
+        cnt = property( Vocabulary::NUAO::usageCount() ).toInt();
+    ++cnt;
+    setProperty( Vocabulary::NUAO::usageCount(), cnt );
+    setProperty( Vocabulary::NUAO::lastUsage(), QDateTime::currentDateTime() );
+}
+
+
 uint Nepomuk::qHash( const Resource& res )
 {
     return qHash(res.resourceUri());
Index: nepomuk/core/ui/test/tagwidgettest.cpp
===================================================================
--- nepomuk/core/ui/test/tagwidgettest.cpp	(révision 0)
+++ nepomuk/core/ui/test/tagwidgettest.cpp	(révision 0)
@@ -0,0 +1,95 @@
+#include "tagwidgettest.h"
+#include "../tagwidget.h"
+
+#include <QVBoxLayout>
+#include <QCheckBox>
+#include <kdebug.h>
+
+
+TagWidgetTest::TagWidgetTest()
+    : QWidget()
+{
+    m_tagWidget = new Nepomuk::TagWidget(this);
+    m_tagWidget->setMaxTagsShown(8);
+    QVBoxLayout* lay = new QVBoxLayout(this);
+    lay->addWidget(m_tagWidget);
+    connect(m_tagWidget, SIGNAL(tagClicked(Nepomuk::Tag)),
+            this, SLOT(slotTagClicked(Nepomuk::Tag)));
+    connect(m_tagWidget, SIGNAL(selectionChanged(QList<Nepomuk::Tag>)),
+            this, SLOT(slotSelectionChanged(QList<Nepomuk::Tag>)));
+
+    QCheckBox* box = new QCheckBox( "Minimode", this );
+    connect(box, SIGNAL(toggled(bool)), this, SLOT(enableMinimode(bool)));
+    lay->addWidget(box);
+
+    box = new QCheckBox( "Align Right", this );
+    connect(box, SIGNAL(toggled(bool)), this, SLOT(alignRight(bool)));
+    lay->addWidget(box);
+
+    box = new QCheckBox( "Disable clicking", this );
+    connect(box, SIGNAL(toggled(bool)), this, SLOT(disableClicking(bool)));
+    lay->addWidget(box);
+
+    box = new QCheckBox( "Read only", this );
+    connect(box, SIGNAL(toggled(bool)), this, SLOT(setReadOnly(bool)));
+    lay->addWidget(box);
+}
+
+TagWidgetTest::~TagWidgetTest()
+{
+}
+
+
+void TagWidgetTest::slotTagClicked(const Nepomuk::Tag& tag)
+{
+    kDebug() << "Tag clicked:" << tag.resourceUri() << tag.genericLabel();
+}
+
+
+void TagWidgetTest::slotSelectionChanged( const QList<Nepomuk::Tag>& tags )
+{
+    QStringList ts;
+    foreach(const Nepomuk::Tag& tag, tags)
+        ts << tag.genericLabel();
+    kDebug() << "Selection changed:" << ts;
+}
+
+
+void TagWidgetTest::enableMinimode( bool enable )
+{
+    Nepomuk::TagWidget::ModeFlags flags = m_tagWidget->modeFlags();
+    if( enable ) {
+        flags |= Nepomuk::TagWidget::MiniMode;
+        flags &= ~Nepomuk::TagWidget::StandardMode;
+    }
+    else {
+        flags |= Nepomuk::TagWidget::StandardMode;
+        flags &= ~Nepomuk::TagWidget::MiniMode;
+    }
+    m_tagWidget->setModeFlags( flags );
+}
+
+
+void TagWidgetTest::alignRight( bool enable )
+{
+    if( enable )
+        m_tagWidget->setAlignment( Qt::AlignRight );
+    else
+        m_tagWidget->setAlignment( Qt::AlignLeft );
+}
+
+
+void TagWidgetTest::disableClicking( bool enable )
+{
+    Nepomuk::TagWidget::ModeFlags flags = m_tagWidget->modeFlags();
+    m_tagWidget->setModeFlags( enable ? flags | Nepomuk::TagWidget::DisableTagClicking : flags & ~Nepomuk::TagWidget::DisableTagClicking );
+}
+
+
+void TagWidgetTest::setReadOnly( bool enable )
+{
+    Nepomuk::TagWidget::ModeFlags flags = m_tagWidget->modeFlags();
+    m_tagWidget->setModeFlags( enable ? flags | Nepomuk::TagWidget::ReadOnly : flags & ~Nepomuk::TagWidget::ReadOnly );
+}
+
+#include "tagwidgettest.moc"

Modification de propriétés sur nepomuk/core/ui/test/tagwidgettest.cpp
___________________________________________________________________
Ajouté : svn:eol-style
   + native

Index: nepomuk/core/ui/test/tagwidgetapp.cpp
===================================================================
--- nepomuk/core/ui/test/tagwidgetapp.cpp	(révision 0)
+++ nepomuk/core/ui/test/tagwidgetapp.cpp	(révision 0)
@@ -0,0 +1,14 @@
+#include "tagwidgettest.h"
+
+#include <QApplication>
+#include <kcomponentdata.h>
+
+
+int main( int argc, char** argv )
+{
+    QApplication app( argc, argv );
+    KComponentData data( "TagWidgetApp" );
+    TagWidgetTest tw;
+    tw.show();
+    return app.exec();
+}

Modification de propriétés sur nepomuk/core/ui/test/tagwidgetapp.cpp
___________________________________________________________________
Ajouté : svn:eol-style
   + native

Index: nepomuk/core/ui/test/tagwidgettest.h
===================================================================
--- nepomuk/core/ui/test/tagwidgettest.h	(révision 0)
+++ nepomuk/core/ui/test/tagwidgettest.h	(révision 0)
@@ -0,0 +1,30 @@
+#ifndef TAGWIDGETTEST_H
+#define TAGWIDGETTEST_H
+
+#include <QWidget>
+#include "../../tag.h"
+#include "../tagwidget.h"
+
+class TagWidgetTest : public QWidget
+{
+    Q_OBJECT
+
+public:
+    TagWidgetTest();
+    ~TagWidgetTest();
+
+public slots:
+    void slotTagClicked(const Nepomuk::Tag&);
+    void slotSelectionChanged( const QList<Nepomuk::Tag>& tags );
+
+private slots:
+    void enableMinimode( bool enable );
+    void alignRight( bool enable );
+    void disableClicking( bool enable );
+    void setReadOnly( bool enable );
+
+private:
+    Nepomuk::TagWidget* m_tagWidget;
+};
+
+#endif

Modification de propriétés sur nepomuk/core/ui/test/tagwidgettest.h
___________________________________________________________________
Ajouté : svn:eol-style
   + native

Index: nepomuk/core/ui/test/CMakeLists.txt
===================================================================
--- nepomuk/core/ui/test/CMakeLists.txt	(révision 1125741)
+++ nepomuk/core/ui/test/CMakeLists.txt	(copie de travail)
@@ -15,3 +15,13 @@
   ${KDE4_KIO_LIBS}
   nepomuk
   )
+
+kde4_add_executable(tagwidgetapp TEST tagwidgetapp.cpp tagwidgettest.cpp)
+target_link_libraries(tagwidgetapp
+  ${QT_QTCORE_LIBRARY}
+  ${QT_QTGUI_LIBRARY}
+  ${KDE4_KDECORE_LIBS}
+  ${KDE4_KDEUI_LIBS}
+  ${KDE4_KIO_LIBS}
+  nepomuk
+  )
Index: nepomuk/core/ui/kedittagsdialog.cpp
===================================================================
--- nepomuk/core/ui/kedittagsdialog.cpp	(révision 0)
+++ nepomuk/core/ui/kedittagsdialog.cpp	(révision 0)
@@ -0,0 +1,259 @@
+/*****************************************************************************
+ * Copyright (C) 2009 by Peter Penz <peter.penz@gmx.at>                      *
+ *                                                                           *
+ * This library is free software; you can redistribute it and/or             *
+ * modify it under the terms of the GNU Library General Public               *
+ * License version 2 as published by the Free Software Foundation.           *
+ *                                                                           *
+ * This library is distributed in the hope that it will be useful,           *
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of            *
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU         *
+ * Library General Public License for more details.                          *
+ *                                                                           *
+ * You should have received a copy of the GNU Library General Public License *
+ * along with this library; see the file COPYING.LIB.  If not, write to      *
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,      *
+ * Boston, MA 02110-1301, USA.                                               *
+ *****************************************************************************/
+
+#include "kedittagsdialog_p.h"
+
+#include <kicon.h>
+#include <klineedit.h>
+#include <klocale.h>
+#include <kmessagebox.h>
+
+#include <QEvent>
+#include <QHBoxLayout>
+#include <QLabel>
+#include <QListWidget>
+#include <QPushButton>
+#include <QTimer>
+#include <QVBoxLayout>
+#include <QWidget>
+
+KEditTagsDialog::KEditTagsDialog(const QList<Nepomuk::Tag>& tags,
+                                 QWidget* parent,
+                                 Qt::WFlags flags) :
+    KDialog(parent, flags),
+    m_tags(tags),
+    m_tagsList(0),
+    m_newTagItem(0),
+    m_deleteCandidate(0),
+    m_newTagEdit(0),
+    m_deleteButtonTimer(0)
+{
+
+    const QString caption = (tags.count() > 0) ?
+                            i18nc("@title:window", "Change Tags") :
+                            i18nc("@title:window", "Add Tags");
+    setCaption(caption);
+    setButtons(KDialog::Ok | KDialog::Cancel);
+    setDefaultButton(KDialog::Ok);
+
+    QWidget* mainWidget = new QWidget(this);
+    QVBoxLayout* topLayout = new QVBoxLayout(mainWidget);
+
+    QLabel* label = new QLabel(i18nc("@label:textbox",
+                                     "Configure which tags should "
+                                     "be applied."), this);
+
+    m_tagsList = new QListWidget(mainWidget);
+    m_tagsList->setMouseTracking(true);
+    m_tagsList->setSortingEnabled(true);
+    m_tagsList->setSelectionMode(QAbstractItemView::NoSelection);
+    m_tagsList->installEventFilter(this);
+    connect(m_tagsList, SIGNAL(itemEntered(QListWidgetItem*)),
+            this, SLOT(slotItemEntered(QListWidgetItem*)));
+    connect(m_tagsList, SIGNAL(itemEntered(QListWidgetItem*)),
+            this, SLOT(slotItemEntered(QListWidgetItem*)));
+
+    QLabel* newTagLabel = new QLabel(i18nc("@label", "Create new tag:"));
+    m_newTagEdit = new KLineEdit(this);
+    m_newTagEdit->setClearButtonShown(true);
+    connect(m_newTagEdit, SIGNAL(textEdited(const QString&)),
+            this, SLOT(slotTextEdited(const QString&)));
+
+    QHBoxLayout* newTagLayout = new QHBoxLayout();
+    newTagLayout->addWidget(newTagLabel);
+    newTagLayout->addWidget(m_newTagEdit, 1);
+
+    topLayout->addWidget(label);
+    topLayout->addWidget(m_tagsList);
+    topLayout->addLayout(newTagLayout);
+
+    setMainWidget(mainWidget);
+
+    loadTags();
+
+    // create the delete button, which is shown when
+    // hovering the items
+    m_deleteButton = new QPushButton(m_tagsList->viewport());
+    m_deleteButton->setIcon(KIcon("edit-delete"));
+    m_deleteButton->setToolTip(i18nc("@info", "Delete tag"));
+    m_deleteButton->hide();
+    connect(m_deleteButton, SIGNAL(clicked()), this, SLOT(deleteTag()));
+
+    m_deleteButtonTimer = new QTimer(this);
+    m_deleteButtonTimer->setSingleShot(true);
+    m_deleteButtonTimer->setInterval(500);
+    connect(m_deleteButtonTimer, SIGNAL(timeout()), this, SLOT(showDeleteButton()));
+}
+
+KEditTagsDialog::~KEditTagsDialog()
+{
+}
+
+QList<Nepomuk::Tag> KEditTagsDialog::tags() const
+{
+    return m_tags;
+}
+
+bool KEditTagsDialog::eventFilter(QObject* watched, QEvent* event)
+{
+    if ((watched == m_tagsList) && (event->type() == QEvent::Leave)) {
+        m_deleteButtonTimer->stop();
+        m_deleteButton->hide();
+    }
+    return KDialog::eventFilter(watched, event);
+}
+
+void KEditTagsDialog::slotButtonClicked(int button)
+{
+    if (button == KDialog::Ok) {
+        // update m_tags with the checked values, so
+        // that the caller of the KEditTagsDialog can
+        // receive the tags by KEditTagsDialog::tags()
+        m_tags.clear();
+
+        const int count = m_tagsList->count();
+        for (int i = 0; i < count; ++i) {
+            QListWidgetItem* item = m_tagsList->item(i);
+            if (item->checkState() == Qt::Checked) {
+                const QString label = item->data(Qt::UserRole).toString();
+                Nepomuk::Tag tag(label);
+                tag.setLabel(label);
+                m_tags.append(tag);
+            }
+        }
+
+        accept();
+    } else {
+        KDialog::slotButtonClicked(button);
+    }
+}
+
+void KEditTagsDialog::slotTextEdited(const QString& text)
+{
+    // Remove unnecessary spaces from a new tag is
+    // mandatory, as the user cannot see the difference
+    // between a tag "Test" and "Test ".
+    const QString tagText = text.simplified();
+    if (tagText.isEmpty()) {
+        removeNewTagItem();
+        return;
+    }
+
+    // Check whether the new tag already exists. If this
+    // is the case, remove the new tag item.
+    const int count = m_tagsList->count();
+    for (int i = 0; i < count; ++i) {
+        const QListWidgetItem* item = m_tagsList->item(i);
+        const bool remove = (item->text() == tagText) &&
+                            ((m_newTagItem == 0) || (m_newTagItem != item));
+        if (remove) {
+            m_tagsList->scrollToItem(item);
+            removeNewTagItem();
+            return;
+        }
+    }
+
+    // There is no tag in the list with the the passed text.
+    if (m_newTagItem == 0) {
+        m_newTagItem = new QListWidgetItem(tagText, m_tagsList);
+    } else {
+        m_newTagItem->setText(tagText);
+    }
+    m_newTagItem->setData(Qt::UserRole, tagText);
+    m_newTagItem->setCheckState(Qt::Checked);
+    m_tagsList->scrollToItem(m_newTagItem);
+}
+
+void KEditTagsDialog::slotItemEntered(QListWidgetItem* item)
+{
+    // align the delete-button to stay on the right border
+    // of the item
+    const QRect rect = m_tagsList->visualItemRect(item);
+    const int size = rect.height();
+    const int x = rect.right() - size;
+    const int y = rect.top();
+    m_deleteButton->setGeometry(x, y, size, size);
+
+    m_deleteCandidate = item;
+    m_deleteButtonTimer->start();
+}
+
+void KEditTagsDialog::showDeleteButton()
+{
+    m_deleteButton->show();
+}
+
+void KEditTagsDialog::deleteTag()
+{
+    Q_ASSERT(m_deleteCandidate != 0);
+    const QString text = i18nc("@info",
+                               "Should the tag <resource>%1</resource> really be deleted for all files?",
+                               m_deleteCandidate->text());
+    const QString caption = i18nc("@title", "Delete tag");
+    const KGuiItem deleteItem(i18nc("@action:button", "Delete"), KIcon("edit-delete"));
+    const KGuiItem cancelItem(i18nc("@action:button", "Cancel"), KIcon("dialog-cancel"));
+    if (KMessageBox::warningYesNo(this, text, caption, deleteItem, cancelItem) == KMessageBox::Yes) {
+        const QString label = m_deleteCandidate->data(Qt::UserRole).toString();
+        Nepomuk::Tag tag(label);
+        tag.remove();
+
+        delete m_deleteCandidate;
+        m_deleteCandidate = 0;
+    }
+}
+
+static bool tagLabelLessThan( const Nepomuk::Tag& t1, const Nepomuk::Tag& t2 )
+{
+    return t1.genericLabel() < t2.genericLabel();
+}
+
+void KEditTagsDialog::loadTags()
+{
+    // load all available tags and mark those tags as checked
+    // that have been passed to the KEditTagsDialog
+    QList<Nepomuk::Tag> tags = Nepomuk::Tag::allTags();
+    qSort( tags.begin(), tags.end(), tagLabelLessThan );
+
+    foreach (const Nepomuk::Tag& tag, tags) {
+        const QString label = tag.genericLabel();
+
+        QListWidgetItem* item = new QListWidgetItem(label, m_tagsList);
+        item->setData(Qt::UserRole, label);
+
+        bool check = false;
+        foreach (const Nepomuk::Tag& selectedTag, m_tags) {
+            if (selectedTag == tag) {
+                check = true;
+                break;
+            }
+        }
+        item->setCheckState(check ? Qt::Checked : Qt::Unchecked);
+    }
+}
+
+void KEditTagsDialog::removeNewTagItem()
+{
+    if (m_newTagItem != 0) {
+        const int row = m_tagsList->row(m_newTagItem);
+        m_tagsList->takeItem(row);
+        delete m_newTagItem;
+        m_newTagItem = 0;
+    }
+}
+
+#include "kedittagsdialog_p.moc"

Modification de propriétés sur nepomuk/core/ui/kedittagsdialog.cpp
___________________________________________________________________
Ajouté : svn:eol-style
   + native

Index: nepomuk/core/ui/nepomukmassupdatejob.cpp
===================================================================
--- nepomuk/core/ui/nepomukmassupdatejob.cpp	(révision 1125741)
+++ nepomuk/core/ui/nepomukmassupdatejob.cpp	(copie de travail)
@@ -153,4 +153,12 @@
     return job;
 }
 
+Nepomuk::MassUpdateJob* Nepomuk::MassUpdateJob::commentResources( const QList<Nepomuk::Resource>& rl, const QString& comment )
+{
+    Nepomuk::MassUpdateJob* job = new Nepomuk::MassUpdateJob();
+    job->setResources( rl );
+    job->setProperties( QList<QPair<QUrl,Nepomuk::Variant> >() << qMakePair( QUrl( Nepomuk::Resource::descriptionUri() ), Nepomuk::Variant( comment ) ) );
+    return job;
+}
+
 #include "nepomukmassupdatejob.moc"
Index: nepomuk/core/ui/kmetadatatagwidget.h
===================================================================
--- nepomuk/core/ui/kmetadatatagwidget.h	(révision 1125741)
+++ nepomuk/core/ui/kmetadatatagwidget.h	(copie de travail)
@@ -1,100 +1,2 @@
-/*
- * This file is part of the Nepomuk KDE project.
- * Copyright (C) 2006-2007 Sebastian Trueg <trueg@kde.org>
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Library General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Library General Public License for more details.
- *
- * You should have received a copy of the GNU Library General Public License
- * along with this library; see the file COPYING.LIB.  If not, write to
- * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA 02110-1301, USA.
- */
-
-#ifndef _KMETADATA_TAG_WIDGET_H_
-#define _KMETADATA_TAG_WIDGET_H_
-
-#include "nepomuk_export.h"
-
-#include <QtGui/QWidget>
-
-namespace Nepomuk {
-    class Resource;
-    class Tag;
-
-    /**
-     * TagWidget provides a simple GUI interface to assign tags.
-     * It consists of a single text line displaying the assigned
-     * tags and a menu to change the tags.
-     */
-    class NEPOMUK_EXPORT TagWidget : public QWidget
-    {
-        Q_OBJECT
-
-    public:
-        /**
-         * Creates a new TagWidget for resource. The assigned tags are loaded
-         * instantly.
-         */
-        explicit TagWidget( const Resource& resource, QWidget* parent = 0 );
-        TagWidget( QWidget* parent = 0 );
-        ~TagWidget();
-
-        /**
-         * \return The resources that are supposed to be tagged or an empty
-         * list if none have been set.
-         */
-        QList<Resource> taggedResources() const;
-
-        /**
-         * \return The list of all tags that are assigned to the currently set
-         * resource or an empty list if no resource has been set.
-         *
-         * \sa setTaggedResource, taggedResource, Resource::getTags
-         */
-        QList<Tag> assignedTags() const;
-
-    Q_SIGNALS:
-        /**
-         * This signal is emitted whenever a tag is clicked.
-         */
-        void tagClicked( Tag );
-
-    public Q_SLOTS:
-        /**
-         * Set the Resource to be tagged. The assigned tags will be loaded
-         * instantly.
-         */
-        void setTaggedResource( const Resource& resource );
-
-        void setTaggedResources( const QList<Resource>& resources );
-
-        /**
-         * Set the list of tags to be assigned to the configured resource.
-         * If no resource has been set this method does nothing.
-         *
-         * \sa setTaggedResource
-         */
-        void setAssignedTags( const QList<Tag>& tags );
-
-    private Q_SLOTS:
-        void fillTagMenu();
-        void createTag();
-        void updateAssignedTagsFromMenu();
-        void slotTagUpdateDone();
-        void slotTagClicked( const QString& text );
-
-    private:
-        class Private;
-        Private* const d;
-    };
-}
-
-#endif
+// backwards compatibility
+#include "tagwidget.h"
Index: nepomuk/core/ui/kblocklayout.cpp
===================================================================
--- nepomuk/core/ui/kblocklayout.cpp	(révision 1125741)
+++ nepomuk/core/ui/kblocklayout.cpp	(copie de travail)
@@ -21,13 +21,17 @@
 /*
   KBlockLayout is based on the FlowLayout example from QT4.
   Copyright (C) 2004-2006 Trolltech ASA. All rights reserved.
+  Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+  All rights reserved.
+  Contact: Nokia Corporation (qt-info@nokia.com)
 */
 
 #include "kblocklayout.h"
 
 #include <QtCore/QList>
+#include <QtGui/QStyle>
+#include <QtGui/QWidget>
 
-
 class KBlockLayout::Private
 {
 public:
@@ -35,24 +39,45 @@
         : alignment(Qt::AlignLeft|Qt::AlignTop) {
     }
 
+    int smartSpacing(QStyle::PixelMetric pm) const
+    {
+        QObject *parent = q->parent();
+        if (!parent) {
+            return -1;
+        } else if (parent->isWidgetType()) {
+            QWidget *pw = static_cast<QWidget *>(parent);
+            return pw->style()->pixelMetric(pm, 0, pw);
+        } else {
+            return static_cast<QLayout *>(parent)->spacing();
+        }
+    }
+
     QList<QLayoutItem*> itemList;
 
+    int m_hSpace;
+    int m_vSpace;
+
     Qt::Alignment alignment;
+
+    KBlockLayout* q;
 };
 
 
-KBlockLayout::KBlockLayout( QWidget* parent, int margin, int spacing )
+KBlockLayout::KBlockLayout( QWidget* parent, int margin, int hSpacing, int vSpacing )
     : QLayout(parent),
       d( new Private() )
 {
+    d->q = this;
     setMargin(margin);
-    setSpacing(spacing);
+    setSpacing(hSpacing, vSpacing);
 }
 
-KBlockLayout::KBlockLayout( int spacing )
+KBlockLayout::KBlockLayout( int margin, int hSpacing, int vSpacing )
     : d( new Private() )
 {
-    setSpacing(spacing);
+    d->q = this;
+    setMargin(margin);
+    setSpacing(hSpacing, vSpacing);
 }
 
 KBlockLayout::~KBlockLayout()
@@ -73,6 +98,31 @@
     return d->alignment;
 }
 
+int KBlockLayout::horizontalSpacing() const
+{
+    if (d->m_hSpace >= 0) {
+        return d->m_hSpace;
+    } else {
+        return d->smartSpacing(QStyle::PM_LayoutHorizontalSpacing);
+    }
+}
+
+int KBlockLayout::verticalSpacing() const
+{
+    if (d->m_vSpace >= 0) {
+        return d->m_vSpace;
+    } else {
+        return d->smartSpacing(QStyle::PM_LayoutVerticalSpacing);
+    }
+}
+
+void KBlockLayout::setSpacing( int h, int v )
+{
+    d->m_hSpace = h;
+    d->m_vSpace = v;
+    QLayout::setSpacing( h );
+}
+
 void KBlockLayout::addItem( QLayoutItem* item )
 {
     d->itemList.append(item);
@@ -153,15 +203,16 @@
     // 1. calculate lines
     QList<Row> rows;
     QList<QLayoutItem*> rowItems;
-    foreach( QLayoutItem* item, d->itemList ) {
-        int nextX = x + item->sizeHint().width() + spacing();
-        if (nextX - spacing() > rect.right() && lineHeight > 0) {
-            rows.append( Row( rowItems, lineHeight, x - spacing() ) );
+    for( int i = 0; i < d->itemList.count(); ++i ) {
+        QLayoutItem* item = d->itemList[i];
+        int nextX = x + item->sizeHint().width() + horizontalSpacing();
+        if (nextX - horizontalSpacing() > rect.right() && lineHeight > 0) {
+            rows.append( Row( rowItems, lineHeight, x - horizontalSpacing() ) );
             rowItems.clear();
 
             x = rect.x();
-            y = y + lineHeight + spacing();
-            nextX = x + item->sizeHint().width() + spacing();
+            y = y + lineHeight + verticalSpacing();
+            nextX = x + item->sizeHint().width() + horizontalSpacing();
             lineHeight = 0;
         }
 
@@ -171,7 +222,7 @@
         lineHeight = qMax(lineHeight, item->sizeHint().height());
     }
     // append the last row
-    rows.append( Row( rowItems, lineHeight, x ) );
+    rows.append( Row( rowItems, lineHeight, x-horizontalSpacing() ) );
 
     int finalHeight = y + lineHeight - rect.y();
     if( testOnly )
@@ -194,13 +245,13 @@
                 yy += (row.height - item->sizeHint().height())/2;
             item->setGeometry(QRect(QPoint(x, yy), item->sizeHint()));
 
-            x += item->sizeHint().width() + spacing();
+            x += item->sizeHint().width() + horizontalSpacing();
 
             if( alignment() & Qt::AlignJustify )
                 x += (rect.width() - row.width)/qMax(row.items.count()-1,1);
         }
 
-        y = y + row.height + spacing();
+        y = y + row.height + verticalSpacing();
     }
 
     return finalHeight;
Index: nepomuk/core/ui/kratingwidget.cpp
===================================================================
--- nepomuk/core/ui/kratingwidget.cpp	(révision 1125741)
+++ nepomuk/core/ui/kratingwidget.cpp	(copie de travail)
@@ -162,9 +162,13 @@
 
 void KRatingWidget::setRating( int rating )
 {
-    d->rating = rating;
-    d->hoverRating = rating;
-    update();
+    if ( rating != d->rating ) {
+        d->rating = rating;
+        d->hoverRating = rating;
+        emit ratingChanged( rating );
+        emit ratingChanged( (unsigned int)rating );
+        update();
+    }
 }
 
 
@@ -197,10 +201,8 @@
 void KRatingWidget::mousePressEvent( QMouseEvent* e )
 {
     if ( e->button() == Qt::LeftButton ) {
-        d->hoverRating = d->rating = d->ratingPainter.ratingFromPosition( contentsRect(), e->pos() );
-        update();
-        emit ratingChanged( d->rating );
-        emit ratingChanged( (unsigned int)d->rating );
+        d->hoverRating = d->ratingPainter.ratingFromPosition( contentsRect(), e->pos() );
+        setRating( d->hoverRating );
     }
 }
 
@@ -208,13 +210,14 @@
 void KRatingWidget::mouseMoveEvent( QMouseEvent* e )
 {
     // when moving the mouse we show the user what the result of clicking will be
+    const int prevHoverRating = d->hoverRating;
     d->hoverRating = d->ratingPainter.ratingFromPosition( contentsRect(), e->pos() );
+    if ( d->hoverRating != prevHoverRating ) {
+        update();
+    }
     if ( d->hoverRating >= 0 && e->buttons() & Qt::LeftButton ) {
-        d->rating = d->hoverRating;
-        emit ratingChanged( d->rating );
-        emit ratingChanged( (unsigned int)d->rating );
+        setRating( d->hoverRating );
     }
-    update();
 }
 
 
Index: nepomuk/core/ui/tagwidget_p.h
===================================================================
--- nepomuk/core/ui/tagwidget_p.h	(révision 0)
+++ nepomuk/core/ui/tagwidget_p.h	(révision 0)
@@ -0,0 +1,70 @@
+/*
+ * This file is part of the Nepomuk KDE project.
+ * Copyright (C) 2006-2010 Sebastian Trueg <trueg@kde.org>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public License
+ * along with this library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifndef _NEPOMUK_TAG_WIDGET_P_H_
+#define _NEPOMUK_TAG_WIDGET_P_H_
+
+#include "tagwidget.h"
+#include "../tag.h"
+
+#include <QtCore/QList>
+#include <QtCore/QMap>
+
+class QPushButton;
+class QLabel;
+class KBlockLayout;
+
+namespace Nepomuk {
+
+class TagCheckBox;
+
+class TagWidgetPrivate
+{
+public:
+    void init( TagWidget* parent );
+    void rebuild();
+    void buildTagHash( const QList<Tag>& tags );
+    QList<Tag> loadTags( int max );
+    QList<Tag> intersectResourceTags();
+
+    /// lookup (and if necessary create) checkbox for tag
+    TagCheckBox* getTagCheckBox( const Tag& tag );
+
+    /// check the corresponding checkboxes and even
+    /// add missing checkboxes
+    void selectTags( const QList<Tag>& tags );
+
+    /// start a massupdate job to set the selected tags on the resources
+    void updateResources();
+
+    QList<Resource> m_resources;
+    int m_maxTags;
+    TagWidget::ModeFlags m_flags;
+    bool m_blockSelectionChangedSignal;
+
+    QMap<Tag, TagCheckBox*> m_checkBoxHash;
+    QPushButton* m_showAllButton;
+    QLabel* m_showAllLinkLabel;
+    KBlockLayout* m_flowLayout;
+    TagWidget* q;
+};
+}
+
+#endif

Modification de propriétés sur nepomuk/core/ui/tagwidget_p.h
___________________________________________________________________
Ajouté : svn:eol-style
   + native

Index: nepomuk/core/ui/nepomukmassupdatejob.h
===================================================================
--- nepomuk/core/ui/nepomukmassupdatejob.h	(révision 1125741)
+++ nepomuk/core/ui/nepomukmassupdatejob.h	(copie de travail)
@@ -34,12 +34,28 @@
 
 
 namespace Nepomuk {
-    class MassUpdateJob : public KJob
+    /**
+     * \class MassUpdateJob nepomukmassupdatejob.h Nepomuk/MassUpdateJob
+     *
+     * \brief A KJob to set Nepomuk properties on a set of resources at once.
+     *
+     * \author Sebastian Trueg <trueg@kde.org>
+     */
+    class NEPOMUK_EXPORT MassUpdateJob : public KJob
     {
         Q_OBJECT
 
     public:
+        /**
+         * Default constructor. Normally there is no need to use this.
+         * Use tagResources(), rateResources(), or commentResources()
+         * instead.
+         */
         MassUpdateJob( QObject* parent = 0 );
+
+        /**
+         * Destructor
+         */
         ~MassUpdateJob();
 
         /**
@@ -57,7 +73,7 @@
         /**
          * Set the properties to change in the mass update.
          */
-        void setProperties( const QList<QPair<QUrl,Nepomuk::Variant> >& props );
+        void setProperties( const QList<QPair<QUrl, Nepomuk::Variant> >& props );
 
         /**
          * Actually start the job.
@@ -66,6 +82,7 @@
 
         static MassUpdateJob* tagResources( const QList<Nepomuk::Resource>&, const QList<Nepomuk::Tag>& tags );
         static MassUpdateJob* rateResources( const QList<Nepomuk::Resource>&, int rating );
+        static MassUpdateJob* commentResources( const QList<Nepomuk::Resource>&, const QString& comment);
 
     protected:
         bool doKill();
Index: nepomuk/core/ui/kblocklayout.h
===================================================================
--- nepomuk/core/ui/kblocklayout.h	(révision 1125741)
+++ nepomuk/core/ui/kblocklayout.h	(copie de travail)
@@ -36,8 +36,8 @@
 class KBlockLayout : public QLayout
 {
  public:
-    explicit KBlockLayout( QWidget *parent, int margin = 0, int spacing = -1 );
-    KBlockLayout( int spacing = -1 );
+    explicit KBlockLayout( QWidget *parent, int margin = 0, int hSpacing = -1, int vSpacing = -1 );
+    KBlockLayout( int margin = 0, int hSpacing = -1, int vSpacing = -1 );
     ~KBlockLayout();
 
     /**
@@ -50,6 +50,11 @@
     void setAlignment( Qt::Alignment );
     Qt::Alignment alignment() const;
 
+    int horizontalSpacing() const;
+    int verticalSpacing() const;
+
+    void setSpacing( int h,  int v );
+
     void addItem( QLayoutItem* item );
     Qt::Orientations expandingDirections() const;
     bool hasHeightForWidth() const;
Index: nepomuk/core/ui/kratingwidget.h
===================================================================
--- nepomuk/core/ui/kratingwidget.h	(révision 1125741)
+++ nepomuk/core/ui/kratingwidget.h	(copie de travail)
@@ -26,6 +26,8 @@
 #include "nepomuk_export.h"
 
 /**
+ * \class KRatingWidget kratingwidget.h Nepomuk/KRatingWidget
+ *
  * \brief Displays a rating value as a row of pixmaps.
  *
  * The KRatingWidget displays a range of stars or other arbitrary
@@ -69,7 +71,7 @@
 
     /**
      * The layout direction. If RTL the stars
-     * representing the rating value will be drawn from the 
+     * representing the rating value will be drawn from the
      * right.
      *
      * \sa setLayoutDirection
@@ -104,21 +106,20 @@
 
  Q_SIGNALS:
     /**
-     * Emitted if the rating is changed by user interaction (ie. mouse click).
-     * A call to setRating does not trigger this signal.
+     * This signal is emitted when the rating is changed.
      */
     void ratingChanged( unsigned int rating );
     void ratingChanged( int rating );
 
  public Q_SLOTS:
     /**
-     * Set the current rating. Calling this method will NOT trigger the
-     * ratingChanged signal.
+     * Set the current rating. Calling this method will trigger the
+     * ratingChanged signal if @p rating is different from the previous rating.
      */
     void setRating( int rating );
 
     /**
-     * \deprecated use setRating( int max )
+     * \deprecated use setRating( int rating )
      */
     KDE_DEPRECATED void setRating( unsigned int rating );
 
Index: nepomuk/core/ui/tagwidget.cpp
===================================================================
--- nepomuk/core/ui/tagwidget.cpp	(révision 0)
+++ nepomuk/core/ui/tagwidget.cpp	(révision 0)
@@ -0,0 +1,387 @@
+/*
+ * This file is part of the Nepomuk KDE project.
+ * Copyright (C) 2006-2010 Sebastian Trueg <trueg@kde.org>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public License
+ * along with this library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#include "tagwidget.h"
+#include "tagwidget_p.h"
+#include "kblocklayout.h"
+#include "nepomukmassupdatejob.h"
+#include "kedittagsdialog_p.h"
+#include "tagcheckbox.h"
+
+#include "../tools.h"
+#include "../tag.h"
+#include "../resourcemanager.h"
+
+#include <karrowbutton.h>
+#include <kinputdialog.h>
+#include <kmessagebox.h>
+#include <klocale.h>
+#include <kglobalsettings.h>
+#include <kdebug.h>
+
+#include <QtGui/QPushButton>
+#include <QtGui/QBoxLayout>
+#include <QtGui/QLabel>
+#include <QtCore/QSet>
+
+#include <Soprano/QueryResultIterator>
+#include <Soprano/Node>
+#include <Soprano/Model>
+#include <Soprano/Vocabulary/NAO>
+
+
+void Nepomuk::TagWidgetPrivate::init( TagWidget* parent )
+{
+    q = parent;
+    m_maxTags = 10;
+    m_flags = TagWidget::StandardMode;
+    m_blockSelectionChangedSignal = false;
+    m_showAllLinkLabel = 0;
+
+    QGridLayout* mainLayout = new QGridLayout( q );
+    mainLayout->setMargin(0);
+    m_flowLayout = new KBlockLayout( 0, KDialog::spacingHint()*3 );
+    m_showAllButton = new QPushButton( i18nc("@label", "Show all tags..."), q );
+    q->connect( m_showAllButton, SIGNAL(clicked()), SLOT(slotShowAll()) );
+    mainLayout->addLayout( m_flowLayout, 0, 0, 1, 2 );
+    mainLayout->addWidget( m_showAllButton, 1, 1, 1, 1 );
+    mainLayout->setColumnStretch( 0, 1 );
+
+    rebuild();
+}
+
+
+void Nepomuk::TagWidgetPrivate::rebuild()
+{
+    if( m_flags & TagWidget::MiniMode ) {
+        buildTagHash( q->selectedTags() );
+    }
+    else {
+        QList<Tag> tags = q->selectedTags();
+        buildTagHash( loadTags( m_maxTags ) );
+        selectTags( tags );
+    }
+}
+
+
+void Nepomuk::TagWidgetPrivate::buildTagHash( const QList<Tag>& tags )
+{
+    qDeleteAll(m_checkBoxHash);
+    m_checkBoxHash.clear();
+
+    foreach( const Nepomuk::Tag& tag, tags ) {
+        getTagCheckBox( tag );
+    }
+
+    delete m_showAllLinkLabel;
+    m_showAllLinkLabel = 0;
+
+    if( m_flags & TagWidget::MiniMode ) {
+        if( !(m_flags&TagWidget::ReadOnly) ) {
+            m_showAllLinkLabel = new QLabel( q );
+            m_flowLayout->addWidget( m_showAllLinkLabel );
+            QFont f(q->font());
+            f.setUnderline(true);
+            m_showAllLinkLabel->setFont(f);
+            m_showAllLinkLabel->setText( QLatin1String("<a href=\"add_tags\">") +
+                                         ( m_checkBoxHash.isEmpty() ? i18nc("@label", "Add Tags...") : i18nc("@label", "Change...") ) +
+                                         QLatin1String("</a>") );
+            q->connect( m_showAllLinkLabel, SIGNAL(linkActivated(QString)), SLOT(slotShowAll()) );
+            m_showAllButton->hide();
+        }
+    }
+    else {
+        m_showAllButton->setShown( !(m_flags&TagWidget::ReadOnly) );
+    }
+}
+
+
+QList<Nepomuk::Tag> Nepomuk::TagWidgetPrivate::loadTags( int max )
+{
+    // get the "max" first tags with the most resources
+    QString query = QString::fromLatin1("select ?r count(distinct ?f) as ?c where { "
+                                        "?r a %1 . "
+                                        "?f %2 ?r . "
+                                        "} ORDER BY DESC(?c) LIMIT %3")
+                    .arg( Soprano::Node::resourceToN3(Soprano::Vocabulary::NAO::Tag()),
+                          Soprano::Node::resourceToN3(Soprano::Vocabulary::NAO::hasTag()))
+                    .arg( max );
+    QList<Nepomuk::Tag> tags;
+    Soprano::QueryResultIterator it = ResourceManager::instance()->mainModel()->executeQuery( query, Soprano::Query::QueryLanguageSparql );
+    while( it.next() ) {
+        // workaround for bug in Virtuoso where resources are returned as strings if a count() is in the select clause
+        tags << Tag( KUrl(it["r"].toString()) );
+    }
+    return tags;
+}
+
+
+QList<Nepomuk::Tag> Nepomuk::TagWidgetPrivate::intersectResourceTags()
+{
+    if ( m_resources.count() == 1 ) {
+        return m_resources.first().tags();
+    }
+    else if ( !m_resources.isEmpty() ) {
+        // determine the tags used for all resources
+        QSet<Tag> tags = QSet<Tag>::fromList( m_resources.first().tags() );
+        QList<Resource>::const_iterator it = m_resources.constBegin();
+        for ( ++it; it != m_resources.constEnd(); ++it ) {
+            tags.intersect( QSet<Tag>::fromList( (*it).tags() ) );
+        }
+        return tags.values();
+    }
+    else {
+        return QList<Tag>();
+    }
+}
+
+
+Nepomuk::TagCheckBox* Nepomuk::TagWidgetPrivate::getTagCheckBox( const Tag& tag )
+{
+    QMap<Tag, TagCheckBox*>::iterator it = m_checkBoxHash.find(tag);
+    if( it == m_checkBoxHash.end() ) {
+        kDebug() << "Creating checkbox for" << tag.genericLabel();
+        TagCheckBox* checkBox = new TagCheckBox( tag, this, q );
+        q->connect( checkBox, SIGNAL(tagClicked(Nepomuk::Tag)), SIGNAL(tagClicked(Nepomuk::Tag)) );
+        q->connect( checkBox, SIGNAL(tagStateChanged(Nepomuk::Tag, int)), SLOT(slotTagStateChanged(Nepomuk::Tag, int)) );
+        m_checkBoxHash.insert( tag, checkBox );
+        m_flowLayout->addWidget( checkBox );
+        return checkBox;
+    }
+    else {
+        return it.value();
+    }
+}
+
+namespace Nepomuk {
+/// operator necessary for QMap::erase
+bool operator<(const Tag& t1, const Tag& t2) {
+    return t1.resourceUri() < t2.resourceUri();
+}
+}
+
+void Nepomuk::TagWidgetPrivate::selectTags( const QList<Tag>& tags )
+{
+    m_blockSelectionChangedSignal = true;
+
+    if( m_flags & TagWidget::MiniMode ) {
+        buildTagHash( tags );
+    }
+    else {
+        foreach( TagCheckBox* checkBox, m_checkBoxHash ) {
+            checkBox->setChecked( false );
+        }
+
+        foreach( const Tag& tag, tags ) {
+            getTagCheckBox(tag)->setChecked( true );
+        }
+
+        // remove the previously added check boxes which are not amongst
+        // the top 10 or remove as many check boxes as possible to get down to
+        // m_maxTags
+        if( !m_checkBoxHash.isEmpty() ) {
+            int r = qMax( m_checkBoxHash.count() - m_maxTags, 0 );
+            QMap<Tag, TagCheckBox*>::iterator it = m_checkBoxHash.end();
+            --it;
+            while( r > 0 ) {
+
+                // stop the loop when we reach the beginning of the hash
+                bool end = ( it == m_checkBoxHash.begin() );
+
+                // remove unused checkboxes
+                if( !it.value()->isChecked() ) {
+                    delete it.value();
+                    it = m_checkBoxHash.erase(it);
+                    --r;
+                }
+
+                if( end ) {
+                    break;
+                }
+                else {
+                    --it;
+                }
+            }
+        }
+    }
+
+    m_blockSelectionChangedSignal = false;
+}
+
+
+void Nepomuk::TagWidgetPrivate::updateResources()
+{
+    if ( !m_resources.isEmpty() ) {
+        Nepomuk::MassUpdateJob* job = Nepomuk::MassUpdateJob::tagResources( m_resources, q->selectedTags() );
+        q->connect( job, SIGNAL( result( KJob* ) ),
+                    SLOT( slotTagUpdateDone() ) );
+        q->setEnabled( false ); // no updates during execution
+        job->start();
+    }
+}
+
+
+Nepomuk::TagWidget::TagWidget( const Resource& resource, QWidget* parent )
+    : QWidget( parent ),
+      d( new TagWidgetPrivate() )
+{
+    d->init( this );
+    setTaggedResource( resource );
+}
+
+
+Nepomuk::TagWidget::TagWidget( QWidget* parent )
+    : QWidget( parent ),
+      d( new TagWidgetPrivate() )
+{
+    d->init( this );
+}
+
+
+Nepomuk::TagWidget::~TagWidget()
+{
+    delete d;
+}
+
+
+QList<Nepomuk::Resource> Nepomuk::TagWidget::taggedResources() const
+{
+    return d->m_resources;
+}
+
+
+QList<Nepomuk::Tag> Nepomuk::TagWidget::assignedTags() const
+{
+    return selectedTags();
+}
+
+
+QList<Nepomuk::Tag> Nepomuk::TagWidget::selectedTags() const
+{
+    QList<Nepomuk::Tag> tags;
+    QMapIterator<Tag, TagCheckBox*> it( d->m_checkBoxHash );
+    while( it.hasNext() ) {
+        it.next();
+        if( it.value()->isChecked() )
+            tags << it.key();
+    }
+    return tags;
+}
+
+
+int Nepomuk::TagWidget::maxTagsShown() const
+{
+    return d->m_maxTags;
+}
+
+
+Qt::Alignment Nepomuk::TagWidget::alignment() const
+{
+    return d->m_flowLayout->alignment();
+}
+
+
+Nepomuk::TagWidget::ModeFlags Nepomuk::TagWidget::modeFlags() const
+{
+    return d->m_flags;
+}
+
+
+void Nepomuk::TagWidget::setTaggedResource( const Resource& resource )
+{
+    QList<Resource> l;
+    l.append( resource );
+    setTaggedResources( l );
+}
+
+
+void Nepomuk::TagWidget::setTaggedResources( const QList<Resource>& resources )
+{
+    // reset selection to a sensible default
+    d->buildTagHash( d->loadTags( d->m_maxTags ) );
+
+    d->m_resources = resources;
+    if ( !resources.isEmpty() ) {
+        d->selectTags( d->intersectResourceTags() );
+    }
+    else {
+        d->selectTags( QList<Tag>() );
+    }
+}
+
+
+void Nepomuk::TagWidget::setAssignedTags( const QList<Tag>& tags )
+{
+    setSelectedTags( tags );
+}
+
+
+void Nepomuk::TagWidget::setSelectedTags( const QList<Nepomuk::Tag>& tags )
+{
+    d->selectTags( tags );
+    d->updateResources();
+}
+
+
+void Nepomuk::TagWidget::setMaxTagsShown( int max )
+{
+    d->m_maxTags = max;
+    setTaggedResources( d->m_resources );
+}
+
+
+void Nepomuk::TagWidget::setAlignment( Qt::Alignment alignment )
+{
+    d->m_flowLayout->setAlignment( alignment );
+}
+
+
+void Nepomuk::TagWidget::setModeFlags( ModeFlags flags )
+{
+    d->m_flags = flags;
+    d->rebuild();
+}
+
+
+void Nepomuk::TagWidget::slotTagUpdateDone()
+{
+    setEnabled( true );
+}
+
+
+void Nepomuk::TagWidget::slotShowAll()
+{
+    KEditTagsDialog dlg( selectedTags(), this );
+    if( dlg.exec() ) {
+        setSelectedTags( dlg.tags() );
+        emit selectionChanged( selectedTags() );
+    }
+}
+
+
+void Nepomuk::TagWidget::slotTagStateChanged( const Nepomuk::Tag&, int )
+{
+    if( !d->m_blockSelectionChangedSignal ) {
+        d->updateResources();
+        emit selectionChanged( selectedTags() );
+    }
+}
+
+#include "tagwidget.moc"

Modification de propriétés sur nepomuk/core/ui/tagwidget.cpp
___________________________________________________________________
Ajouté : svn:eol-style
   + native

Index: nepomuk/core/ui/tagcheckbox.cpp
===================================================================
--- nepomuk/core/ui/tagcheckbox.cpp	(révision 0)
+++ nepomuk/core/ui/tagcheckbox.cpp	(révision 0)
@@ -0,0 +1,169 @@
+/*
+   This file is part of the Nepomuk KDE project.
+   Copyright (C) 2010 Sebastian Trueg <trueg@kde.org>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) version 3, or any
+   later version accepted by the membership of KDE e.V. (or its
+   successor approved by the membership of KDE e.V.), which shall
+   act as a proxy defined in Section 6 of version 3 of the license.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include "tagcheckbox.h"
+#include "tagwidget.h"
+#include "tagwidget_p.h"
+
+#include <kcursor.h>
+#include <kcolorscheme.h>
+#include <kglobalsettings.h>
+
+#include <QtGui/QMouseEvent>
+#include <QtGui/QStyleOptionButton>
+#include <QtGui/QHBoxLayout>
+#include <QtGui/QCheckBox>
+#include <QtGui/QLabel>
+
+
+class Nepomuk::TagCheckBox::CheckBoxWithPublicInitStyleOption : public QCheckBox
+{
+public:
+    CheckBoxWithPublicInitStyleOption( const QString& text, QWidget* parent )
+        : QCheckBox( text, parent ) {
+    }
+
+    void initStyleOption( QStyleOptionButton* so ) {
+        QCheckBox::initStyleOption( so );
+    }
+};
+
+
+Nepomuk::TagCheckBox::TagCheckBox( const Tag& tag, TagWidgetPrivate* tagWidget, QWidget* parent )
+    : QWidget( parent ),
+      m_label(0),
+      m_checkBox(0),
+      m_tag(tag),
+      m_urlHover(false),
+      m_tagWidget(tagWidget)
+{
+    QHBoxLayout* layout = new QHBoxLayout(this);
+    layout->setMargin(0);
+    if( tagWidget->m_flags & TagWidget::MiniMode ) {
+        setFont(KGlobalSettings::smallestReadableFont());
+        m_label = new QLabel( tag.genericLabel(), this );
+        m_label->setMouseTracking(true);
+        m_child = m_label;
+    }
+    else {
+        m_checkBox = new CheckBoxWithPublicInitStyleOption( tag.genericLabel(), this );
+        m_child = m_checkBox;
+        connect(m_checkBox, SIGNAL(stateChanged(int)), this, SLOT(slotStateChanged(int)));
+    }
+    m_child->installEventFilter( this );
+    m_child->setMouseTracking(true);
+    layout->addWidget( m_child );
+    m_font = font();
+}
+
+
+Nepomuk::TagCheckBox::~TagCheckBox()
+{
+}
+
+
+bool Nepomuk::TagCheckBox::isChecked() const
+{
+    if( m_checkBox )
+        return m_checkBox->isChecked();
+    else
+        return true;
+}
+
+
+void Nepomuk::TagCheckBox::setChecked( bool checked )
+{
+    if( m_checkBox )
+        m_checkBox->setChecked( checked );
+}
+
+
+void Nepomuk::TagCheckBox::leaveEvent( QEvent* event )
+{
+    QWidget::leaveEvent( event );
+    enableUrlHover( false );
+}
+
+
+bool Nepomuk::TagCheckBox::eventFilter( QObject* watched, QEvent* event )
+{
+    if( watched == m_child ) {
+        switch( event->type() ) {
+        case QEvent::MouseMove: {
+            QMouseEvent* me = static_cast<QMouseEvent*>(event);
+            if( !(m_tagWidget->m_flags & TagWidget::DisableTagClicking) )
+                enableUrlHover( tagRect().contains(me->pos()) );
+        }
+
+        case QEvent::MouseButtonRelease: {
+            QMouseEvent* me = static_cast<QMouseEvent*>(event);
+            if( !(m_tagWidget->m_flags & TagWidget::DisableTagClicking) &&
+                me->button() == Qt::LeftButton &&
+                tagRect().contains(me->pos()) ) {
+                emit tagClicked( m_tag );
+                return true;
+            }
+        }
+
+        default:
+            // do nothing
+            break;
+        }
+    }
+
+    return QWidget::eventFilter( watched, event );
+}
+
+
+void Nepomuk::TagCheckBox::slotStateChanged( int state )
+{
+    emit tagStateChanged( m_tag, state );
+}
+
+
+QRect Nepomuk::TagCheckBox::tagRect() const
+{
+    if( m_checkBox ) {
+        QStyleOptionButton opt;
+        m_checkBox->initStyleOption(&opt);
+        return style()->subElementRect(QStyle::SE_CheckBoxContents,
+                                       &opt,
+                                       m_checkBox);
+    }
+    else {
+        return QRect(QPoint(0, 0), m_label->size());
+    }
+}
+
+
+void Nepomuk::TagCheckBox::enableUrlHover( bool enable )
+{
+    if( m_urlHover != enable ) {
+        m_urlHover = enable;
+        QFont f(m_font);
+        if(enable)
+            f.setUnderline(true);
+        m_child->setFont(f);
+        m_child->setCursor( enable ? Qt::PointingHandCursor : Qt::ArrowCursor );
+    }
+}
+
+#include "tagcheckbox.moc"

Modification de propriétés sur nepomuk/core/ui/tagcheckbox.cpp
___________________________________________________________________
Ajouté : svn:eol-style
   + native

Index: nepomuk/core/ui/kedittagsdialog_p.h
===================================================================
--- nepomuk/core/ui/kedittagsdialog_p.h	(révision 0)
+++ nepomuk/core/ui/kedittagsdialog_p.h	(révision 0)
@@ -0,0 +1,78 @@
+/*****************************************************************************
+ * Copyright (C) 2009 by Peter Penz <peter.penz@gmx.at>                      *
+ *                                                                           *
+ * This library is free software; you can redistribute it and/or             *
+ * modify it under the terms of the GNU Library General Public               *
+ * License version 2 as published by the Free Software Foundation.           *
+ *                                                                           *
+ * This library is distributed in the hope that it will be useful,           *
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of            *
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU         *
+ * Library General Public License for more details.                          *
+ *                                                                           *
+ * You should have received a copy of the GNU Library General Public License *
+ * along with this library; see the file COPYING.LIB.  If not, write to      *
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,      *
+ * Boston, MA 02110-1301, USA.                                               *
+ *****************************************************************************/
+
+#ifndef KEDIT_TAGS_DIALOG_H
+#define KEDIT_TAGS_DIALOG_H
+
+#include <kdialog.h>
+#include <tag.h>
+
+class KLineEdit;
+class QListWidget;
+class QListWidgetItem;
+class QPushButton;
+class QTimer;
+
+/**
+ * @brief Dialog to edit a list of Nepomuk tags.
+ *
+ * It is possible for the user to add existing tags,
+ * create new tags or to remove tags.
+ *
+ * @see KMetaDataConfigurationDialog
+ */
+class KEditTagsDialog : public KDialog
+{
+    Q_OBJECT
+
+public:
+    KEditTagsDialog(const QList<Nepomuk::Tag>& tags,
+                    QWidget* parent = 0,
+                    Qt::WFlags flags = 0);
+
+    virtual ~KEditTagsDialog();
+
+    QList<Nepomuk::Tag> tags() const;
+
+    virtual bool eventFilter(QObject* watched, QEvent* event);
+
+protected slots:
+    virtual void slotButtonClicked(int button);
+
+private slots:
+    void slotTextEdited(const QString& text);
+    void slotItemEntered(QListWidgetItem* item);
+    void showDeleteButton();
+    void deleteTag();
+
+private:
+    void loadTags();
+    void removeNewTagItem();
+
+private:
+    QList<Nepomuk::Tag> m_tags;
+    QListWidget* m_tagsList;
+    QListWidgetItem* m_newTagItem;
+    QListWidgetItem* m_deleteCandidate;
+    KLineEdit* m_newTagEdit;
+
+    QPushButton* m_deleteButton;
+    QTimer* m_deleteButtonTimer;
+};
+
+#endif

Modification de propriétés sur nepomuk/core/ui/kedittagsdialog_p.h
___________________________________________________________________
Ajouté : svn:eol-style
   + native

Index: nepomuk/core/ui/tagwidget.h
===================================================================
--- nepomuk/core/ui/tagwidget.h	(révision 0)
+++ nepomuk/core/ui/tagwidget.h	(révision 0)
@@ -0,0 +1,237 @@
+/*
+ * This file is part of the Nepomuk KDE project.
+ * Copyright (C) 2006-2010 Sebastian Trueg <trueg@kde.org>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public License
+ * along with this library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifndef _NEPOMUK_TAG_WIDGET_H_
+#define _NEPOMUK_TAG_WIDGET_H_
+
+#include "nepomuk_export.h"
+
+#include <QtGui/QWidget>
+
+namespace Nepomuk {
+    class Resource;
+    class Tag;
+    class TagWidgetPrivate;
+
+    /**
+     * \class TagWidget tagwidget.h Nepomuk/TagWidget
+     *
+     * \brief Allows to change a selection of tags.
+     *
+     * TagWidget provides a simple GUI interface to assign tags.
+     * It has two basic modes:
+     * \li If resources are set via setTaggedResource() or setTaggedResources()
+     * the changes in the tag selection are automatically assigned to the
+     * selected resources.
+     * \li If no resources have been set the widget simply emits the selectionChanged()
+     * signal.
+     *
+     * \author Sebastian Trueg <trueg@kde.org>
+     */
+    class NEPOMUK_EXPORT TagWidget : public QWidget
+    {
+        Q_OBJECT
+
+    public:
+        /**
+         * Creates a new TagWidget for resource. The assigned tags are loaded
+         * instantly.
+         */
+        explicit TagWidget( const Resource& resource, QWidget* parent = 0 );
+
+        /**
+         * Constructor
+         */
+        TagWidget( QWidget* parent = 0 );
+
+        /**
+         * Desctructor
+         */
+        ~TagWidget();
+
+        /**
+         * \return The resources that are supposed to be tagged or an empty
+         * list if none have been set.
+         */
+        QList<Resource> taggedResources() const;
+
+        /**
+         * \deprecated use selectedTags() instead
+         */
+        KDE_DEPRECATED QList<Tag> assignedTags() const;
+
+        /**
+         * The list of selected tags.
+         *
+         * \return The list of all tags that are currently selected. In case
+         * resources to be tagged have been selected this list matches the
+         * tags assigned to the resources.
+         *
+         * \sa setTaggedResource, taggedResource, Resource::getTags
+         *
+         * \since 4.5
+         */
+        QList<Nepomuk::Tag> selectedTags() const;
+
+        /**
+         * By default the TagWidget shows the most often used tags in the
+         * main window and allows access to all tags via an additional button.
+         * This is the maximum number of tags that should be shown unless they
+         * are selected.
+         *
+         * \sa setMaxTagsShown()
+         *
+         * \since 4.5
+         */
+        int maxTagsShown() const;
+
+        /**
+         * The alignment of the tags in the widget.
+         *
+         * \since 4.5
+         */
+        Qt::Alignment alignment() const;
+
+        /**
+         * Flags to configure the widget.
+         *
+         * \since 4.5
+         */
+        enum ModeFlag {
+            /**
+             * The mini mode which tries to
+             * display the tags on the least
+             * space possible.
+             */
+            MiniMode = 0x1,
+
+            /**
+             * The standard mode which is used by default
+             * provides a set of check boxes for the most
+             * frequently used tags.
+             */
+            StandardMode = 0x2,
+
+            /**
+             * Read only mode which prevents the changing
+             * of tags by the user.
+             */
+            ReadOnly = 0x4,
+
+            /**
+             * Disable the clicking of the tags. This will
+             * also disable the emitting of the tagClicked()
+             * signal.
+             */
+            DisableTagClicking = 0x8
+        };
+        Q_DECLARE_FLAGS( ModeFlags, ModeFlag )
+
+        /**
+         * Flags the widget is configured with.
+         *
+         * \sa setModeFlags()
+         *
+         * \since 4.5
+         */
+        ModeFlags modeFlags() const;
+
+    Q_SIGNALS:
+        /**
+         * This signal is emitted whenever a tag is clicked.
+         */
+        void tagClicked( Nepomuk::Tag );
+
+        /**
+         * Emitted whenever the selection of tags changes.
+         *
+         * \since 4.5
+         */
+        void selectionChanged( const QList<Nepomuk::Tag>& tags );
+
+    public Q_SLOTS:
+        /**
+         * Set the Resource to be tagged. The assigned tags will be loaded
+         * instantly.
+         */
+        void setTaggedResource( const Resource& resource );
+
+        /**
+         * Set the resources to be tagged. If the list of resources is
+         * empty TagWidget will only emit the selectionChanged() signal.
+         */
+        void setTaggedResources( const QList<Resource>& resources );
+
+        /**
+         * \deprecated use setSelectedTags() instead
+         */
+        KDE_DEPRECATED void setAssignedTags( const QList<Nepomuk::Tag>& tags );
+
+        /**
+         * Set the list of selected tags. In case resources have been
+         * set via setTaggedResource() or setTaggedResources() their
+         * list of tags is changed automatically.
+         *
+         * \since 4.5
+         */
+        void setSelectedTags( const QList<Nepomuk::Tag>& tags );
+
+        /**
+         * By default the TagWidget shows the most often used tags in the
+         * main window and allows access to all tags via an additional button.
+         *
+         * The number of tags that are shown by default can be changed.
+         *
+         * \param max The maximum number of tags that should be shown in the
+         * main window. Set to 0 for no limit. Be aware that more tags might be
+         * shown since selected tags are always shown.
+         *
+         * \since 4.5
+         */
+        void setMaxTagsShown( int max );
+
+        /**
+         * Set the alignment to use. Only horizontal alignment flags make a
+         * difference.
+         *
+         * \since 4.5
+         */
+        void setAlignment( Qt::Alignment alignment );
+
+        /**
+         * Set flags to change the behaviour and look of the tag widget.
+         *
+         * \since 4.5
+         */
+        void setModeFlags( ModeFlags flags );
+
+    private Q_SLOTS:
+        void slotShowAll();
+        void slotTagUpdateDone();
+        void slotTagStateChanged( const Nepomuk::Tag&, int );
+
+    private:
+        TagWidgetPrivate* const d;
+    };
+}
+
+Q_DECLARE_OPERATORS_FOR_FLAGS( Nepomuk::TagWidget::ModeFlags )
+
+#endif

Modification de propriétés sur nepomuk/core/ui/tagwidget.h
___________________________________________________________________
Ajouté : svn:eol-style
   + native

Index: nepomuk/core/ui/kratingpainter.h
===================================================================
--- nepomuk/core/ui/kratingpainter.h	(révision 1125741)
+++ nepomuk/core/ui/kratingpainter.h	(copie de travail)
@@ -33,6 +33,8 @@
 
 
 /**
+ * \class KRatingPainter kratingpainter.h Nepomuk/KRatingPainter
+ *
  * \brief Utility class that draws a row of stars for a rating value.
  *
  * The KRatingPainter also allows to determine a rating value from
@@ -54,7 +56,7 @@
      * should be sufficient.
      */
     KRatingPainter();
-        
+
     /**
      * Destructor
      */
@@ -86,7 +88,7 @@
 
     /**
      * The layout direction. If RTL the stars
-     * representing the rating value will be drawn from the 
+     * representing the rating value will be drawn from the
      * right.
      *
      * \sa setLayoutDirection
@@ -134,7 +136,7 @@
      * one rating step corresponds to half a star.
      */
     void setHalfStepsEnabled( bool enabled );
-        
+
     /**
      * The alignment of the stars in the drawing rect.
      * All alignment flags are supported.
Index: nepomuk/core/ui/tagcheckbox.h
===================================================================
--- nepomuk/core/ui/tagcheckbox.h	(révision 0)
+++ nepomuk/core/ui/tagcheckbox.h	(révision 0)
@@ -0,0 +1,78 @@
+/*
+   This file is part of the Nepomuk KDE project.
+   Copyright (C) 2010 Sebastian Trueg <trueg@kde.org>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) version 3, or any
+   later version accepted by the membership of KDE e.V. (or its
+   successor approved by the membership of KDE e.V.), which shall
+   act as a proxy defined in Section 6 of version 3 of the license.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef _NEPOMUK_TAG_CHECKBOX_H_
+#define _NEPOMUK_TAG_CHECKBOX_H_
+
+#include <QtGui/QWidget>
+#include <QtGui/QFont>
+
+#include "../tag.h"
+#include "tagwidget_p.h"
+
+class QMouseEvent;
+class QLabel;
+
+namespace Nepomuk {
+class TagCheckBox : public QWidget
+{
+    Q_OBJECT
+
+public:
+    TagCheckBox( const Tag& tag, TagWidgetPrivate* tagWidget, QWidget* parent = 0 );
+    ~TagCheckBox();
+
+    Tag tag() const { return m_tag; }
+
+    bool isChecked() const;
+
+public Q_SLOTS:
+    void setChecked( bool checked );
+
+Q_SIGNALS:
+    void tagClicked( const Nepomuk::Tag& tag );
+    void tagStateChanged( const Nepomuk::Tag& tag, int state );
+
+protected:
+    void leaveEvent( QEvent* event );
+    bool eventFilter( QObject* watched, QEvent* event );
+
+private Q_SLOTS:
+    void slotStateChanged( int state );
+
+private:
+    QRect tagRect() const;
+    void enableUrlHover( bool enabled );
+
+    // two modes: checkbox and simple label
+    QLabel* m_label;
+    class CheckBoxWithPublicInitStyleOption;
+    CheckBoxWithPublicInitStyleOption* m_checkBox;
+    QWidget* m_child;
+
+    Tag m_tag;
+    bool m_urlHover;
+    QFont m_font;
+    TagWidgetPrivate* m_tagWidget;
+};
+}
+
+#endif

Modification de propriétés sur nepomuk/core/ui/tagcheckbox.h
___________________________________________________________________
Ajouté : svn:eol-style
   + native

Index: nepomuk/core/ui/CMakeLists.txt
===================================================================
--- nepomuk/core/ui/CMakeLists.txt	(révision 1125741)
+++ nepomuk/core/ui/CMakeLists.txt	(copie de travail)
@@ -15,6 +15,8 @@
   kmetadatatagwidget.h
   ktagdisplaywidget.h
   kratingpainter.h
+  nepomukmassupdatejob.h
+  tagwidget.h
   DESTINATION ${INCLUDE_INSTALL_DIR}/nepomuk COMPONENT Devel
 )
 
Index: nepomuk/Mainpage.dox
===================================================================
--- nepomuk/Mainpage.dox	(révision 1125741)
+++ nepomuk/Mainpage.dox	(copie de travail)
@@ -3,7 +3,7 @@
  * $Id: sourceheader 511311 2006-02-19 14:51:05Z trueg $
  *
  * This file is part of the Nepomuk KDE project.
- * Copyright (C) 2006-2009 Sebastian Trueg <trueg@kde.org>
+ * Copyright (C) 2006-2010 Sebastian Trueg <trueg@kde.org>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -314,6 +314,34 @@
 Nepomuk::Query::FileQuery fileQuery( term );
 \endcode
 
+
+Any other term can be used as sub term in a ComparisonTerm (%Vocabulary namespace generated via \ref nepomuk-rcgen).
+The following query does return all resources related to person contacts that are tagged with \p tag.
+
+\code
+Nepomuk::Query::AndTerm andTerm;
+andTerm.addSubTerm( Nepomuk::Query::ResourceTypeTerm( Nepomuk::Vocabulary::NCO::PersonContact() ) );
+andTerm.addSubTerm( Nepomuk::Query::ComparisonTerm( Soprano::Vocabulary::NAO::hasTag(),
+                                                    Nepomuk::Query::ResourceTerm( tag ) ) );
+Nepomuk::Query::ComparisonTerm cterm( Nepomuk::Vocabulary::NAO::isRelated(),
+                                      andTerm );
+\endcode
+
+
+To make matters even more complex the above ComparisonTerm can be inverted:
+
+\code
+cterm.setInverted(true);
+\endcode
+
+This will not match resources related to some tagged person contact but match
+resources that some tagged person contact is related to (sounds confusing but
+remember that the properties are not symmetric by default, i.e. the graph of
+data is directed.)
+
+
+\subsection query_examples_file Listing Files
+
 Restrict the search to a specific folder:
 
 \code
@@ -330,6 +358,19 @@
 fileQuery.setTerm( Nepomuk::Query::AndTerm( fileQuery.term(), noFolderTerm ) );
 \endcode
 
+List all query results in a KDirModel:
+
+\code
+KDirModel* model = getFancyDirModel();
+Nepomuk::Query::Query query = buildFancyQuery();
+KUrl searchUrl = query.toSearchUrl();
+model->dirLister()->open( searchUrl );
+\endcode
+
+KIO will use the \p nepomuksearch:/ slave to list search results as file entries.
+
+\subsection query_examples_misc Misc Query Examples
+
 Match all EmailAddress instances with a specific email address:
 \code
 Nepomuk::Query::ComparisonTerm email( Vocabulary::NCO::emailAddress(), Soprano::LiteralValue( "trueg@kde.org" ) );
@@ -344,17 +385,6 @@
 \code
 Nepomuk::Query::AndTerm( type, Nepomuk::Query::ComparisonTerm( Vocabulary::NCO::hasEmailAddress(), email ) );
 \endcode
-
-List all query results in a KDirModel:
-
-\code
-KDirModel* model = getFancyDirModel();
-Nepomuk::Query::Query query = buildFancyQuery();
-KUrl searchUrl = query.toSearchUrl();
-model->dirLister()->open( searchUrl );
-\endcode
-
-KIO will use the \p nepomuksearch:/ slave to list search results as file entries.
 */
 
 
@@ -496,8 +526,11 @@
 // DOXYGEN_SET_EXCLUDE += @topdir@/nepomuk/core/nie.h
 // DOXYGEN_SET_EXCLUDE += @topdir@/nepomuk/core/ontology/entitymanager.h
 // DOXYGEN_SET_EXCLUDE += @topdir@/nepomuk/core/ui/nepomukmassupdatejob.h
-// DOXYGEN_SET_EXCLUDE += @topdir@/nepomuk/core/ui/kautoscrollarea.h
+// DOXYGEN_SET_EXCLUDE += @topdir@/nepomuk/core/ui/tagcheckbox.h
 // DOXYGEN_SET_EXCLUDE += @topdir@/nepomuk/core/ui/kblocklayout.h
+// DOXYGEN_SET_EXCLUDE_PATTERNS += @topdir@/nepomuk/core/*_p.h
+// DOXYGEN_SET_EXCLUDE_PATTERNS += @topdir@/nepomuk/core/ontology/*_p.h
+// DOXYGEN_SET_EXCLUDE_PATTERNS += @topdir@/nepomuk/core/ui/*_p.h
 // DOXYGEN_SET_EXCLUDE_PATTERNS += @topdir@/nepomuk/query/*_p.h
 // DOXYGEN_SET_PROJECT_NAME = Nepomuk
 // vim:ts=4:sw=4:expandtab:filetype=doxygen
Index: nepomuk/rcgen/templates/source_safe.tpl
===================================================================
--- nepomuk/rcgen/templates/source_safe.tpl	(révision 1125741)
+++ nepomuk/rcgen/templates/source_safe.tpl	(copie de travail)
@@ -87,7 +87,7 @@
 
 QString Nepomuk::NEPOMUK_RESOURCENAME::resourceTypeUri()
 {
-    return "NEPOMUK_RESOURCETYPEURI";
+    return QLatin1String("NEPOMUK_RESOURCETYPEURI");
 }
 
 NEPOMUK_METHODS
Index: nepomuk/rcgen/fastcode.cpp
===================================================================
--- nepomuk/rcgen/fastcode.cpp	(révision 1125741)
+++ nepomuk/rcgen/fastcode.cpp	(copie de travail)
@@ -29,6 +29,9 @@
 
 QString FastCode::propertyGetterDeclaration( const Property* property, const ResourceClass* rc, const QString &nameSpace ) const
 {
+    Q_UNUSED( property );
+    Q_UNUSED( rc );
+    Q_UNUSED( nameSpace );
     return QString();
 }
 
@@ -43,11 +46,16 @@
 
 QString FastCode::propertyReversePropertyGetterDeclaration( const Property* property, const ResourceClass* rc, const QString &nameSpace ) const
 {
+    Q_UNUSED( property );
+    Q_UNUSED( rc );
+    Q_UNUSED( nameSpace );
     return QString();
 }
 
 QString FastCode::resourceAllResourcesDeclaration( const ResourceClass* rc, const QString &nameSpace ) const
 {
+    Q_UNUSED( rc );
+    Q_UNUSED( nameSpace );
     return QString();
 }
 
@@ -90,6 +98,8 @@
 
 QString FastCode::propertyGetterDefinition( const Property* property, const ResourceClass* rc ) const
 {
+    Q_UNUSED( property );
+    Q_UNUSED( rc );
     return QString();
 }
 
@@ -110,11 +120,14 @@
 
 QString FastCode::propertyReversePropertyGetterDefinition( const Property* property, const ResourceClass* rc ) const
 {
+    Q_UNUSED( property );
+    Q_UNUSED( rc );
     return QString();
 }
 
 QString FastCode::resourceAllResourcesDefinition( const ResourceClass* rc ) const
 {
+    Q_UNUSED( rc );
     return QString();
 }
 
Index: nepomuk/core/variant.cpp
===================================================================
--- nepomuk/core/variant.cpp
+++ nepomuk/core/variant.cpp	2010-05-12 08:54:03.000000000 +0200
@@ -22,6 +22,7 @@
 #include "resource.h"
 
 #include <soprano/literalvalue.h>
+#include <soprano/node.h>
 
 #include <kdebug.h>
 
@@ -1312,6 +1313,7 @@
 }
 
 
+// static
 Nepomuk::Variant Nepomuk::Variant::fromString( const QString& value, int type )
 {
     // first check the types that are not supported by Soprano since they are not literal types
@@ -1328,6 +1330,24 @@
     }
 }
 
+// static
+Nepomuk::Variant Nepomuk::Variant::fromNode( const Soprano::Node& node )
+{
+    //
+    // We cannot put in Resource objects here since then nie:url file:/ URLs would
+    // get converted back to the actual resource URIs which would be useless.
+    // That is why Variant treats QUrl and Resource pretty much as similar.
+    //
+    if ( node.isResource() ) {
+        return Nepomuk::Variant( node.uri() );
+    }
+    else if ( node.isLiteral() ) {
+        return Nepomuk::Variant( node.literal().variant() );
+    }
+    else {
+        return Nepomuk::Variant();
+    }
+}
 
 bool Nepomuk::Variant::operator==( const Variant& other ) const
 {
