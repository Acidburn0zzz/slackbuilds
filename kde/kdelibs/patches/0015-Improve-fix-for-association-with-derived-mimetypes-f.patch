From 8bfcace7efc0feea8899f70dfc15c3050c90ea99 Mon Sep 17 00:00:00 2001
From: David Faure <faure@kde.org>
Date: Sat, 19 Oct 2013 10:15:35 +0200
Subject: [PATCH 15/15] Improve fix for association with derived mimetypes
 (f723e2e7d36)

If a desktop file was mentionning two aliases, they would both get
removed, due to is() returning true for aliases as well.

CCBUG: 321706
---
 kded/kbuildservicefactory.cpp        |  7 ++++++-
 kded/tests/kmimeassociationstest.cpp | 14 ++++++++++----
 2 files changed, 16 insertions(+), 5 deletions(-)

diff --git a/kded/kbuildservicefactory.cpp b/kded/kbuildservicefactory.cpp
index b4564bd..7a2a2fc 100644
--- a/kded/kbuildservicefactory.cpp
+++ b/kded/kbuildservicefactory.cpp
@@ -269,8 +269,13 @@ void KBuildServiceFactory::populateServiceTypes()
                 } else {
                     bool shouldAdd = true;
                     foreach (const QString &otherType, service->serviceTypes()) {
+                        // Skip derived types if the base class is listed (#321706)
                         if (stName != otherType && mime->is(otherType)) {
-                            shouldAdd = false;
+                            // But don't skip aliases (they got resolved into mime->name() already, but don't let two aliases cancel out)
+                            if (KMimeTypeRepository::self()->canonicalName(otherType) != mime->name()) {
+                                //kDebug() << "Skipping" << mime->name() << "because of" << otherType << "(canonical" << KMimeTypeRepository::self()->canonicalName(otherType) << ") while parsing" << service->entryPath();
+                                shouldAdd = false;
+                            }
                         }
                     }
                     if (shouldAdd) {
diff --git a/kded/tests/kmimeassociationstest.cpp b/kded/tests/kmimeassociationstest.cpp
index a07637f..342a8fd 100644
--- a/kded/tests/kmimeassociationstest.cpp
+++ b/kded/tests/kmimeassociationstest.cpp
@@ -140,10 +140,12 @@ private Q_SLOTS:
         // This interacted badly with mimeapps.list listing another app for text/plain, but the
         // lookup found this app first, due to c-src. The fix: ignoring derived mimetypes when
         // the base mimetype is already listed.
+        //
+        // Also include aliases (msword), to check they don't cancel each other out.
         fakeCSrcApplication = m_localApps + "fakecsrcapplication.desktop";
         if (!QFile::exists(fakeCSrcApplication)) {
             mustUpdateKSycoca = true;
-            writeAppDesktopFile(fakeCSrcApplication, QStringList() << "text/plain" << "text/c-src", 8);
+            writeAppDesktopFile(fakeCSrcApplication, QStringList() << "text/plain" << "text/c-src" << "application/vnd.ms-word" << "application/msword", 8);
         }
 
         fakeJpegApplication = m_localApps + "fakejpegapplication.desktop";
@@ -200,6 +202,7 @@ private Q_SLOTS:
         preferredApps["text/plain"] << "faketextapplication.desktop" << "kde4-kwrite.desktop";
         preferredApps["text/x-csrc"] << "faketextapplication.desktop" << "kde4-kwrite.desktop";
         preferredApps["text/html"] << "fakehtmlapplication.desktop";
+        preferredApps["application/msword"] << "fakecsrcapplication.desktop";
         removedApps["image/jpeg"] << "firefox.desktop";
         removedApps["text/html"] << "kde4-dolphin.desktop" << "kde4-kwrite.desktop";
 
@@ -231,14 +234,17 @@ private Q_SLOTS:
         for (ExpectedResultsMap::const_iterator it = preferredApps.constBegin(),
                                                end = preferredApps.constEnd() ; it != end ; ++it) {
             const QString mime = it.key();
-            // Derived mimetypes are handled outside KMimeAssociations
-            if (mime == QLatin1String("text/x-csrc"))
+            // The data for derived types and aliases isn't for this test (which only looks at mimeapps.list)
+            if (mime == QLatin1String("text/x-csrc") || mime == QLatin1String("application/msword"))
                 continue;
             const QList<KServiceOffer> offers = offerHash.offersFor(mime);
             Q_FOREACH(const QString& service, it.value()) {
                 KService::Ptr serv = KService::serviceByStorageId(service);
                 if (serv && !offersContains(offers, serv)) {
-                    kDebug() << serv.data() << serv->entryPath() << "does not have" << mime;
+                    kDebug() << "expected offer" << serv->entryPath() << "not in offers for" << mime << ":";
+                    Q_FOREACH(const KServiceOffer& offer, offers) {
+                        kDebug() << offer.service()->storageId();
+                    }
                     QFAIL("offer does not have servicetype");
                 }
             }
-- 
1.8.3.1

