diff -up kdelibs-4.11.3/kinit/autostart.cpp.autostart-debug kdelibs-4.11.3/kinit/autostart.cpp
--- kdelibs-4.11.3/kinit/autostart.cpp.autostart-debug	2013-06-28 18:03:41.331387754 +0100
+++ kdelibs-4.11.3/kinit/autostart.cpp	2013-12-06 23:59:49.664514325 +0000
@@ -20,6 +20,7 @@
 #define QT_NO_CAST_FROM_ASCII
 #include "autostart.h"
 
+#include <kdebug.h>
 #include <kautostart.h>
 #include <kglobal.h>
 #include <kstandarddirs.h>
@@ -97,8 +98,10 @@ AutoStart::loadAutoStartList()
        item->phase = config.startPhase();
        if (item->phase < 0)
           item->phase = 0;
+			 kWarning() << "Loading autostart list item: name=" << item->name << " phase=" << item->phase;
        m_startList->append(item);
    }
+   kWarning() << "Loading complete";
 }
 
 QString
diff -up kdelibs-4.11.3/kinit/klauncher.cpp.autostart-debug kdelibs-4.11.3/kinit/klauncher.cpp
--- kdelibs-4.11.3/kinit/klauncher.cpp.autostart-debug	2013-11-01 15:45:56.413145482 +0000
+++ kdelibs-4.11.3/kinit/klauncher.cpp	2013-12-07 00:00:43.745672891 +0000
@@ -535,12 +535,20 @@ KLauncher::slotAutoStart()
    KService::Ptr s;
    do
    {
+		 // Return each service from current phase in turn. These are pre-sorted accroding to dependencies
+		 // TODO: Debug startService to ensure we are not stuck in function
+		kWarning() << "Finding next AutoStart service to run";
       QString service = mAutoStart.startService();
+				kWarning() << "Autostarting service: " << service;
+				//If we have a service then we start is in the while condition
       if (service.isEmpty())
       {
+				//Otherwise we report back to ksmserver and we are all done
+				kWarning() << "End of services list";
          // Done
 	 if( !mAutoStart.phaseDone())
 	 {
+		 	kWarning() << "Autostarting done. Reporting back to ksmserver";
 	    mAutoStart.setPhaseDone();
             switch( mAutoStart.phase())
                 {
@@ -555,12 +563,15 @@ KLauncher::slotAutoStart()
                     break;
                 }
 	 }
+	 kWarning() << "End of services but already reported ?????";
          return;
       }
+      
       s = new KService(service);
    }
    while (!start_service(s, QStringList(), QStringList(), "0", false, true, QDBusMessage()));
    // Loop till we find a service that we can start.
+	 // We loop until we have someting to run. We return here because once a service is done we post another timer even and recall this entire method.
 }
 
 void
@@ -607,6 +618,7 @@ KLauncher::requestDone(KLaunchRequest *r
 
    if (request->autoStart)
    {
+		 kWarning() << "Posting slotAutoStart";
       mAutoTimer.start(0);
    }
 
@@ -815,6 +827,7 @@ KLauncher::start_service(KService::Ptr s
                          const QStringList &envs, const QByteArray &startup_id,
                          bool blind, bool autoStart, const QDBusMessage &msg)
 {
+		kWarning() << "Preparing start: " << service->name();
    QStringList urls = _urls;
    bool runPermitted = KDesktopFile::isAuthorizedDesktopFile(service->entryPath());
 
@@ -826,6 +839,7 @@ KLauncher::start_service(KService::Ptr s
       else
          requestResult.error = i18n("Service '%1' is malformatted.", service->entryPath());
       cancel_service_startup_info( NULL, startup_id, envs ); // cancel it if any
+			kWarning() << "Service skipped on this run: valid=" << service->isValid() << " runPermitted=" << runPermitted;
       return false;
    }
    KLaunchRequest *request = new KLaunchRequest;
@@ -863,6 +877,7 @@ KLauncher::start_service(KService::Ptr s
       requestResult.error = i18n("Service '%1' is malformatted.", service->entryPath());
       delete request;
       cancel_service_startup_info( NULL, startup_id, envs );
+			kWarning() << "Service skipped on this run: no arguments";
       return false;
    }
 
@@ -907,6 +922,7 @@ KLauncher::start_service(KService::Ptr s
       msg.setDelayedReply(true);
       request->transaction = msg;
    }
+   	kWarning() << "Service queued on this run";;
    queueRequest(request);
    return true;
 }
@@ -1050,6 +1066,7 @@ KLauncher::slotDequeue()
       KLaunchRequest *request = requestQueue.takeFirst();
       // process request
       request->status = KLaunchRequest::Launching;
+			kWarning() << "Starting: " << request->name;
       requestStart(request);
       if (request->status != KLaunchRequest::Launching)
       {
@@ -1057,7 +1074,9 @@ KLauncher::slotDequeue()
 #ifdef KLAUNCHER_VERBOSE_OUTPUT
          kDebug(7016) << "Request handled already";
 #endif
+				 kWarning() << "Completing: " << request->name;
          requestDone( request );
+				 kWarning() << "Completed.";
          continue;
       }
    } while(requestQueue.count());
