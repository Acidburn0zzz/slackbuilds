Index: nepomuk/kioslaves/search/searchfolder.cpp
===================================================================
--- nepomuk/kioslaves/search/searchfolder.cpp	(révision 1121160)
+++ nepomuk/kioslaves/search/searchfolder.cpp	(copie de travail)
@@ -23,6 +23,7 @@
 #include "nie.h"
 #include "pimo.h"
 #include "nepomuksearchurltools.h"
+#include "resourcestat.h"
 
 #include <Soprano/Vocabulary/Xesam>
 #include <Soprano/Vocabulary/NAO>
@@ -55,8 +56,19 @@
 
     qRegisterMetaType<QList<QUrl> >();
 
-    // parse URL
-    m_query = queryFromUrl( url );
+    // parse URL (this may fail in which case we fall back to pure SPARQL below)
+    m_query = Nepomuk::fromQueryUrl( url );
+
+    // the only request property we handle is nie:url
+    m_query.setRequestProperties( QList<Query::Query::RequestProperty>() << Query::Query::RequestProperty( Nepomuk::Vocabulary::NIE::url() ) );
+
+    if ( m_query.isValid() ) {
+        m_sparqlQuery = m_query.toSparqlQuery();
+    }
+    else {
+        // the URL contains pure sparql. We simply list it without trying to change the limit
+        m_sparqlQuery = Nepomuk::sparqlFromQueryUrl( url );
+    }
 }
 
 
@@ -87,9 +99,7 @@
              this, SLOT( slotFinishedListing() ),
              Qt::DirectConnection );
 
-    Query::Query q;
-    q.addRequestProperty( Query::Query::RequestProperty( Nepomuk::Vocabulary::NIE::url() ) );
-    m_client->sparqlQuery( m_query, q.requestPropertyMap() );
+    m_client->sparqlQuery( m_sparqlQuery, m_query.requestPropertyMap() );
     exec();
     delete m_client;
 
@@ -109,9 +119,6 @@
 
     kDebug() << "listing done";
 
-    m_slave->listEntry( KIO::UDSEntry(), true );
-    m_slave->finished();
-
     // shutdown and delete
     exit();
     deleteLater();
@@ -121,7 +128,7 @@
 // always called in search thread
 void Nepomuk::SearchFolder::slotNewEntries( const QList<Nepomuk::Query::Result>& results )
 {
-    kDebug() << m_url << QThread::currentThread();
+    kDebug() << m_url;
 
     m_resultMutex.lock();
     m_resultsQueue += results;
@@ -137,7 +144,7 @@
 // always called in search thread
 void Nepomuk::SearchFolder::slotFinishedListing()
 {
-    kDebug() << m_url << QThread::currentThread();
+    kDebug() << m_url;
     QMutexLocker lock( &m_resultMutex );
     m_initialListingFinished = true;
     m_resultWaiter.wakeAll();
@@ -171,50 +178,58 @@
 
 
 namespace {
-    bool statFile( const KUrl& url, KIO::UDSEntry& uds )
+    bool statFile( const KUrl& url, const KUrl& fileUrl, KIO::UDSEntry& uds )
     {
         // the akonadi kio slave is just way too slow and
         // in KDE 4.4 akonadi items should have nepomuk:/res/<uuid> URIs anyway
         if ( url.scheme() == QLatin1String( "akonadi" ) )
             return false;
 
-        bool success = false;
-
-        if ( KIO::StatJob* job = KIO::stat( url, KIO::HideProgressInfo ) ) {
-            job->setAutoDelete( false );
-            if ( KIO::NetAccess::synchronousRun( job, 0 ) ) {
-                uds = job->statResult();
-                success = true;
+        if ( !fileUrl.isEmpty() ) {
+            if ( KIO::StatJob* job = KIO::stat( fileUrl, KIO::HideProgressInfo ) ) {
+                // we do not want to wait for the event loop to delete the job
+                QScopedPointer<KIO::StatJob> sp( job );
+                job->setAutoDelete( false );
+                if ( KIO::NetAccess::synchronousRun( job, 0 ) ) {
+                    uds = job->statResult();
+                    return true;
+                }
             }
-            else {
-                kDebug() << "failed to stat" << url;
-            }
-            delete job;
         }
 
-        return success;
+        Nepomuk::Resource res( url );
+        if ( res.exists() ) {
+            uds = Nepomuk::statNepomukResource( res );
+            return true;
+        }
+
+        kDebug() << "failed to stat" << url;
+        return false;
     }
 }
 
 
 // always called in main thread
+// This method tries to avoid loading the Nepomuk::Resource as long as possible by only using the
+// request property nie:url in the Result for local files.
 KIO::UDSEntry Nepomuk::SearchFolder::statResult( const Query::Result& result )
 {
     Resource res( result.resource() );
-    KUrl url = res.resourceUri();
+    KUrl url( res.resourceUri() );
+    KUrl nieUrl( result[Nepomuk::Vocabulary::NIE::url()].uri() );
+    if ( nieUrl.isEmpty() )
+        nieUrl = Nepomuk::nepomukToFileUrl( url );
 
     KIO::UDSEntry uds;
-    if ( statFile( url, uds ) ) {
-        if ( result.resource().hasProperty( Nepomuk::Vocabulary::NIE::url() ) ) {
-            KUrl fileUrl( res.property( Nepomuk::Vocabulary::NIE::url() ).toUrl() );
-
+    if ( statFile( url, nieUrl, uds ) ) {
+        if ( !nieUrl.isEmpty() ) {
             // needed since the nepomuk:/ KIO slave does not do stating of files in its own
             // subdirs (tags and filesystems), and neither do we with real subdirs
             if ( uds.isDir() )
-                uds.insert( KIO::UDSEntry::UDS_URL, fileUrl.url() );
+                uds.insert( KIO::UDSEntry::UDS_URL, nieUrl.url() );
 
-            if ( fileUrl.isLocalFile() ) {
-                uds.insert( KIO::UDSEntry::UDS_LOCAL_PATH, fileUrl.toLocalFile() );
+            if ( nieUrl.isLocalFile() ) {
+                uds.insert( KIO::UDSEntry::UDS_LOCAL_PATH, nieUrl.toLocalFile() );
             }
         }
 
@@ -227,25 +242,26 @@
 
         // make sure we do not use these ugly names for display
         if ( !uds.contains( KIO::UDSEntry::UDS_DISPLAY_NAME ) ) {
-            if ( res.hasType( Nepomuk::Vocabulary::PIMO::Thing() ) ) {
+            // by checking nieUrl we avoid loading the resource for local files
+            if ( nieUrl.isEmpty() &&
+                 res.hasType( Nepomuk::Vocabulary::PIMO::Thing() ) ) {
                 if ( !res.pimoThing().groundingOccurrences().isEmpty() ) {
                     res = res.pimoThing().groundingOccurrences().first();
                 }
             }
 
-            if ( res.hasProperty( Nepomuk::Vocabulary::NIE::url() ) ) {
-                KUrl fileUrl( res.property( Nepomuk::Vocabulary::NIE::url() ).toUrl() );
-                uds.insert( KIO::UDSEntry::UDS_DISPLAY_NAME, fileUrl.fileName() );
+            if ( !nieUrl.isEmpty() ) {
+                uds.insert( KIO::UDSEntry::UDS_DISPLAY_NAME, nieUrl.fileName() );
 
                 // since we change the UDS_NAME KFileItem cannot handle mimetype and such anymore
                 QString mimetype = uds.stringValue( KIO::UDSEntry::UDS_MIME_TYPE );
                 if ( mimetype.isEmpty() ) {
-                    mimetype = KMimeType::findByUrl(fileUrl)->name();
+                    mimetype = KMimeType::findByUrl(nieUrl)->name();
                     uds.insert( KIO::UDSEntry::UDS_MIME_TYPE, mimetype );
                 }
             }
             else {
-                uds.insert( KIO::UDSEntry::UDS_DISPLAY_NAME, result.resource().genericLabel() );
+                uds.insert( KIO::UDSEntry::UDS_DISPLAY_NAME, res.genericLabel() );
             }
         }
 
Index: nepomuk/kioslaves/search/kio_nepomuksearch.cpp
===================================================================
--- nepomuk/kioslaves/search/kio_nepomuksearch.cpp	(révision 1121160)
+++ nepomuk/kioslaves/search/kio_nepomuksearch.cpp	(copie de travail)
@@ -29,18 +29,25 @@
 #include <KDebug>
 #include <KAboutData>
 #include <KApplication>
-#include <KConfig>
+#include <KSharedConfig>
 #include <KConfigGroup>
 #include <KCmdLineArgs>
 #include <kio/global.h>
 #include <kio/job.h>
 #include <KMimeType>
 #include <KStandardDirs>
+#include <KFileItem>
+#include <KDirNotify>
 
-#include <Nepomuk/Resource>
+#include <Nepomuk/Thing>
 #include <Nepomuk/ResourceManager>
 #include <Nepomuk/Variant>
 #include <Nepomuk/Query/QueryServiceClient>
+#include <Nepomuk/Query/ComparisonTerm>
+#include <Nepomuk/Query/ResourceTypeTerm>
+#include <Nepomuk/Query/AndTerm>
+#include <Nepomuk/Query/NegationTerm>
+#include <Nepomuk/Query/Query>
 
 #include <Soprano/Vocabulary/RDF>
 #include <Soprano/Vocabulary/RDFS>
@@ -53,14 +60,21 @@
 
 
 namespace {
-    KIO::UDSEntry statDefaultSearchFolder( const QString& name ) {
-        KIO::UDSEntry uds;
-        uds.insert( KIO::UDSEntry::UDS_NAME, name );
-        uds.insert( KIO::UDSEntry::UDS_DISPLAY_NAME, i18n("Query Results") );
+    void addGenericSearchFolderItems( KIO::UDSEntry& uds ) {
         uds.insert( KIO::UDSEntry::UDS_ACCESS, 0700 );
         uds.insert( KIO::UDSEntry::UDS_USER, KUser().loginName() );
         uds.insert( KIO::UDSEntry::UDS_FILE_TYPE, S_IFDIR );
         uds.insert( KIO::UDSEntry::UDS_MIME_TYPE, QString::fromLatin1( "inode/directory" ) );
+// FIXME        uds.insert( KIO::UDSEntry::UDS_CUSTOM_SORT_WEIGHT, -1 );
+        uds.insert( KIO::UDSEntry::UDS_ICON_OVERLAY_NAMES, QLatin1String( "nepomuk" ) );
+    }
+
+    KIO::UDSEntry statSearchFolder( const KUrl& url ) {
+        KIO::UDSEntry uds;
+        addGenericSearchFolderItems( uds );
+        uds.insert( KIO::UDSEntry::UDS_NAME, Nepomuk::resourceUriToUdsName( url ) );
+        uds.insert( KIO::UDSEntry::UDS_DISPLAY_NAME, Nepomuk::Query::Query::titleFromQueryUrl( url ) );
+        uds.insert( KIO::UDSEntry::UDS_URL, url.url() );
         return uds;
     }
 
@@ -69,9 +83,9 @@
      * Empty if the path only contains the query.
      */
     QString fileNameFromUrl( const KUrl& url ) {
-        QString fn;
         if ( url.hasQueryItem( QLatin1String( "sparql" ) ) ||
              url.hasQueryItem( QLatin1String( "query" ) ) ||
+             url.hasQueryItem( QLatin1String( "encodedquery" ) ) ||
              url.directory() != QLatin1String( "/" ) ) {
             return url.fileName();
         }
@@ -85,30 +99,13 @@
         return( !url.hasQuery() &&
                 ( path.isEmpty() || path == QLatin1String("/") ) );
     }
-
-    // do not cache more than SEARCH_CACHE_MAX search folders at the same time
-    const int SEARCH_CACHE_MAX = 5;
+    const int s_historyMax = 10;
 }
 
 
 Nepomuk::SearchProtocol::SearchProtocol( const QByteArray& poolSocket, const QByteArray& appSocket )
     : KIO::ForwardingSlaveBase( "nepomuksearch", poolSocket, appSocket )
 {
-    // FIXME: trueg: install a file watch on this file and update it whenever the queries change.
-    // FIXME: trueg: also emit a KDirNotify signal to inform KIO about that change
-    KConfig config("kionepomukuserqueriesrc" );
-
-    foreach( QString search, config.group("Searches").readEntry("All searches", QStringList() ) )
-    {
-        search = search.simplified();
-        KConfigGroup grp = config.group(search);
-        KUrl url( grp.readEntry("Query", QString() ) );
-        url.setScheme( QLatin1String( "nepomuksearch" ) );
-        QString name = grp.readEntry( "Name", QString() );
-        if ( !name.isEmpty() ) {
-            addDefaultSearch( name, url );
-        }
-    }
 }
 
 
@@ -137,45 +134,10 @@
 }
 
 
-void Nepomuk::SearchProtocol::addDefaultSearch( const QString& name, const KUrl& url )
-{
-    m_defaultSearches.insert( name, url );
-}
-
-
-Nepomuk::SearchFolder* Nepomuk::SearchProtocol::extractSearchFolder( const KUrl& url )
-{
-    kDebug() << url;
-    if ( SearchFolder* sf = getDefaultQueryFolder( url.fileName() ) ) {
-        kDebug() << "-----> is default search folder";
-        return sf;
-    }
-    else if ( SearchFolder* sf = getQueryFolder( url ) ) {
-        kDebug() << "-----> is on-the-fly search folder";
-        return sf;
-    }
-    else {
-        kDebug() << "-----> does not exist.";
-        return 0;
-    }
-}
-
-
 void Nepomuk::SearchProtocol::listDir( const KUrl& url )
 {
     kDebug() << url;
 
-    //
-    // Root dir: * list default searches: "all music files", "recent files"
-    //           * list configuration entries: "create new default search"
-    //
-    // Root dir with query:
-    //           * execute the query (cached) and list its results
-    //
-    // some folder:
-    //           * Look for a default search and execute that
-    //
-
     if ( isRootUrl( url ) ) {
         listRoot();
     }
@@ -185,8 +147,10 @@
             listEntry( KIO::UDSEntry(),  true);
             finished();
         }
-        else if ( SearchFolder* folder = extractSearchFolder( url ) ) {
+        else if ( SearchFolder* folder = getQueryFolder( url ) ) {
             folder->list();
+            listEntry( KIO::UDSEntry(), true );
+            finished();
         }
         else {
             error( KIO::ERR_DOES_NOT_EXIST, url.prettyUrl() );
@@ -226,8 +190,7 @@
         mimeType( QString::fromLatin1( "inode/directory" ) );
         finished();
     }
-    else if ( url.directory() == QLatin1String( "/" ) &&
-              m_defaultSearches.contains( url.fileName() ) ) {
+    else if ( url.directory() == QLatin1String( "/" ) ) {
         mimeType( QString::fromLatin1( "inode/directory" ) );
         finished();
     }
@@ -248,7 +211,7 @@
         //
         KIO::UDSEntry uds;
         uds.insert( KIO::UDSEntry::UDS_NAME, QString::fromLatin1( "/" ) );
-        uds.insert( KIO::UDSEntry::UDS_DISPLAY_NAME, i18n("Query Results") );
+        uds.insert( KIO::UDSEntry::UDS_DISPLAY_NAME, i18n("Desktop Queries") );
         uds.insert( KIO::UDSEntry::UDS_ICON_NAME, QString::fromLatin1( "nepomuk" ) );
         uds.insert( KIO::UDSEntry::UDS_FILE_TYPE, S_IFDIR );
         uds.insert( KIO::UDSEntry::UDS_MIME_TYPE, QString::fromLatin1( "inode/directory" ) );
@@ -258,8 +221,7 @@
     }
     else if ( fileNameFromUrl( url ).isEmpty() ) {
         kDebug() << "Stat search folder" << url;
-        // we use the encoded query url as UDS_NAME
-        statEntry( statDefaultSearchFolder( QString::fromAscii( url.toEncoded().toPercentEncoding( QByteArray(), QByteArray(), '_' ) ) ) );
+        statEntry( statSearchFolder( url ) );
         finished();
     }
     else {
@@ -284,8 +246,8 @@
 {
     // we do it the speedy but slightly umpf way: decode the encoded URI from the filename
     newURL = Nepomuk::udsNameToResourceUri( url.fileName() );
-    kDebug() << "NEW URL:" << newURL << newURL.protocol() << newURL.path() << newURL.fileName();
-    return newURL.isValid();
+    kDebug() << "URL:" << url << "NEW URL:" << newURL << newURL.protocol() << newURL.path() << newURL.fileName();
+    return !newURL.isEmpty();
 }
 
 
@@ -299,69 +261,34 @@
 {
     kDebug();
 
-    listDefaultSearches();
-    listActions();
-
     listEntry( KIO::UDSEntry(), true );
     finished();
 }
 
 
-void Nepomuk::SearchProtocol::listActions()
-{
-    // FIXME: manage default searches
-}
-
-
 Nepomuk::SearchFolder* Nepomuk::SearchProtocol::getQueryFolder( const KUrl& url )
 {
+    // this is necessary to properly handle user queries which are encoded in the filename in
+    // statSearchFolder(). This is necessary for cases in which UDS_URL is ignored like in
+    // KUrlNavigator's popup menus
+    KUrl normalizedUrl = Nepomuk::udsNameToResourceUri( url.fileName() );
+    if ( normalizedUrl.protocol() != QLatin1String( "nepomuksearch" ) ) {
+        normalizedUrl = url;
+    }
+
     // here we strip off the entry's name since that is not part of the query URL
-    KUrl strippedUrl( url );
     if ( url.hasQuery() ) {
-        strippedUrl.setPath( QLatin1String( "/" ) );
+        normalizedUrl.setPath( QLatin1String( "/" ) );
     }
     else if ( url.directory() != QLatin1String( "/" ) ) {
-        strippedUrl.setPath( QLatin1String( "/" ) + url.path().section( '/', 0, 0 ) );
+        normalizedUrl.setPath( QLatin1String( "/" ) + url.path().section( '/', 0, 0 ) );
     }
 
-    QString urlStr = strippedUrl.url();
-    SearchFolder* folder = new SearchFolder( strippedUrl, this );
+    SearchFolder* folder = new SearchFolder( normalizedUrl, this );
     return folder;
 }
 
 
-Nepomuk::SearchFolder* Nepomuk::SearchProtocol::getDefaultQueryFolder( const QString& name )
-{
-    if ( m_defaultSearches.contains( name ) ) {
-        return getQueryFolder( m_defaultSearches[name] );
-    }
-    else {
-        return 0;
-    }
-}
-
-
-void Nepomuk::SearchProtocol::listDefaultSearches()
-{
-    for ( QHash<QString, KUrl>::const_iterator it = m_defaultSearches.constBegin();
-          it != m_defaultSearches.constEnd(); ++it ) {
-        listEntry( statDefaultSearchFolder( it.key() ), false );
-    }
-}
-
-
-void Nepomuk::SearchProtocol::listDefaultSearch( const QString& name )
-{
-    kDebug() << name;
-    if ( m_defaultSearches.contains( name ) ) {
-        getDefaultQueryFolder( name )->list();
-    }
-    else {
-        error( KIO::ERR_CANNOT_ENTER_DIRECTORY, "Unknown default search: " + name );
-        finished();
-    }
-}
-
 extern "C"
 {
     KDE_EXPORT int kdemain( int argc, char **argv )
Index: nepomuk/kioslaves/search/searchfolder.h
===================================================================
--- nepomuk/kioslaves/search/searchfolder.h	(révision 1121160)
+++ nepomuk/kioslaves/search/searchfolder.h	(copie de travail)
@@ -47,12 +47,31 @@
         Q_OBJECT
 
     public:
+        /**
+         * Create a new search folder which reads the query from \a url.
+         * Call list() to actually let it list results via slave->listEntry()
+         */
         SearchFolder( const KUrl& url, KIO::SlaveBase* slave );
+
+        /**
+         * Destructor
+         */
         ~SearchFolder();
 
-        QString query() const { return m_query; }
+        /**
+         * Query URL used by this folder.
+         */
         KUrl url() const { return m_url; }
 
+        /**
+         * The query used by this folder or an invalid one in case
+         * the query URL contains a pure SPARQL query string.
+         */
+        Query::Query query() const { return m_query; }
+
+        /**
+         * List the results directly on the parent slave.
+         */
         void list();
 
     private Q_SLOTS:
@@ -83,8 +102,12 @@
         // folder properties
         KUrl m_url;
 
+        /// might be invalid in case the url contained a SPARQL query which
+        /// we could not parse. In that case use m_sparqlQuery
+        Query::Query m_query;
+
         // SPARQL query that is actually sent to the query service
-        QString m_query;
+        QString m_sparqlQuery;
 
         // result cache, filled by the search thread
         QQueue<Query::Result> m_resultsQueue;
Index: nepomuk/kioslaves/search/kio_nepomuksearch.h
===================================================================
--- nepomuk/kioslaves/search/kio_nepomuksearch.h	(révision 1121160)
+++ nepomuk/kioslaves/search/kio_nepomuksearch.h	(copie de travail)
@@ -80,21 +80,11 @@
     private:
         bool ensureNepomukRunning( bool emitError = true );
         void listRoot();
-        void listActions();
-        void listDefaultSearches();
-        void listDefaultSearch( const QString& path );
-        void addDefaultSearch( const QString& name, const KUrl& url );
 
-        SearchFolder* extractSearchFolder( const KUrl& url );
-
         /**
          * Get (possibly cached) query folder
          */
         SearchFolder* getQueryFolder( const KUrl& url );
-        SearchFolder* getDefaultQueryFolder( const QString& name );
-
-        // the default search folders
-        QHash<QString, KUrl> m_defaultSearches;
     };
 }
 
Index: nepomuk/kioslaves/search/kdedmodule/searchurllistener.cpp
===================================================================
--- nepomuk/kioslaves/search/kdedmodule/searchurllistener.cpp	(révision 1121160)
+++ nepomuk/kioslaves/search/kdedmodule/searchurllistener.cpp	(copie de travail)
@@ -46,13 +46,16 @@
 }
 
 
-Nepomuk::SearchUrlListener::SearchUrlListener( const KUrl& queryUrl )
+Nepomuk::SearchUrlListener::SearchUrlListener( const KUrl& queryUrl, const KUrl& notifyUrl )
     : QObject( 0 ),
       m_ref( 0 ),
       m_queryUrl( queryUrl ),
+      m_notifyUrl( notifyUrl ),
       m_queryInterface( 0 )
 {
-    kDebug() << queryUrl;
+    kDebug() << queryUrl << notifyUrl;
+    if ( m_notifyUrl.isEmpty() )
+        m_notifyUrl = queryUrl;
 
     const QString queryService = QLatin1String( "org.kde.nepomuk.services.nepomukqueryservice" );
     if ( QDBusConnection::sessionBus().interface()->isServiceRegistered( queryService ) ) {
@@ -97,7 +100,7 @@
 
 void Nepomuk::SearchUrlListener::slotNewEntries( const QList<Nepomuk::Query::Result>& )
 {
-    org::kde::KDirNotify::emitFilesAdded( m_queryUrl.url() );
+    org::kde::KDirNotify::emitFilesAdded( m_notifyUrl.url() );
 }
 
 
@@ -105,7 +108,7 @@
 {
     QStringList urls;
     foreach( const QString& uri, entries ) {
-        KUrl resultUrl( m_queryUrl );
+        KUrl resultUrl( m_notifyUrl );
         resultUrl.addPath( Nepomuk::resourceUriToUdsName( uri ) );
         urls << resultUrl.url();
     }
@@ -122,7 +125,7 @@
         createInterface();
 
         // inform KIO that results are available
-        org::kde::KDirNotify::emitFilesAdded( m_queryUrl.url() );
+        org::kde::KDirNotify::emitFilesAdded( m_notifyUrl.url() );
     }
 }
 
@@ -138,7 +141,7 @@
                                                            "/nepomukqueryservice",
                                                            QDBusConnection::sessionBus() );
 
-    QDBusReply<QDBusObjectPath> r = queryServiceInterface.sparqlQuery( Nepomuk::queryFromUrl( m_queryUrl ),
+    QDBusReply<QDBusObjectPath> r = queryServiceInterface.sparqlQuery( Nepomuk::sparqlFromQueryUrl( m_queryUrl ),
                                                                        nieUriReqProp() );
 
     if ( r.isValid() ) {
Index: nepomuk/kioslaves/search/kdedmodule/nepomuksearchmodule.h
===================================================================
--- nepomuk/kioslaves/search/kdedmodule/nepomuksearchmodule.h	(révision 1121160)
+++ nepomuk/kioslaves/search/kdedmodule/nepomuksearchmodule.h	(copie de travail)
@@ -26,6 +26,8 @@
 #include <QtDBus/QDBusContext>
 #include <QtCore/QMultiHash>
 
+class QDBusServiceWatcher;
+
 namespace Nepomuk {
 
     class SearchUrlListener;
@@ -45,15 +47,15 @@
         Q_SCRIPTABLE QStringList watchedSearchUrls();
 
     private Q_SLOTS:
-        void slotServiceOwnerChanged( const QString& serviceName,
-                                      const QString&,
-                                      const QString& newOwner );
+        void slotServiceUnregistered( const QString& serviceName );
 
     private:
         void unrefUrl( const KUrl& url );
 
         QHash<KUrl, SearchUrlListener*> m_queryHash;
         QMultiHash<QString, KUrl> m_dbusServiceUrlHash;
+
+        QDBusServiceWatcher *m_watcher;
     };
 }
 
Index: nepomuk/kioslaves/search/kdedmodule/searchurllistener.h
===================================================================
--- nepomuk/kioslaves/search/kdedmodule/searchurllistener.h	(révision 1121160)
+++ nepomuk/kioslaves/search/kdedmodule/searchurllistener.h	(copie de travail)
@@ -36,7 +36,7 @@
         Q_OBJECT
 
     public:
-        SearchUrlListener( const KUrl& queryUrl );
+        SearchUrlListener( const KUrl& queryUrl, const KUrl& notifyUrl = KUrl() );
         ~SearchUrlListener();
 
         int ref();
@@ -52,6 +52,7 @@
 
         int m_ref;
         KUrl m_queryUrl;
+        KUrl m_notifyUrl;
         org::kde::nepomuk::Query* m_queryInterface;
     };
 }
Index: nepomuk/kioslaves/search/kdedmodule/nepomuksearchmodule.cpp
===================================================================
--- nepomuk/kioslaves/search/kdedmodule/nepomuksearchmodule.cpp	(révision 1121160)
+++ nepomuk/kioslaves/search/kdedmodule/nepomuksearchmodule.cpp	(copie de travail)
@@ -21,8 +21,10 @@
 #include "searchurllistener.h"
 #include "nie.h"
 #include "dbusoperators_p.h"
+#include "timelinetools.h"
 
 #include <QtDBus/QDBusConnection>
+#include <QtDBus/QDBusServiceWatcher>
 
 #include <kdebug.h>
 #include <kdirnotify.h>
@@ -30,9 +32,20 @@
 namespace {
     inline bool isNepomukSearchUrl( const KUrl& url )
     {
-        static const char* s_nepProName = "nepomuksearch";
+        static const char s_nepProName[] = "nepomuksearch";
         return url.protocol() == QLatin1String( s_nepProName );
     }
+
+    inline bool isTimelineUrl( const KUrl& url )
+    {
+        static const char s_timelineProName[] = "timeline";
+        return url.protocol() == QLatin1String( s_timelineProName );
+    }
+
+    inline bool isNepomukSearchOrTimelineUrl( const KUrl& url )
+    {
+        return isNepomukSearchUrl( url ) || isTimelineUrl( url );
+    }
 }
 
 
@@ -47,10 +60,12 @@
     // connect to serviceOwnerChanged to catch crashed clients that never unregistered
     // themselves
     //
-    connect( QDBusConnection::sessionBus().interface(),
-             SIGNAL( serviceOwnerChanged( const QString&, const QString&, const QString& ) ),
-             this,
-             SLOT( slotServiceOwnerChanged( const QString&, const QString&, const QString& ) ) );
+    m_watcher = new QDBusServiceWatcher( QString(),
+                                         QDBusConnection::sessionBus(),
+                                         QDBusServiceWatcher::WatchForUnregistration,
+                                         this );
+    connect( m_watcher, SIGNAL( serviceUnregistered( const QString& ) ),
+             this, SLOT( slotServiceUnregistered( const QString& ) ) );
 
     //
     // connect to KDirLister telling us that it entered a dir
@@ -80,12 +95,22 @@
 void Nepomuk::SearchModule::registerSearchUrl( const QString& urlString )
 {
     const KUrl url( urlString );
+    KUrl queryUrl;
 
     if ( isNepomukSearchUrl( url ) ) {
+        queryUrl = url;
+    }
+    else if ( isTimelineUrl( url ) ) {
+        QDate date;
+        if ( Nepomuk::parseTimelineUrl( url, &date ) == Nepomuk::DayFolder )
+            queryUrl = Nepomuk::buildTimelineQueryUrl( date );
+    }
+
+    if ( queryUrl.isValid() ) {
         kDebug() << "REGISTER REGISTER REGISTER REGISTER REGISTER REGISTER" << url;
         QHash<KUrl, SearchUrlListener*>::iterator it = m_queryHash.find( url );
         if ( it == m_queryHash.end() ) {
-            SearchUrlListener* listener = new SearchUrlListener( url );
+            SearchUrlListener* listener = new SearchUrlListener( queryUrl, url );
             listener->ref();
             m_queryHash.insert( url, listener );
         }
@@ -93,8 +118,10 @@
             it.value()->ref();
         }
 
-        if ( calledFromDBus() )
+        if ( calledFromDBus() ) {
             m_dbusServiceUrlHash.insert( message().service(), url );
+            m_watcher->addWatchedService( message().service() );
+        }
     }
 }
 
@@ -102,11 +129,14 @@
 void Nepomuk::SearchModule::unregisterSearchUrl( const QString& urlString )
 {
     const KUrl url( urlString );
-    if ( isNepomukSearchUrl( url ) ) {
+    if ( isNepomukSearchOrTimelineUrl( url ) ) {
         kDebug() << "UNREGISTER UNREGISTER UNREGISTER UNREGISTER UNREGISTER" << url;
         unrefUrl( url );
-        if ( calledFromDBus() )
+        if ( calledFromDBus() ) {
             m_dbusServiceUrlHash.remove( message().service(), url );
+            if ( !m_dbusServiceUrlHash.contains( message().service() ) )
+                m_watcher->removeWatchedService( message().service() );
+        }
     }
 }
 
@@ -117,18 +147,15 @@
 }
 
 
-void Nepomuk::SearchModule::slotServiceOwnerChanged( const QString& serviceName,
-                                                     const QString&,
-                                                     const QString& newOwner )
+void Nepomuk::SearchModule::slotServiceUnregistered( const QString& serviceName )
 {
-    if ( newOwner.isEmpty() ) {
-        QHash<QString, KUrl>::iterator it = m_dbusServiceUrlHash.find( serviceName );
-        while ( it != m_dbusServiceUrlHash.end() ) {
-            unrefUrl( it.value() );
-            m_dbusServiceUrlHash.erase( it );
-            it = m_dbusServiceUrlHash.find( serviceName );
-        }
+    QHash<QString, KUrl>::iterator it = m_dbusServiceUrlHash.find( serviceName );
+    while ( it != m_dbusServiceUrlHash.end() ) {
+        unrefUrl( it.value() );
+        m_dbusServiceUrlHash.erase( it );
+        it = m_dbusServiceUrlHash.find( serviceName );
     }
+    m_watcher->removeWatchedService( serviceName );
 }
 
 
Index: nepomuk/kioslaves/search/kdedmodule/CMakeLists.txt
===================================================================
--- nepomuk/kioslaves/search/kdedmodule/CMakeLists.txt	(révision 1121160)
+++ nepomuk/kioslaves/search/kdedmodule/CMakeLists.txt	(copie de travail)
@@ -11,6 +11,7 @@
 set(nepomuksearchmodule_SRCS
   nepomuksearchmodule.cpp
   searchurllistener.cpp
+  ../../common/timelinetools.cpp
 )
 
 soprano_add_ontology(nepomuksearchmodule_SRCS
@@ -18,6 +19,16 @@
   "NIE"
   "Nepomuk::Vocabulary"
   "trig")
+soprano_add_ontology(nepomuksearchmodule_SRCS
+  ${SHAREDDESKTOPONTOLOGIES_ROOT_DIR}/nie/nfo.trig
+  "NFO"
+  "Nepomuk::Vocabulary"
+  "trig")
+soprano_add_ontology(nepomuksearchmodule_SRCS
+  ${SHAREDDESKTOPONTOLOGIES_ROOT_DIR}/nepomuk/nuao.trig
+  "NUAO"
+  "Nepomuk::Vocabulary"
+  "trig")
 
 set_source_files_properties(
   ${nepomuk_kio_slaves_SOURCE_DIR}/../interfaces/org.kde.nepomuk.Query.xml
Index: nepomuk/kioslaves/search/CMakeLists.txt
===================================================================
--- nepomuk/kioslaves/search/CMakeLists.txt	(révision 1121160)
+++ nepomuk/kioslaves/search/CMakeLists.txt	(copie de travail)
@@ -18,6 +18,7 @@
 set(kio_nepomuksearch_PART_SRCS
   kio_nepomuksearch.cpp
   searchfolder.cpp
+  ../common/resourcestat.cpp
 )
 
 soprano_add_ontology(kio_nepomuksearch_PART_SRCS
@@ -41,6 +42,7 @@
 
 target_link_libraries(kio_nepomuksearch
   ${KDE4_KIO_LIBS}
+  ${KDE4_SOLID_LIBS}
   ${NEPOMUK_LIBRARIES}
   ${NEPOMUK_QUERY_LIBRARIES}
   ${SOPRANO_LIBRARIES}
Index: nepomuk/kioslaves/timeline/kio_timeline.cpp
===================================================================
--- nepomuk/kioslaves/timeline/kio_timeline.cpp	(révision 1121160)
+++ nepomuk/kioslaves/timeline/kio_timeline.cpp	(copie de travail)
@@ -20,6 +20,11 @@
 
 #include "kio_timeline.h"
 
+#include "nfo.h"
+#include "nie.h"
+#include "nuao.h"
+#include "timelinetools.h"
+
 #include <KUrl>
 #include <kio/global.h>
 #include <klocale.h>
@@ -28,8 +33,8 @@
 #include <KDebug>
 #include <KLocale>
 #include <kio/netaccess.h>
-#include <KCalendarSystem>
 #include <KComponentData>
+#include <KCalendarSystem>
 
 #include <Soprano/Vocabulary/NAO>
 #include <Soprano/Vocabulary/XMLSchema>
@@ -47,38 +52,6 @@
 
 
 namespace {
-    const char* DATEFORMATSTART("yyyy-MM-ddT00:00:00.000Z");
-    const char* DATEFORMATEND("yyyy-MM-ddT23:59:59.999Z");
-
-    KUrl buildQueryUrl( const QDate& date )
-    {
-        QString dateFrom = date.toString(DATEFORMATSTART);
-        QString dateTo = date.toString(DATEFORMATEND);
-
-        QString query = QString("select distinct ?r where { "
-                                "?r a nfo:FileDataObject . "
-                                "{"
-                                "  ?r nie:lastModified ?date . "
-                                "} "
-#ifdef NEPOMUK_TIMELINE_WITH_NTAO
-                                "UNION "
-                                "{"
-                                "  ?de a ?det . ?det rdfs:subClassOf ntao:DataObjectEvent . "
-                                "  ?de ntao:timestamp ?date . "
-                                "  ?de ntao:dataObject ?r . "
-                                "} "
-#endif
-                                "FILTER(?date > '%1'^^%3 && ?date < '%2'^^%3) . "
-                                "OPTIONAL { ?r2 a nfo:Folder . FILTER(?r=?r2) . } . FILTER(!BOUND(?r2)) . "
-                                "}")
-                        .arg(dateFrom)
-                        .arg(dateTo)
-                        .arg(Soprano::Node::resourceToN3(Soprano::Vocabulary::XMLSchema::dateTime()));
-        KUrl url("nepomuksearch:/");
-        url.addQueryItem( "sparql", query );
-        return url;
-    }
-
     KIO::UDSEntry createFolderUDSEntry( const QString& name, const QString& displayName, const QDate& date )
     {
         KIO::UDSEntry uds;
@@ -116,50 +89,11 @@
                                      KGlobal::locale()->formatDate( date, KLocale::FancyLongDate ),
                                      date );
     }
-
-    QDate applyRelativeDateModificators( const QDate& date, const QMap<QString, QString>& modificators )
-    {
-        QDate newDate( date );
-        const QString dayKey = QLatin1String("relDays");
-        const QString weekKey = QLatin1String("relWeeks");
-        const QString monthKey = QLatin1String("relMonths");
-        const QString yearKey = QLatin1String("relYears");
-        bool ok = false;
-
-        if (modificators.contains(yearKey)) {
-            int relYears = modificators[yearKey].toInt(&ok);
-            if (ok) {
-                newDate = newDate.addYears(relYears);
-            }
-        }
-        if (modificators.contains(monthKey)) {
-            int relMonths = modificators[monthKey].toInt(&ok);
-            if (ok) {
-                newDate = newDate.addMonths(relMonths);
-            }
-        }
-        if (modificators.contains(weekKey)) {
-            int relWeeks = modificators[weekKey].toInt(&ok);
-            if (ok) {
-                const KCalendarSystem * calSystem = KGlobal::locale()->calendar();
-                newDate = newDate.addDays(relWeeks * calSystem->daysInWeek(date));
-            }
-        }
-        if (modificators.contains(dayKey)) {
-            int relDays = modificators[dayKey].toInt(&ok);
-            if (ok) {
-                newDate = newDate.addDays(relDays);
-            }
-        }
-        return newDate;
-    }
 }
 
 
 Nepomuk::TimelineProtocol::TimelineProtocol( const QByteArray& poolSocket, const QByteArray& appSocket )
-    : KIO::ForwardingSlaveBase( "timeline", poolSocket, appSocket ),
-      m_folderType( NoFolder ),
-      m_dateRegexp( QLatin1String("\\d{4}-\\d{2}(?:-(\\d{2}))?") )
+    : KIO::ForwardingSlaveBase( "timeline", poolSocket, appSocket )
 {
     kDebug();
 }
@@ -173,39 +107,34 @@
 
 void Nepomuk::TimelineProtocol::listDir( const KUrl& url )
 {
-    if ( parseUrl( url ) ) {
-        switch( m_folderType ) {
-        case RootFolder:
-            listEntry( createFolderUDSEntry( QLatin1String("today"), i18n("Today"), QDate::currentDate() ), false );
-            listEntry( createFolderUDSEntry( QLatin1String("calendar"), i18n("Calendar"), QDate::currentDate() ), false );
-            listEntry( KIO::UDSEntry(), true );
-            finished();
-            break;
+    switch( parseTimelineUrl( url, &m_date, &m_filename ) ) {
+    case RootFolder:
+        listEntry( createFolderUDSEntry( QLatin1String("today"), i18n("Today"), QDate::currentDate() ), false );
+        listEntry( createFolderUDSEntry( QLatin1String("calendar"), i18n("Calendar"), QDate::currentDate() ), false );
+        listEntry( KIO::UDSEntry(), true );
+        finished();
+        break;
 
-        case CalendarFolder:
-            listThisYearsMonths();
-            // TODO: add entry for previous years
-            listEntry( KIO::UDSEntry(), true );
-            finished();
-            break;
+    case CalendarFolder:
+        listThisYearsMonths();
+        // TODO: add entry for previous years
+        listEntry( KIO::UDSEntry(), true );
+        finished();
+        break;
 
-        case MonthFolder:
-            listDays( m_date.month(), m_date.year() );
-            listEntry( KIO::UDSEntry(), true );
-            finished();
-            break;
+    case MonthFolder:
+        listDays( m_date.month(), m_date.year() );
+        listEntry( KIO::UDSEntry(), true );
+        finished();
+        break;
 
-        case DayFolder:
-            ForwardingSlaveBase::listDir( url );
-            break;
+    case DayFolder:
+        ForwardingSlaveBase::listDir( url );
+        break;
 
-        default:
-            error( KIO::ERR_DOES_NOT_EXIST, url.prettyUrl() );
-            break;
-        }
-    }
-    else {
+    default:
         error( KIO::ERR_DOES_NOT_EXIST, url.prettyUrl() );
+        break;
     }
 }
 
@@ -221,7 +150,7 @@
 {
     kDebug() << url;
 
-    if ( parseUrl( url ) && !m_filename.isEmpty() ) {
+    if ( parseTimelineUrl( url, &m_date, &m_filename ) && !m_filename.isEmpty() ) {
         ForwardingSlaveBase::get( url );
     }
     else {
@@ -234,7 +163,7 @@
 {
     kDebug() << url;
 
-    if ( parseUrl( url ) && !m_filename.isEmpty() ) {
+    if ( parseTimelineUrl( url, &m_date, &m_filename ) && !m_filename.isEmpty() ) {
         ForwardingSlaveBase::put( url, permissions, flags );
     }
     else {
@@ -280,46 +209,41 @@
 
 void Nepomuk::TimelineProtocol::stat( const KUrl& url )
 {
-    if ( parseUrl( url ) ) {
-        switch( m_folderType ) {
-        case RootFolder: {
-            KIO::UDSEntry uds;
-            uds.insert( KIO::UDSEntry::UDS_NAME, QString::fromLatin1( "/" ) );
-            uds.insert( KIO::UDSEntry::UDS_ICON_NAME, QString::fromLatin1( "nepomuk" ) );
-            uds.insert( KIO::UDSEntry::UDS_FILE_TYPE, S_IFDIR );
-            uds.insert( KIO::UDSEntry::UDS_MIME_TYPE, QString::fromLatin1( "inode/directory" ) );
-            statEntry( uds );
-            finished();
-            break;
-        }
+    switch( parseTimelineUrl( url, &m_date, &m_filename ) ) {
+    case RootFolder: {
+        KIO::UDSEntry uds;
+        uds.insert( KIO::UDSEntry::UDS_NAME, QString::fromLatin1( "/" ) );
+        uds.insert( KIO::UDSEntry::UDS_ICON_NAME, QString::fromLatin1( "nepomuk" ) );
+        uds.insert( KIO::UDSEntry::UDS_FILE_TYPE, S_IFDIR );
+        uds.insert( KIO::UDSEntry::UDS_MIME_TYPE, QString::fromLatin1( "inode/directory" ) );
+        statEntry( uds );
+        finished();
+        break;
+    }
 
-        case CalendarFolder:
-            statEntry( createFolderUDSEntry( QLatin1String("calendar"), i18n("Calendar"), QDate::currentDate() ) );
-            finished();
-            break;
+    case CalendarFolder:
+        statEntry( createFolderUDSEntry( QLatin1String("calendar"), i18n("Calendar"), QDate::currentDate() ) );
+        finished();
+        break;
 
-        case MonthFolder:
-            statEntry( createMonthUDSEntry( m_date.month(), m_date.year() ) );
-            finished();
-            break;
+    case MonthFolder:
+        statEntry( createMonthUDSEntry( m_date.month(), m_date.year() ) );
+        finished();
+        break;
 
-        case DayFolder:
-            if ( m_filename.isEmpty() ) {
-                statEntry( createDayUDSEntry( m_date ) );
-                finished();
-            }
-            else {
-                ForwardingSlaveBase::stat( url );
-            }
-            break;
-
-        default:
-            error( KIO::ERR_DOES_NOT_EXIST, url.prettyUrl() );
-            break;
+    case DayFolder:
+        if ( m_filename.isEmpty() ) {
+            statEntry( createDayUDSEntry( m_date ) );
+            finished();
         }
-    }
-    else {
+        else {
+            ForwardingSlaveBase::stat( url );
+        }
+        break;
+
+    default:
         error( KIO::ERR_DOES_NOT_EXIST, url.prettyUrl() );
+        break;
     }
 }
 
@@ -327,8 +251,8 @@
 // only used for the queries
 bool Nepomuk::TimelineProtocol::rewriteUrl( const KUrl& url, KUrl& newURL )
 {
-    if ( parseUrl( url ) && m_folderType == DayFolder ) {
-        newURL = buildQueryUrl( m_date );
+    if ( parseTimelineUrl( url, &m_date, &m_filename ) == DayFolder ) {
+        newURL = buildTimelineQueryUrl( m_date );
         newURL.setPath( QLatin1String( "/" ) + m_filename );
         return true;
     }
@@ -377,67 +301,6 @@
 }
 
 
-bool Nepomuk::TimelineProtocol::parseUrl( const KUrl& url )
-{
-    kDebug() << url;
-
-    // rest
-    m_date = QDate();
-    m_filename.truncate(0);
-
-    const QString path = url.path(KUrl::RemoveTrailingSlash);
-
-    if( path.isEmpty() || path == QLatin1String("/") ) {
-        m_folderType = RootFolder;
-        kDebug() << url << "is root folder";
-        return true;
-    }
-    else if( path.startsWith( QLatin1String( "/today" ) ) ) {
-        m_folderType = DayFolder;
-        m_date = QDate::currentDate();
-        m_filename = path.mid( 7 );
-        kDebug() << url << "is today folder:" << m_date << m_filename;
-        return true;
-    }
-    else if( path == QLatin1String( "/calendar" ) ) {
-        m_folderType = CalendarFolder;
-        kDebug() << url << "is calendar folder";
-        return true;
-    }
-    else {
-        QStringList sections = path.split( QLatin1String( "/" ), QString::SkipEmptyParts );
-        QString dateString;
-        if ( m_dateRegexp.exactMatch( sections.last() ) ) {
-            dateString = sections.last();
-        }
-        else if ( sections.count() > 1 && m_dateRegexp.exactMatch( sections[sections.count()-2] ) ) {
-            dateString = sections[sections.count()-2];
-            m_filename = sections.last();
-        }
-        else {
-            kDebug() << url << "COULD NOT PARSE";
-            return false;
-        }
-
-        if ( m_dateRegexp.cap( 1 ).isEmpty() ) {
-            // no day -> month listing
-            m_folderType = MonthFolder;
-            kDebug() << "parsing " << dateString;
-            m_date = QDate::fromString( dateString, QLatin1String("yyyy-MM") );
-            kDebug() << url << "is month folder:" << m_date.month() << m_date.year();
-            return m_date.month() > 0 && m_date.year() > 0;
-        }
-        else {
-            m_folderType = DayFolder;
-            kDebug() << "parsing " << dateString;
-            m_date = applyRelativeDateModificators( QDate::fromString( dateString, "yyyy-MM-dd" ), url.queryItems() );
-            // only in day folders we can have filenames
-            kDebug() << url << "is day folder:" << m_date << m_filename;
-            return m_date.isValid();
-        }
-    }
-}
-
 extern "C"
 {
     KDE_EXPORT int kdemain( int argc, char **argv )
Index: nepomuk/kioslaves/timeline/CMakeLists.txt
===================================================================
--- nepomuk/kioslaves/timeline/CMakeLists.txt	(révision 1121160)
+++ nepomuk/kioslaves/timeline/CMakeLists.txt	(copie de travail)
@@ -5,12 +5,31 @@
   ${KDE4_INCLUDES}
   ${KDE4_KIO_INCLUDES}
   ${NEPOMUK_INCLUDE_DIR}
+  ${nepomuk_kio_slaves_SOURCE_DIR}/common
 )
 
 ########### next target ###############
 
-set(kio_timeline_PART_SRCS kio_timeline.cpp)
+set(kio_timeline_PART_SRCS
+  kio_timeline.cpp
+  ../common/timelinetools.cpp)
 
+soprano_add_ontology(kio_timeline_PART_SRCS
+  ${SHAREDDESKTOPONTOLOGIES_ROOT_DIR}/nie/nfo.trig
+  "NFO"
+  "Nepomuk::Vocabulary"
+  "trig")
+soprano_add_ontology(kio_timeline_PART_SRCS
+  ${SHAREDDESKTOPONTOLOGIES_ROOT_DIR}/nie/nie.trig
+  "NIE"
+  "Nepomuk::Vocabulary"
+  "trig")
+soprano_add_ontology(kio_timeline_PART_SRCS
+  ${SHAREDDESKTOPONTOLOGIES_ROOT_DIR}/nepomuk/nuao.trig
+  "NUAO"
+  "Nepomuk::Vocabulary"
+  "trig")
+
 kde4_add_plugin(kio_timeline ${kio_timeline_PART_SRCS})
 
 target_link_libraries(kio_timeline
Index: nepomuk/kioslaves/timeline/kio_timeline.h
===================================================================
--- nepomuk/kioslaves/timeline/kio_timeline.h	(révision 1121160)
+++ nepomuk/kioslaves/timeline/kio_timeline.h	(copie de travail)
@@ -24,9 +24,7 @@
 #include <kio/forwardingslavebase.h>
 
 #include <QtCore/QDate>
-#include <QtCore/QRegExp>
 
-
 namespace Nepomuk {
     class TimelineProtocol : public KIO::ForwardingSlaveBase
     {
@@ -100,24 +98,9 @@
         void listThisYearsMonths();
         void listPreviousYears();
 
-        /// will set m_date, m_filename, and m_folderType
-        bool parseUrl( const KUrl& url );
-
-        /// folder type that is set by parseUrl
-        enum FolderType {
-            NoFolder = 0,    /// nothing
-            RootFolder,      /// the root folder
-            CalendarFolder,  /// the calendar folder listing all months
-            MonthFolder,     /// a folder listing a month's days (m_date contains the month)
-            DayFolder        /// a folder listing a day (m_date); optionally m_filename is set
-        };
-
         /// temp vars for the currently handled URL
         QDate m_date;
         QString m_filename;
-        FolderType m_folderType;
-
-        const QRegExp m_dateRegexp;
     };
 }
 
Index: nepomuk/kioslaves/common/resourcestat.cpp
===================================================================
--- nepomuk/kioslaves/common/resourcestat.cpp	(révision 0)
+++ nepomuk/kioslaves/common/resourcestat.cpp	(révision 0)
@@ -0,0 +1,382 @@
+/*
+   Copyright 2008-2010 Sebastian Trueg <trueg@kde.org>
+
+   This program is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public License as
+   published by the Free Software Foundation; either version 2 of
+   the License or (at your option) version 3 or any later version
+   accepted by the membership of KDE e.V. (or its successor approved
+   by the membership of KDE e.V.), which shall act as a proxy
+   defined in Section 14 of version 3 of the license.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include "resourcestat.h"
+#include "nepomuksearchurltools.h"
+#include "nie.h"
+#include "nfo.h"
+#include "pimo.h"
+
+#include <QtCore/QEventLoop>
+#include <QtCore/QTimer>
+#include <QtCore/QFile>
+
+#include <KUrl>
+#include <KMimeType>
+#include <KUser>
+#include <kio/udsentry.h>
+#include <KDebug>
+
+#include <Nepomuk/Thing>
+#include <Nepomuk/Variant>
+#include <Nepomuk/Types/Class>
+#include <Nepomuk/ResourceManager>
+#include <Nepomuk/Query/Query>
+#include <Nepomuk/Query/ComparisonTerm>
+#include <Nepomuk/Query/ResourceTerm>
+
+#include <Soprano/Vocabulary/RDF>
+#include <Soprano/Vocabulary/NAO>
+#include <Soprano/QueryResultIterator>
+#include <Soprano/NodeIterator>
+#include <Soprano/Node>
+#include <Soprano/Model>
+
+#include <Solid/Device>
+#include <Solid/StorageAccess>
+
+
+KUrl Nepomuk::stripQuery( const KUrl& url )
+{
+    KUrl newUrl( url );
+    newUrl.setEncodedQuery( QByteArray() );
+    return newUrl;
+}
+
+
+Nepomuk::Resource Nepomuk::splitNepomukUrl( const KUrl& url, QString* filename )
+{
+    //
+    // let's try to extract the resource from the url in case we listed a tag or
+    // filesystem and need to stat the entries in those virtual folders
+    //
+    // pre KDE 4.4 resources had just a single section, in KDE 4.4 we have "/res/<UUID>"
+    //
+    QString urlStr = stripQuery( url ).url();
+    int pos = urlStr.indexOf( '/', urlStr.startsWith( QLatin1String( "nepomuk:/res/" ) ) ? 13 : 9 );
+    if ( pos > 0 ) {
+        KUrl resourceUri = urlStr.left(pos);
+        if ( filename )
+            *filename = urlStr.mid( pos+1 );
+        return resourceUri;
+    }
+    else {
+        return stripQuery( url );
+    }
+}
+
+
+bool Nepomuk::isRemovableMediaFile( const Nepomuk::Resource& res )
+{
+    if ( res.hasProperty( Nepomuk::Vocabulary::NIE::url() ) ) {
+        KUrl url = res.property( Nepomuk::Vocabulary::NIE::url() ).toUrl();
+        return ( url.protocol() == QLatin1String( "filex" ) );
+    }
+    else {
+        return false;
+    }
+}
+
+
+Solid::StorageAccess* Nepomuk::storageFromUUID( const QString& uuid )
+{
+    QString solidQuery = QString::fromLatin1( "[ StorageVolume.usage=='FileSystem' AND StorageVolume.uuid=='%1' ]" ).arg( uuid.toLower() );
+    QList<Solid::Device> devices = Solid::Device::listFromQuery( solidQuery );
+    kDebug() << uuid << solidQuery << devices.count();
+    if ( !devices.isEmpty() )
+        return devices.first().as<Solid::StorageAccess>();
+    else
+        return 0;
+}
+
+
+bool Nepomuk::mountAndWait( Solid::StorageAccess* storage )
+{
+    kDebug() << storage;
+    QEventLoop loop;
+    loop.connect( storage,
+                  SIGNAL(accessibilityChanged(bool, QString)),
+                  SLOT(quit()) );
+    // timeout 20 second
+    QTimer::singleShot( 20000, &loop, SLOT(quit()) );
+
+    storage->setup();
+    loop.exec();
+
+    kDebug() << storage << storage->isAccessible();
+
+    return storage->isAccessible();
+}
+
+
+KUrl Nepomuk::determineFilesystemPath( const Nepomuk::Resource& fsRes )
+{
+    QString uuidQuery = QString::fromLatin1( "select ?uuid where { %1 %2 ?uuid . }" )
+                        .arg( Soprano::Node::resourceToN3( fsRes.resourceUri() ),
+                              Soprano::Node::resourceToN3( Soprano::Vocabulary::NAO::identifier() ) );
+    Soprano::QueryResultIterator it = Nepomuk::ResourceManager::instance()->mainModel()->executeQuery( uuidQuery, Soprano::Query::QueryLanguageSparql );
+    if ( it.next() ) {
+        Solid::StorageAccess* storage = storageFromUUID( it["uuid"].toString() );
+        it.close();
+        if ( storage &&
+             ( storage->isAccessible() ||
+               mountAndWait( storage ) ) ) {
+            return storage->filePath();
+        }
+    }
+    return KUrl();
+}
+
+
+QString Nepomuk::getFileSystemLabelForRemovableMediaFileUrl( const Nepomuk::Resource& res )
+{
+    QList<Soprano::Node> labelNodes
+        = Nepomuk::ResourceManager::instance()->mainModel()->executeQuery( QString::fromLatin1( "select ?label where { "
+                                                                                                "%1 nie:isPartOf ?fs . "
+                                                                                                "?fs a nfo:Filesystem . "
+                                                                                                "?fs nao:prefLabel ?label . "
+                                                                                                "} LIMIT 1" )
+                                                                           .arg( Soprano::Node::resourceToN3( res.resourceUri() ) ),
+                                                                           Soprano::Query::QueryLanguageSparql ).iterateBindings( "label" ).allNodes();
+
+    if ( !labelNodes.isEmpty() )
+        return labelNodes.first().toString();
+    else
+        return res.property( Nepomuk::Vocabulary::NIE::url() ).toUrl().host(); // Solid UUID
+}
+
+
+KUrl Nepomuk::convertRemovableMediaFileUrl( const KUrl& url, bool evenMountIfNecessary )
+{
+    Solid::StorageAccess* storage = Nepomuk::storageFromUUID( url.host() );
+    kDebug() << url << storage;
+    if ( storage &&
+         ( storage->isAccessible() ||
+           ( evenMountIfNecessary && Nepomuk::mountAndWait( storage ) ) ) ) {
+        kDebug() << "converted:" << KUrl( storage->filePath() + QLatin1String( "/" ) + url.path() );
+        return storage->filePath() + QLatin1String( "/" ) + url.path();
+    }
+    else {
+        return KUrl();
+    }
+}
+
+
+KIO::UDSEntry Nepomuk::statNepomukResource( const Nepomuk::Resource& res )
+{
+    //
+    // We do not have a local file
+    // This is where the magic starts to happen.
+    // This is where we only use Nepomuk properties
+    //
+    KIO::UDSEntry uds;
+
+    // we handle files on removable media which are not mounted
+    // as a special case
+    bool isFileOnRemovableMedium = isRemovableMediaFile( res );
+
+    // The display name can be anything
+    QString displayName;
+    if ( isFileOnRemovableMedium ) {
+        displayName = i18nc( "%1 is a filename of a file on a removable device, "
+                             "%2 is the name of the removable medium which often is something like "
+                             "'X GiB Removable Media.",
+                             "%1 (on unmounted medium <resource>%2</resource>)",
+                             res.genericLabel(),
+                             getFileSystemLabelForRemovableMediaFileUrl( res ) );
+    }
+    else {
+        displayName = res.genericLabel();
+    }
+    uds.insert( KIO::UDSEntry::UDS_DISPLAY_NAME, displayName );
+
+    // UDS_NAME needs to be unique but can be ugly
+    uds.insert( KIO::UDSEntry::UDS_NAME, resourceUriToUdsName( res.resourceUri() ) );
+
+    //
+    // There can still be file resources that have a mimetype but are
+    // stored remotely, thus they do not have a local nie:url
+    //
+    // Sadly Strigi's mimetype is not very useful (yet)
+    /* QStringList mimeTypes = res.property( Vocabulary::NIE::mimeType() ).toStringList();
+    if ( !mimeTypes.isEmpty() ) {
+        uds.insert( KIO::UDSEntry::UDS_MIME_TYPE, mimeTypes.first() );
+    }
+    else */
+    if ( isFileOnRemovableMedium ) {
+        KMimeType::Ptr mt = KMimeType::findByUrl( res.property( Vocabulary::NIE::url() ).toUrl(),
+                                                  0,
+                                                  false, /* no local file as it is not accessible at the moment */
+                                                  true   /* fast mode */ );
+        if ( mt ) {
+            uds.insert( KIO::UDSEntry::UDS_MIME_TYPE, mt->name() );
+        }
+    }
+    else {
+        // Use nice display types like "Person", "Project" and so on
+        Nepomuk::Types::Class type( res.resourceType() );
+        if (!type.label().isEmpty())
+            uds.insert( KIO::UDSEntry::UDS_DISPLAY_TYPE, type.label() );
+
+        QString icon = res.genericIcon();
+        if ( !icon.isEmpty() ) {
+            uds.insert( KIO::UDSEntry::UDS_ICON_NAME, icon );
+        }
+        else {
+            // a fallback icon for nepomuk resources
+            uds.insert( KIO::UDSEntry::UDS_ICON_NAME, QLatin1String( "nepomuk" ) );
+        }
+
+        if ( uds.stringValue( KIO::UDSEntry::UDS_ICON_NAME ) != QLatin1String( "nepomuk" ) )
+            uds.insert( KIO::UDSEntry::UDS_ICON_OVERLAY_NAMES, QLatin1String( "nepomuk" ) );
+    }
+
+    //
+    // Add some random values
+    //
+    uds.insert( KIO::UDSEntry::UDS_ACCESS, 0700 );
+    uds.insert( KIO::UDSEntry::UDS_USER, KUser().loginName() );
+    if ( res.hasProperty( Vocabulary::NIE::lastModified() ) ) {
+        // remotely stored files
+        uds.insert( KIO::UDSEntry::UDS_MODIFICATION_TIME, res.property( Vocabulary::NIE::lastModified() ).toDateTime().toTime_t() );
+    }
+    else {
+        // all nepomuk resources
+        uds.insert( KIO::UDSEntry::UDS_MODIFICATION_TIME, res.property( Soprano::Vocabulary::NAO::lastModified() ).toDateTime().toTime_t() );
+        uds.insert( KIO::UDSEntry::UDS_CREATION_TIME, res.property( Soprano::Vocabulary::NAO::created() ).toDateTime().toTime_t() );
+    }
+
+    if ( res.hasProperty( Vocabulary::NIE::contentSize() ) ) {
+        // remotely stored files
+        uds.insert( KIO::UDSEntry::UDS_SIZE, res.property( Vocabulary::NIE::contentSize() ).toInt() );
+    }
+
+
+    //
+    // Starting with KDE 4.4 we have the pretty UDS_NEPOMUK_URI which makes
+    // everything much cleaner since kio slaves can decide if the resources can be
+    // annotated or not.
+    //
+    uds.insert( KIO::UDSEntry::UDS_NEPOMUK_URI, KUrl( res.resourceUri() ).url() );
+
+    KUrl reUrl = Nepomuk::redirectionUrl( res );
+    if ( !reUrl.isEmpty() ) {
+        uds.insert( KIO::UDSEntry::UDS_MIME_TYPE, QLatin1String( "inode/directory" ) );
+        uds.insert( KIO::UDSEntry::UDS_FILE_TYPE, S_IFDIR );
+
+        // FIXME: not sure this is necessary if we already do the redirect in listDir()
+        uds.insert( KIO::UDSEntry::UDS_URL, reUrl.url() );
+    }
+
+    return uds;
+}
+
+
+bool Nepomuk::willBeRedirected( const Nepomuk::Resource& res )
+{
+    return( res.hasType( Nepomuk::Vocabulary::NFO::Folder() ) ||
+            res.hasType( Soprano::Vocabulary::NAO::Tag() ) ||
+            res.hasType( Nepomuk::Vocabulary::NFO::Filesystem() ) );
+}
+
+
+KUrl Nepomuk::redirectionUrl( const Nepomuk::Resource& res )
+{
+    if ( res.hasType( Nepomuk::Vocabulary::NFO::Folder() ) ) {
+        return res.property( Nepomuk::Vocabulary::NIE::url() ).toUrl();
+    }
+    else if ( res.hasType( Nepomuk::Vocabulary::NFO::Filesystem() ) ) {
+        KUrl fsUrl = determineFilesystemPath( res );
+        if ( fsUrl.isValid() ) {
+            return fsUrl;
+        }
+    }
+    else if ( res.hasType( Soprano::Vocabulary::NAO::Tag() ) ) {
+        Query::ComparisonTerm term( Soprano::Vocabulary::NAO::hasTag(), Query::ResourceTerm( res ), Query::ComparisonTerm::Equal );
+        KUrl queryUrl( Query::Query( term ).toSearchUrl() );
+        queryUrl.addQueryItem( QLatin1String( "title" ), i18n( "Things tagged '%1'", res.genericLabel() ) );
+        return queryUrl.url();
+    }
+
+#if 0 // disabled as long as the strigi service does create a dedicated album resource for each track
+    else if ( res.hasType( Nepomuk::Vocabulary::NMM::MusicAlbum() ) ) {
+        Query::ComparisonTerm term( Nepomuk::Vocabulary::NMM::musicAlbum(), Query::ResourceTerm( res ) );
+        KUrl queryUrl( Query::Query( term ).toSearchUrl() );
+        queryUrl.addQueryItem( QLatin1String( "title" ), res.genericLabel() );
+        return queryUrl.url();
+    }
+#endif
+
+    return KUrl();
+}
+
+
+namespace {
+    /**
+     * Check if the resource represents a local file with an existing nie:url property.
+     */
+    bool isLocalFile( const Nepomuk::Resource& res )
+    {
+        if ( res.hasProperty( Nepomuk::Vocabulary::NIE::url() ) ) {
+            KUrl url = res.property( Nepomuk::Vocabulary::NIE::url() ).toUrl();
+            return ( !url.isEmpty() &&
+                     QFile::exists( url.toLocalFile() ) );
+        }
+        else {
+            return false;
+        }
+    }
+}
+
+KUrl Nepomuk::nepomukToFileUrl( const KUrl& url, bool evenMountIfNecessary )
+{
+    QString filename;
+    Nepomuk::Resource res = splitNepomukUrl( url, &filename );
+
+    if ( !res.exists() )
+        return KUrl();
+
+    KUrl newURL;
+
+    //
+    // let's see if it is a pimo thing which refers to a file
+    //
+    if ( res.hasType( Nepomuk::Vocabulary::PIMO::Thing() ) ) {
+        if ( !res.pimoThing().groundingOccurrences().isEmpty() ) {
+            res = res.pimoThing().groundingOccurrences().first();
+        }
+    }
+
+    if ( isLocalFile( res ) ) {
+        newURL = res.property( Vocabulary::NIE::url() ).toUrl();
+    }
+    else if ( isRemovableMediaFile( res ) ) {
+        const KUrl removableMediaUrl = res.property( Nepomuk::Vocabulary::NIE::url() ).toUrl();
+        newURL = convertRemovableMediaFileUrl( removableMediaUrl, evenMountIfNecessary );
+    }
+
+    if ( newURL.isValid() && !filename.isEmpty() ) {
+        newURL.addPath( filename );
+    }
+
+    kDebug() << url << newURL;
+
+    return newURL;
+}

Modification de propriétés sur nepomuk/kioslaves/common/resourcestat.cpp
___________________________________________________________________
Ajouté : svn:eol-style
   + native

Index: nepomuk/kioslaves/common/timelinetools.cpp
===================================================================
--- nepomuk/kioslaves/common/timelinetools.cpp	(révision 0)
+++ nepomuk/kioslaves/common/timelinetools.cpp	(révision 0)
@@ -0,0 +1,173 @@
+/*
+   This file is part of the Nepomuk KDE project.
+   Copyright (C) 2010 Sebastian Trueg <trueg@kde.org>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License version 2 as published by the Free Software Foundation.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public License
+   along with this library; see the file COPYING.LIB.  If not, write to
+   the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.
+ */
+
+#include "timelinetools.h"
+
+#include <Soprano/Node>
+#include <Soprano/Vocabulary/XMLSchema>
+
+#include "nie.h"
+#include "nfo.h"
+#include "nie.h"
+#include "nuao.h"
+
+#include <KUrl>
+#include <KCalendarSystem>
+#include <KGlobal>
+#include <KLocale>
+#include <KDebug>
+
+#include <QtCore/QDate>
+#include <QtCore/QRegExp>
+
+
+namespace {
+    QDate applyRelativeDateModificators( const QDate& date, const QMap<QString, QString>& modificators )
+    {
+        QDate newDate( date );
+        const QString dayKey = QLatin1String("relDays");
+        const QString weekKey = QLatin1String("relWeeks");
+        const QString monthKey = QLatin1String("relMonths");
+        const QString yearKey = QLatin1String("relYears");
+        bool ok = false;
+
+        if (modificators.contains(yearKey)) {
+            int relYears = modificators[yearKey].toInt(&ok);
+            if (ok) {
+                newDate = newDate.addYears(relYears);
+            }
+        }
+        if (modificators.contains(monthKey)) {
+            int relMonths = modificators[monthKey].toInt(&ok);
+            if (ok) {
+                newDate = newDate.addMonths(relMonths);
+            }
+        }
+        if (modificators.contains(weekKey)) {
+            int relWeeks = modificators[weekKey].toInt(&ok);
+            if (ok) {
+                const KCalendarSystem* calSystem = KGlobal::locale()->calendar();
+                newDate = newDate.addDays(relWeeks * calSystem->daysInWeek(date));
+            }
+        }
+        if (modificators.contains(dayKey)) {
+            int relDays = modificators[dayKey].toInt(&ok);
+            if (ok) {
+                newDate = newDate.addDays(relDays);
+            }
+        }
+        return newDate;
+    }
+}
+
+
+Nepomuk::TimelineFolderType Nepomuk::parseTimelineUrl( const KUrl& url, QDate* date, QString* filename )
+{
+    kDebug() << url;
+
+    static QRegExp s_dateRegexp( QLatin1String("\\d{4}-\\d{2}(?:-(\\d{2}))?") );
+
+    // reset
+    *date = QDate();
+
+    const QString path = url.path(KUrl::RemoveTrailingSlash);
+
+    if( path.isEmpty() || path == QLatin1String("/") ) {
+        kDebug() << url << "is root folder";
+        return RootFolder;
+    }
+    else if( path.startsWith( QLatin1String( "/today" ) ) ) {
+        *date = QDate::currentDate();
+        if ( filename )
+            *filename = path.mid( 7 );
+        kDebug() << url << "is today folder:" << *date;
+        return DayFolder;
+    }
+    else if( path == QLatin1String( "/calendar" ) ) {
+        kDebug() << url << "is calendar folder";
+        return CalendarFolder;
+    }
+    else {
+        QStringList sections = path.split( QLatin1String( "/" ), QString::SkipEmptyParts );
+        QString dateString;
+        if ( s_dateRegexp.exactMatch( sections.last() ) ) {
+            dateString = sections.last();
+        }
+        else if ( sections.count() > 1 && s_dateRegexp.exactMatch( sections[sections.count()-2] ) ) {
+            dateString = sections[sections.count()-2];
+            if ( filename )
+                *filename = sections.last();
+        }
+        else {
+            kDebug() << url << "COULD NOT PARSE";
+            return NoFolder;
+        }
+
+        if ( s_dateRegexp.cap( 1 ).isEmpty() ) {
+            // no day -> month listing
+            kDebug() << "parsing " << dateString;
+            *date = QDate::fromString( dateString, QLatin1String("yyyy-MM") );
+            kDebug() << url << "is month folder:" << date->month() << date->year();
+            if ( date->month() > 0 && date->year() > 0 )
+                return MonthFolder;
+        }
+        else {
+            kDebug() << "parsing " << dateString;
+            *date = applyRelativeDateModificators( QDate::fromString( dateString, "yyyy-MM-dd" ), url.queryItems() );
+            // only in day folders we can have filenames
+            kDebug() << url << "is day folder:" << *date;
+            if ( date->isValid() )
+                return DayFolder;
+        }
+    }
+
+    return NoFolder;
+}
+
+
+KUrl Nepomuk::buildTimelineQueryUrl( const QDate& date )
+{
+    static const char* DATEFORMATSTART("yyyy-MM-ddT00:00:00.000Z");
+    static const char* DATEFORMATEND("yyyy-MM-ddT23:59:59.999Z");
+
+    QString dateFrom = date.toString(DATEFORMATSTART);
+    QString dateTo = date.toString(DATEFORMATEND);
+
+    QString query = QString("select distinct ?r where { "
+                            "?r a %1 . "
+                            "{ ?r %2 ?date . } "
+                            "UNION "
+                            "{ ?r %3 ?date . } "
+                            "UNION "
+                            "{ ?r %4 ?date . } "
+                            "FILTER(?date > '%5'^^%7 && ?date < '%6'^^%7) . "
+                            "OPTIONAL { ?r2 a %8 . FILTER(?r=?r2) . } . FILTER(!BOUND(?r2)) . "
+                            "}")
+                    .arg( Soprano::Node::resourceToN3(Nepomuk::Vocabulary::NFO::FileDataObject()),
+                          Soprano::Node::resourceToN3(Nepomuk::Vocabulary::NIE::lastModified()),
+                          Soprano::Node::resourceToN3(Nepomuk::Vocabulary::NUAO::lastUsage()),
+                          Soprano::Node::resourceToN3(Nepomuk::Vocabulary::NIE::contentCreated()),
+                          dateFrom,
+                          dateTo,
+                          Soprano::Node::resourceToN3(Soprano::Vocabulary::XMLSchema::dateTime()),
+                          Soprano::Node::resourceToN3(Nepomuk::Vocabulary::NFO::Folder()) );
+    KUrl url("nepomuksearch:/");
+    url.addQueryItem( "sparql", query );
+    return url;
+}

Modification de propriétés sur nepomuk/kioslaves/common/timelinetools.cpp
___________________________________________________________________
Ajouté : svn:eol-style
   + native

Index: nepomuk/kioslaves/common/resourcestat.h
===================================================================
--- nepomuk/kioslaves/common/resourcestat.h	(révision 0)
+++ nepomuk/kioslaves/common/resourcestat.h	(révision 0)
@@ -0,0 +1,109 @@
+/*
+   Copyright 2008-2010 Sebastian Trueg <trueg@kde.org>
+
+   This program is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public License as
+   published by the Free Software Foundation; either version 2 of
+   the License or (at your option) version 3 or any later version
+   accepted by the membership of KDE e.V. (or its successor approved
+   by the membership of KDE e.V.), which shall act as a proxy
+   defined in Section 14 of version 3 of the license.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef _NEPOMUK_RESOURCE_STAT_H_
+#define _NEPOMUK_RESOURCE_STAT_H_
+
+class QString;
+class KUrl;
+namespace KIO {
+    class UDSEntry;
+}
+namespace Solid {
+    class StorageAccess;
+}
+
+namespace Nepomuk {
+
+    class Resource;
+
+    /**
+     * Remove all query parts from a KUrl.
+     */
+    KUrl stripQuery( const KUrl& url );
+
+    /**
+     * Split the filename part off a nepomuk:/ URI. This is used in many methods for identifying
+     * entries listed from tags and filesystems.
+     */
+    Nepomuk::Resource splitNepomukUrl( const KUrl& url, QString* filename = 0 );
+
+    /**
+     * Check if the resource represents a file on a removable media using a filex:/
+     * URL.
+     */
+    bool isRemovableMediaFile( const Nepomuk::Resource& res );
+
+    /**
+     * Create a Solid storage access interface from the volume UUID.
+     */
+    Solid::StorageAccess* storageFromUUID( const QString& uuid );
+
+    /**
+     * Mount a storage volume via Solid and wait for it to be mounted with
+     * a timeout of 20 seconds.
+     */
+    bool mountAndWait( Solid::StorageAccess* storage );
+
+    /**
+     * Get the mount path of a nfo:Filesystem resource as created by the removable storage service.
+     */
+    KUrl determineFilesystemPath( const Nepomuk::Resource& fsRes );
+
+    /**
+     * Determine the label for a filesystem \p res is stored on.
+     */
+    QString getFileSystemLabelForRemovableMediaFileUrl( const Nepomuk::Resource& res );
+
+    /**
+     * Convert a filex:/ URL into its actual local file URL.
+     *
+     * \param url The filex:/ URL to convert
+     * \param evenMountIfNecessary If true an existing unmouted volume will be mounted to grant access to the local file.
+     *
+     * \return The converted local URL or an invalid URL if the filesystem the file is stored on could not be/was not mounted.
+     */
+    KUrl convertRemovableMediaFileUrl( const KUrl& url, bool evenMountIfNecessary = false );
+
+    /**
+     * Stat a Nepomuk resource. Might start a local event loop
+     */
+    KIO::UDSEntry statNepomukResource( const Nepomuk::Resource& res );
+
+    /**
+     * \return \p true for all resources that will get a valid redirection url in
+     * redirectionUrl().
+     */
+    bool willBeRedirected( const Nepomuk::Resource& res );
+
+    /**
+     * Create a redirection query URL for resources such as tags or filesystems.
+     * For other resources an empty KUrl is returned.
+     */
+    KUrl redirectionUrl( const Nepomuk::Resource& res );
+
+    /**
+     * Convert a nepomuk:/ URL to a file:/ URL if possible.
+     * Otherwise return an empty KUrl.
+     */
+    KUrl nepomukToFileUrl( const KUrl& url, bool evenMountIfNecessary = false );
+}
+
+#endif

Modification de propriétés sur nepomuk/kioslaves/common/resourcestat.h
___________________________________________________________________
Ajouté : svn:eol-style
   + native

Index: nepomuk/kioslaves/common/timelinetools.h
===================================================================
--- nepomuk/kioslaves/common/timelinetools.h	(révision 0)
+++ nepomuk/kioslaves/common/timelinetools.h	(révision 0)
@@ -0,0 +1,50 @@
+/*
+   This file is part of the Nepomuk KDE project.
+   Copyright (C) 2010 Sebastian Trueg <trueg@kde.org>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License version 2 as published by the Free Software Foundation.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public License
+   along with this library; see the file COPYING.LIB.  If not, write to
+   the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.
+ */
+
+#ifndef _NEPOMUK_TIMELINE_TOOLS_H_
+#define _NEPOMUK_TIMELINE_TOOLS_H_
+
+class QDate;
+class KUrl;
+class QString;
+
+namespace Nepomuk {
+    enum TimelineFolderType {
+        NoFolder = 0,    /// nothing
+        RootFolder,      /// the root folder
+        CalendarFolder,  /// the calendar folder listing all months
+        MonthFolder,     /// a folder listing a month's days (m_date contains the month)
+        DayFolder        /// a folder listing a day (m_date); optionally m_filename is set
+    };
+
+    /**
+     * Parse a timeline URL like timeline:/today and return the type of folder it
+     * represents. If DayFolder is returned \p date is set to the date that should be listed.
+     * Otherwise it is an invalid date. \p filename is optionally set to the name of the file
+     * in the folder.
+     */
+    TimelineFolderType parseTimelineUrl( const KUrl& url, QDate* date, QString* filename = 0 );
+
+    /**
+     * Create a nepomuksearch:/ URL that lists all files modified at \p date.
+     */
+    KUrl buildTimelineQueryUrl( const QDate& date );
+}
+
+#endif

Modification de propriétés sur nepomuk/kioslaves/common/timelinetools.h
___________________________________________________________________
Ajouté : svn:eol-style
   + native

Index: nepomuk/kioslaves/common/nepomuksearchurltools.h
===================================================================
--- nepomuk/kioslaves/common/nepomuksearchurltools.h	(révision 1121160)
+++ nepomuk/kioslaves/common/nepomuksearchurltools.h	(copie de travail)
@@ -48,24 +48,60 @@
         return QUrl::fromEncoded( QByteArray::fromPercentEncoding( name.toAscii(), '_' ) );
     }
 
-    /**
-     * Extract SPARQL query from a nepomuksearch query URL.
-     */
-    inline QString queryFromUrl( const KUrl& url ) {
-        if(url.queryItems().contains( "sparql" ) ) {
+    /// can be removed on Monday when we start using the Nepomuk::Query::Query methods
+    inline QString extractPlainQuery( const KUrl& url ) {
+        if( url.queryItems().contains( "query" ) ) {
+            return url.queryItem( "query" );
+        }
+        else if ( !url.queryItems().contains( "sparql" ) &&
+                  !url.queryItems().contains( "encodedquery" ) ) {
+            return url.path().section( '/', 0, 0, QString::SectionSkipEmpty );
+        }
+        else {
+            return QString();
+        }
+    }
+
+    /// can be removed on Monday and be replaced with Nepomuk::Query::Query::fromQueryUrl
+    inline Nepomuk::Query::Query fromQueryUrl( const KUrl& url )
+    {
+        if( url.protocol() != QLatin1String("nepomuksearch") ) {
+            return Nepomuk::Query::Query();
+        }
+
+        if ( url.queryItems().contains( "sparql" ) ) {
+            return Nepomuk::Query::Query();
+        }
+        else if( url.queryItems().contains( "encodedquery" ) ) {
+            return Nepomuk::Query::Query::fromString( url.queryItem( "encodedquery") );
+        }
+        else {
+            Nepomuk::Query::Query query = Nepomuk::Query::QueryParser::parseQuery( extractPlainQuery(url) );
+            query.setRequestProperties( QList<Nepomuk::Query::Query::RequestProperty>() << Nepomuk::Query::Query::RequestProperty( Nepomuk::Vocabulary::NIE::url(), true ) );
+            return query;
+        }
+    }
+
+
+    /// can be removed on Monday and be replaced with Nepomuk::Query::Query::sparqlFromQueryUrl
+    inline QString sparqlFromQueryUrl( const KUrl& url )
+    {
+        if( url.protocol() != QLatin1String("nepomuksearch") ) {
+            return QString();
+        }
+
+        if( url.queryItems().contains( "sparql" ) ) {
             return url.queryItem( "sparql" );
         }
         else {
-            QString plainQuery;
-            if(url.queryItems().contains( "query" ) ) {
-                plainQuery = url.queryItem( "query" );
+            Nepomuk::Query::Query query = Nepomuk::Query::Query::fromQueryUrl( url );
+            if( query.isValid() ) {
+                query.setRequestProperties( QList<Nepomuk::Query::Query::RequestProperty>() << Nepomuk::Query::Query::RequestProperty( Nepomuk::Vocabulary::NIE::url(), true ) );
+                return query.toSparqlQuery();
             }
             else {
-                plainQuery = url.path().section( '/', 0, 0, QString::SectionSkipEmpty );
+                return QString();
             }
-            Query::Query query = Query::QueryParser::parseQuery( plainQuery );
-            query.addRequestProperty( Query::Query::RequestProperty( Nepomuk::Vocabulary::NIE::url(), true ) );
-            return query.toSparqlQuery();
         }
     }
 }
Index: nepomuk/kioslaves/nepomuk/kio_nepomuk.cpp
===================================================================
--- nepomuk/kioslaves/nepomuk/kio_nepomuk.cpp	(révision 1121160)
+++ nepomuk/kioslaves/nepomuk/kio_nepomuk.cpp	(copie de travail)
@@ -21,15 +21,16 @@
 #include "kio_nepomuk.h"
 #include "nie.h"
 #include "nfo.h"
+//#include "nmm.h"
 #include "pimo.h"
 #include "resourcepagegenerator.h"
 #include "nepomuksearchurltools.h"
+#include "resourcestat.h"
 
 #include <QtCore/QByteArray>
 #include <QtCore/QDateTime>
 #include <QtCore/QFile>
 #include <QtCore/QCoreApplication>
-#include <QtCore/QEventLoop>
 #include <QtCore/QTimer>
 #include <QtDBus/QDBusConnection>
 
@@ -60,170 +61,6 @@
 #include <Solid/StorageAccess>
 
 
-namespace {
-    /**
-     * Check if the resource represents a local file with an existing nie:url property.
-     */
-    bool isLocalFile( const Nepomuk::Resource& res )
-    {
-        if ( res.hasProperty( Nepomuk::Vocabulary::NIE::url() ) ) {
-            KUrl url = res.property( Nepomuk::Vocabulary::NIE::url() ).toUrl();
-            return ( !url.isEmpty() &&
-                     QFile::exists( url.toLocalFile() ) );
-        }
-        else {
-            return false;
-        }
-    }
-
-    /**
-     * Check if the resource represents a file on a removable media using a filex:/
-     * URL.
-     */
-    bool isRemovableMediaFile( const Nepomuk::Resource& res )
-    {
-        if ( res.hasProperty( Nepomuk::Vocabulary::NIE::url() ) ) {
-            KUrl url = res.property( Nepomuk::Vocabulary::NIE::url() ).toUrl();
-            return ( url.protocol() == QLatin1String( "filex" ) );
-        }
-        else {
-            return false;
-        }
-    }
-
-    /**
-     * Mount a storage volume via Solid and wait for it to be mounted with
-     * a timeout of 20 seconds.
-     */
-    bool mountAndWait( Solid::StorageAccess* storage )
-    {
-        kDebug() << storage;
-        QEventLoop loop;
-        loop.connect( storage,
-                      SIGNAL(accessibilityChanged(bool, QString)),
-                      SLOT(quit()) );
-        // timeout 20 second
-        QTimer::singleShot( 20000, &loop, SLOT(quit()) );
-
-        storage->setup();
-        loop.exec();
-
-        kDebug() << storage << storage->isAccessible();
-
-        return storage->isAccessible();
-    }
-
-    /**
-     * Create a Solid storage access interface from the volume UUID.
-     */
-    Solid::StorageAccess* storageFromUUID( const QString& uuid )
-    {
-        QString solidQuery = QString::fromLatin1( "[ StorageVolume.usage=='FileSystem' AND StorageVolume.uuid=='%1' ]" ).arg( uuid.toLower() );
-        QList<Solid::Device> devices = Solid::Device::listFromQuery( solidQuery );
-        kDebug() << uuid << solidQuery << devices.count();
-        if ( !devices.isEmpty() )
-            return devices.first().as<Solid::StorageAccess>();
-        else
-            return 0;
-    }
-
-    /**
-     * Convert a filex:/ URL into its actual local file URL.
-     *
-     * \param url The filex:/ URL to convert
-     * \param evenMountIfNecessary If true an existing unmouted volume will be mounted to grant access to the local file.
-     *
-     * \return The converted local URL or an invalid URL if the filesystem the file is stored on could not be/was not mounted.
-     */
-    KUrl convertRemovableMediaFileUrl( const KUrl& url, bool evenMountIfNecessary = false )
-    {
-        Solid::StorageAccess* storage = storageFromUUID( url.host() );
-        kDebug() << url << storage;
-        if ( storage &&
-             ( storage->isAccessible() ||
-               ( evenMountIfNecessary && mountAndWait( storage ) ) ) ) {
-            kDebug() << "converted:" << KUrl( storage->filePath() + QLatin1String( "/" ) + url.path() );
-            return storage->filePath() + QLatin1String( "/" ) + url.path();
-        }
-        else {
-            return KUrl();
-        }
-    }
-
-    /**
-     * Get the mount path of a nfo:Filesystem resource as created by the removable storage service.
-     */
-    KUrl determineFilesystemPath( const Nepomuk::Resource& fsRes )
-    {
-        QString uuidQuery = QString::fromLatin1( "select ?uuid where { %1 %2 ?uuid . }" )
-                            .arg( Soprano::Node::resourceToN3( fsRes.resourceUri() ),
-                                  Soprano::Node::resourceToN3( Soprano::Vocabulary::NAO::identifier() ) );
-        Soprano::QueryResultIterator it = Nepomuk::ResourceManager::instance()->mainModel()->executeQuery( uuidQuery, Soprano::Query::QueryLanguageSparql );
-        if ( it.next() ) {
-            Solid::StorageAccess* storage = storageFromUUID( it["uuid"].toString() );
-            it.close();
-            if ( storage &&
-                 ( storage->isAccessible() ||
-                   mountAndWait( storage ) ) ) {
-                return storage->filePath();
-            }
-        }
-        return KUrl();
-    }
-
-    /**
-     * Determine the label for a filesystem \p res is stored on.
-     */
-    QString getFileSystemLabelForRemovableMediaFileUrl( const Nepomuk::Resource& res )
-    {
-        QList<Soprano::Node> labelNodes
-            = Nepomuk::ResourceManager::instance()->mainModel()->executeQuery( QString::fromLatin1( "select ?label where { "
-                                                                                                    "%1 nie:isPartOf ?fs . "
-                                                                                                    "?fs a nfo:Filesystem . "
-                                                                                                    "?fs nao:prefLabel ?label . "
-                                                                                                    "} LIMIT 1" )
-                                                                               .arg( Soprano::Node::resourceToN3( res.resourceUri() ) ),
-                                                                               Soprano::Query::QueryLanguageSparql ).iterateBindings( "label" ).allNodes();
-
-        if ( !labelNodes.isEmpty() )
-            return labelNodes.first().toString();
-        else
-            return res.property( Nepomuk::Vocabulary::NIE::url() ).toUrl().host(); // Solid UUID
-    }
-
-    KUrl stripQuery( const KUrl& url )
-    {
-        KUrl newUrl( url );
-        newUrl.setEncodedQuery( QByteArray() );
-        return newUrl;
-    }
-
-    /**
-     * Split the filename part off a nepomuk:/ URI. This is used in many methods for identifying
-     * entries listed from tags and filesystems.
-     */
-    Nepomuk::Resource splitNepomukUrl( const KUrl& url, QString& filename )
-    {
-        //
-        // let's try to extract the resource from the url in case we listed a tag or
-        // filesystem and need to stat the entries in those virtual folders
-        //
-        // pre KDE 4.4 resources had just a single section, in KDE 4.4 we have "/res/<UUID>"
-        //
-        QString urlStr = stripQuery( url ).url();
-        int pos = urlStr.indexOf( '/', urlStr.startsWith( QLatin1String( "nepomuk:/res/" ) ) ? 13 : 9 );
-        if ( pos > 0 ) {
-            KUrl resourceUri = urlStr.left(pos);
-            filename = urlStr.mid( pos+1 );
-            return resourceUri;
-        }
-        else {
-            return stripQuery( url );
-        }
-    }
-}
-
-
 Nepomuk::NepomukProtocol::NepomukProtocol( const QByteArray& poolSocket, const QByteArray& appSocket )
     : KIO::ForwardingSlaveBase( "nepomuk", poolSocket, appSocket )
 {
@@ -247,28 +84,12 @@
     // anything.
     // See README for details
     //
-    QString filename;
-    Nepomuk::Resource res = splitNepomukUrl( url, filename );
-
-    if ( res.hasType( Nepomuk::Vocabulary::NFO::Folder() ) ) {
-        redirection( res.property( Nepomuk::Vocabulary::NIE::url() ).toUrl() );
+    Nepomuk::Resource res = Nepomuk::splitNepomukUrl( url );
+    KUrl reUrl = Nepomuk::redirectionUrl( res );
+    if ( !reUrl.isEmpty() ) {
+        redirection( reUrl );
         finished();
     }
-    else if ( res.hasType( Soprano::Vocabulary::NAO::Tag() ) ) {
-        Query::ComparisonTerm term( Soprano::Vocabulary::NAO::hasTag(), Query::ResourceTerm( res ), Query::ComparisonTerm::Equal );
-        redirection( Query::Query( term ).toSearchUrl().url() );
-        finished();
-    }
-    else if ( res.hasType( Nepomuk::Vocabulary::NFO::Filesystem() ) ) {
-        KUrl fsUrl = determineFilesystemPath( res );
-        if ( fsUrl.isValid() ) {
-            redirection( fsUrl );
-            finished();
-        }
-        else {
-            error( KIO::ERR_DOES_NOT_EXIST, url.prettyUrl() );
-        }
-    }
     else {
         error( KIO::ERR_DOES_NOT_EXIST, url.prettyUrl() );
     }
@@ -284,30 +105,15 @@
 
     m_currentOperation = Get;
 
-    //
-    // First we check if it is a generic resource which cannot be forwarded
-    // If we could rewrite the URL than we can continue as Get operation
-    // which will also try to mount removable devices.
-    // If not we generate a HTML page.
-    //
-    KUrl newUrl;
-    if ( rewriteUrl( url, newUrl ) ) {
-        //
-        // rewriteUrl() returns true even if we have no new url for removable media
-        //
-        if ( newUrl.isEmpty() ) {
-            QString filename;
-            Nepomuk::Resource res = splitNepomukUrl( url, filename );
-            if ( isRemovableMediaFile( res ) ) {
-                error( KIO::ERR_SLAVE_DEFINED,
-                       i18nc( "@info", "Please insert the removable medium <resource>%1</resource> to access this file.",
-                              getFileSystemLabelForRemovableMediaFileUrl( res ) ) );
-            }
-        }
-        else {
-            ForwardingSlaveBase::get( url );
-        }
+    Nepomuk::Resource res = splitNepomukUrl( url );
+    if ( Nepomuk::isRemovableMediaFile( res ) ) {
+        error( KIO::ERR_SLAVE_DEFINED,
+               i18nc( "@info", "Please insert the removable medium <resource>%1</resource> to access this file.",
+                      getFileSystemLabelForRemovableMediaFileUrl( res ) ) );
     }
+    else if ( !Nepomuk::nepomukToFileUrl( url ).isEmpty() ) {
+        ForwardingSlaveBase::get( url );
+    }
     else {
         // TODO: call the share service for remote files (KDE 4.5)
 
@@ -358,34 +164,18 @@
     kDebug() << url;
 
     m_currentOperation = Stat;
-    KUrl newUrl;
-    if ( rewriteUrl( url, newUrl ) ) {
+    if ( !Nepomuk::nepomukToFileUrl( url ).isEmpty() ) {
         ForwardingSlaveBase::stat( url );
     }
     else {
-        newUrl = stripQuery( url );
-        Nepomuk::Resource res( newUrl );
+        KUrl strippedUrl = stripQuery( url );
+        Nepomuk::Resource res( strippedUrl );
 
         if ( !res.exists() ) {
-            error( KIO::ERR_DOES_NOT_EXIST, url.prettyUrl() );
+            error( KIO::ERR_DOES_NOT_EXIST, strippedUrl.prettyUrl() );
         }
         else {
-            KIO::UDSEntry uds = statNepomukResource( res );
-
-            // special case: tags and filesystems are handled as folders
-            if ( res.hasType( Soprano::Vocabulary::NAO::Tag() ) ||
-                 res.hasType( Nepomuk::Vocabulary::NFO::Filesystem() ) ) {
-                kDebug() << res.resourceUri() << "is tag or filesystem -> mimetype inode/directory";
-                uds.insert( KIO::UDSEntry::UDS_MIME_TYPE, QLatin1String( "inode/directory" ) );
-                uds.insert( KIO::UDSEntry::UDS_FILE_TYPE, S_IFDIR );
-            }
-
-            // special case: tags cannot be redirected in stat, thus we need to use UDS_URL here
-            if ( res.hasType( Soprano::Vocabulary::NAO::Tag() ) ) {
-                Query::ComparisonTerm term( Soprano::Vocabulary::NAO::hasTag(), Query::ResourceTerm( res ), Query::ComparisonTerm::Equal );
-                uds.insert( KIO::UDSEntry::UDS_URL, Query::Query( term ).toSearchUrl().url() );
-            }
-
+            KIO::UDSEntry uds = Nepomuk::statNepomukResource( res );
             statEntry( uds );
             finished();
         }
@@ -393,88 +183,6 @@
 }
 
 
-KIO::UDSEntry Nepomuk::NepomukProtocol::statNepomukResource( const Nepomuk::Resource& res )
-{
-    //
-    // We do not have a local file
-    // This is where the magic starts to happen.
-    // This is where we only use Nepomuk properties
-    //
-    KIO::UDSEntry uds;
-
-    // The display name can be anything
-    uds.insert( KIO::UDSEntry::UDS_DISPLAY_NAME, res.genericLabel() );
-
-    // UDS_NAME needs to be unique but can be ugly
-    uds.insert( KIO::UDSEntry::UDS_NAME, resourceUriToUdsName( res.resourceUri() ) );
-
-    //
-    // There can still be file resources that have a mimetype but are
-    // stored remotely, thus they do not have a local nie:url
-    //
-    // Sadly Strigi's mimetype is not very useful (yet)
-    /* QStringList mimeTypes = res.property( Vocabulary::NIE::mimeType() ).toStringList();
-    if ( !mimeTypes.isEmpty() ) {
-        uds.insert( KIO::UDSEntry::UDS_MIME_TYPE, mimeTypes.first() );
-    }
-    else */
-    if ( isRemovableMediaFile( res ) ) {
-        KMimeType::Ptr mt = KMimeType::findByUrl( res.property( Vocabulary::NIE::url() ).toUrl(),
-                                                  0,
-                                                  false, /* no local file as it is not accessible at the moment */
-                                                  true   /* fast mode */ );
-        if ( mt ) {
-            uds.insert( KIO::UDSEntry::UDS_MIME_TYPE, mt->name() );
-        }
-    }
-    else {
-        // Use nice display types like "Person", "Project" and so on
-        Nepomuk::Types::Class type( res.resourceType() );
-        if (!type.label().isEmpty())
-            uds.insert( KIO::UDSEntry::UDS_DISPLAY_TYPE, type.label() );
-
-        QString icon = res.genericIcon();
-        if ( !icon.isEmpty() ) {
-            uds.insert( KIO::UDSEntry::UDS_ICON_NAME, icon );
-        }
-        else {
-            // a fallback icon for nepomuk resources
-            uds.insert( KIO::UDSEntry::UDS_ICON_NAME, "nepomuk" );
-        }
-    }
-
-    //
-    // Add some random values
-    //
-    uds.insert( KIO::UDSEntry::UDS_ACCESS, 0700 );
-    uds.insert( KIO::UDSEntry::UDS_USER, KUser().loginName() );
-    if ( res.hasProperty( Vocabulary::NIE::lastModified() ) ) {
-        // remotely stored files
-        uds.insert( KIO::UDSEntry::UDS_MODIFICATION_TIME, res.property( Vocabulary::NIE::lastModified() ).toDateTime().toTime_t() );
-    }
-    else {
-        // all nepomuk resources
-        uds.insert( KIO::UDSEntry::UDS_MODIFICATION_TIME, res.property( Soprano::Vocabulary::NAO::lastModified() ).toDateTime().toTime_t() );
-        uds.insert( KIO::UDSEntry::UDS_CREATION_TIME, res.property( Soprano::Vocabulary::NAO::created() ).toDateTime().toTime_t() );
-    }
-
-    if ( res.hasProperty( Vocabulary::NIE::contentSize() ) ) {
-        // remotely stored files
-        uds.insert( KIO::UDSEntry::UDS_SIZE, res.property( Vocabulary::NIE::contentSize() ).toInt() );
-    }
-
-
-    //
-    // Starting with KDE 4.4 we have the pretty UDS_NEPOMUK_URI which makes
-    // everything much cleaner since kio slaves can decide if the resources can be
-    // annotated or not.
-    //
-    uds.insert( KIO::UDSEntry::UDS_NEPOMUK_URI, KUrl( res.resourceUri() ).url() );
-
-    return uds;
-}
-
-
 void Nepomuk::NepomukProtocol::mimetype( const KUrl& url )
 {
     if ( !ensureNepomukRunning() )
@@ -485,18 +193,15 @@
     m_currentOperation = Other;
 
     QString filename;
-    Nepomuk::Resource res = splitNepomukUrl( url, filename );
+    Nepomuk::Resource res = Nepomuk::splitNepomukUrl( url, &filename );
     if ( filename.isEmpty() &&
-         ( res.hasType( Soprano::Vocabulary::NAO::Tag() ) ||
-           res.hasType( Nepomuk::Vocabulary::NFO::Filesystem() ) ) ) {
+         Nepomuk::willBeRedirected( res ) ) {
         kDebug() << res.resourceUri() << "is tag or file system -> mimetype inode/directory";
-        // in listDir() we list tags as search folders
         mimeType( QLatin1String( "inode/directory" ) );
         finished();
     }
     else {
-        KUrl newUrl;
-        if ( rewriteUrl( url, newUrl ) ) {
+        if ( !Nepomuk::nepomukToFileUrl( url ).isEmpty() ) {
             ForwardingSlaveBase::mimetype( url );
         }
         else {
@@ -548,73 +253,11 @@
     if ( url.queryItemValue( QLatin1String( "noFollow" ) ) == QLatin1String( "true" ) )
         return false;
 
-    QString filename;
-    Nepomuk::Resource res = splitNepomukUrl( url, filename );
-
-    if ( !res.exists() )
-        return false;
-
-    //
-    // let's see if it is a pimo thing which refers to a file
-    //
-    if ( res.hasType( Nepomuk::Vocabulary::PIMO::Thing() ) ) {
-        if ( !res.pimoThing().groundingOccurrences().isEmpty() ) {
-            res = res.pimoThing().groundingOccurrences().first();
-        }
-    }
-
-    if ( isLocalFile( res ) ) {
-        newURL = res.property( Vocabulary::NIE::url() ).toUrl();
-    }
-    else if ( isRemovableMediaFile( res ) ) {
-        const KUrl removableMediaUrl = res.property( Nepomuk::Vocabulary::NIE::url() ).toUrl();
-        newURL = convertRemovableMediaFileUrl( res.property( Nepomuk::Vocabulary::NIE::url() ).toUrl(), m_currentOperation == Get );
-        if ( !newURL.isValid() && m_currentOperation == Get ) {
-            // error handling in get()
-            return true;
-        }
-        kDebug() << "Rewriting removable media URL" << url << "to" << newURL;
-    }
-
-    if ( newURL.isValid() && !filename.isEmpty() ) {
-        newURL.addPath( filename );
-    }
-
-    kDebug() << url << newURL;
-
+    newURL = Nepomuk::nepomukToFileUrl( url, m_currentOperation == Get );
     return newURL.isValid();
 }
 
 
-void Nepomuk::NepomukProtocol::prepareUDSEntry( KIO::UDSEntry& uds,
-                                                bool listing ) const
-{
-    // this will set mimetype and UDS_LOCAL_PATH for local files
-    ForwardingSlaveBase::prepareUDSEntry( uds, listing );
-
-    // make sure we have unique names for everything
-    uds.insert( KIO::UDSEntry::UDS_NAME, resourceUriToUdsName( requestedUrl() ) );
-
-    // make sure we do not use these ugly names for display
-    if ( !uds.contains( KIO::UDSEntry::UDS_DISPLAY_NAME ) ) {
-        Nepomuk::Resource res( requestedUrl() );
-        if ( res.hasType( Nepomuk::Vocabulary::PIMO::Thing() ) ) {
-            if ( !res.pimoThing().groundingOccurrences().isEmpty() ) {
-                res = res.pimoThing().groundingOccurrences().first();
-            }
-        }
-
-        if ( res.hasProperty( Nepomuk::Vocabulary::NIE::url() ) ) {
-            KUrl fileUrl( res.property( Nepomuk::Vocabulary::NIE::url() ).toUrl() );
-            uds.insert( KIO::UDSEntry::UDS_DISPLAY_NAME, fileUrl.fileName() );
-        }
-        else {
-            uds.insert( KIO::UDSEntry::UDS_DISPLAY_NAME, res.genericLabel() );
-        }
-    }
-}
-
-
 bool Nepomuk::NepomukProtocol::ensureNepomukRunning()
 {
     if ( Nepomuk::ResourceManager::instance()->init() ) {
Index: nepomuk/kioslaves/nepomuk/kio_nepomuk.h
===================================================================
--- nepomuk/kioslaves/nepomuk/kio_nepomuk.h	(révision 1121160)
+++ nepomuk/kioslaves/nepomuk/kio_nepomuk.h	(copie de travail)
@@ -45,9 +45,6 @@
          */
         bool rewriteUrl( const KUrl& url, KUrl& newURL );
 
-        void prepareUDSEntry( KIO::UDSEntry &entry,
-                              bool listing = false ) const;
-
     private:
         enum Operation {
             Get,
@@ -56,11 +53,6 @@
         };
         Operation m_currentOperation;
         bool ensureNepomukRunning();
-
-        /**
-         * Creates an UDS entry for an arbitrary Nepomuk resource by relying on its properties.
-         */
-        KIO::UDSEntry statNepomukResource( const Nepomuk::Resource& res );
     };
 }
 
Index: nepomuk/kioslaves/nepomuk/CMakeLists.txt
===================================================================
--- nepomuk/kioslaves/nepomuk/CMakeLists.txt	(révision 1121160)
+++ nepomuk/kioslaves/nepomuk/CMakeLists.txt	(copie de travail)
@@ -6,7 +6,8 @@
 
 set(kio_nepomuk_PART_SRCS 
   kio_nepomuk.cpp
-  resourcepagegenerator.cpp)
+  resourcepagegenerator.cpp
+  ../common/resourcestat.cpp)
 
 soprano_add_ontology(kio_nepomuk_PART_SRCS ${SHAREDDESKTOPONTOLOGIES_ROOT_DIR}/nie/nie.trig "NIE" "Nepomuk::Vocabulary" "trig")
 soprano_add_ontology(kio_nepomuk_PART_SRCS ${SHAREDDESKTOPONTOLOGIES_ROOT_DIR}/nie/nfo.trig "NFO" "Nepomuk::Vocabulary" "trig")
Index: nepomuk/interfaces/org.kde.nepomuk.RemovableStorage.xml
===================================================================
--- nepomuk/interfaces/org.kde.nepomuk.RemovableStorage.xml	(révision 1121160)
+++ nepomuk/interfaces/org.kde.nepomuk.RemovableStorage.xml	(copie de travail)
@@ -6,5 +6,8 @@
       <arg type="s" direction="out"/>
       <arg name="url" type="s" direction="in"/>
     </method>
+    <method name="currentlyMountedAndIndexed">
+      <arg type="as" direction="out"/>
+    </method>
   </interface>
 </node>
Index: nepomuk/interfaces/org.kde.nepomuk.Strigi.xml
===================================================================
--- nepomuk/interfaces/org.kde.nepomuk.Strigi.xml	(révision 1121160)
+++ nepomuk/interfaces/org.kde.nepomuk.Strigi.xml	(copie de travail)
@@ -11,6 +11,9 @@
     <method name="currentFolder">
       <arg type="s" direction="out" />
     </method>
+    <method name="currentFile">
+      <arg type="s" direction="out" />
+    </method>
     <method name="suspend" />
     <method name="resume" />
     <method name="updateFolder">
@@ -24,6 +27,9 @@
       <arg name="path" type="s" direction="in" />
       <arg name="forced" type="b" direction="in" />
     </method>
+    <method name="indexFile">
+      <arg name="path" type="s" direction="in" />
+    </method>
     <method name="analyzeResource" >
       <arg name="uri" direction="in" type="s" />
       <arg name="lastModificationDate" direction="in" type="u" />
Index: nepomuk/interfaces/org.kde.nepomuk.FileWatch.xml
===================================================================
--- nepomuk/interfaces/org.kde.nepomuk.FileWatch.xml	(révision 0)
+++ nepomuk/interfaces/org.kde.nepomuk.FileWatch.xml	(révision 0)
@@ -0,0 +1,9 @@
+<!DOCTYPE node PUBLIC "-//freedesktop//DTD D-BUS Object Introspection 1.0//EN"
+          "http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd">
+<node>
+  <interface name="org.kde.nepomuk.FileWatch">
+    <method name="watchFolder">
+      <arg name="path" type="s" direction="in"/>
+    </method>
+  </interface>
+</node>
Index: nepomuk/services/ontologyloader/nepomukontologyloader.desktop
===================================================================
--- nepomuk/services/ontologyloader/nepomukontologyloader.desktop	(révision 1121160)
+++ nepomuk/services/ontologyloader/nepomukontologyloader.desktop	(copie de travail)
@@ -32,6 +32,7 @@
 Name[hr]=Nepomuk Učitavač Ontologije
 Name[hsb]=Nepomuk začitanje ontologije
 Name[hu]=Nepomuk ontológiabetöltő
+Name[ia]=Cargator de Ontologia de Nepomuk
 Name[id]=Pemuat Ontologi Nepomuk
 Name[is]=Nepomuk verufræðihöndlari (Ontology Loader)
 Name[it]=Caricatore delle ontologie di Nepomuk
@@ -101,6 +102,7 @@
 Comment[hr]=Nepomukova usluga koja održava ontologije instalirane na sustav
 Comment[hsb]=Nepomukowa słužba, kiž so stara wo instalowane ontologije
 Comment[hu]=Nepomuk-szolgáltatás a rendszer ontológiáinak karbantartásához
+Comment[ia]=Servicio de Nepomuk que il mantene le ontologias installate su le systema
 Comment[id]=Layanan Nepomuk yang mengelola ontologi yang terinstal di sistem
 Comment[is]=Nepomuk þjónusta sem viðheldur þeim verufræðitengingum (ontologies) sem uppsettar eru á kerfinu
 Comment[it]=Servizio di Nepomuk che mantiene le ontologie installate sul sistema
Index: nepomuk/services/removablestorage/removablestorageservice.cpp
===================================================================
--- nepomuk/services/removablestorage/removablestorageservice.cpp	(révision 1121160)
+++ nepomuk/services/removablestorage/removablestorageservice.cpp	(copie de travail)
@@ -20,6 +20,7 @@
 #include "nfo.h"
 #include "nie.h"
 #include "strigiserviceinterface.h"
+#include "filewatchserviceinterface.h"
 
 #include <QtDBus/QDBusConnection>
 #include <QtCore/QUuid>
@@ -172,6 +173,26 @@
 }
 
 
+QStringList Nepomuk::RemovableStorageService::currentlyMountedAndIndexed()
+{
+    if( KConfig( "nepomukstrigirc" ).group( "General" ).readEntry( "index newly mounted", false ) ) {
+        QStringList paths;
+        for ( QHash<QString, Entry>::ConstIterator it = m_metadataCache.constBegin();
+              it != m_metadataCache.constEnd(); ++it ) {
+            const Entry& entry = it.value();
+            const Solid::StorageAccess* storage = entry.m_device.as<Solid::StorageAccess>();
+            if ( storage && storage->isAccessible() ) {
+                paths << storage->filePath();
+            }
+        }
+        return paths;
+    }
+    else {
+        return QStringList();
+    }
+}
+
+
 void Nepomuk::RemovableStorageService::initCacheEntries()
 {
     QList<Solid::Device> devices
@@ -248,14 +269,25 @@
         //
         entry.m_lastMountPath = entry.m_device.as<Solid::StorageAccess>()->filePath();
 
-        //
-        // tell Strigi to update the newly mounted device
-        //
-        if( KConfig( "nepomukstrigirc" ).group( "General" ).readEntry( "index newly mounted", false ) ) {
-            org::kde::nepomuk::Strigi interface( "org.kde.nepomuk.services.nepomukstrigiservice",
-                                                 "/nepomukstrigiservice",
-                                                 QDBusConnection::sessionBus() );
-            interface.indexFolder( entry.m_lastMountPath, false );
+        if ( entry.hasLastMountPath() ) {
+            //
+            // tell the filewatch service that it should monitor the new medium
+            //
+            org::kde::nepomuk::FileWatch( "org.kde.nepomuk.services.nepomukfilewatch",
+                                          "/nepomukfilewatch",
+                                          QDBusConnection::sessionBus() )
+                .watchFolder( entry.m_lastMountPath );
+
+
+            //
+            // tell Strigi to update the newly mounted device
+            //
+            if( KConfig( "nepomukstrigirc" ).group( "General" ).readEntry( "index newly mounted", false ) ) {
+                org::kde::nepomuk::Strigi( "org.kde.nepomuk.services.nepomukstrigiservice",
+                                           "/nepomukstrigiservice",
+                                           QDBusConnection::sessionBus() )
+                    .indexFolder( entry.m_lastMountPath, false );
+            }
         }
 
         //
@@ -284,7 +316,7 @@
             }
         }
     }
-    else {
+    else if ( entry.hasLastMountPath() ) {
         //
         // The first thing we need to do is to inform nepomuk:/ kio slave instances that something has changed
         // so any caches will be cleared. Otherwise KDirModel and friends might try to access the old media URLs
@@ -367,6 +399,13 @@
     return path;
 }
 
+
+bool Nepomuk::RemovableStorageService::Entry::hasLastMountPath() const
+{
+    return( !m_lastMountPath.isEmpty() &&
+            m_lastMountPath != QLatin1String( "/" ) );
+}
+
 NEPOMUK_EXPORT_SERVICE( Nepomuk::RemovableStorageService, "nepomukremovablestorageservice")
 
 #include "removablestorageservice.moc"
Index: nepomuk/services/removablestorage/removablestorageservice.h
===================================================================
--- nepomuk/services/removablestorage/removablestorageservice.h	(révision 1121160)
+++ nepomuk/services/removablestorage/removablestorageservice.h	(copie de travail)
@@ -65,6 +65,8 @@
          */
         Q_SCRIPTABLE QString resourceUriFromLocalFileUrl( const QString& url );
 
+        Q_SCRIPTABLE QStringList currentlyMountedAndIndexed();
+
     private Q_SLOTS:
         void slotSolidDeviceAdded( const QString& udi );
         void slotSolidDeviceRemoved( const QString& udi );
@@ -89,6 +91,7 @@
 
             KUrl constructRelativeUrl( const QString& path ) const;
             QString constructLocalPath( const KUrl& filexUrl ) const;
+            bool hasLastMountPath() const;
 
             Solid::Device m_device;
             QString m_lastMountPath;
Index: nepomuk/services/removablestorage/CMakeLists.txt
===================================================================
--- nepomuk/services/removablestorage/CMakeLists.txt	(révision 1121160)
+++ nepomuk/services/removablestorage/CMakeLists.txt	(copie de travail)
@@ -16,6 +16,7 @@
 soprano_add_ontology(SRCS ${SHAREDDESKTOPONTOLOGIES_ROOT_DIR}/nie/nie.trig "NIE" "Nepomuk::Vocabulary" "trig")
 
 qt4_add_dbus_interface(SRCS ../../interfaces/org.kde.nepomuk.Strigi.xml strigiserviceinterface)
+qt4_add_dbus_interface(SRCS ../../interfaces/org.kde.nepomuk.FileWatch.xml filewatchserviceinterface)
 
 kde4_add_plugin(nepomukremovablestorageservice ${SRCS})
 
Index: nepomuk/services/strigi/eventmonitor.h
===================================================================
--- nepomuk/services/strigi/eventmonitor.h	(révision 1121160)
+++ nepomuk/services/strigi/eventmonitor.h	(copie de travail)
@@ -22,7 +22,7 @@
 #include <QtCore/QObject>
 #include <QtCore/QStringList>
 #include <QtCore/QTimer>
-#include <QtCore/QTime>
+#include <QtCore/QDateTime>
 
 class KDiskFreeSpace;
 
@@ -42,12 +42,16 @@
         void slotPowerManagementStatusChanged( bool conserveResources );
         void slotCheckAvailableSpace();
         void slotIndexingStopped();
+        void pauseIndexing(int pauseState);
+        void resumeIndexing();
+        void slotIndexingSuspended( bool suspended );
 
     private:
         enum {
             NotPaused,
             PausedDueToPowerManagement,
-            PausedDueToAvailSpace
+            PausedDueToAvailSpace,
+            PausedCustom
         };
 
         IndexScheduler* m_indexScheduler;
@@ -56,9 +60,8 @@
         // timer used to periodically check for available space
         QTimer m_availSpaceTimer;
 
-        QTime m_initialIndexTime;
-
-        QTimer m_periodicUpdateTimer;
+        QDateTime m_indexingStartTime;
+        int m_totalIndexingSeconds;
     };
 }
 
Index: nepomuk/services/strigi/strigiserviceadaptor.h
===================================================================
--- nepomuk/services/strigi/strigiserviceadaptor.h	(révision 1121160)
+++ nepomuk/services/strigi/strigiserviceadaptor.h	(copie de travail)
@@ -43,6 +43,9 @@
                     "    <method name=\"currentFolder\">\n"
                     "      <arg direction=\"out\" type=\"s\"/>\n"
                     "    </method>\n"
+                    "    <method name=\"currentFile\">\n"
+                    "      <arg direction=\"out\" type=\"s\"/>\n"
+                    "    </method>\n"
                     "    <method name=\"suspend\"/>\n"
                     "    <method name=\"resume\"/>\n"
                     "    <method name=\"updateFolder\">\n"
@@ -56,6 +59,9 @@
                     "      <arg direction=\"in\" type=\"s\" name=\"path\"/>\n"
                     "      <arg direction=\"in\" type=\"b\" name=\"forced\"/>\n"
                     "    </method>\n"
+                    "    <method name=\"indexFile\">\n"
+                    "      <arg direction=\"in\" type=\"s\" name=\"path\"/>\n"
+                    "    </method>\n"
                     "    <method name=\"analyzeResource\">\n"
                     "      <arg direction=\"in\" type=\"s\" name=\"uri\"/>\n"
                     "      <arg direction=\"in\" type=\"u\" name=\"lastModificationDate\"/>\n"
@@ -86,6 +92,7 @@
         bool isIndexing();
         bool isSuspended();
         QString currentFolder();
+        QString currentFile();
         void resume();
         void suspend();
 
@@ -104,6 +111,11 @@
          */
         void indexFolder( const QString& path, bool forced );
 
+        /**
+         * Index a specific file
+         */
+        void indexFile( const QString& path );
+
         void analyzeResource( const QString& uri, uint mTime, const QByteArray& data );
         void analyzeResourceFromTempFileAndDeleteTempFile( const QString& uri, uint mTime, const QString& tmpFile );
         QString userStatusString() const;
Index: nepomuk/services/strigi/indexscheduler.cpp
===================================================================
--- nepomuk/services/strigi/indexscheduler.cpp	(révision 1121160)
+++ nepomuk/services/strigi/indexscheduler.cpp	(copie de travail)
@@ -32,6 +32,7 @@
 #include <QtCore/QDateTime>
 #include <QtCore/QByteArray>
 #include <QtCore/QUrl>
+#include <QtCore/QTimer>
 
 #include <KDebug>
 #include <KTemporaryFile>
@@ -130,6 +131,13 @@
 {
     m_analyzerConfig = new StoppableConfiguration;
 
+    // see updateDir(QString,bool) for details on the timer
+    m_dirsToUpdateWakeupTimer = new QTimer( this );
+    m_dirsToUpdateWakeupTimer->setSingleShot( true );
+    m_dirsToUpdateWakeupTimer->setInterval(1000);
+    connect( m_dirsToUpdateWakeupTimer, SIGNAL( timeout() ),
+             this, SLOT( slotDirsToUpdateWakeupTimeout() ) );
+
     connect( StrigiServiceConfig::self(), SIGNAL( configChanged() ),
              this, SLOT( slotConfigChanged() ) );
 }
@@ -383,7 +391,9 @@
         if ( !waitForContinue() )
             return false;
 
+        m_currentUrl = file.filePath();
         analyzeFile( file, analyzer );
+        m_currentUrl = KUrl();
     }
 
     // recurse into subdirs (we do this in a separate loop to always keep a proper state:
@@ -405,7 +415,6 @@
     //
     // strigi asserts if the file path has a trailing slash
     //
-    m_currentUrl = file.filePath();
     QString filePath = m_currentUrl.toLocalFile( KUrl::RemoveTrailingSlash );
     QString dir = m_currentUrl.directory(KUrl::IgnoreTrailingSlash);
 
@@ -427,9 +436,6 @@
     else {
         analysisresult.index(0);
     }
-
-    // done with this file
-    m_currentUrl = KUrl();
 }
 
 
@@ -453,7 +459,15 @@
 {
     QMutexLocker lock( &m_dirsToUpdateMutex );
     m_dirsToUpdate << qMakePair( path, UpdateDirFlags( forceUpdate ? ForceUpdate : NoUpdateFlags ) );
-    m_dirsToUpdateWc.wakeAll();
+
+    // sometimes the filewatch service will call this method many times in a row with the same
+    // folder (in case a whole folder is created or modified). In order not to run an update every
+    // time we slightly delay the update process
+    if ( !isSuspended() &&
+         isIndexing() &&
+         !m_dirsToUpdateWakeupTimer->isActive() ) {
+        m_dirsToUpdateWakeupTimer->start();
+    }
 }
 
 
@@ -495,6 +509,12 @@
 }
 
 
+void Nepomuk::IndexScheduler::slotDirsToUpdateWakeupTimeout()
+{
+    m_dirsToUpdateWc.wakeAll();
+}
+
+
 namespace {
     class QDataStreamStrigiBufferedStream : public Strigi::BufferedStream<char>
     {
@@ -545,6 +565,14 @@
 }
 
 
+void Nepomuk::IndexScheduler::analyzeFile( const QString& path )
+{
+    Strigi::StreamAnalyzer analyzer( *m_analyzerConfig );
+    analyzer.setIndexWriter( *m_indexManager->indexWriter() );
+    analyzeFile( path, &analyzer );
+}
+
+
 void Nepomuk::IndexScheduler::deleteEntries( const QStringList& entries )
 {
     // recurse into subdirs
Index: nepomuk/services/strigi/nepomukstrigiservice.desktop
===================================================================
--- nepomuk/services/strigi/nepomukstrigiservice.desktop	(révision 1121160)
+++ nepomuk/services/strigi/nepomukstrigiservice.desktop	(copie de travail)
@@ -35,6 +35,7 @@
 Name[hr]=Uslufa Nepomuk Strigi
 Name[hsb]=Nepomuk Strigi słužba
 Name[hu]=Nepomuk Strigi szolgáltatás
+Name[ia]=Servicio de Strigi de Nepomuk
 Name[id]=Layanan Nepomuk Strigi
 Name[is]=Nepomuk Strigi þjónusta
 Name[it]=Servizio Strigi di Nepomuk
@@ -72,7 +73,7 @@
 Name[te]=Nepomuk Strigi సేవ
 Name[tg]=Хидматҳои Nepomuk Strigi
 Name[th]=บริการ Nepomuk Strigi
-Name[tr]=Nepomuk Strigi Servisi
+Name[tr]=Nepomuk Strigi Hizmeti
 Name[uk]=Служба Strigi Nepomuk
 Name[uz]=Nepomuk Strigi xizmati
 Name[uz@cyrillic]=Nepomuk Strigi хизмати
@@ -106,6 +107,7 @@
 Comment[hr]=Nepomukova usluga koja upravlja strigidaemonom, tj. indeksira datoteke na računalu
 Comment[hsb]=Nepomukowa słužba za strigidemon, to su indeksowe dataje na dźěłowym powjerchu
 Comment[hu]=A Strigi szolgáltatást kezeli, amely fájlok indexelését végzi
+Comment[ia]=Servicio de Nepomuk que controla le strigidaemon, i.e. indicisa le files su le scriptorio
 Comment[id]=Layanan Nepomuk yang mengontrol jurik strigi, misalnya berkas indeks di desktop
 Comment[is]=Nepomuk þjónusta sem stýrir strigidaemon, þ.e. býr til yfirlit um skrár á skjáborði
 Comment[it]=Servizio di Nepomuk che controlla il demone strigi, cioè indicizza i file del desktop
Index: nepomuk/services/strigi/strigiserviceconfig.cpp
===================================================================
--- nepomuk/services/strigi/strigiserviceconfig.cpp	(révision 1121160)
+++ nepomuk/services/strigi/strigiserviceconfig.cpp	(copie de travail)
@@ -17,6 +17,7 @@
 */
 
 #include "strigiserviceconfig.h"
+#include "removablestorageserviceinterface.h"
 #include "strigiservicedefaults.h"
 
 #include <QtCore/QStringList>
@@ -197,7 +198,7 @@
         bool included = false;
         for ( int i = 0; i < folders.count(); ++i ) {
             if ( f != folders[i].first &&
-                 f.startsWith( folders[i].first ) )
+                 f.startsWith( KUrl( folders[i].first ).path( KUrl::AddTrailingSlash ) ) )
                 included = folders[i].second;
         }
         return included == include;
@@ -240,6 +241,11 @@
 void Nepomuk::StrigiServiceConfig::buildFolderCache()
 {
     QStringList includeFoldersPlain = m_config.group( "General" ).readPathEntry( "folders", QStringList() << QDir::homePath() );
+    org::kde::nepomuk::RemovableStorage removableStorageService( "org.kde.nepomuk.services.removablestorageservice",
+                                                                 "/removablestorageservice",
+                                                                 QDBusConnection::sessionBus() );
+    if ( removableStorageService.isValid() )
+        includeFoldersPlain << removableStorageService.currentlyMountedAndIndexed();
     QStringList excludeFoldersPlain = m_config.group( "General" ).readPathEntry( "exclude folders", QStringList() );;
 
     m_folderCache.clear();
Index: nepomuk/services/strigi/indexscheduler.h
===================================================================
--- nepomuk/services/strigi/indexscheduler.h	(révision 1121160)
+++ nepomuk/services/strigi/indexscheduler.h	(copie de travail)
@@ -37,8 +37,8 @@
 
 class QFileInfo;
 class QByteArray;
+class QTimer;
 
-
 namespace Nepomuk {
     /**
      * The IndexScheduler performs the normal indexing,
@@ -157,6 +157,11 @@
         void updateAll( bool forceUpdate = false );
 
         /**
+         * Analyze the one file without conditions.
+         */
+        void analyzeFile( const QString& path );
+
+        /**
          * Analyze a resource that is not read from the local harddisk.
          *
          * \param uri The resource URI to identify the resource.
@@ -174,6 +179,7 @@
 
     private Q_SLOTS:
         void slotConfigChanged();
+        void slotDirsToUpdateWakeupTimeout();
 
     private:
         void run();
@@ -215,6 +221,7 @@
 
         QMutex m_dirsToUpdateMutex;
         QWaitCondition m_dirsToUpdateWc;
+        QTimer* m_dirsToUpdateWakeupTimer;
 
         QString m_currentFolder;
         KUrl m_currentUrl;
Index: nepomuk/services/strigi/systray.cpp
===================================================================
--- nepomuk/services/strigi/systray.cpp	(révision 1121160)
+++ nepomuk/services/strigi/systray.cpp	(copie de travail)
@@ -82,7 +82,7 @@
         setStatus( newStatus );
     }
 
-    QString statusString = m_service->userStatusString();
+    QString statusString = m_service->simpleUserStatusString();
     if ( statusString != m_prevStatus ) {
         m_prevStatus = statusString;
         setToolTip("nepomuk", i18n("Search Service"), statusString );
Index: nepomuk/services/strigi/strigiservice.cpp
===================================================================
--- nepomuk/services/strigi/strigiservice.cpp	(révision 1121160)
+++ nepomuk/services/strigi/strigiservice.cpp	(copie de travail)
@@ -24,8 +24,8 @@
 #include "systray.h"
 #include "strigiserviceconfig.h"
 #include "statuswidget.h"
-#include "filesystemwatcher.h"
 #include "useractivitymonitor.h"
+#include "filewatchserviceinterface.h"
 
 #include <KDebug>
 #include <KDirNotify>
@@ -42,10 +42,6 @@
     : Service( parent, true ),
       m_indexManager( 0 )
 {
-    // only so ResourceManager won't open yet another connection to the nepomuk server
-    ResourceManager::instance()->setOverrideMainModel( mainModel() );
-
-
     // lower process priority - we do not want to spoil KDE usage
     // ==============================================================
     if ( !lowerPriority() )
@@ -64,18 +60,6 @@
         // monitor all kinds of events
         ( void )new EventMonitor( m_indexScheduler, this );
 
-        // monitor the file system
-        m_fsWatcher = new FileSystemWatcher( this );
-        m_fsWatcher->setWatchRecursively( true );
-        connect( m_fsWatcher, SIGNAL( dirty( QString ) ),
-                 this, SLOT( slotDirDirty( QString ) ) );
-
-        // monitor all KDE-ish changes for quick updates
-        connect( new org::kde::KDirNotify( QString(), QString(), QDBusConnection::sessionBus(), this ),
-                 SIGNAL( FilesAdded( QString ) ),
-                 this, SLOT( slotDirDirty( const QString& ) ) );
-
-
         // update the watches if the config changes
         connect( StrigiServiceConfig::self(), SIGNAL( configChanged() ),
                  this, SLOT( updateWatches() ) );
@@ -98,23 +82,14 @@
                  this, SIGNAL( statusStringChanged() ) );
         connect( m_indexScheduler, SIGNAL( indexingSuspended(bool) ),
                  this, SIGNAL( statusStringChanged() ) );
-        connect( m_fsWatcher, SIGNAL( statusChanged(FileSystemWatcher::Status) ),
-                 this, SIGNAL( statusStringChanged() ) );
 
         // setup the indexer to index at snail speed for the first two minutes
         // this is done for KDE startup - to not slow that down too much
         m_indexScheduler->setIndexingSpeed( IndexScheduler::SnailPace );
-        QTimer::singleShot( 2*60*1000, m_indexScheduler, SLOT( setReducedIndexingSpeed() ) );
 
-        // slow down on user activity (start also only after 2 minutes)
-        UserActivityMonitor* userActivityMonitor = new UserActivityMonitor( this );
-        connect( userActivityMonitor, SIGNAL( userActive( bool ) ),
-                 m_indexScheduler, SLOT( setReducedIndexingSpeed( bool ) ) );
-        QTimer::singleShot( 2*60*1000, userActivityMonitor, SLOT( start() ) );
+        // delayed init for the rest which uses IO and CPU
+        QTimer::singleShot( 2*60*1000, this, SLOT( finishInitialization() ) );
 
-        // start watching the index folders
-        QTimer::singleShot( 2*60*1000, this, SLOT( updateWatches() ) );
-
         // start the actual indexing
         m_indexScheduler->start();
     }
@@ -139,46 +114,68 @@
 }
 
 
-void Nepomuk::StrigiService::updateWatches()
+void Nepomuk::StrigiService::finishInitialization()
 {
-    // the hard way since the KDirWatch API is too simple
-    QStringList folders = StrigiServiceConfig::self()->includeFolders();
-    if ( folders != m_fsWatcher->folders() ) {
-        m_fsWatcher->setFolders( StrigiServiceConfig::self()->includeFolders() );
-        m_fsWatcher->setInterval( 2*60 ); // check every 2 minutes
-        m_fsWatcher->start();
-    }
+    // slow down on user activity (start also only after 2 minutes)
+    UserActivityMonitor* userActivityMonitor = new UserActivityMonitor( this );
+    connect( userActivityMonitor, SIGNAL( userActive( bool ) ),
+             m_indexScheduler, SLOT( setReducedIndexingSpeed( bool ) ) );
+    userActivityMonitor->start();
+
+    // full speed until the user is active
+    m_indexScheduler->setIndexingSpeed( IndexScheduler::FullSpeed );
+
+    updateWatches();
 }
 
 
-void Nepomuk::StrigiService::slotDirDirty( const QString& path )
+void Nepomuk::StrigiService::updateWatches()
 {
-    if ( StrigiServiceConfig::self()->shouldFolderBeIndexed( path ) ) {
-        m_indexScheduler->updateDir( path );
+    org::kde::nepomuk::FileWatch filewatch( "org.kde.nepomuk.services.nepomukfilewatch",
+                                            "/nepomukfilewatch",
+                                            QDBusConnection::sessionBus() );
+    foreach( const QString& folder, StrigiServiceConfig::self()->includeFolders() ) {
+        filewatch.watchFolder( folder );
     }
 }
 
 
 QString Nepomuk::StrigiService::userStatusString() const
 {
+    return userStatusString( false );
+}
+
+
+QString Nepomuk::StrigiService::simpleUserStatusString() const
+{
+    return userStatusString( true );
+}
+
+
+QString Nepomuk::StrigiService::userStatusString( bool simple ) const
+{
     bool indexing = m_indexScheduler->isIndexing();
     bool suspended = m_indexScheduler->isSuspended();
     QString folder = m_indexScheduler->currentFolder();
 
-    if ( suspended )
+    if ( suspended ) {
         return i18nc( "@info:status", "File indexer is suspended" );
-    else if ( indexing )
-        return i18nc( "@info:status", "Strigi is currently indexing files in folder %1", folder );
-    else if ( m_fsWatcher->status() == FileSystemWatcher::Checking )
-        return i18nc( "@info:status", "Checking file system for new files" );
-    else
+    }
+    else if ( indexing ) {
+        if ( folder.isEmpty() || simple )
+            return i18nc( "@info:status", "Strigi is currently indexing files" );
+        else
+            return i18nc( "@info:status", "Strigi is currently indexing files in folder %1", folder );
+    }
+    else {
         return i18nc( "@info:status", "File indexer is idle" );
+    }
 }
 
 
 bool Nepomuk::StrigiService::isIdle() const
 {
-    return ( !m_indexScheduler->isIndexing() && m_fsWatcher->status() == FileSystemWatcher::Idle );
+    return ( !m_indexScheduler->isIndexing() );
 }
 
 
@@ -186,11 +183,9 @@
 {
     if ( suspend ) {
         m_indexScheduler->suspend();
-        m_fsWatcher->suspend();
     }
     else {
         m_indexScheduler->resume();
-        m_fsWatcher->resume();
     }
 }
 
Index: nepomuk/services/strigi/strigiservice.h
===================================================================
--- nepomuk/services/strigi/strigiservice.h	(révision 1121160)
+++ nepomuk/services/strigi/strigiservice.h	(copie de travail)
@@ -26,7 +26,6 @@
 namespace Strigi {
     class IndexManager;
 }
-class FileSystemWatcher;
 
 namespace Nepomuk {
 
@@ -50,24 +49,28 @@
 
     public Q_SLOTS:
         /**
-         * \return A user readable status string
+         * \return A user readable status string. Includes the currently indexed folder.
          */
         QString userStatusString() const;
+
+        /**
+         * Simplified status string without details.
+         */
+        QString simpleUserStatusString() const;
         bool isIdle() const;
         void setSuspended( bool );
         bool isSuspended() const;
 
     private Q_SLOTS:
+        void finishInitialization();
         void updateWatches();
-        void slotDirDirty( const QString& );
 
     private:
         void updateStrigiConfig();
+        QString userStatusString( bool simple ) const;
 
         Strigi::IndexManager* m_indexManager;
         IndexScheduler* m_indexScheduler;
-
-        FileSystemWatcher* m_fsWatcher;
     };
 }
 
Index: nepomuk/services/strigi/statuswidget.cpp
===================================================================
--- nepomuk/services/strigi/statuswidget.cpp	(révision 1121160)
+++ nepomuk/services/strigi/statuswidget.cpp	(copie de travail)
@@ -1,5 +1,5 @@
 /* This file is part of the KDE Project
-   Copyright (c) 2008 Sebastian Trueg <trueg@kde.org>
+   Copyright (c) 2008-2010 Sebastian Trueg <trueg@kde.org>
 
    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Library General Public
Index: nepomuk/services/strigi/eventmonitor.cpp
===================================================================
--- nepomuk/services/strigi/eventmonitor.cpp	(révision 1121160)
+++ nepomuk/services/strigi/eventmonitor.cpp	(copie de travail)
@@ -43,14 +43,9 @@
 Nepomuk::EventMonitor::EventMonitor( IndexScheduler* scheduler, QObject* parent )
     : QObject( parent ),
       m_indexScheduler( scheduler ),
-      m_pauseState( NotPaused )
+      m_pauseState( NotPaused ),
+      m_totalIndexingSeconds( 0 )
 {
-    // FileSystemWatcher does not catch changes to files, only new and removed files
-    // thus, we also do periodic updates of the whole index every two hours
-    connect( &m_periodicUpdateTimer, SIGNAL( timeout() ),
-             m_indexScheduler, SLOT( updateAll() ) );
-    m_periodicUpdateTimer.setInterval( 2*60*60*1000 );
-
     // monitor the powermanagement to not drain the battery
     connect( Solid::PowerManagement::notifier(), SIGNAL( appShouldConserveResourcesChanged( bool ) ),
              this, SLOT( slotPowerManagementStatusChanged( bool ) ) );
@@ -63,7 +58,7 @@
     if ( StrigiServiceConfig::self()->isInitialRun() ) {
         // TODO: add actions to this notification
 
-        m_initialIndexTime.start();
+        m_indexingStartTime = QDateTime::currentDateTime();
 
         // inform the user about the initial indexing
         sendEvent( "initialIndexingStarted",
@@ -76,10 +71,10 @@
         connect( m_indexScheduler, SIGNAL( indexingStopped() ),
                  this, SLOT( slotIndexingStopped() ),
                  Qt::QueuedConnection );
+                 
+        connect( m_indexScheduler, SIGNAL( indexingSuspended(bool) ),
+                 this, SLOT( slotIndexingSuspended(bool) ) );
     }
-    else {
-        m_periodicUpdateTimer.start();
-    }
 
     slotPowerManagementStatusChanged( Solid::PowerManagement::appShouldConserveResources() );
 }
@@ -94,16 +89,14 @@
 {
     if ( !conserveResources && m_pauseState == PausedDueToPowerManagement ) {
         kDebug() << "Resuming indexer due to power management";
-        m_pauseState = NotPaused;
-        m_indexScheduler->resume();
+        resumeIndexing();
         sendEvent( "indexingResumed", i18n("Resuming indexing of files for fast searching."), "battery-charging" );
     }
     else if ( conserveResources &&
               m_indexScheduler->isRunning() &&
               !m_indexScheduler->isSuspended() ) {
         kDebug() << "Pausing indexer due to power management";
-        m_pauseState = PausedDueToPowerManagement;
-        m_indexScheduler->suspend();
+        pauseIndexing( PausedDueToPowerManagement );
         sendEvent( "indexingSuspended", i18n("Suspending the indexing of files to preserve resources."), "battery-100" );
     }
 }
@@ -116,8 +109,7 @@
         if ( info.available() <= StrigiServiceConfig::self()->minDiskSpace() ) {
             if ( m_indexScheduler->isRunning() &&
                 !m_indexScheduler->isSuspended() ) {
-                m_pauseState = PausedDueToAvailSpace;
-                m_indexScheduler->suspend();
+                pauseIndexing( PausedDueToAvailSpace );
                 sendEvent( "indexingSuspended",
                            i18n("Disk space is running low (%1 left). Suspending indexing of files.",
                                 KIO::convertSize( info.available() ) ),
@@ -126,8 +118,7 @@
         }
         else if ( m_pauseState == PausedDueToAvailSpace ) {
             kDebug() << "Resuming indexer due to disk space";
-            m_pauseState = NotPaused;
-            m_indexScheduler->resume();
+            resumeIndexing();
             sendEvent( "indexingResumed", i18n("Resuming indexing of files for fast searching."), "drive-harddisk" );
         }
     }
@@ -142,16 +133,48 @@
 {
     // inform the user about the end of initial indexing. This will only be called once
     if ( !m_indexScheduler->isSuspended() ) {
-        kDebug() << "initial indexing took" << m_initialIndexTime.elapsed();
+        m_totalIndexingSeconds += m_indexingStartTime.secsTo( QDateTime::currentDateTime() );
+        const int elapsed = m_totalIndexingSeconds * 1000;
+        
+        kDebug() << "initial indexing took" << elapsed;
         sendEvent( "initialIndexingFinished",
-                   i18nc( "@info %1 is a duration formatted using KLocale::formatDuration",
+                   i18nc( "@info %1 is a duration formatted using KLocale::prettyFormatDuration",
                           "Initial indexing of files for fast searching finished in %1",
-                          KGlobal::locale()->formatDuration( m_initialIndexTime.elapsed() ) ),
+                          KGlobal::locale()->prettyFormatDuration( elapsed ) ),
                    "nepomuk" );
         m_indexScheduler->disconnect( this );
+    }
+}
 
-        m_periodicUpdateTimer.start();
+
+void Nepomuk::EventMonitor::pauseIndexing(int pauseState)
+{
+    m_pauseState = pauseState;
+    m_indexScheduler->suspend();
+
+    m_totalIndexingSeconds += m_indexingStartTime.secsTo( QDateTime::currentDateTime() );
+}
+
+
+void Nepomuk::EventMonitor::resumeIndexing()
+{
+    m_pauseState = NotPaused;
+    m_indexScheduler->resume();
+
+    m_indexingStartTime = QDateTime::currentDateTime();
+}
+
+
+void Nepomuk::EventMonitor::slotIndexingSuspended( bool suspended )
+{
+    if( suspended ) {
+        //The indexing is already paused, this meerly sets the correct state, and adjusts the timing.
+        pauseIndexing( PausedCustom );
     }
+    else {
+        //Again, used to set the correct state, and adjust the timing.
+        resumeIndexing();
+    }
 }
 
 #include "eventmonitor.moc"
Index: nepomuk/services/strigi/CMakeLists.txt
===================================================================
--- nepomuk/services/strigi/CMakeLists.txt	(révision 1121160)
+++ nepomuk/services/strigi/CMakeLists.txt	(copie de travail)
@@ -33,7 +33,6 @@
   eventmonitor.cpp
   systray.cpp
   statuswidget.cpp
-  filesystemwatcher.cpp
   useractivitymonitor.cpp
   )
 
@@ -48,6 +47,9 @@
   "Nepomuk::Vocabulary"
   "trig")
 
+qt4_add_dbus_interface(strigiservice_SRCS ../../interfaces/org.kde.nepomuk.RemovableStorage.xml removablestorageserviceinterface)
+qt4_add_dbus_interface(strigiservice_SRCS ../../interfaces/org.kde.nepomuk.FileWatch.xml filewatchserviceinterface)
+
 kde4_add_ui_files(strigiservice_SRCS
   statuswidget.ui)
 
@@ -59,7 +61,7 @@
   ${KDE4_KDEUI_LIBS}
   ${KDE4_KIO_LIBS}
   ${KDE4_SOLID_LIBS}
-  ${KDE4_KUTILS_LIBS}
+  ${KDE4_KIDLETIME_LIBS}
   ${NEPOMUK_LIBRARIES}
   ${SOPRANO_LIBRARIES}
   )
Index: nepomuk/services/strigi/strigiserviceadaptor.cpp
===================================================================
--- nepomuk/services/strigi/strigiserviceadaptor.cpp	(révision 1121160)
+++ nepomuk/services/strigi/strigiserviceadaptor.cpp	(copie de travail)
@@ -27,6 +27,7 @@
 #include <QtCore/QUrl>
 #include <QtCore/QDateTime>
 #include <QtCore/QFile>
+#include <QtCore/QFileInfo>
 #include <QtCore/QDataStream>
 
 #include <KDebug>
@@ -72,6 +73,12 @@
 }
 
 
+QString Nepomuk::StrigiServiceAdaptor::currentFile()
+{
+    return m_service->indexScheduler()->currentFile();
+}
+
+
 void Nepomuk::StrigiServiceAdaptor::resume()
 {
     // handle method call org.kde.nepomuk.Strigi.resume
@@ -88,8 +95,17 @@
 
 void Nepomuk::StrigiServiceAdaptor::updateFolder( const QString& path, bool forced )
 {
-    if ( StrigiServiceConfig::self()->shouldFolderBeIndexed( path ) )
-        m_service->indexScheduler()->updateDir( path, forced );
+    QFileInfo info( path );
+    if ( info.exists() ) {
+        QString dirPath;
+        if ( info.isDir() )
+            dirPath = info.absoluteFilePath();
+        else
+            dirPath = info.absolutePath();
+
+        if ( StrigiServiceConfig::self()->shouldFolderBeIndexed( dirPath ) )
+            m_service->indexScheduler()->updateDir( dirPath, forced );
+    }
 }
 
 
@@ -101,10 +117,25 @@
 
 void Nepomuk::StrigiServiceAdaptor::indexFolder( const QString& path, bool forced )
 {
-    m_service->indexScheduler()->updateDir( path, forced );
+    QFileInfo info( path );
+    if ( info.exists() ) {
+        QString dirPath;
+        if ( info.isDir() )
+            dirPath = info.absoluteFilePath();
+        else
+            dirPath = info.absolutePath();
+
+        m_service->indexScheduler()->updateDir( dirPath, forced );
+    }
 }
 
 
+void Nepomuk::StrigiServiceAdaptor::indexFile( const QString& path )
+{
+    m_service->indexScheduler()->analyzeFile( path );
+}
+
+
 void Nepomuk::StrigiServiceAdaptor::analyzeResource( const QString& uri, uint mTime, const QByteArray& data )
 {
     QDataStream stream( data );
Index: nepomuk/services/storage/repository.cpp
===================================================================
--- nepomuk/services/storage/repository.cpp	(révision 1121160)
+++ nepomuk/services/storage/repository.cpp	(copie de travail)
@@ -204,7 +206,6 @@
                 kDebug() << "Starting model conversion";
 
                 convertingData = true;
-                // No need to use the index filter as it already contains the data
                 m_modelCopyJob = new ModelCopyJob( oldModel, m_model, this );
                 connect( m_modelCopyJob, SIGNAL( result( KJob* ) ), this, SLOT( copyFinished( KJob* ) ) );
                 m_modelCopyJob->start();
Index: nepomuk/services/storage/nepomukcore.cpp
===================================================================
--- nepomuk/services/storage/nepomukcore.cpp	(révision 1121160)
+++ nepomuk/services/storage/nepomukcore.cpp	(copie de travail)
@@ -28,7 +28,7 @@
 
 #include <Soprano/BackendSetting>
 
-static const char* s_repositoryName = "main";
+static const char s_repositoryName[] = "main";
 
 Nepomuk::Core::Core( QObject* parent )
     : Soprano::Server::ServerCore( parent ),
Index: nepomuk/services/storage/nepomukstorage.desktop
===================================================================
--- nepomuk/services/storage/nepomukstorage.desktop	(révision 1121160)
+++ nepomuk/services/storage/nepomukstorage.desktop	(copie de travail)
@@ -33,6 +33,7 @@
 Name[hr]=Nepomuk Pohrana Podataka
 Name[hsb]=Nepomuk składowanje datow
 Name[hu]=Nepomuk adattároló
+Name[ia]=Nepomuk Storage de Datos
 Name[id]=Penyimpanan Data Nepomuk
 Name[is]=Nepomuk gagnageymsla
 Name[it]=Memorizzazione di dati di Nepomuk
@@ -105,6 +106,7 @@
 Comment[hr]=Nepomukova sržna usluga pohrane podataka
 Comment[hsb]=Centralna Nepomukowa słužba za składowanje datow
 Comment[hu]=Nepomuk adattároló alapszolgáltatás
+Comment[ia]=Le servicio de storage de datos  del Corde de Nepomuk
 Comment[id]=Layanan penyimpanan data Inti Nepomuk
 Comment[is]=Kjarni Nepomuk gagnageymslumiðlunar
 Comment[it]=Il servizio principale di memorizzazione dati di Nepomuk
@@ -140,7 +142,7 @@
 Comment[sv]=Nepomuk-datalagringstjänstens kärna
 Comment[ta]=The Core Nepomuk data storage service
 Comment[te]=ఆధార Nepomuk డాటా నిల్వ సేవ
-Comment[tg]=Основная служба хранения данных Nepomuk
+Comment[tg]=Хидмати асосии захирагоҳи Nepomuk
 Comment[th]=บริการจัดเก็บข้อมูลระดับแกนของ Nepomik
 Comment[tr]=Nepomuk Ana veri depolama servisi
 Comment[uk]=Ядро служби збереження даних Nepomuk
Index: nepomuk/services/activities/nepomukactivitiesservice.cpp
===================================================================
--- nepomuk/services/activities/nepomukactivitiesservice.cpp	(révision 0)
+++ nepomuk/services/activities/nepomukactivitiesservice.cpp	(révision 0)
@@ -0,0 +1,321 @@
+/*
+ * Copyright (c) 2010 Ivan Cukic <ivan.cukic(at)kde.org>
+ * Copyright (c) 2008 Sebastian Trueg <trueg@kde.org>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License version 2 as published by the Free Software Foundation.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public License
+ * along with this library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#include "nepomukactivitiesservice.h"
+#include "activitiesserviceadaptor.h"
+
+#include <QUuid>
+#include <QDebug>
+
+#include <KPluginFactory>
+#include <KDebug>
+#include <KConfig>
+#include <KStandardDirs>
+
+#include <Soprano/Model>
+#include <Soprano/StatementIterator>
+#include <Soprano/Statement>
+#include <Soprano/Node>
+#include <Soprano/NodeIterator>
+#include <Soprano/QueryResultIterator>
+#include <Soprano/Vocabulary/NAO>
+#include <Soprano/Vocabulary/RDF>
+
+#include <Nepomuk/Resource>
+#include <Nepomuk/ResourceManager>
+#include <Nepomuk/Variant>
+#include <Nepomuk/Query/Query>
+#include <Nepomuk/Query/AndTerm>
+#include <Nepomuk/Query/OrTerm>
+#include <Nepomuk/Query/ComparisonTerm>
+#include <Nepomuk/Query/ResourceTypeTerm>
+#include <Nepomuk/Query/ResourceTerm>
+#include <Nepomuk/Query/LiteralTerm>
+
+#include "nie.h"
+
+#define URL_ACTIVITY_TYPE "http://www.kde.org/ontologies/activities#Activity"
+#define ACTIVITIES_PROTOCOL "activities://"
+
+/**
+ * this macro creates a service factory which can then be found by the Qt/KDE
+ * plugin system in the Nepomuk server.
+ */
+NEPOMUK_EXPORT_SERVICE( NepomukActivitiesService, "nepomukactivitiesservice" )
+
+NepomukActivitiesService::NepomukActivitiesService(QObject * parent, const QList < QVariant > & params)
+    : Nepomuk::Service( parent )
+{
+    kDebug() << "started";
+
+    Q_UNUSED(parent)
+    Q_UNUSED(params)
+
+    Nepomuk::ResourceManager::instance()->init();
+
+    new NepomukActivitiesServiceAdaptor(this);
+
+    m_model = mainModel();
+
+    setServiceInitialized(true);
+}
+
+NepomukActivitiesService::~NepomukActivitiesService()
+{
+}
+
+QStringList NepomukActivitiesService::listAvailable() const
+{
+    QStringList result;
+
+    foreach (const Nepomuk::Resource & resource,
+            Nepomuk::ResourceManager::instance()->allResourcesOfType(QUrl(URL_ACTIVITY_TYPE))) {
+
+        kDebug() << "url for resource" << resource << urlForResource(resource);
+
+        result << activityId(resource);
+    }
+
+    return result;
+}
+
+void NepomukActivitiesService::add(const QString & id, const QString & name)
+{
+    Nepomuk::Resource activity = activityResource(id);
+    activity.setLabel(name);
+    activity.addType(QUrl(URL_ACTIVITY_TYPE));
+    activity.addIdentifier(ACTIVITIES_PROTOCOL + id);
+
+    kDebug() << activity << id << name;
+}
+
+void NepomukActivitiesService::remove(const QString & id)
+{
+    Nepomuk::Resource activity = activityResource(id);
+
+    kDebug() << activity << id;
+
+    activity.remove();
+}
+
+QString NepomukActivitiesService::name(const QString & id) const
+{
+    return activityResource(id).label();
+}
+
+void NepomukActivitiesService::setName(const QString & id, const QString & name)
+{
+    activityResource(id).setLabel(name);
+}
+
+QString NepomukActivitiesService::icon(const QString & id) const
+{
+    QStringList symbols = activityResource(id).symbols();
+
+    if (symbols.isEmpty()) {
+        return QString();
+    } else {
+        return symbols.first();
+    }
+}
+
+void NepomukActivitiesService::setIcon(const QString & id, const QString & icon)
+{
+    QStringList symbols;
+
+    symbols << icon;
+
+    activityResource(id).setSymbols(symbols);
+}
+
+QString NepomukActivitiesService::resourceUri(const QString & id) const
+{
+    return KUrl(activityResource(id).resourceUri()).url();
+}
+
+QString NepomukActivitiesService::uri(const QString & id) const
+{
+    return ACTIVITIES_PROTOCOL + id;
+}
+
+void NepomukActivitiesService::associateResource(const QString & activityId,
+    const QString & resourceUri, const QString & typeUri)
+{
+    Nepomuk::Resource activity = activityResource(activityId);
+    Nepomuk::Resource resource = Nepomuk::Resource(resourceUri);
+
+    kDebug() << activity << resource;
+
+    activity.addIsRelated(resource);
+
+    if (!typeUri.isEmpty()) {
+        resource.addType(QUrl(typeUri));
+        kDebug() << "set the resource type to" << typeUri;
+    }
+}
+
+void NepomukActivitiesService::disassociateResource(const QString & activityId,
+    const QString & resourceUri)
+{
+    Nepomuk::Resource activity = activityResource(activityId);
+    Nepomuk::Resource resource = Nepomuk::Resource(resourceUri);
+
+    kDebug() << activity << resource;
+
+    QList< Nepomuk::Resource > v = activity.isRelateds();
+    v.removeAll(resource);
+    activity.setIsRelateds(v);
+}
+
+QStringList NepomukActivitiesService::associatedResources(
+    const QString & id, const QString & resourceType) const
+{
+
+    Nepomuk::Resource activity = activityResource(id);
+
+    Nepomuk::Query::Term term = Nepomuk::Query::ComparisonTerm(
+            Soprano::Vocabulary::NAO::isRelated(),
+            Nepomuk::Query::ResourceTerm(activity)
+        ).inverted();
+
+    if (!resourceType.isEmpty()) {
+        // OrTerm so that we can support programs that use
+        // types not available in ontologies
+        KUrl resourceTypeUri(resourceType);
+
+        term = Nepomuk::Query::AndTerm(
+            term,
+            Nepomuk::Query::OrTerm(
+                Nepomuk::Query::ComparisonTerm(
+                    Soprano::Vocabulary::RDF::type(),
+                    Nepomuk::Query::ResourceTerm(Nepomuk::Resource(resourceTypeUri))
+                ),
+                Nepomuk::Query::ResourceTypeTerm(resourceTypeUri)
+            )
+        );
+    }
+
+    Nepomuk::Query::Query query(term);
+
+    Soprano::QueryResultIterator it = m_model->executeQuery(query.toSparqlQuery(),
+        Soprano::Query::QueryLanguageSparql );
+
+    QStringList result;
+
+    while ( it.next() ) {
+        QUrl uri = it["r"].uri();
+
+        Nepomuk::Resource resource(uri);
+
+        result << urlForResource(resource);
+    }
+
+    return result;
+}
+
+QStringList NepomukActivitiesService::forResource(const QString & uri) const
+{
+    kDebug() << "uri" << uri;
+
+    Nepomuk::Resource resource = Nepomuk::Resource(KUrl(uri));
+    Nepomuk::Resource activityType(QUrl(URL_ACTIVITY_TYPE));
+
+    Nepomuk::Query::Query query(
+        Nepomuk::Query::AndTerm(
+            Nepomuk::Query::ComparisonTerm(
+                Soprano::Vocabulary::RDF::type(),
+                Nepomuk::Query::ResourceTerm(activityType)
+            ),
+            Nepomuk::Query::ComparisonTerm(
+                Soprano::Vocabulary::NAO::isRelated(),
+                Nepomuk::Query::ResourceTerm(resource)
+            )
+        )
+    );
+
+    Soprano::QueryResultIterator it = m_model->executeQuery(query.toSparqlQuery(),
+        Soprano::Query::QueryLanguageSparql);
+
+    QStringList result;
+
+    while ( it.next() ) {
+        QUrl uri = it["r"].uri();
+
+        Nepomuk::Resource resource(uri);
+
+        kDebug() << urlForResource(resource);
+
+        result << activityId(resource);
+    }
+
+    return result;
+
+}
+
+void NepomukActivitiesService::_deleteAll()
+{
+    foreach (Nepomuk::Resource resource,
+            Nepomuk::ResourceManager::instance()->allResourcesOfType(QUrl(URL_ACTIVITY_TYPE))) {
+        kDebug() << "NepomukActivitiesService::_deleteAllActivities: resource: " << resource <<
+                resource.exists();
+        resource.remove();
+    }
+}
+
+QString NepomukActivitiesService::_serviceIteration() const
+{
+    return "0.3";
+}
+
+// Private
+
+Nepomuk::Resource NepomukActivitiesService::activityResource(const QString & id) const
+{
+    return Nepomuk::Resource(KUrl(ACTIVITIES_PROTOCOL + id));
+}
+
+QString NepomukActivitiesService::urlForResource(const Nepomuk::Resource & resource) const
+{
+    if (resource.identifiers().size()) {
+        return resource.identifiers()[0];
+
+    } else if (resource.hasProperty(Ontologies::nie::url())) {
+        return KUrl(resource.property(Ontologies::nie::url()).toUrl()).url();
+
+    } else {
+        kDebug() << resource.properties().keys();
+
+        return KUrl(resource.resourceUri()).url();
+
+    }
+}
+
+QString NepomukActivitiesService::activityId(const Nepomuk::Resource & resource) const
+{
+    foreach(QString identifier, resource.identifiers()) { // krazy:exclude=foreach
+        if (identifier.startsWith(ACTIVITIES_PROTOCOL)) {
+            return identifier.replace(QLatin1String(ACTIVITIES_PROTOCOL), QString());
+        }
+    }
+
+    return KUrl(resource.resourceUri()).url()
+            .replace(QLatin1String(ACTIVITIES_PROTOCOL), QString());
+}
+
+#include "nepomukactivitiesservice.moc"

Modification de propriétés sur nepomuk/services/activities/nepomukactivitiesservice.cpp
___________________________________________________________________
Ajouté : svn:eol-style
   + native

Index: nepomuk/services/activities/org.kde.nepomuk.ActivitiesService.xml
===================================================================
--- nepomuk/services/activities/org.kde.nepomuk.ActivitiesService.xml	(révision 0)
+++ nepomuk/services/activities/org.kde.nepomuk.ActivitiesService.xml	(révision 0)
@@ -0,0 +1,70 @@
+<!DOCTYPE node PUBLIC "-//freedesktop//DTD D-BUS Object Introspection 1.0//EN" "http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd">
+<node>
+  <interface name="org.kde.nepomuk.services.NepomukActivitiesService">
+    <method name="listAvailable">
+      <arg type="as" direction="out"/>
+    </method>
+    <method name="add">
+      <arg name="activityId" type="s" direction="in"/>
+      <arg name="activityName" type="s" direction="in"/>
+    </method>
+    <method name="remove">
+      <arg name="activityId" type="s" direction="in"/>
+    </method>
+    <method name="name">
+      <arg type="s" direction="out"/>
+      <arg name="activityId" type="s" direction="in"/>
+    </method>
+    <method name="setName">
+      <arg name="activityId" type="s" direction="in"/>
+      <arg name="name" type="s" direction="in"/>
+    </method>
+    <method name="icon">
+      <arg type="s" direction="out"/>
+      <arg name="activityId" type="s" direction="in"/>
+    </method>
+    <method name="setIcon">
+      <arg name="activityId" type="s" direction="in"/>
+      <arg name="name" type="s" direction="in"/>
+    </method>
+    <method name="resourceUri">
+      <arg type="s" direction="out"/>
+      <arg name="activityId" type="s" direction="in"/>
+    </method>
+    <method name="uri">
+      <arg type="s" direction="out"/>
+      <arg name="activityId" type="s" direction="in"/>
+    </method>
+    <method name="associateResource">
+      <arg name="activityID" type="s" direction="in"/>
+      <arg name="resourceUri" type="s" direction="in"/>
+      <arg name="typeUri" type="s" direction="in"/>
+    </method>
+    <method name="associateResource">
+      <arg name="activityID" type="s" direction="in"/>
+      <arg name="resourceUri" type="s" direction="in"/>
+    </method>
+    <method name="disassociateResource">
+      <arg name="activityID" type="s" direction="in"/>
+      <arg name="resourceUri" type="s" direction="in"/>
+    </method>
+    <method name="associatedResources">
+      <arg type="as" direction="out"/>
+      <arg name="activityId" type="s" direction="in"/>
+      <arg name="resourceType" type="s" direction="in"/>
+    </method>
+    <method name="associatedResources">
+      <arg type="as" direction="out"/>
+      <arg name="activityId" type="s" direction="in"/>
+    </method>
+    <method name="forResource">
+      <arg type="as" direction="out"/>
+      <arg name="uri" type="s" direction="in"/>
+    </method>
+    <method name="_deleteAll">
+    </method>
+    <method name="_serviceIteration">
+      <arg type="s" direction="out"/>
+    </method>
+  </interface>
+</node>
Index: nepomuk/services/activities/nepomukactivitiesservice.h
===================================================================
--- nepomuk/services/activities/nepomukactivitiesservice.h	(révision 0)
+++ nepomuk/services/activities/nepomukactivitiesservice.h	(révision 0)
@@ -0,0 +1,162 @@
+/*
+ * Copyright (c) 2010 Ivan Cukic <ivan.cukic(at)kde.org>
+ * Copyright (c) 2008 Sebastian Trueg <trueg@kde.org>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License version 2 as published by the Free Software Foundation.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public License
+ * along with this library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifndef NEPOMUK_ACTIVITIES_SERVICE_H
+#define NEPOMUK_ACTIVITIES_SERVICE_H
+
+#include <Nepomuk/Service>
+#include <Nepomuk/Resource>
+
+#include <QtCore/QVariant>
+#include <QtCore/QUrl>
+
+#include <KConfigGroup>
+
+/**
+ * Nepomuk service for storing workspace activities
+ */
+class NepomukActivitiesService: public Nepomuk::Service {
+    Q_OBJECT
+    Q_CLASSINFO("D-Bus Interface", "org.kde.nepomuk.services.NepomukActivitiesService")
+
+public:
+    /**
+     * Creates a new ActivitiesService
+     */
+    NepomukActivitiesService(QObject* parent, const QVariantList & args);
+
+    /**
+     * Destroys this ActivitiesService
+     */
+    ~NepomukActivitiesService();
+
+public Q_SLOTS:
+    /**
+     * @returns the list of all activities
+     */
+    QStringList listAvailable() const;
+
+    /**
+     * Creates a new activity. If the activity already
+     * exists, only the name is set
+     * @param activityId id to be used
+     * @param activityName name of the activity
+     */
+    void add(const QString & activityId,
+            const QString & activityName);
+
+    /**
+     * Remove the specified activity
+     * @param activityId id of the activity to delete
+     */
+    void remove(const QString & activityId);
+
+    /**
+     * @returns the name of the specified activity
+     * @param activityId id of the activity
+     */
+    QString name(const QString & activityId) const;
+
+    /**
+     * Sets the name of the specified activity
+     * @param activityId id of the activity
+     * @param name name to be set
+     */
+    void setName(const QString & activityId, const QString & name);
+
+    /**
+     * @returns the icon of the specified activity
+     * @param activityId id of the activity
+     */
+    QString icon(const QString & activityId) const;
+
+    /**
+     * Sets the icon of the specified activity.
+     * @param activityId id of the activity
+     * @param icon path or freedesktop.org icon name
+     */
+    void setIcon(const QString & activityId, const QString & icon);
+
+    /**
+     * @returns the Nepomuk URI of the specified activity
+     * @param activityId id of the activity
+     */
+    QString resourceUri(const QString & activityId) const;
+
+    /**
+     * @returns activity uri for the specified activity
+     * @param activityId id of the activity
+     */
+    QString uri(const QString & activityId) const;
+
+    /**
+     * Links the resource and the activity. (Adds 'is related to' link
+     * from the resource to the activity)
+     * @param activityID id of the activity
+     * @param resourceUri Nepomuk resource URI
+     * @param typeUri type to assign to the resource to be linked
+     */
+    void associateResource(const QString & activityID,
+        const QString & resourceUri, const QString & typeUri = QString());
+
+    /**
+     * Unlinks the resource and the activity. (Removes 'is related to' link
+     * from the resource to the activity)
+     * @param activityID id of the activity
+     * @param resourceUri Nepomuk resource URI
+     */
+    void disassociateResource(const QString & activityID,
+        const QString & resourceUri);
+
+    /**
+     * @returns the list of resources that are related to
+     * the specified activity
+     * @param activityId id of the activity
+     */
+    QStringList associatedResources(const QString & activityId, const QString & resourceType = QString()) const;
+
+    /**
+     * @returns the list of activities associated with the
+     * specified resource
+     */
+    QStringList forResource(const QString & uri) const;
+
+    /**
+     * This function is for debugging purposes only,
+     * and will be deleted
+     */
+    void _deleteAll();
+
+    /**
+     * This function is for debugging purposes only,
+     * and will be deleted
+     */
+    QString _serviceIteration() const;
+
+private:
+    Soprano::Model * m_model;
+
+    Nepomuk::Resource activityResource(const QString & activityId) const;
+    QString activityId(const Nepomuk::Resource & resource) const;
+
+    QString urlForResource(const Nepomuk::Resource & resource) const;
+
+};
+
+#endif // NEPOMUK_ACTIVITIES_SERVICE_H

Modification de propriétés sur nepomuk/services/activities/nepomukactivitiesservice.h
___________________________________________________________________
Ajouté : svn:eol-style
   + native

Index: nepomuk/services/activities/nepomukactivitiesservice.desktop
===================================================================
--- nepomuk/services/activities/nepomukactivitiesservice.desktop	(révision 0)
+++ nepomuk/services/activities/nepomukactivitiesservice.desktop	(révision 0)
@@ -0,0 +1,38 @@
+[Desktop Entry]
+Type=Service
+ServiceTypes=NepomukService
+X-KDE-Library=nepomukactivitiesservice
+X-KDE-Nepomuk-autostart=true
+X-KDE-Nepomuk-start-on-demand=false
+Name=Nepomuk Activities Service
+Name[ca]=Servei d'activitats del Nepomuk
+Name[ca@valencia]=Servei d'activitats del Nepomuk
+Name[da]=Nepomuk aktivitetstjeneste
+Name[de]=Nepomuk-Aktivitäten-Dienst
+Name[el]=Υπηρεσία δραστηριοτήτων Nepomuk
+Name[en_GB]=Nepomuk Activities Service
+Name[es]=Servicio de actividades de Nepomuk
+Name[et]=Nepomuki tegevuste teenus
+Name[fr]=Service d'agencements de Nepomuk
+Name[hr]=Usluga Aktivnosti Nepomuka
+Name[ia]=Servicio de Activitate de Nepomuk
+Name[id]=Layanan Aktivitas Nepomuk
+Name[is]=Nepomuk virkniþjónusta
+Name[it]=Servizio delle attività di Nepomuk
+Name[ja]=Nepomuk アクティビティサービス
+Name[kk]=Nepomuk белсенділік қызметі
+Name[km]=សេវា​សកម្មភាព​របស់ Nepomuk
+Name[kn]=ನೆಪೋಮುಕ್ ಚಟುವಟಿಕೆಗಳ ಸೇವೆ
+Name[lt]=Nepomuk veiklų tarnyba
+Name[nb]=Nepomuk aktivitetstjeneste
+Name[nds]=Nepomuk-Aktivitetendeenst
+Name[nl]=Nepomuk activiteitenservice
+Name[pa]=ਨਿਪੋਮੁਕ ਸਟਰੀਗੀ ਸਰਵਿਸ
+Name[pt]=Serviço de Actividades do Nepomuk
+Name[pt_BR]=Serviço de Atividades do Nepomuk
+Name[sv]=Nepomuk aktivitetstjänst
+Name[uk]=Служба просторів дій Nepomuk
+Name[x-test]=xxNepomuk Activities Servicexx
+Name[zh_CN]=Nepomuk 活动服务
+Name[zh_TW]=Nepomuk 活動服務
+Comment=
Index: nepomuk/services/activities/CMakeLists.txt
===================================================================
--- nepomuk/services/activities/CMakeLists.txt	(révision 0)
+++ nepomuk/services/activities/CMakeLists.txt	(révision 0)
@@ -0,0 +1,48 @@
+include(SopranoAddOntology)
+
+set(nepomukactivitiesservice_SRCS
+   nepomukactivitiesservice.cpp
+   )
+
+qt4_add_dbus_adaptor(nepomukactivitiesservice_SRCS
+   org.kde.nepomuk.ActivitiesService.xml
+   nepomukactivitiesservice.h
+   NepomukActivitiesService
+   )
+
+soprano_add_ontology(
+   nepomukactivitiesservice_SRCS
+   "${SHAREDDESKTOPONTOLOGIES_ROOT_DIR}/nie/nie.trig"
+   "nie"
+   "Ontologies"
+   "trig"
+   )
+
+kde4_add_plugin(
+   nepomukactivitiesservice ${nepomukactivitiesservice_SRCS}
+   )
+
+target_link_libraries(nepomukactivitiesservice
+   ${SOPRANO_CLIENT_LIBRARIES}
+   ${SOPRANO_LIBRARIES}
+   ${QT_QTCORE_LIBRARY}
+   ${QT_QTDBUS_LIBRARY}
+   ${KDE4_KDECORE_LIBS}
+   ${NEPOMUK_LIBRARIES}
+   ${NEPOMUK_QUERY_LIBRARIES}
+   )
+
+install(
+   FILES nepomukactivitiesservice.desktop
+   DESTINATION ${SERVICES_INSTALL_DIR}
+   )
+
+install(
+   TARGETS nepomukactivitiesservice
+   DESTINATION ${PLUGIN_INSTALL_DIR}
+   )
+
+# install(FILES
+#    org.kde.nepomuk.ActivitiesService.xml
+#    DESTINATION ${DBUS_INTERFACES_INSTALL_DIR}
+#    )

Modification de propriétés sur nepomuk/services/activities/CMakeLists.txt
___________________________________________________________________
Ajouté : svn:eol-style
   + native

Index: nepomuk/services/filewatch/metadatamover.h
===================================================================
--- nepomuk/services/filewatch/metadatamover.h	(révision 1121160)
+++ nepomuk/services/filewatch/metadatamover.h	(copie de travail)
@@ -50,6 +50,16 @@
 
         void stop();
 
+    Q_SIGNALS:
+        /**
+         * Emitted for files (and folders) that have been moved but
+         * do not have metadata to be moved. This allows the strigi
+         * service to pick them up in case they are of interest. The
+         * typical example would be moving a file from a non-indexed into
+         * an indexed folder.
+         */
+        void movedWithoutData( const QString& path );
+
     private Q_SLOTS:
         void slotClearRecentlyFinishedRequests();
 
@@ -68,7 +78,7 @@
          * If old pre-KDE 4.4 file:/ resource URIs are used these are
          * updated to the new nepomuk:/res/<UUID> scheme
          */
-        void updateMetadata( const KUrl& from, const KUrl& to );
+        void updateMetadata( const KUrl& from, const KUrl& to, bool includeChildren = true );
 
         /**
          * Convert old pre-KDE 4.4 style file:/ resource URIs to the
Index: nepomuk/services/filewatch/kinotify.h
===================================================================
--- nepomuk/services/filewatch/kinotify.h	(révision 0)
+++ nepomuk/services/filewatch/kinotify.h	(révision 0)
@@ -0,0 +1,176 @@
+/* This file is part of the KDE libraries
+   Copyright (C) 2007-2010 Sebastian Trueg <trueg@kde.org>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public License
+   along with this library; see the file COPYING.LIB.  If not, write to
+   the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.
+*/
+
+#ifndef _KINOTIFY_H_
+#define _KINOTIFY_H_
+
+#include <QtCore/QObject>
+#include <QtCore/QFlags>
+
+/**
+ * A simple wrapper around inotify which only allows
+ * to add folders recursively.
+ */
+class KInotify : public QObject
+{
+    Q_OBJECT
+
+public:
+    KInotify( QObject* parent );
+    ~KInotify();
+
+    /**
+     * Inotify events that can occur. Use with addWatch
+     * to define the events that should be watched.
+     *
+     * These flags correspond to the native Linux inotify flags.
+     */
+    enum WatchEvent {
+        EventAccess = 0x00000001, /**< File was accessed (read, compare inotify's IN_ACCESS) */
+        EventAttributeChange = 0x00000004, /**< Metadata changed (permissions, timestamps, extended attributes, etc., compare inotify's IN_ATTRIB) */
+        EventCloseWrite = 0x00000008, /**< File opened for writing was closed (compare inotify's IN_CLOSE_WRITE) */
+        EventCloseRead = 0x00000010, /**< File not opened for writing was closed (compare inotify's IN_CLOSE_NOWRITE) */
+        EventCreate = 0x00000100, /** File/directory created in watched directory (compare inotify's IN_CREATE) */
+        EventDelete = 0x00000200, /**< File/directory deleted from watched directory (compare inotify's IN_DELETE) */
+        EventDeleteSelf = 0x00000400, /**< Watched file/directory was itself deleted (compare inotify's IN_DELETE_SELF) */
+        EventModify = 0x00000002, /**< File was modified (compare inotify's IN_MODIFY) */
+        EventMoveSelf = 0x00000800, /**< Watched file/directory was itself moved (compare inotify's IN_MOVE_SELF) */
+        EventMoveFrom = 0x00000040, /**< File moved out of watched directory (compare inotify's IN_MOVED_FROM) */
+        EventMoveTo = 0x00000080, /**< File moved into watched directory (compare inotify's IN_MOVED_TO) */
+        EventOpen = 0x00000020, /**< File was opened (compare inotify's IN_OPEN) */
+        EventUnmount = 0x00002000, /**< Backing fs was unmounted (compare inotify's IN_UNMOUNT) */
+        EventQueueOverflow = 0x00004000, /**< Event queued overflowed (compare inotify's IN_Q_OVERFLOW) */
+        EventIgnored = 0x00008000, /**< File was ignored (compare inotify's IN_IGNORED) */
+        EventMove = ( EventMoveFrom|EventMoveTo),
+        EventAll = ( EventAccess|
+                     EventAttributeChange|
+                     EventCloseWrite|
+                     EventCloseRead|
+                     EventCreate|
+                     EventDelete|
+                     EventDeleteSelf|
+                     EventModify|
+                     EventMoveSelf|
+                     EventMoveFrom|
+                     EventMoveTo|
+                     EventOpen )
+    };
+    Q_DECLARE_FLAGS(WatchEvents, WatchEvent)
+
+    /**
+     * Watch flags
+     *
+     * These flags correspond to the native Linux inotify flags.
+     */
+    enum WatchFlag {
+        FlagOnlyDir = 0x01000000, /**< Only watch the path if it is a directory (IN_ONLYDIR) */
+        FlagDoNotFollow = 0x02000000, /**< Don't follow a sym link (IN_DONT_FOLLOW) */
+        FlagOneShot = 0x80000000 /**< Only send event once (IN_ONESHOT) */
+    };
+    Q_DECLARE_FLAGS(WatchFlags, WatchFlag)
+
+    /**
+     * \return \p true if inotify is available and usable.
+     */
+    bool available() const;
+
+    bool watchingPath( const QString& path ) const;
+
+public Q_SLOTS:
+    bool addWatch( const QString& path, WatchEvents modes, WatchFlags flags = WatchFlags() );
+    bool removeWatch( const QString& path );
+
+Q_SIGNALS:
+    /**
+     * Emitted if a file is accessed (KInotify::EventAccess)
+     */
+    void accessed( const QString& file );
+
+    /**
+     * Emitted if file attributes are changed (KInotify::EventAttributeChange)
+     */
+    void attributeChanged( const QString& file );
+
+    /**
+     * Emitted if FIXME (KInotify::EventCloseWrite)
+     */
+    void closedWrite( const QString& file );
+
+    /**
+     * Emitted if FIXME (KInotify::EventCloseRead)
+     */
+    void closedRead( const QString& file );
+
+    /**
+     * Emitted if a new file has been created in one of the watched
+     * folders (KInotify::EventCreate)
+     */
+    void created( const QString& file );
+
+    /**
+     * Emitted if a watched file or folder has been deleted.
+     * This includes files in watched foldes (KInotify::EventDelete and KInotify::EventDeleteSelf)
+     */
+    void deleted( const QString& file );
+
+    /**
+     * Emitted if a watched file is modified (KInotify::EventModify)
+     */
+    void modified( const QString& file );
+
+    /**
+     * Emitted if a file or folder has been moved or renamed.
+     *
+     * \warning The moved signal will only be emitted if both the source and target folder
+     * are being watched.
+     */
+    void moved( const QString& oldName, const QString& newName );
+
+    /**
+     * Emitted if a file is opened (KInotify::EventOpen)
+     */
+    void opened( const QString& file );
+
+    /**
+     * Emitted if a watched path has been unmounted (KInotify::EventUnmount)
+     */
+    void unmounted( const QString& file );
+
+    /**
+     * Emitted if during updating the internal watch structures (recursive watches)
+     * the inotify user watch limit was reached.
+     *
+     * This means that not all requested paths can be watched until the user watch
+     * limit is increased.
+     *
+     * This signal will only be emitted once.
+     */
+    void watchUserLimitReached();
+
+private Q_SLOTS:
+    void slotEvent( int );
+
+private:
+    class Private;
+    Private* const d;
+
+    Q_PRIVATE_SLOT( d, void _k_addWatches() )
+};
+
+#endif

Modification de propriétés sur nepomuk/services/filewatch/kinotify.h
___________________________________________________________________
Ajouté : svn:eol-style
   + native

Index: nepomuk/services/filewatch/nepomukfilewatch.cpp
===================================================================
--- nepomuk/services/filewatch/nepomukfilewatch.cpp	(révision 1121160)
+++ nepomuk/services/filewatch/nepomukfilewatch.cpp	(copie de travail)
@@ -1,5 +1,5 @@
 /* This file is part of the KDE Project
-   Copyright (c) 2007-2008 Sebastian Trueg <trueg@kde.org>
+   Copyright (c) 2007-2010 Sebastian Trueg <trueg@kde.org>
 
    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Library General Public
@@ -18,45 +18,114 @@
 
 #include "nepomukfilewatch.h"
 #include "metadatamover.h"
+#include "strigiserviceinterface.h"
+#include "../strigi/priority.h"
+#include "nie.h"
 
+#ifdef BUILD_KINOTIFY
+#include "kinotify.h"
+#endif
+
 #include <QtCore/QDir>
+#include <QtCore/QThread>
 #include <QtDBus/QDBusConnection>
 
 #include <KDebug>
 #include <KUrl>
 #include <KPluginFactory>
 
+#include <Nepomuk/ResourceManager>
 
-// Restrictions and TODO:
-// ----------------------
-//
-// * KIO slaves that do change the local file system may emit stuff like
-//   file:///foo/bar -> xyz://foobar while the file actually ends up in
-//   the local file system again. This is not handled here. It is maybe
-//   necessary to use KFileItem::mostLocalUrl to determine local paths
-//   before deciding to call updateMetaDataForResource.
-//
-// * Only operations done through KIO are caught
-//
+#include <Soprano/Model>
+#include <Soprano/QueryResultIterator>
+#include <Soprano/Node>
 
+
 using namespace Soprano;
 
 
 NEPOMUK_EXPORT_SERVICE( Nepomuk::FileWatch, "nepomukfilewatch")
 
 
+namespace {
+
+    class RemoveInvalidThread : public QThread {
+    public :
+        RemoveInvalidThread(QObject* parent = 0);
+        void run();
+    };
+
+    RemoveInvalidThread::RemoveInvalidThread(QObject* parent): QThread(parent)
+    {
+        connect( this, SIGNAL(finished()), this, SLOT(deleteLater()) );
+    }
+
+    void RemoveInvalidThread::run()
+    {
+        QString query = QString::fromLatin1( "select distinct ?g ?url where { ?r %1 ?url. FILTER( regex(str(?url), 'file://') ). graph ?g { ?r ?p ?o. } }" )
+                                        .arg( Soprano::Node::resourceToN3( Nepomuk::Vocabulary::NIE::url() ) );
+        Soprano::QueryResultIterator it = Nepomuk::ResourceManager::instance()->mainModel()->executeQuery( query, Soprano::Query::QueryLanguageSparql );
+
+        while( it.next() ) {
+            QUrl url( it["url"].uri() );
+            QString file = url.toLocalFile();
+
+            if( !file.isEmpty() && !QFile::exists(file) ) {
+                kDebug() << "REMOVING " << file;
+                Nepomuk::ResourceManager::instance()->mainModel()->removeContext( it["g"] );
+            }
+        }
+    }
+
+}
+
+
 Nepomuk::FileWatch::FileWatch( QObject* parent, const QList<QVariant>& )
     : Service( parent )
 {
     // start the mover thread
     m_metadataMover = new MetadataMover( mainModel(), this );
+    connect( m_metadataMover, SIGNAL(movedWithoutData(QString)),
+             this, SLOT(slotMovedWithoutData(QString)),
+             Qt::QueuedConnection );
     m_metadataMover->start();
 
-    // monitor KIO for changes
-    QDBusConnection::sessionBus().connect( QString(), QString(), "org.kde.KDirNotify", "FileMoved",
-                                           this, SIGNAL( slotFileMoved( const QString&, const QString& ) ) );
-    QDBusConnection::sessionBus().connect( QString(), QString(), "org.kde.KDirNotify", "FilesRemoved",
-                                           this, SIGNAL( slotFilesDeleted( const QStringList& ) ) );
+#ifdef BUILD_KINOTIFY
+    // listing all folders in watchFolder below will be IO-intensive. Do not grab it all
+    if ( !lowerIOPriority() )
+        kDebug() << "Failed to lower io priority.";
+
+    // monitor the file system for changes (restricted by the inotify limit)
+    m_dirWatch = new KInotify( this );
+
+    // FIXME: force to only use maxUserWatches-500 or something or always leave 500 free watches
+
+    connect( m_dirWatch, SIGNAL( moved( const QString&, const QString& ) ),
+             this, SLOT( slotFileMoved( const QString&, const QString& ) ) );
+    connect( m_dirWatch, SIGNAL( deleted( const QString& ) ),
+             this, SLOT( slotFileDeleted( const QString& ) ) );
+    connect( m_dirWatch, SIGNAL( created( const QString& ) ),
+             this, SLOT( slotFileCreated( const QString& ) ) );
+    connect( m_dirWatch, SIGNAL( modified( const QString& ) ),
+             this, SLOT( slotFileModified( const QString& ) ) );
+    connect( m_dirWatch, SIGNAL( watchUserLimitReached() ),
+             this, SLOT( slotInotifyWatchUserLimitReached() ) );
+
+    // recursively watch the whole home dir
+
+    // FIXME: we cannot simply watch the folders that contain annotated files since moving
+    // one of these files out of the watched "area" would mean we "lose" it, i.e. we have no
+    // information about where it is moved.
+    // On the other hand only using the homedir means a lot of restrictions.
+    // One dummy solution would be a hybrid: watch the whole home dir plus all folders that
+    // contain annotated files outside of the home dir and hope for the best
+
+    watchFolder( QDir::homePath() );
+#else
+    connectToKDirWatch();
+#endif
+
+    (new RemoveInvalidThread())->start();
 }
 
 
@@ -67,9 +136,15 @@
 }
 
 
-void Nepomuk::FileWatch::moveFileMetadata( const QString& from, const QString& to )
+void Nepomuk::FileWatch::watchFolder( const QString& path )
 {
-    slotFileMoved( from, to );
+    kDebug() << path;
+#ifdef BUILD_KINOTIFY
+    if ( m_dirWatch && !m_dirWatch->watchingPath( path ) )
+        m_dirWatch->addWatch( path,
+                              KInotify::WatchEvents( KInotify::EventMove|KInotify::EventDelete|KInotify::EventDeleteSelf|KInotify::EventCreate ),
+                              KInotify::WatchFlags() );
+#endif
 }
 
 
@@ -102,4 +177,57 @@
     slotFilesDeleted( QStringList( urlString ) );
 }
 
+
+void Nepomuk::FileWatch::slotFileCreated( const QString& path )
+{
+    updateFolderViaStrigi( path );
+}
+
+
+void Nepomuk::FileWatch::slotFileModified( const QString& path )
+{
+    updateFolderViaStrigi( path );
+}
+
+
+void Nepomuk::FileWatch::slotMovedWithoutData( const QString& path )
+{
+    updateFolderViaStrigi( path );
+}
+
+
+// static
+void Nepomuk::FileWatch::updateFolderViaStrigi( const QString& path )
+{
+    //
+    // Tell Strigi service (if running) to update the newly created
+    // folder or the folder containing the newly created file
+    //
+    org::kde::nepomuk::Strigi strigi( "org.kde.nepomuk.services.nepomukstrigiservice", "/nepomukstrigiservice", QDBusConnection::sessionBus() );
+    if ( strigi.isValid() ) {
+        strigi.updateFolder( path, false /* no forced update */ );
+    }
+}
+
+
+void Nepomuk::FileWatch::connectToKDirWatch()
+{
+    // monitor KIO for changes
+    QDBusConnection::sessionBus().connect( QString(), QString(), "org.kde.KDirNotify", "FileMoved",
+                                           this, SIGNAL( slotFileMoved( const QString&, const QString& ) ) );
+    QDBusConnection::sessionBus().connect( QString(), QString(), "org.kde.KDirNotify", "FilesRemoved",
+                                           this, SIGNAL( slotFilesDeleted( const QStringList& ) ) );
+}
+
+
+#ifdef BUILD_KINOTIFY
+void Nepomuk::FileWatch::slotInotifyWatchUserLimitReached()
+{
+    // we do it the brutal way for now hoping with new kernels and defaults this will never happen
+    delete m_dirWatch;
+    m_dirWatch = 0;
+    connectToKDirWatch();
+}
+#endif
+
 #include "nepomukfilewatch.moc"
Index: nepomuk/services/filewatch/metadatamover.cpp
===================================================================
--- nepomuk/services/filewatch/metadatamover.cpp	(révision 1121160)
+++ nepomuk/services/filewatch/metadatamover.cpp	(copie de travail)
@@ -1,5 +1,5 @@
 /* This file is part of the KDE Project
-   Copyright (c) 2009 Sebastian Trueg <trueg@kde.org>
+   Copyright (c) 2009-2010 Sebastian Trueg <trueg@kde.org>
 
    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Library General Public
@@ -19,6 +19,7 @@
 #include "metadatamover.h"
 #include "nie.h"
 #include "nfo.h"
+#include "nepomukfilewatch.h"
 
 #include <QtCore/QDir>
 #include <QtCore/QRegExp>
@@ -30,6 +32,7 @@
 #include <Soprano/Node>
 #include <Soprano/NodeIterator>
 #include <Soprano/QueryResultIterator>
+#include <Soprano/LiteralValue>
 #include <Soprano/Vocabulary/Xesam>
 
 #include <Nepomuk/Resource>
@@ -39,6 +42,7 @@
 #include <Nepomuk/Query/Query>
 #include <Nepomuk/Query/ComparisonTerm>
 #include <Nepomuk/Query/ResourceTerm>
+#include <Nepomuk/Query/LiteralTerm>
 
 #include <KDebug>
 
@@ -70,6 +74,7 @@
 
 void Nepomuk::MetadataMover::moveFileMetadata( const KUrl& from, const KUrl& to )
 {
+    kDebug() << from << to;
     m_queueMutex.lock();
     UpdateRequest req( from, to );
     if ( !m_updateQueue.contains( req ) &&
@@ -82,18 +87,13 @@
 
 void Nepomuk::MetadataMover::removeFileMetadata( const KUrl& file )
 {
-    m_queueMutex.lock();
-    UpdateRequest req( file );
-    if ( !m_updateQueue.contains( req ) &&
-         !m_recentlyFinishedRequests.contains( req ) )
-        m_updateQueue.enqueue( req );
-    m_queueMutex.unlock();
-    m_queueWaiter.wakeAll();
+    removeFileMetadata( KUrl::List() << file );
 }
 
 
 void Nepomuk::MetadataMover::removeFileMetadata( const KUrl::List& files )
 {
+    kDebug() << files;
     m_queueMutex.lock();
     foreach( const KUrl& file, files ) {
         UpdateRequest req( file );
@@ -189,7 +189,7 @@
 }
 
 
-void Nepomuk::MetadataMover::updateMetadata( const KUrl& from, const KUrl& to )
+void Nepomuk::MetadataMover::updateMetadata( const KUrl& from, const KUrl& to, bool includeChildren )
 {
     kDebug() << from << "->" << to;
 
@@ -206,8 +206,8 @@
     Resource oldResource( from );
 
     if ( oldResource.exists() ) {
-        QUrl oldResourceUri = oldResource.resourceUri();
-        QUrl newResourceUri = oldResourceUri;
+        const QUrl oldResourceUri = oldResource.resourceUri();
+        QUrl newResourceUri( oldResourceUri );
 
         //
         // Handle legacy file:/ resource URIs
@@ -217,31 +216,110 @@
             newResourceUri = updateLegacyMetadata( oldResourceUri );
         }
 
-
         //
-        // Now update the nie:url and nie:isPartOf relations
+        // Now update the nie:url, nfo:fileName, and nie:isPartOf relations.
         //
-        Resource newResource( newResourceUri );
-        newResource.setProperty( Nepomuk::Vocabulary::NIE::url(), to );
-        if ( newResource.hasProperty( Nepomuk::Vocabulary::NFO::fileName() ) )
-            newResource.setProperty( Nepomuk::Vocabulary::NFO::fileName(), to.fileName() );
-        Resource newParent( to.directory( KUrl::IgnoreTrailingSlash ) );
-        if ( newParent.exists() ) {
-            newResource.setProperty( Nepomuk::Vocabulary::NIE::isPartOf(), newParent );
-        }
+        // We do NOT use Resource::setProperty to avoid the overhead and data clutter of creating
+        // new metadata graphs for the changed data.
+        //
+        // TODO: put this into a nice API which can act as the low-level version of Nepomuk::Resource
+        //
+        QString query = QString::fromLatin1( "select distinct ?g ?u ?f ?p where { "
+                                             "graph ?g { %1 ?prop ?obj . "
+                                             "OPTIONAL { %1 %2 ?u . } . "
+                                             "OPTIONAL { %1 %3 ?f . } . "
+                                             "OPTIONAL { %1 %4 ?p . } . "
+                                             "} . "
+                                             "FILTER(BOUND(?u) || BOUND(?f) || BOUND(?p)) . }" )
+                        .arg( Soprano::Node::resourceToN3( newResourceUri ),
+                              Soprano::Node::resourceToN3( Nepomuk::Vocabulary::NIE::url() ),
+                              Soprano::Node::resourceToN3( Nepomuk::Vocabulary::NFO::fileName() ),
+                              Soprano::Node::resourceToN3( Nepomuk::Vocabulary::NIE::isPartOf() ) );
+        QList<Soprano::BindingSet> graphs
+            = m_model->executeQuery( query, Soprano::Query::QueryLanguageSparql ).allBindings();
 
+        Q_FOREACH( const Soprano::BindingSet& graph, graphs ) {
+
+            if ( graph["u"].isValid() ) {
+                m_model->removeStatement( newResourceUri,
+                                          Nepomuk::Vocabulary::NIE::url(),
+                                          graph["u"],
+                                          graph["g"] );
+                m_model->addStatement( newResourceUri,
+                                       Nepomuk::Vocabulary::NIE::url(),
+                                       to,
+                                       graph["g"] );
+            }
+
+            if ( graph["f"].isValid() ) {
+                m_model->removeStatement( newResourceUri,
+                                          Nepomuk::Vocabulary::NFO::fileName(),
+                                          graph["f"],
+                                          graph["g"] );
+                m_model->addStatement( newResourceUri,
+                                       Nepomuk::Vocabulary::NFO::fileName(),
+                                       Soprano::LiteralValue( to.fileName() ),
+                                       graph["g"] );
+            }
+
+            if ( graph["p"].isValid() ) {
+                m_model->removeStatement( newResourceUri,
+                                          Nepomuk::Vocabulary::NIE::isPartOf(),
+                                          graph["p"],
+                                          graph["g"] );
+                Resource newParent( to.directory( KUrl::IgnoreTrailingSlash ) );
+                if ( newParent.exists() ) {
+                    m_model->addStatement( newResourceUri,
+                                           Nepomuk::Vocabulary::NIE::isPartOf(),
+                                           newParent.resourceUri(),
+                                           graph["g"] );
+                }
+            }
+        }
+    }
+    else {
+        //
+        // If we have no metadata yet we need to tell strigi (if running) so it can
+        // create the metadata in case the target folder is configured to be indexed.
+        //
+        emit movedWithoutData( to.directory( KUrl::IgnoreTrailingSlash ) );
+    }
+ 
+    if ( includeChildren && QFileInfo( to.toLocalFile() ).isDir() ) {
         //
         // Recursively update children
+        // We cannot use the nie:isPartOf relation since only children could have metadata. Thus, we do a regex
+        // match on all files and folders below the URL we got.
         //
-        Query::Query query( Query::ComparisonTerm( Nepomuk::Vocabulary::NIE::isPartOf(), Query::ResourceTerm( newResource ) ) );
-        query.addRequestProperty( Query::Query::RequestProperty( Nepomuk::Vocabulary::NIE::url() ) );
-        Soprano::QueryResultIterator it = m_model->executeQuery( query.toSparqlQuery(), Soprano::Query::QueryLanguageSparql );
+        // CAUTION: The trailing slash on the from URL is essential! Otherwise we might match the newly added
+        //          URLs, too (in case a rename only added chars to the name)
+        //
+        QString query = QString::fromLatin1( "select distinct ?r ?url where { "
+                                             "?r %1 ?url . "
+                                             "FILTER(REGEX(STR(?url),'^%2')) . "
+                                             "}" )
+                        .arg( Soprano::Node::resourceToN3( Nepomuk::Vocabulary::NIE::url() ),
+                              from.url(KUrl::AddTrailingSlash) );
+        kDebug() << query;
+
+        const QString oldBasePath = from.path( KUrl::AddTrailingSlash );
+        const QString newBasePath = to.path( KUrl::AddTrailingSlash );
+
+        Soprano::QueryResultIterator it = m_model->executeQuery( query, Soprano::Query::QueryLanguageSparql );
         while ( it.next() ) {
-            QUrl uri = it[0].uri();
-            KUrl url = it[1].uri();
-            KUrl newUrl( to );
-            newUrl.addPath( url.fileName() );
-            updateMetadata( url, newUrl );
+
+            // the resource URI of the resource to update
+            const QUrl uri = it[0].uri();
+
+            // the old URL of the resource to update
+            const KUrl url = it[1].uri();
+
+            // now construct the new URL
+            QString oldRelativePath = url.path().mid( oldBasePath.length() );
+            KUrl newUrl( newBasePath + oldRelativePath );
+
+            // finally update the metadata (excluding children since we already handle them all here)
+            updateMetadata( url, newUrl, false );
         }
     }
 }
@@ -256,9 +337,9 @@
     //
     // update the resource properties
     //
-    QList<Soprano::Statement> sl = m_model->listStatements( Soprano::Statement( oldResourceUri,
-                                                                                Soprano::Node(),
-                                                                                Soprano::Node() ) ).allStatements();
+    QList<Soprano::Statement> sl = m_model->listStatements( oldResourceUri,
+                                                            Soprano::Node(),
+                                                            Soprano::Node() ).allStatements();
     Q_FOREACH( const Soprano::Statement& s, sl ) {
         //
         // Skip all the stuff we will update later on
@@ -270,10 +351,10 @@
             continue;
         }
 
-        m_model->addStatement( Soprano::Statement( newResourceUri,
-                                                   s.predicate(),
-                                                   s.object(),
-                                                   s.context() ) );
+        m_model->addStatement( newResourceUri,
+                               s.predicate(),
+                               s.object(),
+                               s.context() );
     }
 
     m_model->removeStatements( sl );
Index: nepomuk/services/filewatch/nepomukfilewatch.h
===================================================================
--- nepomuk/services/filewatch/nepomukfilewatch.h	(révision 1121160)
+++ nepomuk/services/filewatch/nepomukfilewatch.h	(copie de travail)
@@ -1,5 +1,5 @@
 /* This file is part of the KDE Project
-   Copyright (c) 2007-2008 Sebastian Trueg <trueg@kde.org>
+   Copyright (c) 2007-2010 Sebastian Trueg <trueg@kde.org>
 
    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Library General Public
@@ -31,9 +31,7 @@
     }
 }
 
-namespace KInotify {
-    class DirWatch;
-}
+class KInotify;
 
 class KUrl;
 
@@ -50,19 +48,32 @@
         FileWatch( QObject* parent, const QVariantList& );
         ~FileWatch();
 
+        /**
+         * Tells strigi to update the folder at \p path or the folder
+         * containing \p path in case it is a file.
+         */
+        static void updateFolderViaStrigi( const QString& path );
+
     public Q_SLOTS:
-        Q_SCRIPTABLE void moveFileMetadata( const QString& from, const QString& to );
+        Q_SCRIPTABLE void watchFolder( const QString& path );
 
     private Q_SLOTS:
         void slotFileMoved( const QString& from, const QString& to );
         void slotFileDeleted( const QString& path );
         void slotFilesDeleted( const QStringList& path );
+        void slotFileCreated( const QString& );
+        void slotFileModified( const QString& );
+        void slotMovedWithoutData( const QString& );
+        void connectToKDirWatch();
+#ifdef BUILD_KINOTIFY
+        void slotInotifyWatchUserLimitReached();
+#endif
 
     private:
         MetadataMover* m_metadataMover;
 
-#ifndef Q_WS_WIN
-        KInotify::DirWatch* m_dirWatch;
+#ifdef BUILD_KINOTIFY
+        KInotify* m_dirWatch;
 #endif
     };
 }
Index: nepomuk/services/filewatch/CMakeLists.txt
===================================================================
--- nepomuk/services/filewatch/CMakeLists.txt	(révision 1121160)
+++ nepomuk/services/filewatch/CMakeLists.txt	(copie de travail)
@@ -16,8 +16,19 @@
   nepomukfilewatch.cpp
   metadatamover.cpp
   updaterequest.cpp
+  ../strigi/priority.cpp
   )
 
+qt4_add_dbus_interface(SRCS ../../interfaces/org.kde.nepomuk.Strigi.xml strigiserviceinterface)
+
+if(CMAKE_SYSTEM_NAME MATCHES "Linux")
+  set(SRCS
+    ${SRCS}
+    kinotify.cpp
+)
+add_definitions(-DBUILD_KINOTIFY)
+endif(CMAKE_SYSTEM_NAME MATCHES "Linux")
+
 soprano_add_ontology(SRCS
   ${SHAREDDESKTOPONTOLOGIES_ROOT_DIR}/nie/nie.trig
   "NIE"
Index: nepomuk/services/filewatch/nepomukfilewatch.desktop
===================================================================
--- nepomuk/services/filewatch/nepomukfilewatch.desktop	(révision 1121160)
+++ nepomuk/services/filewatch/nepomukfilewatch.desktop	(copie de travail)
@@ -34,6 +34,7 @@
 Name[hr]=Nepomuk nadgledanje datoteka
 Name[hsb]=NepomukFileWatch
 Name[hu]=NepomukFileWatch
+Name[ia]=NepomukFileWatch
 Name[id]=Pengawas Berkas Nepomuk
 Name[is]=Nepomuk skráavörður
 Name[it]=Sorveglianza dei file di Nepomuk
@@ -106,6 +107,7 @@
 Comment[hr]=Nepomukova usluga nadgledanja datoteka za otkrivanje promjena nad istima
 Comment[hsb]=Nepomukowe wobkedźbowanje datajow za zwěsćenje změnow
 Comment[hu]=Nepomuk fájlfigyelő szolgáltatás fájlváltozások követéséhez
+Comment[ia]=Servicio de guarda de file Nepomuk pro monitorar variationes de file
 Comment[id]=Layanan pengawas berkas Nepomuk untuk memonitor perubahan pada berkas
 Comment[is]=Nepomuk skráavarslan fylgist með breytingum á skrám
 Comment[it]=Il servizio di sorveglianza di Nepomuk per monitorare i cambiamenti dei file
@@ -140,7 +142,7 @@
 Comment[sv]=Nepomuks filövervakningstjänst för att bevaka filändringar
 Comment[ta]=The Nepomuk file watch service for monitoring file changes
 Comment[te]=ఫైల్ మార్పులను మానిటరింగ్ చేయుటకొరకు Nepomuk ఫైల్ వాచ్ సేవ
-Comment[tg]=Служба Nepomuk file watch контролирует изменения в файлах
+Comment[tg]=Системаи Nepomuk тағйиротҳоро дар файлҳо муайян мекунад
 Comment[th]=บริการของ Nepomuk สำหรับคอยตรวจจับความเปลี่ยนแปลงของแฟ้ม
 Comment[tr]=Dosya değişikliklerini izlemek için Nepomuk dosya izleme servisi
 Comment[uk]=Служба Nepomuk для спостереження за змінами в файлах
Index: nepomuk/services/filewatch/kinotify.cpp
===================================================================
--- nepomuk/services/filewatch/kinotify.cpp	(révision 0)
+++ nepomuk/services/filewatch/kinotify.cpp	(révision 0)
@@ -0,0 +1,403 @@
+/* This file is part of the KDE libraries
+   Copyright (C) 2007-2010 Sebastian Trueg <trueg@kde.org>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public License
+   along with this library; see the file COPYING.LIB.  If not, write to
+   the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.
+*/
+
+#include "kinotify.h"
+
+#include <QtCore/QSocketNotifier>
+#include <QtCore/QHash>
+#include <QtCore/QDirIterator>
+#include <QtCore/QFile>
+#include <QtCore/QQueue>
+
+#include <kdebug.h>
+
+#include <sys/inotify.h>
+#include <sys/utsname.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <dirent.h>
+
+
+namespace {
+    const int EVENT_STRUCT_SIZE = sizeof( struct inotify_event );
+
+    // we need one event to fit into the buffer, the problem is that the name
+    // is a variable length array
+    const int EVENT_BUFFER_SIZE = EVENT_STRUCT_SIZE + 1024*16;
+
+    QByteArray normalizePath( const QByteArray& path ) {
+        QByteArray p( path );
+        if ( p.endsWith( '/' ) )
+            p.truncate( p.length()-1 );
+        return p;
+    }
+}
+
+class KInotify::Private
+{
+public:
+    Private( KInotify* parent )
+        : watchHiddenFolders( true ),
+          m_inotifyFd( -1 ),
+          m_notifier( 0 ),
+          q( parent) {
+    }
+
+    ~Private() {
+        close();
+    }
+
+    QHash<int, QString> cookies;
+    QHash<int, QByteArray> pathHash;
+
+    /// queue of paths to install watches for
+    QQueue<QByteArray> pathsToWatch;
+
+    unsigned char eventBuffer[EVENT_BUFFER_SIZE];
+
+    // FIXME: only stored from the last addWatch call
+    WatchEvents mode;
+    WatchFlags flags;
+
+    bool watchHiddenFolders;
+
+    int inotify() {
+        if ( m_inotifyFd < 0 ) {
+            open();
+        }
+        return m_inotifyFd;
+    }
+
+    void close() {
+        kDebug();
+        delete m_notifier;
+        m_notifier = 0;
+
+        ::close( m_inotifyFd );
+        m_inotifyFd = -1;
+    }
+
+    bool addWatch( const QByteArray& path ) {
+        // we always need the unmount event to maintain our path hash
+        const int mask = mode|flags|EventUnmount;
+
+        int wd = inotify_add_watch( inotify(), path.data(), mask );
+        if ( wd > 0 ) {
+//            kDebug() << "Successfully added watch for" << path << pathHash.count();
+            pathHash.insert( wd, normalizePath( path ) );
+            return true;
+        }
+        else {
+            kDebug() << "Failed to create watch for" << path;
+            static bool userLimitReachedSignaled = false;
+            if ( !userLimitReachedSignaled && errno == ENOSPC ) {
+                kDebug() << "User limit reached. Please raise the inotify user watch limit.";
+                userLimitReachedSignaled = true;
+                emit q->watchUserLimitReached();
+            }
+            return false;
+        }
+    }
+
+    bool addWatchesRecursively( const QByteArray& path )
+    {
+        if ( !addWatch( path ) )
+            return false;
+
+        int len = offsetof(struct dirent, d_name) +
+                  pathconf(path.data(), _PC_NAME_MAX) + 1;
+        struct dirent* entry = ( struct dirent* )new char[len];
+
+        DIR* dir = opendir( path.data() );
+        if ( dir ) {
+            struct dirent *result = 0;
+            while ( !readdir_r( dir, entry, &result ) ) {
+
+                if ( !result ) {
+                    // end of folder
+                    break;
+                }
+
+                if ( ( entry->d_type == DT_UNKNOWN ||
+                       entry->d_type == DT_DIR ) &&
+                     ( watchHiddenFolders ||
+                       qstrncmp( entry->d_name, ".", 1 ) ) &&
+                     qstrcmp( entry->d_name, "." ) &&
+                     qstrcmp( entry->d_name, ".." ) ) {
+                    bool isDir = true;
+                    QByteArray subDir = path + '/' + QByteArray::fromRawData( entry->d_name, qstrlen( entry->d_name ) );
+                    if ( entry->d_type == DT_UNKNOWN ) {
+                        struct stat buf;
+                        lstat( subDir.data(), &buf );
+                        isDir = S_ISDIR( buf.st_mode );
+                    }
+
+                    if ( isDir ) {
+                        pathsToWatch.enqueue( subDir );
+                    }
+                }
+            }
+
+            closedir( dir );
+            delete [] entry;
+
+            return true;
+        }
+        else {
+            kDebug() << "Could not open dir" << path;
+            return false;
+        }
+    }
+
+    void removeWatch( int wd ) {
+        pathHash.remove( wd );
+        inotify_rm_watch( inotify(), wd );
+    }
+
+    void _k_addWatches() {
+        // add the next batch of paths
+        for ( int i = 0; i < 100; ++i ) {
+            if ( pathsToWatch.isEmpty() ||
+                 !addWatchesRecursively( pathsToWatch.dequeue() ) ) {
+                return;
+            }
+        }
+
+        // asyncroneously add the next batch
+        if ( !pathsToWatch.isEmpty() ) {
+            QMetaObject::invokeMethod( q, "_k_addWatches", Qt::QueuedConnection );
+        }
+    }
+
+private:
+    void open() {
+        kDebug();
+        m_inotifyFd = inotify_init();
+        delete m_notifier;
+        if ( m_inotifyFd > 0 ) {
+            fcntl( m_inotifyFd, F_SETFD, FD_CLOEXEC );
+            kDebug() << "Successfully opened connection to inotify:" << m_inotifyFd;
+            m_notifier = new QSocketNotifier( m_inotifyFd, QSocketNotifier::Read );
+            connect( m_notifier, SIGNAL( activated( int ) ), q, SLOT( slotEvent( int ) ) );
+        }
+    }
+
+    int m_inotifyFd;
+    QSocketNotifier* m_notifier;
+
+    KInotify* q;
+};
+
+
+KInotify::KInotify( QObject* parent )
+    : QObject( parent ),
+      d( new Private( this ) )
+{
+}
+
+
+KInotify::~KInotify()
+{
+    delete d;
+}
+
+
+bool KInotify::available() const
+{
+    if( d->inotify() > 0 ) {
+        // trueg: Copied from KDirWatch.
+        struct utsname uts;
+        int major, minor, patch;
+        if ( uname(&uts) < 0 ) {
+            return false; // *shrug*
+        }
+        else if ( sscanf( uts.release, "%d.%d.%d", &major, &minor, &patch) != 3 ) {
+            return false; // *shrug*
+        }
+        else if( major * 1000000 + minor * 1000 + patch < 2006014 ) { // <2.6.14
+            kDebug(7001) << "Can't use INotify, Linux kernel too old";
+            return false;
+        }
+
+        return true;
+    }
+    else {
+        return false;
+    }
+}
+
+
+bool KInotify::watchingPath( const QString& path ) const
+{
+    QByteArray p( normalizePath( QFile::encodeName( path ) ) );
+    QHash<int, QByteArray>::const_iterator end = d->pathHash.constEnd();
+    for ( QHash<int, QByteArray>::const_iterator it = d->pathHash.constBegin();
+          it != end; ++it ) {
+        if ( it.value() == p )
+            return true;
+    }
+    return false;
+}
+
+
+bool KInotify::addWatch( const QString& path, WatchEvents mode, WatchFlags flags )
+{
+    kDebug() << path;
+
+    d->mode = mode;
+    d->flags = flags;
+    d->pathsToWatch.append( QFile::encodeName( path ) );
+    d->_k_addWatches();
+    return true;
+}
+
+
+// TODO: do this more efficiently
+bool KInotify::removeWatch( const QString& path )
+{
+    QByteArray encodedPath = QFile::encodeName( path );
+    QHash<int, QByteArray>::iterator it = d->pathHash.begin();
+    while ( it != d->pathHash.end() ) {
+        if ( it.value().startsWith( encodedPath ) ) {
+            inotify_rm_watch( d->inotify(), it.key() );
+            it = d->pathHash.erase( it );
+        }
+        else {
+            ++it;
+        }
+    }
+    return true;
+}
+
+
+void KInotify::slotEvent( int socket )
+{
+    // read at least one event
+    int len = read( socket, d->eventBuffer, EVENT_BUFFER_SIZE );
+    int i = 0;
+    while ( i < len && len-i >= EVENT_STRUCT_SIZE  ) {
+        struct inotify_event* event = ( struct inotify_event* )&d->eventBuffer[i];
+
+        QByteArray encodedPath = QByteArray::fromRawData( event->name, event->len );
+
+        kDebug() << encodedPath;
+
+        if ( encodedPath[0] != '/' ) {
+            encodedPath = d->pathHash.value( event->wd ) + '/' + encodedPath;
+        }
+
+        QString path = QFile::decodeName( encodedPath );
+
+        kDebug() << path;
+
+
+        // now signal the event
+        if ( event->mask & EventAccess) {
+            kDebug() << path << "EventAccess";
+            emit accessed( path );
+        }
+        if ( event->mask & EventAttributeChange ) {
+            kDebug() << path << "EventAttributeChange";
+            emit attributeChanged( path );
+        }
+        if ( event->mask & EventCloseWrite ) {
+            kDebug() << path << "EventCloseWrite";
+            emit closedWrite( path );
+        }
+        if ( event->mask & EventCloseRead ) {
+            kDebug() << path << "EventCloseRead";
+            emit closedRead( path );
+        }
+        if ( event->mask & EventCreate ) {
+            kDebug() << path << "EventCreate";
+            if ( event->mask & IN_ISDIR ) {
+                // FIXME: store the mode and flags somewhere
+                addWatch( encodedPath, d->mode, d->flags );
+            }
+            emit created( path );
+        }
+        if ( event->mask & EventDelete ) {
+            kDebug() << path << "EventDelete";
+            if ( event->mask & IN_ISDIR ) {
+                d->removeWatch( event->wd );
+            }
+            emit deleted( path );
+        }
+        if ( event->mask & EventDeleteSelf ) {
+            kDebug() << path << "EventDeleteSelf";
+            if ( event->mask & IN_ISDIR ) {
+                d->removeWatch( event->wd );
+            }
+            emit deleted( path );
+        }
+        if ( event->mask & EventModify ) {
+            kDebug() << path << "EventModify";
+            emit modified( path );
+        }
+        if ( event->mask & EventMoveSelf ) {
+            kDebug() << path << "EventMoveSelf";
+        }
+        if ( event->mask & EventMoveFrom ) {
+            kDebug() << path << "EventMoveFrom";
+            d->cookies[event->cookie] = path;
+        }
+        if ( event->mask & EventMoveTo ) {
+            // check if we have a cookie for this one
+            if ( d->cookies.contains( event->cookie ) ) {
+                QString oldPath = d->cookies[event->cookie];
+                d->cookies.remove( event->cookie );
+                kDebug() << oldPath << "EventMoveTo" << path;
+                emit moved( oldPath, path );
+            }
+            else {
+                kDebug() << "No cookie for move information of" << path;
+            }
+        }
+        if ( event->mask & EventOpen ) {
+            kDebug() << path << "EventOpen";
+            emit opened( path );
+        }
+        if ( event->mask & EventUnmount ) {
+            kDebug() << path << "EventUnmount. removing from path hash";
+            if ( event->mask & IN_ISDIR ) {
+                d->removeWatch( event->wd );
+            }
+            emit unmounted( path );
+        }
+        if ( event->mask & EventQueueOverflow ) {
+            // This should not happen since we grab all events as soon as they arrive
+            kDebug() << path << "EventQueueOverflow";
+//            emit queueOverflow();
+        }
+        if ( event->mask & EventIgnored ) {
+            kDebug() << path << "EventIgnored";
+        }
+
+        i += EVENT_STRUCT_SIZE + event->len;
+    }
+
+    if ( len < 0 ) {
+        kDebug() << "Failed to read event.";
+    }
+}
+
+#include "kinotify.moc"

Modification de propriétés sur nepomuk/services/filewatch/kinotify.cpp
___________________________________________________________________
Ajouté : svn:eol-style
   + native

Index: nepomuk/services/queryservice/folder.h
===================================================================
--- nepomuk/services/queryservice/folder.h	(révision 1121160)
+++ nepomuk/services/queryservice/folder.h	(copie de travail)
@@ -63,6 +63,8 @@
 
             QList<FolderConnection*> openConnections() const;
 
+            QString query() const { return m_query; }
+
         public Q_SLOTS:
             void update();
 
Index: nepomuk/services/queryservice/folderconnection.h
===================================================================
--- nepomuk/services/queryservice/folderconnection.h	(révision 1121160)
+++ nepomuk/services/queryservice/folderconnection.h	(copie de travail)
@@ -48,6 +48,13 @@
             /// close the connection to the folder. Will delete this connection
             void close();
 
+            /// \return \p true if the initial listing has been finished and the finishedListing()
+            /// has been emitted
+            bool isListingFinished() const;
+
+            /// \return the SPARQL query of the folder
+            QString queryString() const;
+
         Q_SIGNALS:
             void newEntries( const QList<Nepomuk::Query::Result>& );
             void entriesRemoved( const QStringList& );
Index: nepomuk/services/queryservice/searchthread.h
===================================================================
--- nepomuk/services/queryservice/searchthread.h	(révision 1121160)
+++ nepomuk/services/queryservice/searchthread.h	(copie de travail)
@@ -59,8 +59,8 @@
             void run();
 
         private:
-            void sparqlQuery( const QString& query, double baseScore );
-            Nepomuk::Query::Result extractResult( const Soprano::QueryResultIterator& it ) const;
+            void sparqlQuery( const QString& query );
+            Nepomuk::Query::Result extractResult( const Resource& resultResource, const Soprano::QueryResultIterator& it ) const;
 
             QString m_sparqlQuery;
             RequestPropertyMap m_requestProperties;
Index: nepomuk/services/queryservice/queryservice.cpp
===================================================================
--- nepomuk/services/queryservice/queryservice.cpp	(révision 1121160)
+++ nepomuk/services/queryservice/queryservice.cpp	(copie de travail)
@@ -26,6 +26,7 @@
 #include <QtDBus/QDBusConnectionInterface>
 #include <QtDBus/QDBusObjectPath>
 #include <QtDBus/QDBusMessage>
+#include <QtDBus/QDBusServiceWatcher>
 
 #include <KPluginFactory>
 #include <KUrl>
@@ -50,10 +51,12 @@
 
     s_instance = this;
 
-    connect( QDBusConnection::sessionBus().interface(),
-             SIGNAL( serviceOwnerChanged( const QString&, const QString&, const QString& ) ),
-             this,
-             SLOT( slotServiceOwnerChanged( const QString&, const QString&, const QString& ) ) );
+    m_serviceWatcher = new QDBusServiceWatcher( QString(),
+                                                QDBusConnection::sessionBus(),
+                                                QDBusServiceWatcher::WatchForUnregistration, this);
+
+    connect( m_serviceWatcher, SIGNAL( serviceUnregistered(const QString& ) ),
+             this, SLOT( slotServiceUnregistered( const QString& ) ) );
 }
 
 
@@ -102,6 +105,7 @@
     QString dbusClient = msg.service();
     m_openConnections.insert( dbusClient, conn );
     m_connectionDBusServiceHash.insert( conn, dbusClient );
+    m_serviceWatcher->addWatchedService( dbusClient );
 
     return QDBusObjectPath( dbusObjectPath );
 }
@@ -155,18 +159,15 @@
 }
 
 
-void Nepomuk::Query::QueryService::slotServiceOwnerChanged( const QString& serviceName,
-                                                            const QString&,
-                                                            const QString& newOwner )
+void Nepomuk::Query::QueryService::slotServiceUnregistered( const QString& serviceName )
 {
-    if ( newOwner.isEmpty() ) {
-        QList<FolderConnection*> conns = m_openConnections.values( serviceName );
-        if ( !conns.isEmpty() ) {
-            kDebug() << "Service" << serviceName << "went down. Removing connections";
-            // hash cleanup will be triggered automatically
-            qDeleteAll( conns );
-        }
+    QList<FolderConnection*> conns = m_openConnections.values( serviceName );
+    if ( !conns.isEmpty() ) {
+        kDebug() << "Service" << serviceName << "went down. Removing connections";
+        // hash cleanup will be triggered automatically
+        qDeleteAll( conns );
     }
+    m_serviceWatcher->removeWatchedService(serviceName);
 }
 
 #include "queryservice.moc"
Index: nepomuk/services/queryservice/folderconnection.cpp
===================================================================
--- nepomuk/services/queryservice/folderconnection.cpp	(révision 1121160)
+++ nepomuk/services/queryservice/folderconnection.cpp	(copie de travail)
@@ -115,4 +115,16 @@
     deleteLater();
 }
 
+
+bool Nepomuk::Query::FolderConnection::isListingFinished() const
+{
+    return m_folder->initialListingDone();
+}
+
+
+QString Nepomuk::Query::FolderConnection::queryString() const
+{
+    return m_folder->query();
+}
+
 #include "folderconnection.moc"
Index: nepomuk/services/queryservice/queryservice.h
===================================================================
--- nepomuk/services/queryservice/queryservice.h	(révision 1121160)
+++ nepomuk/services/queryservice/queryservice.h	(copie de travail)
@@ -30,6 +30,7 @@
 
 class QDBusObjectPath;
 class QDBusMessage;
+class QDBusServiceWatcher;
 
 namespace Nepomuk {
     namespace Query {
@@ -62,9 +63,7 @@
             Q_SCRIPTABLE QDBusObjectPath sparqlQuery( const QString& query, const RequestPropertyMapDBus& requestProps, const QDBusMessage& msg );
 
         private Q_SLOTS:
-            void slotServiceOwnerChanged( const QString& serviceName,
-                                          const QString&,
-                                          const QString& newOwner );
+            void slotServiceUnregistered( const QString& serviceName );
             void slotFolderDestroyed( QObject* folder );
             void slotFolderConnectionDestroyed( QObject* conn );
 
@@ -82,6 +81,7 @@
             QHash<FolderConnection*, QString> m_connectionDBusServiceHash; // maps connections to their using dbus service
 
             int m_folderConnectionCnt; // only used for unique dbus object path generation
+            QDBusServiceWatcher *m_serviceWatcher;
         };
     }
 }
Index: nepomuk/services/queryservice/nepomukqueryservice.desktop
===================================================================
--- nepomuk/services/queryservice/nepomukqueryservice.desktop	(révision 1121160)
+++ nepomuk/services/queryservice/nepomukqueryservice.desktop	(copie de travail)
@@ -34,6 +34,7 @@
 Name[hr]=Nepomuk Upitna Usluga
 Name[hsb]=NepomukQueryService
 Name[hu]=Nepomuk-lekérdezés
+Name[ia]=NepomukQueryService
 Name[id]=NepomukQueryService
 Name[is]=Nepomuk fyrirspurnamiðlari
 Name[it]=Servizio di interrogazioni di Nepomuk
@@ -71,7 +72,7 @@
 Name[ta]=NepomukQueryService
 Name[tg]=Хидматҳои Nepomuk
 Name[th]=NepomukQueryService
-Name[tr]=Nepomuk Sorgulama Servisi
+Name[tr]=NepomukQueryService
 Name[uk]=NepomukQueryService
 Name[wa]=SierviceCweraedjeNepomuk
 Name[x-test]=xxNepomukQueryServicexx
@@ -101,9 +102,11 @@
 Comment[hr]=Nepomuk Upitna Usluga pruža sučelje za trajne upitne direktorije
 Comment[hsb]=Nepomukowa naprašowanska słužba staji intefejs za persistentne naprašowanske zapiski k dispoziciji.
 Comment[hu]=A Nepomuk lekérdező szolgáltatás keresőmappákhoz nyújt felületet
+Comment[ia]=Le Nepomuk Query Service forni un interface pro classificatores persistente de demanda
 Comment[id]=Layanan Tanya Nepomuk menyediakan antarmuka untuk folder pertanyaan yang kukuh
 Comment[is]=Nepomuk fyrirspurnamiðlarinn er viðmót fyrir viðvarandi fyrirspurnamöppur (persistent query folders)
 Comment[it]=Il servizio di interrogazione di Nepomuk fornisce un'interfaccia per cartelle di interrogazione persistenti
+Comment[ja]=Nepomuk クエリサービスは永続クエリフォルダのインターフェースを提供します
 Comment[kk]=Nepomuk сұраныс қызметі тұрақты сұраныс қапшытарына интерфейсті қамтамасыз етеді
 Comment[km]=សេវា​សំណួរ Nepomuk ផ្ដល់​នូវ​ចំណុច​ប្រទាក់​សម្រាប់​ថត​សំណួរ​ជាប់លាប់
 Comment[kn]=ಅವಿಚ್ಛಿನ್ನ ವಿಚಾರಣಾ (ಪರ್ಸಿಸ್ಟೆಂಟ್ ಕ್ವೆರಿ) ಕಡತಕೋಶಗಳಿಗೆ ನೆಪೋಮುಕ್ ವಿಚಾರಣಾ ಸೇವೆ ಒಂದು ಸಂಪರ್ಕತಟವನ್ನು (ಇಂಟರ್ಫೇಸ್) ನೀಡುತ್ತದೆ
@@ -135,7 +138,7 @@
 Comment[ta]=The Nepomuk Query Service provides an interface for persistent query folders
 Comment[te]=నెపోమక్ క్వరీ సేవ అనునది ఎప్పుడూవుండే క్వరీ ఫోల్డర్సుకు ఇంటర్ఫేస్‌ను అందిస్తుంది
 Comment[th]=บริการสืบค้น Nepomuk เป็นส่วนติดต่อสำหรับโฟลเดอร์สืบค้นข้อมูลถาวร
-Comment[tr]=Nepomuk Sorgulama Servisi kalıcı sorgu dizinleri için bir arayüz sağlar
+Comment[tr]=Nepomuk Sorgulama Hizmeti kalıcı sorgu dizinleri için bir arayüz sağlar
 Comment[uk]=Служба запитів Nepomuk надає інтерфейс для постійних тек запитів
 Comment[wa]=Li siervice di cweraedje di Nepomuk dene èn eterface po des ridants d' cweraedje wårdés
 Comment[x-test]=xxThe Nepomuk Query Service provides an interface for persistent query foldersxx
Index: nepomuk/services/queryservice/searchthread.cpp
===================================================================
--- nepomuk/services/queryservice/searchthread.cpp	(révision 1121160)
+++ nepomuk/services/queryservice/searchthread.cpp	(copie de travail)
@@ -46,8 +46,9 @@
 #include <KRandom>
 
 #include <QtCore/QTime>
-#include <QLatin1String>
-#include <QStringList>
+#include <QtCore/QRegExp>
+#include <QtCore/QLatin1String>
+#include <QtCore/QStringList>
 
 
 
@@ -105,19 +106,19 @@
     // created via the Nepomuk query API.
     //
     if ( m_sparqlQuery.endsWith( QLatin1String( "}" ) ) ) {
-        sparqlQuery( m_sparqlQuery + QLatin1String( " LIMIT 10" ), 1.0 );
+        sparqlQuery( m_sparqlQuery + QLatin1String( " LIMIT 10" ) );
         if ( !m_canceled && m_resultCnt >= 10 )
-            sparqlQuery( m_sparqlQuery + QLatin1String( " OFFSET 10" ), 1.0 );
+            sparqlQuery( m_sparqlQuery + QLatin1String( " OFFSET 10" ) );
     }
     else {
-        sparqlQuery( m_sparqlQuery, 1.0 );
+        sparqlQuery( m_sparqlQuery );
     }
 
     kDebug() << time.elapsed();
 }
 
 
-void Nepomuk::Query::SearchThread::sparqlQuery( const QString& query, double baseScore )
+void Nepomuk::Query::SearchThread::sparqlQuery( const QString& query )
 {
     kDebug() << query;
 
@@ -127,26 +128,49 @@
 
         ++m_resultCnt;
 
-        Result result = extractResult( hits );
-        result.setScore( baseScore );
+        Resource res = Resource::fromResourceUri( hits[0].uri() );
+        if ( !res.hasType( Soprano::Vocabulary::RDFS::Class() ) &&
+             !res.hasType( Soprano::Vocabulary::RDF::Property() ) &&
+             !res.hasType( Soprano::Vocabulary::NRL::Graph() ) ) {
+            Result result = extractResult( res, hits );
 
-        kDebug() << "Found result:" << result.resource().resourceUri();
+            kDebug() << "Found result:" << result.resource().resourceUri() << result.score();
 
-        emit newResult( result );
+            emit newResult( result );
+        }
     }
 }
 
 
-Nepomuk::Query::Result Nepomuk::Query::SearchThread::extractResult( const Soprano::QueryResultIterator& it ) const
+Nepomuk::Query::Result Nepomuk::Query::SearchThread::extractResult( const Resource& resultResource, const Soprano::QueryResultIterator& it ) const
 {
     kDebug() << it.binding( 0 ).uri();
-    Result result( it.binding( 0 ).uri() );
+    Result result( resultResource );
 
+    // make sure we do not store values twice
+    QStringList names = it.bindingNames();
+    names.removeAll( QLatin1String( "r" ) );
+
     for ( RequestPropertyMap::const_iterator rpIt = m_requestProperties.constBegin();
           rpIt != m_requestProperties.constEnd(); ++rpIt ) {
         result.addRequestProperty( rpIt.value(), it.binding( rpIt.key() ) );
+        names.removeAll( rpIt.key() );
     }
 
+    static const char* s_scoreVarName = "_n_f_t_m_s_";
+
+    Soprano::BindingSet set;
+    int score = 0;
+    Q_FOREACH( const QString& var, names ) {
+        if ( var == QLatin1String( s_scoreVarName ) )
+            score = it[var].literal().toInt();
+        else
+            set.insert( var, it[var] );
+    }
+
+    result.setAdditionalBindings( set );
+    result.setScore( ( double )score );
+
     // score will be set above
     return result;
 }
Index: nepomuk/services/migration1/nepomukmigration1.desktop
===================================================================
--- nepomuk/services/migration1/nepomukmigration1.desktop	(révision 1121160)
+++ nepomuk/services/migration1/nepomukmigration1.desktop	(copie de travail)
@@ -32,9 +32,11 @@
 Comment[hr]=Nepomuk Seoba Podataka Razina 1
 Comment[hsb]=Nepomuk migracija datow runina 1
 Comment[hu]=Nepomuk adatmigráció 1. szint
+Comment[ia]=Migration de Datos de Nepomuk de Nivello 1
 Comment[id]=Migrasi Data Nepomuk Level 1
 Comment[is]=Nepomuk gagnaflutningur, stig 1
 Comment[it]=Migrazione dei dati di Nepomuk di livello 1
+Comment[ja]=Nepomuk データ移行レベル 1
 Comment[kk]=Nepomuk деректерді көшіп ауыстыру - 1-деңгей
 Comment[km]=ការ​ប្ដូរ​ទិន្នន័យ Nepomuk កម្រិត ១
 Comment[kn]=ನೆಪೋಮುಕ್ ದತ್ತ ವಲಸೆ ಸ್ತರ ೧
Index: nepomuk/services/CMakeLists.txt
===================================================================
--- nepomuk/services/CMakeLists.txt	(révision 1121160)
+++ nepomuk/services/CMakeLists.txt	(copie de travail)
@@ -5,3 +5,5 @@
 add_subdirectory(queryservice)
 add_subdirectory(strigi)
 add_subdirectory(removablestorage)
+
+add_subdirectory(activities)
Index: nepomuk/server/servicecontroller.cpp
===================================================================
--- nepomuk/server/servicecontroller.cpp	(révision 1121160)
+++ nepomuk/server/servicecontroller.cpp	(copie de travail)
@@ -24,13 +24,15 @@
 #include <QtCore/QEventLoop>
 #include <QtCore/QTimer>
 
+#include <QtDBus/QDBusServiceWatcher>
+
 #include <KStandardDirs>
 #include <KConfigGroup>
 #include <KDebug>
 
 
 namespace {
-    QString dbusServiceName( const QString& serviceName ) {
+    inline QString dbusServiceName( const QString& serviceName ) {
         return QString("org.kde.nepomuk.services.%1").arg(serviceName);
     }
 }
@@ -42,6 +44,7 @@
     Private()
         : processControl( 0 ),
           serviceControlInterface( 0 ),
+          dbusServiceWatcher( 0 ),
           attached( false ),
           initialized( false ),
           failedToInitialize( false ) {
@@ -54,6 +57,7 @@
 
     ProcessControl* processControl;
     OrgKdeNepomukServiceControlInterface* serviceControlInterface;
+    QDBusServiceWatcher* dbusServiceWatcher;
 
     // true if we attached to an already running instance instead of
     // starting our own (in that case processControl will be 0)
@@ -158,12 +162,25 @@
     d->initialized = false;
     d->failedToInitialize = false;
 
+    if ( !d->dbusServiceWatcher ) {
+        d->dbusServiceWatcher = new QDBusServiceWatcher( dbusServiceName(name()),
+                                                         QDBusConnection::sessionBus(),
+                                                         QDBusServiceWatcher::WatchForRegistration | QDBusServiceWatcher::WatchForUnregistration,
+                                                         this );
+    }
+    d->dbusServiceWatcher->disconnect( this );
+
     // check if the service is already running, ie. has been started by someone else or by a crashed instance of the server
     // we cannot rely on the auto-restart feature of ProcessControl here. So we handle that completely in slotServiceOwnerChanged
     if( QDBusConnection::sessionBus().interface()->isServiceRegistered( dbusServiceName( name() ) ) ) {
         kDebug() << "Attaching to already running service" << name();
         d->attached = true;
         createServiceControlInterface();
+
+        // we do not have ProcessControl to take care of restarting. Thus, we monitor the service via DBus
+        connect( d->dbusServiceWatcher, SIGNAL( serviceUnregistered( QString ) ),
+                 this, SLOT( slotServiceUnregistered( QString ) ) );
+
         return true;
     }
     else {
@@ -175,10 +192,9 @@
                      this, SLOT( slotProcessFinished( bool ) ) );
         }
 
-        connect( QDBusConnection::sessionBus().interface(),
-                 SIGNAL( serviceOwnerChanged( const QString&, const QString&, const QString& ) ),
-                 this,
-                 SLOT( slotServiceOwnerChanged( const QString&, const QString&, const QString& ) ) );
+        // wait for the service to be registered with DBus before creating the service interface
+        connect( d->dbusServiceWatcher, SIGNAL( serviceRegistered( QString ) ),
+                 this, SLOT( slotServiceRegistered( QString ) ) );
 
         d->processControl->setCrashPolicy( ProcessControl::RestartOnCrash );
         return d->processControl->start( KGlobal::dirs()->locate( "exe", "nepomukservicestub" ),
@@ -265,19 +281,19 @@
 }
 
 
-void Nepomuk::ServiceController::slotServiceOwnerChanged( const QString& serviceName,
-                                                          const QString& oldOwner,
-                                                          const QString& newOwner )
+void Nepomuk::ServiceController::slotServiceRegistered( const QString& serviceName )
 {
-    if( !newOwner.isEmpty() && serviceName == dbusServiceName( name() ) ) {
+    if( serviceName == dbusServiceName( name() ) ) {
         createServiceControlInterface();
     }
+}
 
+void Nepomuk::ServiceController::slotServiceUnregistered( const QString& serviceName )
+{
     // an attached service was not started through ProcessControl. Thus, we cannot rely
     // on its restart-on-crash feature and have to do it manually. Afterwards it is back
-    // to normals
-    else if( d->attached &&
-             oldOwner == dbusServiceName( name() ) ) {
+    // to normal
+    if( d->attached && serviceName == dbusServiceName( name() ) ) {
         kDebug() << "Attached service" << name() << "went down. Restarting ourselves.";
         d->attached = false;
         start();
Index: nepomuk/server/servicecontroller.h
===================================================================
--- nepomuk/server/servicecontroller.h	(révision 1121160)
+++ nepomuk/server/servicecontroller.h	(copie de travail)
@@ -80,9 +80,8 @@
         
     private Q_SLOTS:
         void slotProcessFinished( bool );
-        void slotServiceOwnerChanged( const QString& serviceName,
-                                      const QString&,
-                                      const QString& newOwner );
+        void slotServiceRegistered( const QString& serviceName );
+        void slotServiceUnregistered( const QString& serviceName );
         void slotServiceInitialized( bool success );
         
     private:
Index: nepomuk/server/processcontrol.cpp
===================================================================
--- nepomuk/server/processcontrol.cpp	(révision 1121160)
+++ nepomuk/server/processcontrol.cpp	(copie de travail)
@@ -90,27 +90,27 @@
         if ( mPolicy == RestartOnCrash ) {
              // don't try to start an unstartable application
             if ( !mFailedToStart && --mCrashCount >= 0 ) {
-                qDebug( "Application '%s' crashed! %d restarts left.", qPrintable( mApplication ), mCrashCount );
+                qDebug( "Application '%s' crashed! %d restarts left.", qPrintable( commandLine() ), mCrashCount );
                 start();
             } else {
                 if ( mFailedToStart ) {
-                    qDebug( "Application '%s' failed to start!", qPrintable( mApplication ) );
+                    qDebug( "Application '%s' failed to start!", qPrintable( commandLine() ) );
                 } else {
-                    qDebug( "Application '%s' crashed to often. Giving up!", qPrintable( mApplication ) );
+                    qDebug( "Application '%s' crashed to often. Giving up!", qPrintable( commandLine() ) );
                 }
                 emit finished(false);
             }
         } else {
-            qDebug( "Application '%s' crashed. No restart!", qPrintable( mApplication ) );
+            qDebug( "Application '%s' crashed. No restart!", qPrintable( commandLine() ) );
         }
     } else {
         if ( exitCode != 0 ) {
             qDebug( "ProcessControl: Application '%s' returned with exit code %d (%s)",
-                    qPrintable( mApplication ), exitCode, qPrintable( mProcess.errorString() ) );
+                    qPrintable( commandLine() ), exitCode, qPrintable( mProcess.errorString() ) );
             mFailedToStart = true;
             emit finished(false);
         } else {
-            qDebug( "Application '%s' exited normally...", qPrintable( mApplication ) );
+            qDebug( "Application '%s' exited normally...", qPrintable( commandLine() ) );
             emit finished(true);
         }
     }
@@ -145,4 +145,9 @@
     return mProcess.state() == QProcess::Running;
 }
 
+QString ProcessControl::commandLine() const
+{
+    return mApplication + QLatin1String(" ") + mArguments.join(QLatin1String(" "));
+}
+
 #include "processcontrol.moc"
Index: nepomuk/server/processcontrol.h
===================================================================
--- nepomuk/server/processcontrol.h	(révision 1121160)
+++ nepomuk/server/processcontrol.h	(copie de travail)
@@ -97,6 +97,8 @@
 private:
     bool start();
 
+    QString commandLine() const;
+
     QProcess mProcess;
     QString mApplication;
     QStringList mArguments;
Index: nepomuk/server/nepomukservice.desktop
===================================================================
--- nepomuk/server/nepomukservice.desktop	(révision 1121160)
+++ nepomuk/server/nepomukservice.desktop	(copie de travail)
@@ -32,6 +32,7 @@
 Comment[hr]=Usluga Nepomuk
 Comment[hsb]=Nepomuk-słužba
 Comment[hu]=Nepomuk szolgáltatás
+Comment[ia]=Servicio de Nepomuk
 Comment[id]=Layanan Nepomuk
 Comment[is]=Nepomuk þjónusta
 Comment[it]=Servizio Nepomuk
@@ -70,7 +71,7 @@
 Comment[te]=Nepomuk సేవ
 Comment[tg]=Хидматҳои Nepomuk
 Comment[th]=บริการ Neomuk
-Comment[tr]=Nepomuk Servisi
+Comment[tr]=Nepomuk Hizmeti
 Comment[uk]=Служба Nepomuk
 Comment[uz]=Nepomuk xizmati
 Comment[uz@cyrillic]=Nepomuk хизмати
Index: nepomuk/server/servicemanager.cpp
===================================================================
--- nepomuk/server/servicemanager.cpp	(révision 1121160)
+++ nepomuk/server/servicemanager.cpp	(copie de travail)
@@ -155,8 +155,9 @@
 
     /**
      * Stop a service and all services depending on it.
+     * Return true if it was stopped, false if it was not running.
      */
-    void stopService( ServiceController* );
+    bool stopService( ServiceController* );
 
     /**
      * Start pending services based on the newly initialized service newService
@@ -244,8 +245,12 @@
 }
 
 
-void Nepomuk::ServiceManager::Private::stopService( ServiceController* sc )
+bool Nepomuk::ServiceManager::Private::stopService( ServiceController* sc )
 {
+    // make sure the service is not scheduled to be started later anymore
+    pendingServices.remove( sc );
+
+    // stop it if already running
     if( sc->isRunning() ) {
         // shut down any service depending of this one first
         foreach( const QString &dep, dependencyTree.servicesDependingOn( sc->name() ) ) {
@@ -253,7 +258,11 @@
         }
 
         sc->stop();
+        return true;
     }
+    else {
+        return false;
+    }
 }
 
 
@@ -316,6 +325,7 @@
 
 void Nepomuk::ServiceManager::stopAllServices()
 {
+    d->pendingServices.clear();
     for( QHash<QString, ServiceController*>::iterator it = d->services.begin();
          it != d->services.end(); ++it ) {
         ServiceController* serviceControl = it.value();
@@ -327,39 +337,8 @@
 bool Nepomuk::ServiceManager::startService( const QString& name )
 {
     if( ServiceController* sc = d->findService( name ) ) {
-        if( !sc->isRunning() ) {
-            // start dependencies if possible
-            foreach( const QString &dependency, d->dependencyTree[name] ) {
-                if ( ServiceController* depSc = d->findService( dependency ) ) {
-                    if( depSc->autostart() || depSc->startOnDemand() ) {
-                        if ( !startService( dependency ) ) {
-                            kDebug() << "Cannot start dependency" << dependency;
-                            return false;
-                        }
-                    }
-                    else {
-                        kDebug() << "Dependency" << dependency << "can not be started automatically. It is not an autostart or start on demand service";
-                        return false;
-                    }
-                }
-                else {
-                    kDebug() << "Invalid dependency:" << dependency;
-                    return false;
-                }
-            }
-
-            if ( sc->start() ) {
-                return sc->waitForInitialized();
-            }
-            else {
-                // failed to start service
-                return false;
-            }
-        }
-        else {
-            // service already running
-            return true;
-        }
+        d->startService( sc );
+        return sc->waitForInitialized();
     }
     else {
         // could not find service
@@ -371,12 +350,8 @@
 bool Nepomuk::ServiceManager::stopService( const QString& name )
 {
     if( ServiceController* sc = d->findService( name ) ) {
-        if( sc->isRunning() ) {
-            d->stopService( sc );
-            return true;
-        }
+        return d->stopService( sc );
     }
-
     return false;
 }
 
Index: nepomuk/server/nepomukserver.desktop
===================================================================
--- nepomuk/server/nepomukserver.desktop	(révision 1121160)
+++ nepomuk/server/nepomukserver.desktop	(copie de travail)
@@ -35,6 +35,7 @@
 Name[hr]=Poslužitelj Nepomuk
 Name[hsb]=Nepomuk Serwer
 Name[hu]=Nepomuk szolgáltatás
+Name[ia]=Servitor de Nepomuk
 Name[id]=Server Nepomuk
 Name[is]=Nepomuk miðlari
 Name[it]=Server di Nepomuk
@@ -110,11 +111,12 @@
 Comment[hr]=Nepomuk poslužitelj koji pruža usluge pohrane i upravljanja Strigijem
 Comment[hsb]=Nepomuk-serwer staji składowanske słužby a strigi-kontrolu k dispoziciji.
 Comment[hu]=A Nepomuk szolgáltatás tárolási lehetőséget biztosít és a Strigi vezérlését végzi
+Comment[ia]=Le servitor Nepomuk forniente servicios de Storage e controlante de strigi
 Comment[id]=Server Nepomuk memberikan layanan Penyimpanan dan pengendalian strigi
 Comment[is]=Nepomuk miðlarinn heldur utanum geymsluþjónustur og Strigi stýringu
 Comment[it]=Il server Nepomuk fornisce servizi di memorizzazione e controllo di Strigi
 Comment[ja]=ストレージサービスを提供し Strigi を制御する Nepomuk サーバ
-Comment[kk]=Сақтау қызметі және strigi бақлауын атқаратын Nepomuk сервері
+Comment[kk]=Сақтау қызметі және strigi бақылауын атқаратын Nepomuk сервері
 Comment[km]=ម៉ាស៊ីន​បម្រើ Nepomuk ផ្ដល់​សេវា​ផ្ទុក និង​ការត្រួតពិនិត្យ strigi
 Comment[kn]=ಸ್ಟ್ರಿಗಿ ನಿಯಂತ್ರಣ ಮತ್ತು ಸಂಗ್ರಹ ಸೇವೆಗಳನ್ನು ಒದಗಿಸುವ ನೆಪೋಮುಕ್ ಪರಿಚಾರಕ (ಸರ್ವರ್)
 Comment[ko]=저장소 서비스를 제공하는 Nepomuk 서버와 Strigi 제어
@@ -146,7 +148,7 @@
 Comment[sv]=Nepomuk-server som tillhandahåller lagringstjänster och styrning av Strigi
 Comment[ta]=The Nepomuk Server providing Storage services and strigi controlling
 Comment[te]=Nepomuk సేవిక నిల్వ సేవలను మరియు strigi నింయత్రణను అందిస్తుంది
-Comment[tg]=Сервер Nepomuk предоставляет службы хранения данных и управление Strigi
+Comment[tg]=Хидматгоҳи Nepomuk хидматҳои захира ва идоракунии маълумот дастрас мекунад
 Comment[th]=บริการ Nepomuk จะให้บริการจัดเก็บข้อมูลและทำการควบคุม strigi
 Comment[tr]=Nepomuk Sunucusu Depolama servislerini ve Strigi uygulamasının kontrolünü sağlar
 Comment[uk]=Сервер Nepomuk надає служби збереження і керування strigi
Index: nepomuk/strigibackend/nepomukindexwriter.cpp
===================================================================
--- nepomuk/strigibackend/nepomukindexwriter.cpp	(révision 1121160)
+++ nepomuk/strigibackend/nepomukindexwriter.cpp	(copie de travail)
@@ -1,5 +1,5 @@
 /*
-  Copyright (C) 2007-2009 Sebastian Trueg <trueg@kde.org>
+  Copyright (C) 2007-2010 Sebastian Trueg <trueg@kde.org>
 
   This library is free software; you can redistribute it and/or
   modify it under the terms of the GNU General Public License as
@@ -21,6 +21,7 @@
 #include "util.h"
 #include "nfo.h"
 #include "nie.h"
+#include "nrl.h"
 
 #include <Soprano/Soprano>
 #include <Soprano/Vocabulary/RDF>
@@ -127,11 +128,14 @@
     class FileMetaData
     {
     public:
-        FileMetaData( const KUrl& url );
+        FileMetaData( const Strigi::AnalysisResult* idx );
 
         /// stores basic data including the nie:url and the nrl:GraphMetadata in \p model
         void storeBasicData( Soprano::Model* model );
 
+        /// map a blank node to a resource
+        QUrl mapNode( const std::string& s );
+
         /// The resource URI
         QUrl resourceUri;
 
@@ -147,8 +151,12 @@
         /// a buffer for all plain-text content generated by strigi
         std::string content;
 
+    private:
+        /// The Strigi result
+        const Strigi::AnalysisResult* m_analysisResult;
+
         /// mapping from blank nodes used in addTriplet to our urns
-        QMap<std::string, QUrl> blankNodeMap;
+        QMap<std::string, QUrl> m_blankNodeMap;
     };
 
     class RegisteredFieldData
@@ -170,10 +178,12 @@
         bool isRdfType;
     };
 
-    FileMetaData::FileMetaData( const KUrl& url )
-        : fileUrl( url ),
-          fileInfo( url.toLocalFile() )
+    FileMetaData::FileMetaData( const Strigi::AnalysisResult* idx )
+        : m_analysisResult( idx )
     {
+        fileUrl = createFileUrl( idx );
+        fileInfo = fileUrl.toLocalFile();
+
         // determine the resource URI by using Nepomuk::Resource's power
         // this will automatically find previous uses of the file in question
         // with backwards compatibility
@@ -183,6 +193,27 @@
         context = Nepomuk::ResourceManager::instance()->generateUniqueUri( "ctx" );
     }
 
+    QUrl FileMetaData::mapNode( const std::string& s )
+    {
+        if ( s[0] == ':' ) {
+            if( m_blankNodeMap.contains( s ) ) {
+                return m_blankNodeMap[s];
+            }
+            else {
+                QUrl urn = Nepomuk::ResourceManager::instance()->generateUniqueUri( QString() );
+                m_blankNodeMap.insert( s, urn );
+                return urn;
+            }
+        }
+        // special case to properly handle nie:isPartOf relations created for containers
+        else if ( s == m_analysisResult->path() ) {
+            return resourceUri;
+        }
+        else {
+            return QUrl::fromEncoded( s.c_str() );
+        }
+    }
+
     void FileMetaData::storeBasicData( Soprano::Model* model )
     {
         model->addStatement( resourceUri, Nepomuk::Vocabulary::NIE::url(), fileUrl, context );
@@ -206,7 +237,7 @@
         QUrl metaDataContext = Nepomuk::ResourceManager::instance()->generateUniqueUri( "ctx" );
         model->addStatement( context,
                              Vocabulary::RDF::type(),
-                             Vocabulary::NRL::InstanceBase(),
+                             Nepomuk::Vocabulary::NRL::DiscardableInstanceBase(),
                              metaDataContext );
         model->addStatement( context,
                              Vocabulary::NAO::created(),
@@ -218,10 +249,10 @@
                              metaDataContext );
         model->addStatement( metaDataContext,
                              Vocabulary::RDF::type(),
-                             Vocabulary::NRL::GraphMetadata(),
+                             Nepomuk::Vocabulary::NRL::GraphMetadata(),
                              metaDataContext );
         model->addStatement( metaDataContext,
-                             Vocabulary::NRL::coreGraphMetadataFor(),
+                             Nepomuk::Vocabulary::NRL::coreGraphMetadataFor(),
                              context,
                              metaDataContext );
     }
@@ -272,22 +303,6 @@
         }
     }
 
-    QUrl mapNode( FileMetaData* fmd, const std::string& s ) {
-        if ( s[0] == ':' ) {
-            if( fmd->blankNodeMap.contains( s ) ) {
-                return fmd->blankNodeMap[s];
-            }
-            else {
-                QUrl urn = Nepomuk::ResourceManager::instance()->generateUniqueUri( QString() );
-                fmd->blankNodeMap.insert( s, urn );
-                return urn;
-            }
-        }
-        else {
-            return QUrl::fromEncoded( s.c_str() );
-        }
-    }
-
     Soprano::Model* repository;
 
     //
@@ -355,7 +370,7 @@
     }
 
     // create the file data used during the analysis
-    FileMetaData* data = new FileMetaData( createFileUrl( idx ) );
+    FileMetaData* data = new FileMetaData( idx );
 
     // remove previously indexed data
     removeIndexedData( data->resourceUri, data->fileUrl );
@@ -449,7 +464,7 @@
             if ( value[0] == ':' ) {
                 Nepomuk::Types::Property property( rfd->property );
                 if ( property.range().isValid() ) {
-                    statement.setObject( d->mapNode( md, value ) );
+                    statement.setObject( md->mapNode( value ) );
                 }
             }
         }
@@ -545,11 +560,11 @@
 
     FileMetaData* md = fileDataForResult( d->currentResultStack.top() );
 
-    QUrl subject = d->mapNode( md, s );
-    Nepomuk::Types::Property property( d->mapNode( md, p ) );
+    QUrl subject = md->mapNode( s );
+    Nepomuk::Types::Property property( md->mapNode( p ) );
     Soprano::Node object;
     if ( property.range().isValid() )
-        object = d->mapNode( md, o );
+        object = md->mapNode( o );
     else
         object = Soprano::LiteralValue::fromString( QString::fromUtf8( o.c_str() ), property.literalRangeType().dataTypeUri() );
 
Index: nepomuk/strigibackend/CMakeLists.txt
===================================================================
--- nepomuk/strigibackend/CMakeLists.txt	(révision 1121160)
+++ nepomuk/strigibackend/CMakeLists.txt	(copie de travail)
@@ -15,6 +15,11 @@
 )
 
 soprano_add_ontology(strigi_nepomuk_indexer_SRCS
+  ${SHAREDDESKTOPONTOLOGIES_ROOT_DIR}/nepomuk/nrl.trig
+  "NRL"
+  "Nepomuk::Vocabulary"
+  "trig")
+soprano_add_ontology(strigi_nepomuk_indexer_SRCS
   ${SHAREDDESKTOPONTOLOGIES_ROOT_DIR}/nie/nfo.trig
   "NFO"
   "Nepomuk::Vocabulary"
Index: nepomuk/kcm/kcm_nepomuk.desktop
===================================================================
--- nepomuk/kcm/kcm_nepomuk.desktop	(révision 1121160)
+++ nepomuk/kcm/kcm_nepomuk.desktop	(copie de travail)
@@ -8,7 +8,7 @@
 X-KDE-ServiceTypes=KCModule
 X-KDE-Library=kcm_nepomuk
 X-KDE-ParentApp=kcontrol
-X-KDE-System-Settings-Parent-Category=advanced-user-settings
+X-KDE-System-Settings-Parent-Category=advanced-user-settings
 
 Name=Desktop Search
 Name[ar]=بحث سطح المكتب
@@ -40,6 +40,7 @@
 Name[hr]=Pretraživanje računala
 Name[hsb]=Pytanje za dźěłowy powjerch
 Name[hu]=Asztali keresés
+Name[ia]=Cerca de Scriptorio
 Name[id]=Pencarian Desktop
 Name[is]=Skjáborðsleit
 Name[it]=Ricerca desktop
@@ -115,6 +116,7 @@
 Comment[hr]=Konfiguracija Nepomuk/Strigi poslužitelja
 Comment[hsb]=Připrawjenje Nepomuk/Strigi-Serwera
 Comment[hu]=A Nepomuk/Strigi szolgáltatás beállítása
+Comment[ia]=Configuration de servitor Nepomuk/Strigi
 Comment[id]=Konfigurasi Server Nepomuk/Strigi
 Comment[is]=Nepomuk/Strigi miðlarastillingar
 Comment[it]=Configurazione dei server di Nepomuk/Strigi
Index: nepomuk/kcm/nepomukserverkcm.cpp
===================================================================
--- nepomuk/kcm/nepomukserverkcm.cpp	(révision 1121160)
+++ nepomuk/kcm/nepomukserverkcm.cpp	(copie de travail)
@@ -28,6 +28,7 @@
 #include <KMessageBox>
 
 #include <QtGui/QTreeView>
+#include <QtDBus/QDBusServiceWatcher>
 
 #include <Soprano/PluginManager>
 
@@ -117,10 +118,15 @@
     connect( m_checkShowHiddenFolders, SIGNAL( toggled( bool ) ),
              m_folderModel, SLOT( setHiddenFoldersShown( bool ) ) );
 
-    connect( QDBusConnection::sessionBus().interface(),
-             SIGNAL( serviceOwnerChanged( const QString&, const QString&, const QString& ) ),
-             this,
-             SLOT( slotUpdateStrigiStatus() ) );
+    QDBusServiceWatcher * watcher = new QDBusServiceWatcher( this );
+    watcher->addWatchedService( QLatin1String("org.kde.nepomuk.services.nepomukstrigiservice") );
+    watcher->setConnection( QDBusConnection::sessionBus() );
+    watcher->setWatchMode( QDBusServiceWatcher::WatchForRegistration | QDBusServiceWatcher::WatchForUnregistration );
+    
+    connect( watcher, SIGNAL( serviceRegistered(const QString&) ),
+             this, SLOT( slotUpdateStrigiStatus() ) );
+    connect( watcher, SIGNAL( serviceUnregistered(const QString&) ),
+             this, SLOT( slotUpdateStrigiStatus() ) );
 
     recreateStrigiInterface();
 }
Index: nepomuk/kcm/nepomukconfigwidget.ui
===================================================================
--- nepomuk/kcm/nepomukconfigwidget.ui	(révision 1121160)
+++ nepomuk/kcm/nepomukconfigwidget.ui	(copie de travail)
@@ -158,7 +158,7 @@
              <string>Index the files on removable media like USB sticks when they are mounted</string>
             </property>
             <property name="text">
-             <string>Index Files on Removable Media</string>
+             <string>Index files on removable media</string>
             </property>
            </widget>
           </item>
@@ -194,7 +194,7 @@
           <item>
            <widget class="QLabel" name="label_4">
             <property name="text">
-             <string>The maximum amount of memory the Nepomuk database should use. The more memory Nepomuk has the more performant it will be.</string>
+             <string>&lt;p&gt;The maximum amount of main memory the Nepomuk system should use for its database process. The more memory is available to Nepomuk the better will be its performance. (The Nepomuk database process shows up as &lt;command&gt;virtuoso-t&lt;/command&gt; in the process manager.)</string>
             </property>
             <property name="wordWrap">
              <bool>true</bool>
@@ -222,7 +222,7 @@
             <item>
              <widget class="QSpinBox" name="m_editMemoryUsage">
               <property name="suffix">
-               <string> MB</string>
+               <string> MiB</string>
               </property>
               <property name="minimum">
                <number>50</number>
Index: nepomuk/servicestub/main.cpp
===================================================================
--- nepomuk/servicestub/main.cpp	(révision 1121160)
+++ nepomuk/servicestub/main.cpp	(copie de travail)
@@ -23,6 +23,7 @@
 #include <KService>
 #include <KServiceTypeTrader>
 #include <KDebug>
+#include <KApplication>
 
 #include <QtCore/QTextStream>
 #include <QtCore/QTimer>
@@ -80,10 +81,6 @@
 
     KCmdLineArgs::init( argc, argv, &aboutData );
 
-    QApplication app( argc, argv );
-    installSignalHandler();
-    QApplication::setQuitOnLastWindowClosed( false );
-
     // FIXME: set the proper KConfig rc name using the service name
 
     KCmdLineArgs* args = KCmdLineArgs::parsedArgs();
@@ -100,7 +97,10 @@
     args->clear();
 
     aboutData.setAppName( serviceName.toLocal8Bit() );
-    KComponentData compData( aboutData );
+    KApplication app( true /* The strigi service actually needs a GUI at the moment */ );
+    app.disableSessionManagement();
+    installSignalHandler();
+    QApplication::setQuitOnLastWindowClosed( false );
 
 
     // check if NepomukServer is running
@@ -142,12 +142,12 @@
 
     // register the service control
     // ====================================
-    Nepomuk::ServiceControl* control = new Nepomuk::ServiceControl( serviceName, service, &app );
+    Nepomuk::ServiceControl control( serviceName, service, 0 );
 
 
     // start the service (queued since we need an event loop)
     // ====================================
-    QTimer::singleShot( 0, control, SLOT( start() ) );
+    QTimer::singleShot( 0, &control, SLOT( start() ) );
 
     return app.exec();
 }
