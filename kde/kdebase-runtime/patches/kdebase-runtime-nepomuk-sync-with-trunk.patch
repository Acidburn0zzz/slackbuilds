Index: nepomuk/kioslaves/search/kio_nepomuksearch.cpp
===================================================================
--- nepomuk/kioslaves/search/kio_nepomuksearch.cpp	(révision 1121160)
+++ nepomuk/kioslaves/search/kio_nepomuksearch.cpp	(copie de travail)
@@ -69,7 +69,6 @@
      * Empty if the path only contains the query.
      */
     QString fileNameFromUrl( const KUrl& url ) {
-        QString fn;
         if ( url.hasQueryItem( QLatin1String( "sparql" ) ) ||
              url.hasQueryItem( QLatin1String( "query" ) ) ||
              url.directory() != QLatin1String( "/" ) ) {
Index: nepomuk/kioslaves/search/kdedmodule/nepomuksearchmodule.h
===================================================================
--- nepomuk/kioslaves/search/kdedmodule/nepomuksearchmodule.h	(révision 1121160)
+++ nepomuk/kioslaves/search/kdedmodule/nepomuksearchmodule.h	(copie de travail)
@@ -26,6 +26,8 @@
 #include <QtDBus/QDBusContext>
 #include <QtCore/QMultiHash>
 
+class QDBusServiceWatcher;
+
 namespace Nepomuk {
 
     class SearchUrlListener;
@@ -45,15 +47,15 @@
         Q_SCRIPTABLE QStringList watchedSearchUrls();
 
     private Q_SLOTS:
-        void slotServiceOwnerChanged( const QString& serviceName,
-                                      const QString&,
-                                      const QString& newOwner );
+        void slotServiceUnregistered( const QString& serviceName );
 
     private:
         void unrefUrl( const KUrl& url );
 
         QHash<KUrl, SearchUrlListener*> m_queryHash;
         QMultiHash<QString, KUrl> m_dbusServiceUrlHash;
+
+        QDBusServiceWatcher *m_watcher;
     };
 }
 
Index: nepomuk/kioslaves/search/kdedmodule/nepomuksearchmodule.cpp
===================================================================
--- nepomuk/kioslaves/search/kdedmodule/nepomuksearchmodule.cpp	(révision 1121160)
+++ nepomuk/kioslaves/search/kdedmodule/nepomuksearchmodule.cpp	(copie de travail)
@@ -23,6 +23,7 @@
 #include "dbusoperators_p.h"
 
 #include <QtDBus/QDBusConnection>
+#include <QtDBus/QDBusServiceWatcher>
 
 #include <kdebug.h>
 #include <kdirnotify.h>
@@ -30,7 +31,7 @@
 namespace {
     inline bool isNepomukSearchUrl( const KUrl& url )
     {
-        static const char* s_nepProName = "nepomuksearch";
+        static const char s_nepProName[] = "nepomuksearch";
         return url.protocol() == QLatin1String( s_nepProName );
     }
 }
@@ -47,10 +48,12 @@
     // connect to serviceOwnerChanged to catch crashed clients that never unregistered
     // themselves
     //
-    connect( QDBusConnection::sessionBus().interface(),
-             SIGNAL( serviceOwnerChanged( const QString&, const QString&, const QString& ) ),
-             this,
-             SLOT( slotServiceOwnerChanged( const QString&, const QString&, const QString& ) ) );
+    m_watcher = new QDBusServiceWatcher( QString(),
+                                         QDBusConnection::sessionBus(),
+                                         QDBusServiceWatcher::WatchForUnregistration,
+                                         this );
+    connect( m_watcher, SIGNAL( serviceUnregistered( const QString& ) ),
+             this, SLOT( slotServiceUnregistered( const QString& ) ) );
 
     //
     // connect to KDirLister telling us that it entered a dir
@@ -93,8 +96,10 @@
             it.value()->ref();
         }
 
-        if ( calledFromDBus() )
+        if ( calledFromDBus() ) {
             m_dbusServiceUrlHash.insert( message().service(), url );
+            m_watcher->addWatchedService( message().service() );
+        }
     }
 }
 
@@ -105,8 +110,11 @@
     if ( isNepomukSearchUrl( url ) ) {
         kDebug() << "UNREGISTER UNREGISTER UNREGISTER UNREGISTER UNREGISTER" << url;
         unrefUrl( url );
-        if ( calledFromDBus() )
+        if ( calledFromDBus() ) {
             m_dbusServiceUrlHash.remove( message().service(), url );
+            if ( !m_dbusServiceUrlHash.contains( message().service() ) )
+                m_watcher->removeWatchedService( message().service() );
+        }
     }
 }
 
@@ -117,18 +125,15 @@
 }
 
 
-void Nepomuk::SearchModule::slotServiceOwnerChanged( const QString& serviceName,
-                                                     const QString&,
-                                                     const QString& newOwner )
+void Nepomuk::SearchModule::slotServiceUnregistered( const QString& serviceName )
 {
-    if ( newOwner.isEmpty() ) {
-        QHash<QString, KUrl>::iterator it = m_dbusServiceUrlHash.find( serviceName );
-        while ( it != m_dbusServiceUrlHash.end() ) {
-            unrefUrl( it.value() );
-            m_dbusServiceUrlHash.erase( it );
-            it = m_dbusServiceUrlHash.find( serviceName );
-        }
+    QHash<QString, KUrl>::iterator it = m_dbusServiceUrlHash.find( serviceName );
+    while ( it != m_dbusServiceUrlHash.end() ) {
+        unrefUrl( it.value() );
+        m_dbusServiceUrlHash.erase( it );
+        it = m_dbusServiceUrlHash.find( serviceName );
     }
+    m_watcher->removeWatchedService( serviceName );
 }
 
 
Index: nepomuk/kioslaves/nepomuk/kio_nepomuk.cpp
===================================================================
--- nepomuk/kioslaves/nepomuk/kio_nepomuk.cpp	(révision 1121160)
+++ nepomuk/kioslaves/nepomuk/kio_nepomuk.cpp	(copie de travail)
@@ -402,8 +402,24 @@
     //
     KIO::UDSEntry uds;
 
+    // we handle files on removable media which are not mounted
+    // as a special case
+    bool isFileOnRemovableMedium = isRemovableMediaFile( res );
+
     // The display name can be anything
-    uds.insert( KIO::UDSEntry::UDS_DISPLAY_NAME, res.genericLabel() );
+    QString displayName;
+    if ( isFileOnRemovableMedium ) {
+        displayName = i18nc( "%1 is a filename of a file on a removable device, "
+                             "%2 is the name of the removable medium which often is something like "
+                             "'X GiB Removable Media.",
+                             "%1 (on unmounted medium <resource>%2</resource>)",
+                             res.genericLabel(),
+                             getFileSystemLabelForRemovableMediaFileUrl( res ) );
+    }
+    else {
+        displayName = res.genericLabel();
+    }
+    uds.insert( KIO::UDSEntry::UDS_DISPLAY_NAME, displayName );
 
     // UDS_NAME needs to be unique but can be ugly
     uds.insert( KIO::UDSEntry::UDS_NAME, resourceUriToUdsName( res.resourceUri() ) );
@@ -418,7 +434,7 @@
         uds.insert( KIO::UDSEntry::UDS_MIME_TYPE, mimeTypes.first() );
     }
     else */
-    if ( isRemovableMediaFile( res ) ) {
+    if ( isFileOnRemovableMedium ) {
         KMimeType::Ptr mt = KMimeType::findByUrl( res.property( Vocabulary::NIE::url() ).toUrl(),
                                                   0,
                                                   false, /* no local file as it is not accessible at the moment */
@@ -565,7 +584,7 @@
     }
     else if ( isRemovableMediaFile( res ) ) {
         const KUrl removableMediaUrl = res.property( Nepomuk::Vocabulary::NIE::url() ).toUrl();
-        newURL = convertRemovableMediaFileUrl( res.property( Nepomuk::Vocabulary::NIE::url() ).toUrl(), m_currentOperation == Get );
+        newURL = convertRemovableMediaFileUrl( removableMediaUrl, m_currentOperation == Get );
         if ( !newURL.isValid() && m_currentOperation == Get ) {
             // error handling in get()
             return true;
Index: nepomuk/interfaces/org.kde.nepomuk.RemovableStorage.xml
===================================================================
--- nepomuk/interfaces/org.kde.nepomuk.RemovableStorage.xml	(révision 1121160)
+++ nepomuk/interfaces/org.kde.nepomuk.RemovableStorage.xml	(copie de travail)
@@ -6,5 +6,8 @@
       <arg type="s" direction="out"/>
       <arg name="url" type="s" direction="in"/>
     </method>
+    <method name="currentlyMountedAndIndexed">
+      <arg type="as" direction="out"/>
+    </method>
   </interface>
 </node>
Index: nepomuk/interfaces/org.kde.nepomuk.Strigi.xml
===================================================================
--- nepomuk/interfaces/org.kde.nepomuk.Strigi.xml	(révision 1121160)
+++ nepomuk/interfaces/org.kde.nepomuk.Strigi.xml	(copie de travail)
@@ -11,6 +11,9 @@
     <method name="currentFolder">
       <arg type="s" direction="out" />
     </method>
+    <method name="currentFile">
+      <arg type="s" direction="out" />
+    </method>
     <method name="suspend" />
     <method name="resume" />
     <method name="updateFolder">
Index: nepomuk/interfaces/org.kde.nepomuk.FileWatch.xml
===================================================================
--- nepomuk/interfaces/org.kde.nepomuk.FileWatch.xml	(révision 0)
+++ nepomuk/interfaces/org.kde.nepomuk.FileWatch.xml	(révision 0)
@@ -0,0 +1,9 @@
+<!DOCTYPE node PUBLIC "-//freedesktop//DTD D-BUS Object Introspection 1.0//EN"
+          "http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd">
+<node>
+  <interface name="org.kde.nepomuk.FileWatch">
+    <method name="watchFolder">
+      <arg name="path" type="s" direction="in"/>
+    </method>
+  </interface>
+</node>
Index: nepomuk/services/ontologyloader/nepomukontologyloader.desktop
===================================================================
--- nepomuk/services/ontologyloader/nepomukontologyloader.desktop	(révision 1121160)
+++ nepomuk/services/ontologyloader/nepomukontologyloader.desktop	(copie de travail)
@@ -32,6 +32,7 @@
 Name[hr]=Nepomuk Učitavač Ontologije
 Name[hsb]=Nepomuk začitanje ontologije
 Name[hu]=Nepomuk ontológiabetöltő
+Name[ia]=Cargator de Ontologia de Nepomuk
 Name[id]=Pemuat Ontologi Nepomuk
 Name[is]=Nepomuk verufræðihöndlari (Ontology Loader)
 Name[it]=Caricatore delle ontologie di Nepomuk
@@ -101,6 +102,7 @@
 Comment[hr]=Nepomukova usluga koja održava ontologije instalirane na sustav
 Comment[hsb]=Nepomukowa słužba, kiž so stara wo instalowane ontologije
 Comment[hu]=Nepomuk-szolgáltatás a rendszer ontológiáinak karbantartásához
+Comment[ia]=Servicio de Nepomuk que il mantene le ontologias installate su le systema
 Comment[id]=Layanan Nepomuk yang mengelola ontologi yang terinstal di sistem
 Comment[is]=Nepomuk þjónusta sem viðheldur þeim verufræðitengingum (ontologies) sem uppsettar eru á kerfinu
 Comment[it]=Servizio di Nepomuk che mantiene le ontologie installate sul sistema
Index: nepomuk/services/removablestorage/removablestorageservice.cpp
===================================================================
--- nepomuk/services/removablestorage/removablestorageservice.cpp	(révision 1121160)
+++ nepomuk/services/removablestorage/removablestorageservice.cpp	(copie de travail)
@@ -20,6 +20,7 @@
 #include "nfo.h"
 #include "nie.h"
 #include "strigiserviceinterface.h"
+#include "filewatchserviceinterface.h"
 
 #include <QtDBus/QDBusConnection>
 #include <QtCore/QUuid>
@@ -172,6 +173,26 @@
 }
 
 
+QStringList Nepomuk::RemovableStorageService::currentlyMountedAndIndexed()
+{
+    if( KConfig( "nepomukstrigirc" ).group( "General" ).readEntry( "index newly mounted", false ) ) {
+        QStringList paths;
+        for ( QHash<QString, Entry>::ConstIterator it = m_metadataCache.constBegin();
+              it != m_metadataCache.constEnd(); ++it ) {
+            const Entry& entry = it.value();
+            const Solid::StorageAccess* storage = entry.m_device.as<Solid::StorageAccess>();
+            if ( storage && storage->isAccessible() ) {
+                paths << storage->filePath();
+            }
+        }
+        return paths;
+    }
+    else {
+        return QStringList();
+    }
+}
+
+
 void Nepomuk::RemovableStorageService::initCacheEntries()
 {
     QList<Solid::Device> devices
@@ -248,14 +269,25 @@
         //
         entry.m_lastMountPath = entry.m_device.as<Solid::StorageAccess>()->filePath();
 
-        //
-        // tell Strigi to update the newly mounted device
-        //
-        if( KConfig( "nepomukstrigirc" ).group( "General" ).readEntry( "index newly mounted", false ) ) {
-            org::kde::nepomuk::Strigi interface( "org.kde.nepomuk.services.nepomukstrigiservice",
-                                                 "/nepomukstrigiservice",
-                                                 QDBusConnection::sessionBus() );
-            interface.indexFolder( entry.m_lastMountPath, false );
+        if ( entry.hasLastMountPath() ) {
+            //
+            // tell the filewatch service that it should monitor the new medium
+            //
+            org::kde::nepomuk::FileWatch( "org.kde.nepomuk.services.nepomukfilewatch",
+                                          "/nepomukfilewatch",
+                                          QDBusConnection::sessionBus() )
+                .watchFolder( entry.m_lastMountPath );
+
+
+            //
+            // tell Strigi to update the newly mounted device
+            //
+            if( KConfig( "nepomukstrigirc" ).group( "General" ).readEntry( "index newly mounted", false ) ) {
+                org::kde::nepomuk::Strigi( "org.kde.nepomuk.services.nepomukstrigiservice",
+                                           "/nepomukstrigiservice",
+                                           QDBusConnection::sessionBus() )
+                    .indexFolder( entry.m_lastMountPath, false );
+            }
         }
 
         //
@@ -284,7 +316,7 @@
             }
         }
     }
-    else {
+    else if ( entry.hasLastMountPath() ) {
         //
         // The first thing we need to do is to inform nepomuk:/ kio slave instances that something has changed
         // so any caches will be cleared. Otherwise KDirModel and friends might try to access the old media URLs
@@ -367,6 +399,13 @@
     return path;
 }
 
+
+bool Nepomuk::RemovableStorageService::Entry::hasLastMountPath() const
+{
+    return( !m_lastMountPath.isEmpty() &&
+            m_lastMountPath != QLatin1String( "/" ) );
+}
+
 NEPOMUK_EXPORT_SERVICE( Nepomuk::RemovableStorageService, "nepomukremovablestorageservice")
 
 #include "removablestorageservice.moc"
Index: nepomuk/services/removablestorage/removablestorageservice.h
===================================================================
--- nepomuk/services/removablestorage/removablestorageservice.h	(révision 1121160)
+++ nepomuk/services/removablestorage/removablestorageservice.h	(copie de travail)
@@ -65,6 +65,8 @@
          */
         Q_SCRIPTABLE QString resourceUriFromLocalFileUrl( const QString& url );
 
+        Q_SCRIPTABLE QStringList currentlyMountedAndIndexed();
+
     private Q_SLOTS:
         void slotSolidDeviceAdded( const QString& udi );
         void slotSolidDeviceRemoved( const QString& udi );
@@ -89,6 +91,7 @@
 
             KUrl constructRelativeUrl( const QString& path ) const;
             QString constructLocalPath( const KUrl& filexUrl ) const;
+            bool hasLastMountPath() const;
 
             Solid::Device m_device;
             QString m_lastMountPath;
Index: nepomuk/services/removablestorage/nepomukremovablestorageservice.desktop
===================================================================
--- nepomuk/services/removablestorage/nepomukremovablestorageservice.desktop	(révision 1121160)
+++ nepomuk/services/removablestorage/nepomukremovablestorageservice.desktop	(copie de travail)
@@ -18,10 +18,9 @@
 Name[fi]=Nepomukin irrotettava tallennuspalvelu
 Name[fr]=Service de stockage amovible de Nepomuk
 Name[fy]=Nepomuk opslach tsjinst
-Name[ga]=Seirbhís Stórála Inbhainte Nepomuk
 Name[he]=שירות התקני אחסון נשלפים של Nepomuk
 Name[hr]=Nepomukova usluga za uklonjivo skladište
-Name[hu]=Nepomuk eltávolítható tároló szolgáltatás
+Name[ia]=Servicio de Nepomuk de Storage Removibile
 Name[id]=Layanan Penyimpanan Dapat Dilepas Nepomuk
 Name[is]=Nepomuk miðlari fyrir aftengjanlegar gagnageymslur
 Name[it]=Servizio per supporti rimovibili di Nepomuk
@@ -50,9 +49,9 @@
 Name[sr@ijekavianlatin]=Nepomukov servis uklonjivih skladišta
 Name[sr@latin]=Nepomukov servis uklonjivih skladišta
 Name[sv]=Nepomuk-tjänst för flyttbara medier
-Name[tg]=Основная служба хранения данных Nepomuk
+Name[tg]=Хидмати захирагоҳи Nepomuk
 Name[th]=บริการเก็บข้อมูล Nepomuk บนสื่อถอด/เสียบได้
-Name[tr]=Nepomuk Çıkarılabilir Depolama Servisi
+Name[tr]=Nepomuk Çıkarılabilir Depolama Hizmeti
 Name[uk]=Служба зберігання на портативних пристроях Nepomuk
 Name[x-test]=xxNepomuk Removable Storage Servicexx
 Name[zh_CN]=Nepomuk 可移动存储服务
@@ -72,7 +71,7 @@
 Comment[fr]=Le service de stockage amovible de Nepomuk, fournissant les méta-données de Mepomuk sur les périphériques de stockage amovibles.
 Comment[fy]=De Nepomuk útnimber opslach tsjinst, ferskaft troch de Nepomuk metadata op útnimber opslach apparaten.
 Comment[hr]=Nepomukova usluga uklonjivih uređaja za pohranu pruža pristup Nepomukovim metapodacima na uklonjivim uređajima za pohranu.
-Comment[hu]=A Nepomuk cserélhető tároló szolgáltatás, hozzáférést biztosít a Nepumuk metaadatához a cserélhető tároló eszközökön.
+Comment[ia]=Le servicio de storage removibile de Nepomuk forni accesso a metadata de Nepomuk su dispositivos de storage removibile.
 Comment[id]=Layanan penyimpanan dapat dilepas Nepomuk, memberikan akses ke metadata Nepomuk di divais penyimpanan dapat dilepas.
 Comment[is]=Nepomuk miðlari fyrir aftengjanlegar gagnageymslur, gerir kleift að nálgast Nepomuk lýsigögn á aftengjanlegum gagnageymslum.
 Comment[it]=Il servizio per supporti rimovibili di Nepomuk, che dà accesso ai dati aggiuntivi di Nepomuk sui supporti rimovibili.
@@ -99,7 +98,7 @@
 Comment[sr@latin]=Nepomukov servis uklonjivih skladišta daje pristup Nepomukovim metapodacima na uklonjivim skladišnim uređajima.
 Comment[sv]=Nepomuks tjänst för flyttbara medier, vilken ger tillgång till Nepomuk metadata för flyttbara lagringsenheter.
 Comment[th]=บริการเก็บข้อมูล Nepomuk บนสื่อถอด/เสียบได้ ให้บริการในการเข้าใช้งานข้อมูลต่าง ๆ ของ Nepomuk บนอุปกรณ์ต่าง ๆ ที่เป็นประเภทถอด/เสียบได้
-Comment[tr]=Nepomuk çıkarılabilir depolama servisi, çıkarılabilir depolama aygıtlarındaki Nepomuk meta verisine erişmeyi sağlar.
+Comment[tr]=Nepomuk çıkarılabilir depolama hizmeti, çıkarılabilir depolama aygıtlarındaki Nepomuk verilerine erişmeyi sağlar.
 Comment[uk]=Служба зберігання на портативних носіях Nepomuk надає вам доступ до метаданих Nepomuk, що зберігаються на портативних носіях.
 Comment[x-test]=xxThe Nepomuk removable storage service, providing access to Nepomuk metadata on removable storage devices.xx
 Comment[zh_CN]=Nepomuk 可移动存储服务，提供了对可移动存储设备上的 Nepomuk 元数据访问功能。
Index: nepomuk/services/removablestorage/CMakeLists.txt
===================================================================
--- nepomuk/services/removablestorage/CMakeLists.txt	(révision 1121160)
+++ nepomuk/services/removablestorage/CMakeLists.txt	(copie de travail)
@@ -16,6 +16,7 @@
 soprano_add_ontology(SRCS ${SHAREDDESKTOPONTOLOGIES_ROOT_DIR}/nie/nie.trig "NIE" "Nepomuk::Vocabulary" "trig")
 
 qt4_add_dbus_interface(SRCS ../../interfaces/org.kde.nepomuk.Strigi.xml strigiserviceinterface)
+qt4_add_dbus_interface(SRCS ../../interfaces/org.kde.nepomuk.FileWatch.xml filewatchserviceinterface)
 
 kde4_add_plugin(nepomukremovablestorageservice ${SRCS})
 
Index: nepomuk/services/strigi/eventmonitor.h
===================================================================
--- nepomuk/services/strigi/eventmonitor.h	(révision 1121160)
+++ nepomuk/services/strigi/eventmonitor.h	(copie de travail)
@@ -22,7 +22,7 @@
 #include <QtCore/QObject>
 #include <QtCore/QStringList>
 #include <QtCore/QTimer>
-#include <QtCore/QTime>
+#include <QtCore/QDateTime>
 
 class KDiskFreeSpace;
 
@@ -42,12 +42,16 @@
         void slotPowerManagementStatusChanged( bool conserveResources );
         void slotCheckAvailableSpace();
         void slotIndexingStopped();
+        void pauseIndexing(int pauseState);
+        void resumeIndexing();
+        void slotIndexingSuspended( bool suspended );
 
     private:
         enum {
             NotPaused,
             PausedDueToPowerManagement,
-            PausedDueToAvailSpace
+            PausedDueToAvailSpace,
+            PausedCustom
         };
 
         IndexScheduler* m_indexScheduler;
@@ -56,9 +60,8 @@
         // timer used to periodically check for available space
         QTimer m_availSpaceTimer;
 
-        QTime m_initialIndexTime;
-
-        QTimer m_periodicUpdateTimer;
+        QDateTime m_indexingStartTime;
+        int m_totalIndexingSeconds;
     };
 }
 
Index: nepomuk/services/strigi/strigiserviceadaptor.h
===================================================================
--- nepomuk/services/strigi/strigiserviceadaptor.h	(révision 1121160)
+++ nepomuk/services/strigi/strigiserviceadaptor.h	(copie de travail)
@@ -43,6 +43,9 @@
                     "    <method name=\"currentFolder\">\n"
                     "      <arg direction=\"out\" type=\"s\"/>\n"
                     "    </method>\n"
+                    "    <method name=\"currentFile\">\n"
+                    "      <arg direction=\"out\" type=\"s\"/>\n"
+                    "    </method>\n"
                     "    <method name=\"suspend\"/>\n"
                     "    <method name=\"resume\"/>\n"
                     "    <method name=\"updateFolder\">\n"
@@ -86,6 +89,7 @@
         bool isIndexing();
         bool isSuspended();
         QString currentFolder();
+        QString currentFile();
         void resume();
         void suspend();
 
Index: nepomuk/services/strigi/nepomukstrigiservice.desktop
===================================================================
--- nepomuk/services/strigi/nepomukstrigiservice.desktop	(révision 1121160)
+++ nepomuk/services/strigi/nepomukstrigiservice.desktop	(copie de travail)
@@ -35,6 +35,7 @@
 Name[hr]=Uslufa Nepomuk Strigi
 Name[hsb]=Nepomuk Strigi słužba
 Name[hu]=Nepomuk Strigi szolgáltatás
+Name[ia]=Servicio de Strigi de Nepomuk
 Name[id]=Layanan Nepomuk Strigi
 Name[is]=Nepomuk Strigi þjónusta
 Name[it]=Servizio Strigi di Nepomuk
@@ -72,7 +73,7 @@
 Name[te]=Nepomuk Strigi సేవ
 Name[tg]=Хидматҳои Nepomuk Strigi
 Name[th]=บริการ Nepomuk Strigi
-Name[tr]=Nepomuk Strigi Servisi
+Name[tr]=Nepomuk Strigi Hizmeti
 Name[uk]=Служба Strigi Nepomuk
 Name[uz]=Nepomuk Strigi xizmati
 Name[uz@cyrillic]=Nepomuk Strigi хизмати
@@ -106,6 +107,7 @@
 Comment[hr]=Nepomukova usluga koja upravlja strigidaemonom, tj. indeksira datoteke na računalu
 Comment[hsb]=Nepomukowa słužba za strigidemon, to su indeksowe dataje na dźěłowym powjerchu
 Comment[hu]=A Strigi szolgáltatást kezeli, amely fájlok indexelését végzi
+Comment[ia]=Servicio de Nepomuk que controla le strigidaemon, i.e. indicisa le archivos su le scriptorio
 Comment[id]=Layanan Nepomuk yang mengontrol jurik strigi, misalnya berkas indeks di desktop
 Comment[is]=Nepomuk þjónusta sem stýrir strigidaemon, þ.e. býr til yfirlit um skrár á skjáborði
 Comment[it]=Servizio di Nepomuk che controlla il demone strigi, cioè indicizza i file del desktop
Index: nepomuk/services/strigi/strigiserviceconfig.cpp
===================================================================
--- nepomuk/services/strigi/strigiserviceconfig.cpp	(révision 1121160)
+++ nepomuk/services/strigi/strigiserviceconfig.cpp	(copie de travail)
@@ -17,6 +17,7 @@
 */
 
 #include "strigiserviceconfig.h"
+#include "removablestorageserviceinterface.h"
 #include "strigiservicedefaults.h"
 
 #include <QtCore/QStringList>
@@ -197,7 +198,7 @@
         bool included = false;
         for ( int i = 0; i < folders.count(); ++i ) {
             if ( f != folders[i].first &&
-                 f.startsWith( folders[i].first ) )
+                 f.startsWith( KUrl( folders[i].first ).path( KUrl::AddTrailingSlash ) ) )
                 included = folders[i].second;
         }
         return included == include;
@@ -240,6 +241,11 @@
 void Nepomuk::StrigiServiceConfig::buildFolderCache()
 {
     QStringList includeFoldersPlain = m_config.group( "General" ).readPathEntry( "folders", QStringList() << QDir::homePath() );
+    org::kde::nepomuk::RemovableStorage removableStorageService( "org.kde.nepomuk.services.removablestorageservice",
+                                                                 "/removablestorageservice",
+                                                                 QDBusConnection::sessionBus() );
+    if ( removableStorageService.isValid() )
+        includeFoldersPlain << removableStorageService.currentlyMountedAndIndexed();
     QStringList excludeFoldersPlain = m_config.group( "General" ).readPathEntry( "exclude folders", QStringList() );;
 
     m_folderCache.clear();
Index: nepomuk/services/strigi/systray.cpp
===================================================================
--- nepomuk/services/strigi/systray.cpp	(révision 1121160)
+++ nepomuk/services/strigi/systray.cpp	(copie de travail)
@@ -82,7 +82,7 @@
         setStatus( newStatus );
     }
 
-    QString statusString = m_service->userStatusString();
+    QString statusString = m_service->simpleUserStatusString();
     if ( statusString != m_prevStatus ) {
         m_prevStatus = statusString;
         setToolTip("nepomuk", i18n("Search Service"), statusString );
Index: nepomuk/services/strigi/strigiservice.cpp
===================================================================
--- nepomuk/services/strigi/strigiservice.cpp	(révision 1121160)
+++ nepomuk/services/strigi/strigiservice.cpp	(copie de travail)
@@ -24,8 +24,8 @@
 #include "systray.h"
 #include "strigiserviceconfig.h"
 #include "statuswidget.h"
-#include "filesystemwatcher.h"
 #include "useractivitymonitor.h"
+#include "filewatchserviceinterface.h"
 
 #include <KDebug>
 #include <KDirNotify>
@@ -42,10 +42,6 @@
     : Service( parent, true ),
       m_indexManager( 0 )
 {
-    // only so ResourceManager won't open yet another connection to the nepomuk server
-    ResourceManager::instance()->setOverrideMainModel( mainModel() );
-
-
     // lower process priority - we do not want to spoil KDE usage
     // ==============================================================
     if ( !lowerPriority() )
@@ -64,18 +60,6 @@
         // monitor all kinds of events
         ( void )new EventMonitor( m_indexScheduler, this );
 
-        // monitor the file system
-        m_fsWatcher = new FileSystemWatcher( this );
-        m_fsWatcher->setWatchRecursively( true );
-        connect( m_fsWatcher, SIGNAL( dirty( QString ) ),
-                 this, SLOT( slotDirDirty( QString ) ) );
-
-        // monitor all KDE-ish changes for quick updates
-        connect( new org::kde::KDirNotify( QString(), QString(), QDBusConnection::sessionBus(), this ),
-                 SIGNAL( FilesAdded( QString ) ),
-                 this, SLOT( slotDirDirty( const QString& ) ) );
-
-
         // update the watches if the config changes
         connect( StrigiServiceConfig::self(), SIGNAL( configChanged() ),
                  this, SLOT( updateWatches() ) );
@@ -98,23 +82,14 @@
                  this, SIGNAL( statusStringChanged() ) );
         connect( m_indexScheduler, SIGNAL( indexingSuspended(bool) ),
                  this, SIGNAL( statusStringChanged() ) );
-        connect( m_fsWatcher, SIGNAL( statusChanged(FileSystemWatcher::Status) ),
-                 this, SIGNAL( statusStringChanged() ) );
 
         // setup the indexer to index at snail speed for the first two minutes
         // this is done for KDE startup - to not slow that down too much
         m_indexScheduler->setIndexingSpeed( IndexScheduler::SnailPace );
-        QTimer::singleShot( 2*60*1000, m_indexScheduler, SLOT( setReducedIndexingSpeed() ) );
 
-        // slow down on user activity (start also only after 2 minutes)
-        UserActivityMonitor* userActivityMonitor = new UserActivityMonitor( this );
-        connect( userActivityMonitor, SIGNAL( userActive( bool ) ),
-                 m_indexScheduler, SLOT( setReducedIndexingSpeed( bool ) ) );
-        QTimer::singleShot( 2*60*1000, userActivityMonitor, SLOT( start() ) );
+        // delayed init for the rest which uses IO and CPU
+        QTimer::singleShot( 2*60*1000, this, SLOT( finishInitialization() ) );
 
-        // start watching the index folders
-        QTimer::singleShot( 2*60*1000, this, SLOT( updateWatches() ) );
-
         // start the actual indexing
         m_indexScheduler->start();
     }
@@ -139,46 +114,68 @@
 }
 
 
-void Nepomuk::StrigiService::updateWatches()
+void Nepomuk::StrigiService::finishInitialization()
 {
-    // the hard way since the KDirWatch API is too simple
-    QStringList folders = StrigiServiceConfig::self()->includeFolders();
-    if ( folders != m_fsWatcher->folders() ) {
-        m_fsWatcher->setFolders( StrigiServiceConfig::self()->includeFolders() );
-        m_fsWatcher->setInterval( 2*60 ); // check every 2 minutes
-        m_fsWatcher->start();
-    }
+    // slow down on user activity (start also only after 2 minutes)
+    UserActivityMonitor* userActivityMonitor = new UserActivityMonitor( this );
+    connect( userActivityMonitor, SIGNAL( userActive( bool ) ),
+             m_indexScheduler, SLOT( setReducedIndexingSpeed( bool ) ) );
+    userActivityMonitor->start();
+
+    // full speed until the user is active
+    m_indexScheduler->setIndexingSpeed( IndexScheduler::FullSpeed );
+
+    updateWatches();
 }
 
 
-void Nepomuk::StrigiService::slotDirDirty( const QString& path )
+void Nepomuk::StrigiService::updateWatches()
 {
-    if ( StrigiServiceConfig::self()->shouldFolderBeIndexed( path ) ) {
-        m_indexScheduler->updateDir( path );
+    org::kde::nepomuk::FileWatch filewatch( "org.kde.nepomuk.services.nepomukfilewatch",
+                                            "/nepomukfilewatch",
+                                            QDBusConnection::sessionBus() );
+    foreach( const QString& folder, StrigiServiceConfig::self()->includeFolders() ) {
+        filewatch.watchFolder( folder );
     }
 }
 
 
 QString Nepomuk::StrigiService::userStatusString() const
 {
+    return userStatusString( false );
+}
+
+
+QString Nepomuk::StrigiService::simpleUserStatusString() const
+{
+    return userStatusString( true );
+}
+
+
+QString Nepomuk::StrigiService::userStatusString( bool simple ) const
+{
     bool indexing = m_indexScheduler->isIndexing();
     bool suspended = m_indexScheduler->isSuspended();
     QString folder = m_indexScheduler->currentFolder();
 
-    if ( suspended )
+    if ( suspended ) {
         return i18nc( "@info:status", "File indexer is suspended" );
-    else if ( indexing )
-        return i18nc( "@info:status", "Strigi is currently indexing files in folder %1", folder );
-    else if ( m_fsWatcher->status() == FileSystemWatcher::Checking )
-        return i18nc( "@info:status", "Checking file system for new files" );
-    else
+    }
+    else if ( indexing ) {
+        if ( folder.isEmpty() || simple )
+            return i18nc( "@info:status", "Strigi is currently indexing files" );
+        else
+            return i18nc( "@info:status", "Strigi is currently indexing files in folder %1", folder );
+    }
+    else {
         return i18nc( "@info:status", "File indexer is idle" );
+    }
 }
 
 
 bool Nepomuk::StrigiService::isIdle() const
 {
-    return ( !m_indexScheduler->isIndexing() && m_fsWatcher->status() == FileSystemWatcher::Idle );
+    return ( !m_indexScheduler->isIndexing() );
 }
 
 
@@ -186,11 +183,9 @@
 {
     if ( suspend ) {
         m_indexScheduler->suspend();
-        m_fsWatcher->suspend();
     }
     else {
         m_indexScheduler->resume();
-        m_fsWatcher->resume();
     }
 }
 
Index: nepomuk/services/strigi/strigiservice.h
===================================================================
--- nepomuk/services/strigi/strigiservice.h	(révision 1121160)
+++ nepomuk/services/strigi/strigiservice.h	(copie de travail)
@@ -26,7 +26,6 @@
 namespace Strigi {
     class IndexManager;
 }
-class FileSystemWatcher;
 
 namespace Nepomuk {
 
@@ -50,24 +49,28 @@
 
     public Q_SLOTS:
         /**
-         * \return A user readable status string
+         * \return A user readable status string. Includes the currently indexed folder.
          */
         QString userStatusString() const;
+
+        /**
+         * Simplified status string without details.
+         */
+        QString simpleUserStatusString() const;
         bool isIdle() const;
         void setSuspended( bool );
         bool isSuspended() const;
 
     private Q_SLOTS:
+        void finishInitialization();
         void updateWatches();
-        void slotDirDirty( const QString& );
 
     private:
         void updateStrigiConfig();
+        QString userStatusString( bool simple ) const;
 
         Strigi::IndexManager* m_indexManager;
         IndexScheduler* m_indexScheduler;
-
-        FileSystemWatcher* m_fsWatcher;
     };
 }
 
Index: nepomuk/services/strigi/statuswidget.cpp
===================================================================
--- nepomuk/services/strigi/statuswidget.cpp	(révision 1121160)
+++ nepomuk/services/strigi/statuswidget.cpp	(copie de travail)
@@ -1,5 +1,5 @@
 /* This file is part of the KDE Project
-   Copyright (c) 2008 Sebastian Trueg <trueg@kde.org>
+   Copyright (c) 2008-2010 Sebastian Trueg <trueg@kde.org>
 
    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Library General Public
Index: nepomuk/services/strigi/eventmonitor.cpp
===================================================================
--- nepomuk/services/strigi/eventmonitor.cpp	(révision 1121160)
+++ nepomuk/services/strigi/eventmonitor.cpp	(copie de travail)
@@ -43,14 +43,9 @@
 Nepomuk::EventMonitor::EventMonitor( IndexScheduler* scheduler, QObject* parent )
     : QObject( parent ),
       m_indexScheduler( scheduler ),
-      m_pauseState( NotPaused )
+      m_pauseState( NotPaused ),
+      m_totalIndexingSeconds( 0 )
 {
-    // FileSystemWatcher does not catch changes to files, only new and removed files
-    // thus, we also do periodic updates of the whole index every two hours
-    connect( &m_periodicUpdateTimer, SIGNAL( timeout() ),
-             m_indexScheduler, SLOT( updateAll() ) );
-    m_periodicUpdateTimer.setInterval( 2*60*60*1000 );
-
     // monitor the powermanagement to not drain the battery
     connect( Solid::PowerManagement::notifier(), SIGNAL( appShouldConserveResourcesChanged( bool ) ),
              this, SLOT( slotPowerManagementStatusChanged( bool ) ) );
@@ -63,7 +58,7 @@
     if ( StrigiServiceConfig::self()->isInitialRun() ) {
         // TODO: add actions to this notification
 
-        m_initialIndexTime.start();
+        m_indexingStartTime = QDateTime::currentDateTime();
 
         // inform the user about the initial indexing
         sendEvent( "initialIndexingStarted",
@@ -76,10 +71,10 @@
         connect( m_indexScheduler, SIGNAL( indexingStopped() ),
                  this, SLOT( slotIndexingStopped() ),
                  Qt::QueuedConnection );
+                 
+        connect( m_indexScheduler, SIGNAL( indexingSuspended(bool) ),
+                 this, SLOT( slotIndexingSuspended(bool) ) );
     }
-    else {
-        m_periodicUpdateTimer.start();
-    }
 
     slotPowerManagementStatusChanged( Solid::PowerManagement::appShouldConserveResources() );
 }
@@ -94,16 +89,14 @@
 {
     if ( !conserveResources && m_pauseState == PausedDueToPowerManagement ) {
         kDebug() << "Resuming indexer due to power management";
-        m_pauseState = NotPaused;
-        m_indexScheduler->resume();
+        resumeIndexing();
         sendEvent( "indexingResumed", i18n("Resuming indexing of files for fast searching."), "battery-charging" );
     }
     else if ( conserveResources &&
               m_indexScheduler->isRunning() &&
               !m_indexScheduler->isSuspended() ) {
         kDebug() << "Pausing indexer due to power management";
-        m_pauseState = PausedDueToPowerManagement;
-        m_indexScheduler->suspend();
+        pauseIndexing( PausedDueToPowerManagement );
         sendEvent( "indexingSuspended", i18n("Suspending the indexing of files to preserve resources."), "battery-100" );
     }
 }
@@ -116,8 +109,7 @@
         if ( info.available() <= StrigiServiceConfig::self()->minDiskSpace() ) {
             if ( m_indexScheduler->isRunning() &&
                 !m_indexScheduler->isSuspended() ) {
-                m_pauseState = PausedDueToAvailSpace;
-                m_indexScheduler->suspend();
+                pauseIndexing( PausedDueToAvailSpace );
                 sendEvent( "indexingSuspended",
                            i18n("Disk space is running low (%1 left). Suspending indexing of files.",
                                 KIO::convertSize( info.available() ) ),
@@ -126,8 +118,7 @@
         }
         else if ( m_pauseState == PausedDueToAvailSpace ) {
             kDebug() << "Resuming indexer due to disk space";
-            m_pauseState = NotPaused;
-            m_indexScheduler->resume();
+            resumeIndexing();
             sendEvent( "indexingResumed", i18n("Resuming indexing of files for fast searching."), "drive-harddisk" );
         }
     }
@@ -142,16 +133,48 @@
 {
     // inform the user about the end of initial indexing. This will only be called once
     if ( !m_indexScheduler->isSuspended() ) {
-        kDebug() << "initial indexing took" << m_initialIndexTime.elapsed();
+        m_totalIndexingSeconds += m_indexingStartTime.secsTo( QDateTime::currentDateTime() );
+        const int elapsed = m_totalIndexingSeconds * 1000;
+        
+        kDebug() << "initial indexing took" << elapsed;
         sendEvent( "initialIndexingFinished",
-                   i18nc( "@info %1 is a duration formatted using KLocale::formatDuration",
+                   i18nc( "@info %1 is a duration formatted using KLocale::prettyFormatDuration",
                           "Initial indexing of files for fast searching finished in %1",
-                          KGlobal::locale()->formatDuration( m_initialIndexTime.elapsed() ) ),
+                          KGlobal::locale()->prettyFormatDuration( elapsed ) ),
                    "nepomuk" );
         m_indexScheduler->disconnect( this );
+    }
+}
 
-        m_periodicUpdateTimer.start();
+
+void Nepomuk::EventMonitor::pauseIndexing(int pauseState)
+{
+    m_pauseState = pauseState;
+    m_indexScheduler->suspend();
+
+    m_totalIndexingSeconds += m_indexingStartTime.secsTo( QDateTime::currentDateTime() );
+}
+
+
+void Nepomuk::EventMonitor::resumeIndexing()
+{
+    m_pauseState = NotPaused;
+    m_indexScheduler->resume();
+
+    m_indexingStartTime = QDateTime::currentDateTime();
+}
+
+
+void Nepomuk::EventMonitor::slotIndexingSuspended( bool suspended )
+{
+    if( suspended ) {
+        //The indexing is already paused, this meerly sets the correct state, and adjusts the timing.
+        pauseIndexing( PausedCustom );
     }
+    else {
+        //Again, used to set the correct state, and adjust the timing.
+        resumeIndexing();
+    }
 }
 
 #include "eventmonitor.moc"
Index: nepomuk/services/strigi/CMakeLists.txt
===================================================================
--- nepomuk/services/strigi/CMakeLists.txt	(révision 1121160)
+++ nepomuk/services/strigi/CMakeLists.txt	(copie de travail)
@@ -33,7 +33,6 @@
   eventmonitor.cpp
   systray.cpp
   statuswidget.cpp
-  filesystemwatcher.cpp
   useractivitymonitor.cpp
   )
 
@@ -48,6 +47,9 @@
   "Nepomuk::Vocabulary"
   "trig")
 
+qt4_add_dbus_interface(strigiservice_SRCS ../../interfaces/org.kde.nepomuk.RemovableStorage.xml removablestorageserviceinterface)
+qt4_add_dbus_interface(strigiservice_SRCS ../../interfaces/org.kde.nepomuk.FileWatch.xml filewatchserviceinterface)
+
 kde4_add_ui_files(strigiservice_SRCS
   statuswidget.ui)
 
@@ -59,7 +61,7 @@
   ${KDE4_KDEUI_LIBS}
   ${KDE4_KIO_LIBS}
   ${KDE4_SOLID_LIBS}
-  ${KDE4_KUTILS_LIBS}
+  ${KDE4_KIDLETIME_LIBS}
   ${NEPOMUK_LIBRARIES}
   ${SOPRANO_LIBRARIES}
   )
Index: nepomuk/services/strigi/strigiserviceadaptor.cpp
===================================================================
--- nepomuk/services/strigi/strigiserviceadaptor.cpp	(révision 1121160)
+++ nepomuk/services/strigi/strigiserviceadaptor.cpp	(copie de travail)
@@ -72,6 +72,12 @@
 }
 
 
+QString Nepomuk::StrigiServiceAdaptor::currentFile()
+{
+    return m_service->indexScheduler()->currentFile();
+}
+
+
 void Nepomuk::StrigiServiceAdaptor::resume()
 {
     // handle method call org.kde.nepomuk.Strigi.resume
Index: nepomuk/services/storage/repository.cpp
===================================================================
--- nepomuk/services/storage/repository.cpp	(révision 1121160)
+++ nepomuk/services/storage/repository.cpp	(copie de travail)
@@ -204,7 +206,6 @@
                 kDebug() << "Starting model conversion";
 
                 convertingData = true;
-                // No need to use the index filter as it already contains the data
                 m_modelCopyJob = new ModelCopyJob( oldModel, m_model, this );
                 connect( m_modelCopyJob, SIGNAL( result( KJob* ) ), this, SLOT( copyFinished( KJob* ) ) );
                 m_modelCopyJob->start();
Index: nepomuk/services/storage/nepomukcore.cpp
===================================================================
--- nepomuk/services/storage/nepomukcore.cpp	(révision 1121160)
+++ nepomuk/services/storage/nepomukcore.cpp	(copie de travail)
@@ -28,7 +28,7 @@
 
 #include <Soprano/BackendSetting>
 
-static const char* s_repositoryName = "main";
+static const char s_repositoryName[] = "main";
 
 Nepomuk::Core::Core( QObject* parent )
     : Soprano::Server::ServerCore( parent ),
Index: nepomuk/services/storage/nepomukstorage.desktop
===================================================================
--- nepomuk/services/storage/nepomukstorage.desktop	(révision 1121160)
+++ nepomuk/services/storage/nepomukstorage.desktop	(copie de travail)
@@ -33,6 +33,7 @@
 Name[hr]=Nepomuk Pohrana Podataka
 Name[hsb]=Nepomuk składowanje datow
 Name[hu]=Nepomuk adattároló
+Name[ia]=Nepomuk Storage de Datos
 Name[id]=Penyimpanan Data Nepomuk
 Name[is]=Nepomuk gagnageymsla
 Name[it]=Memorizzazione di dati di Nepomuk
@@ -105,6 +106,7 @@
 Comment[hr]=Nepomukova sržna usluga pohrane podataka
 Comment[hsb]=Centralna Nepomukowa słužba za składowanje datow
 Comment[hu]=Nepomuk adattároló alapszolgáltatás
+Comment[ia]=Le servicio de storage de datos  del Corde de Nepomuk
 Comment[id]=Layanan penyimpanan data Inti Nepomuk
 Comment[is]=Kjarni Nepomuk gagnageymslumiðlunar
 Comment[it]=Il servizio principale di memorizzazione dati di Nepomuk
@@ -140,7 +142,7 @@
 Comment[sv]=Nepomuk-datalagringstjänstens kärna
 Comment[ta]=The Core Nepomuk data storage service
 Comment[te]=ఆధార Nepomuk డాటా నిల్వ సేవ
-Comment[tg]=Основная служба хранения данных Nepomuk
+Comment[tg]=Хидмати асосии захирагоҳи Nepomuk
 Comment[th]=บริการจัดเก็บข้อมูลระดับแกนของ Nepomik
 Comment[tr]=Nepomuk Ana veri depolama servisi
 Comment[uk]=Ядро служби збереження даних Nepomuk
Index: nepomuk/services/activities/nepomukactivitiesservice.cpp
===================================================================
--- nepomuk/services/activities/nepomukactivitiesservice.cpp	(révision 0)
+++ nepomuk/services/activities/nepomukactivitiesservice.cpp	(révision 0)
@@ -0,0 +1,321 @@
+/*
+ * Copyright (c) 2010 Ivan Cukic <ivan.cukic(at)kde.org>
+ * Copyright (c) 2008 Sebastian Trueg <trueg@kde.org>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License version 2 as published by the Free Software Foundation.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public License
+ * along with this library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#include "nepomukactivitiesservice.h"
+#include "activitiesserviceadaptor.h"
+
+#include <QUuid>
+#include <QDebug>
+
+#include <KPluginFactory>
+#include <KDebug>
+#include <KConfig>
+#include <KStandardDirs>
+
+#include <Soprano/Model>
+#include <Soprano/StatementIterator>
+#include <Soprano/Statement>
+#include <Soprano/Node>
+#include <Soprano/NodeIterator>
+#include <Soprano/QueryResultIterator>
+#include <Soprano/Vocabulary/NAO>
+#include <Soprano/Vocabulary/RDF>
+
+#include <Nepomuk/Resource>
+#include <Nepomuk/ResourceManager>
+#include <Nepomuk/Variant>
+#include <Nepomuk/Query/Query>
+#include <Nepomuk/Query/AndTerm>
+#include <Nepomuk/Query/OrTerm>
+#include <Nepomuk/Query/ComparisonTerm>
+#include <Nepomuk/Query/ResourceTypeTerm>
+#include <Nepomuk/Query/ResourceTerm>
+#include <Nepomuk/Query/LiteralTerm>
+
+#include "nie.h"
+
+#define URL_ACTIVITY_TYPE "http://www.kde.org/ontologies/activities#Activity"
+#define ACTIVITIES_PROTOCOL "activities://"
+
+/**
+ * this macro creates a service factory which can then be found by the Qt/KDE
+ * plugin system in the Nepomuk server.
+ */
+NEPOMUK_EXPORT_SERVICE( NepomukActivitiesService, "nepomukactivitiesservice" )
+
+NepomukActivitiesService::NepomukActivitiesService(QObject * parent, const QList < QVariant > & params)
+    : Nepomuk::Service( parent )
+{
+    kDebug() << "started";
+
+    Q_UNUSED(parent)
+    Q_UNUSED(params)
+
+    Nepomuk::ResourceManager::instance()->init();
+
+    new NepomukActivitiesServiceAdaptor(this);
+
+    m_model = mainModel();
+
+    setServiceInitialized(true);
+}
+
+NepomukActivitiesService::~NepomukActivitiesService()
+{
+}
+
+QStringList NepomukActivitiesService::listAvailable() const
+{
+    QStringList result;
+
+    foreach (const Nepomuk::Resource & resource,
+            Nepomuk::ResourceManager::instance()->allResourcesOfType(QUrl(URL_ACTIVITY_TYPE))) {
+
+        kDebug() << "url for resource" << resource << urlForResource(resource);
+
+        result << activityId(resource);
+    }
+
+    return result;
+}
+
+void NepomukActivitiesService::add(const QString & id, const QString & name)
+{
+    Nepomuk::Resource activity = activityResource(id);
+    activity.setLabel(name);
+    activity.addType(QUrl(URL_ACTIVITY_TYPE));
+    activity.addIdentifier(ACTIVITIES_PROTOCOL + id);
+
+    kDebug() << activity << id << name;
+}
+
+void NepomukActivitiesService::remove(const QString & id)
+{
+    Nepomuk::Resource activity = activityResource(id);
+
+    kDebug() << activity << id;
+
+    activity.remove();
+}
+
+QString NepomukActivitiesService::name(const QString & id) const
+{
+    return activityResource(id).label();
+}
+
+void NepomukActivitiesService::setName(const QString & id, const QString & name)
+{
+    activityResource(id).setLabel(name);
+}
+
+QString NepomukActivitiesService::icon(const QString & id) const
+{
+    QStringList symbols = activityResource(id).symbols();
+
+    if (symbols.isEmpty()) {
+        return QString();
+    } else {
+        return symbols.first();
+    }
+}
+
+void NepomukActivitiesService::setIcon(const QString & id, const QString & icon)
+{
+    QStringList symbols;
+
+    symbols << icon;
+
+    activityResource(id).setSymbols(symbols);
+}
+
+QString NepomukActivitiesService::resourceUri(const QString & id) const
+{
+    return KUrl(activityResource(id).resourceUri()).url();
+}
+
+QString NepomukActivitiesService::uri(const QString & id) const
+{
+    return ACTIVITIES_PROTOCOL + id;
+}
+
+void NepomukActivitiesService::associateResource(const QString & activityId,
+    const QString & resourceUri, const QString & typeUri)
+{
+    Nepomuk::Resource activity = activityResource(activityId);
+    Nepomuk::Resource resource = Nepomuk::Resource(resourceUri);
+
+    kDebug() << activity << resource;
+
+    activity.addIsRelated(resource);
+
+    if (!typeUri.isEmpty()) {
+        resource.addType(QUrl(typeUri));
+        kDebug() << "set the resource type to" << typeUri;
+    }
+}
+
+void NepomukActivitiesService::disassociateResource(const QString & activityId,
+    const QString & resourceUri)
+{
+    Nepomuk::Resource activity = activityResource(activityId);
+    Nepomuk::Resource resource = Nepomuk::Resource(resourceUri);
+
+    kDebug() << activity << resource;
+
+    QList< Nepomuk::Resource > v = activity.isRelateds();
+    v.removeAll(resource);
+    activity.setIsRelateds(v);
+}
+
+QStringList NepomukActivitiesService::associatedResources(
+    const QString & id, const QString & resourceType) const
+{
+
+    Nepomuk::Resource activity = activityResource(id);
+
+    Nepomuk::Query::Term term = Nepomuk::Query::ComparisonTerm(
+            Soprano::Vocabulary::NAO::isRelated(),
+            Nepomuk::Query::ResourceTerm(activity)
+        ).inverted();
+
+    if (!resourceType.isEmpty()) {
+        // OrTerm so that we can support programs that use
+        // types not available in ontologies
+        KUrl resourceTypeUri(resourceType);
+
+        term = Nepomuk::Query::AndTerm(
+            term,
+            Nepomuk::Query::OrTerm(
+                Nepomuk::Query::ComparisonTerm(
+                    Soprano::Vocabulary::RDF::type(),
+                    Nepomuk::Query::ResourceTerm(Nepomuk::Resource(resourceTypeUri))
+                ),
+                Nepomuk::Query::ResourceTypeTerm(resourceTypeUri)
+            )
+        );
+    }
+
+    Nepomuk::Query::Query query(term);
+
+    Soprano::QueryResultIterator it = m_model->executeQuery(query.toSparqlQuery(),
+        Soprano::Query::QueryLanguageSparql );
+
+    QStringList result;
+
+    while ( it.next() ) {
+        QUrl uri = it["r"].uri();
+
+        Nepomuk::Resource resource(uri);
+
+        result << urlForResource(resource);
+    }
+
+    return result;
+}
+
+QStringList NepomukActivitiesService::forResource(const QString & uri) const
+{
+    kDebug() << "uri" << uri;
+
+    Nepomuk::Resource resource = Nepomuk::Resource(KUrl(uri));
+    Nepomuk::Resource activityType(QUrl(URL_ACTIVITY_TYPE));
+
+    Nepomuk::Query::Query query(
+        Nepomuk::Query::AndTerm(
+            Nepomuk::Query::ComparisonTerm(
+                Soprano::Vocabulary::RDF::type(),
+                Nepomuk::Query::ResourceTerm(activityType)
+            ),
+            Nepomuk::Query::ComparisonTerm(
+                Soprano::Vocabulary::NAO::isRelated(),
+                Nepomuk::Query::ResourceTerm(resource)
+            )
+        )
+    );
+
+    Soprano::QueryResultIterator it = m_model->executeQuery(query.toSparqlQuery(),
+        Soprano::Query::QueryLanguageSparql);
+
+    QStringList result;
+
+    while ( it.next() ) {
+        QUrl uri = it["r"].uri();
+
+        Nepomuk::Resource resource(uri);
+
+        kDebug() << urlForResource(resource);
+
+        result << activityId(resource);
+    }
+
+    return result;
+
+}
+
+void NepomukActivitiesService::_deleteAll()
+{
+    foreach (Nepomuk::Resource resource,
+            Nepomuk::ResourceManager::instance()->allResourcesOfType(QUrl(URL_ACTIVITY_TYPE))) {
+        kDebug() << "NepomukActivitiesService::_deleteAllActivities: resource: " << resource <<
+                resource.exists();
+        resource.remove();
+    }
+}
+
+QString NepomukActivitiesService::_serviceIteration() const
+{
+    return "0.3";
+}
+
+// Private
+
+Nepomuk::Resource NepomukActivitiesService::activityResource(const QString & id) const
+{
+    return Nepomuk::Resource(KUrl(ACTIVITIES_PROTOCOL + id));
+}
+
+QString NepomukActivitiesService::urlForResource(const Nepomuk::Resource & resource) const
+{
+    if (resource.identifiers().size()) {
+        return resource.identifiers()[0];
+
+    } else if (resource.hasProperty(Ontologies::nie::url())) {
+        return KUrl(resource.property(Ontologies::nie::url()).toUrl()).url();
+
+    } else {
+        kDebug() << resource.properties().keys();
+
+        return KUrl(resource.resourceUri()).url();
+
+    }
+}
+
+QString NepomukActivitiesService::activityId(const Nepomuk::Resource & resource) const
+{
+    foreach(QString identifier, resource.identifiers()) { // krazy:exclude=foreach
+        if (identifier.startsWith(ACTIVITIES_PROTOCOL)) {
+            return identifier.replace(QLatin1String(ACTIVITIES_PROTOCOL), QString());
+        }
+    }
+
+    return KUrl(resource.resourceUri()).url()
+            .replace(QLatin1String(ACTIVITIES_PROTOCOL), QString());
+}
+
+#include "nepomukactivitiesservice.moc"

Modification de propriétés sur nepomuk/services/activities/nepomukactivitiesservice.cpp
___________________________________________________________________
Ajouté : svn:eol-style
   + native

Index: nepomuk/services/activities/org.kde.nepomuk.ActivitiesService.xml
===================================================================
--- nepomuk/services/activities/org.kde.nepomuk.ActivitiesService.xml	(révision 0)
+++ nepomuk/services/activities/org.kde.nepomuk.ActivitiesService.xml	(révision 0)
@@ -0,0 +1,70 @@
+<!DOCTYPE node PUBLIC "-//freedesktop//DTD D-BUS Object Introspection 1.0//EN" "http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd">
+<node>
+  <interface name="org.kde.nepomuk.services.NepomukActivitiesService">
+    <method name="listAvailable">
+      <arg type="as" direction="out"/>
+    </method>
+    <method name="add">
+      <arg name="activityId" type="s" direction="in"/>
+      <arg name="activityName" type="s" direction="in"/>
+    </method>
+    <method name="remove">
+      <arg name="activityId" type="s" direction="in"/>
+    </method>
+    <method name="name">
+      <arg type="s" direction="out"/>
+      <arg name="activityId" type="s" direction="in"/>
+    </method>
+    <method name="setName">
+      <arg name="activityId" type="s" direction="in"/>
+      <arg name="name" type="s" direction="in"/>
+    </method>
+    <method name="icon">
+      <arg type="s" direction="out"/>
+      <arg name="activityId" type="s" direction="in"/>
+    </method>
+    <method name="setIcon">
+      <arg name="activityId" type="s" direction="in"/>
+      <arg name="name" type="s" direction="in"/>
+    </method>
+    <method name="resourceUri">
+      <arg type="s" direction="out"/>
+      <arg name="activityId" type="s" direction="in"/>
+    </method>
+    <method name="uri">
+      <arg type="s" direction="out"/>
+      <arg name="activityId" type="s" direction="in"/>
+    </method>
+    <method name="associateResource">
+      <arg name="activityID" type="s" direction="in"/>
+      <arg name="resourceUri" type="s" direction="in"/>
+      <arg name="typeUri" type="s" direction="in"/>
+    </method>
+    <method name="associateResource">
+      <arg name="activityID" type="s" direction="in"/>
+      <arg name="resourceUri" type="s" direction="in"/>
+    </method>
+    <method name="disassociateResource">
+      <arg name="activityID" type="s" direction="in"/>
+      <arg name="resourceUri" type="s" direction="in"/>
+    </method>
+    <method name="associatedResources">
+      <arg type="as" direction="out"/>
+      <arg name="activityId" type="s" direction="in"/>
+      <arg name="resourceType" type="s" direction="in"/>
+    </method>
+    <method name="associatedResources">
+      <arg type="as" direction="out"/>
+      <arg name="activityId" type="s" direction="in"/>
+    </method>
+    <method name="forResource">
+      <arg type="as" direction="out"/>
+      <arg name="uri" type="s" direction="in"/>
+    </method>
+    <method name="_deleteAll">
+    </method>
+    <method name="_serviceIteration">
+      <arg type="s" direction="out"/>
+    </method>
+  </interface>
+</node>
Index: nepomuk/services/activities/nepomukactivitiesservice.h
===================================================================
--- nepomuk/services/activities/nepomukactivitiesservice.h	(révision 0)
+++ nepomuk/services/activities/nepomukactivitiesservice.h	(révision 0)
@@ -0,0 +1,162 @@
+/*
+ * Copyright (c) 2010 Ivan Cukic <ivan.cukic(at)kde.org>
+ * Copyright (c) 2008 Sebastian Trueg <trueg@kde.org>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License version 2 as published by the Free Software Foundation.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public License
+ * along with this library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifndef NEPOMUK_ACTIVITIES_SERVICE_H
+#define NEPOMUK_ACTIVITIES_SERVICE_H
+
+#include <Nepomuk/Service>
+#include <Nepomuk/Resource>
+
+#include <QtCore/QVariant>
+#include <QtCore/QUrl>
+
+#include <KConfigGroup>
+
+/**
+ * Nepomuk service for storing workspace activities
+ */
+class NepomukActivitiesService: public Nepomuk::Service {
+    Q_OBJECT
+    Q_CLASSINFO("D-Bus Interface", "org.kde.nepomuk.services.NepomukActivitiesService")
+
+public:
+    /**
+     * Creates a new ActivitiesService
+     */
+    NepomukActivitiesService(QObject* parent, const QVariantList & args);
+
+    /**
+     * Destroys this ActivitiesService
+     */
+    ~NepomukActivitiesService();
+
+public Q_SLOTS:
+    /**
+     * @returns the list of all activities
+     */
+    QStringList listAvailable() const;
+
+    /**
+     * Creates a new activity. If the activity already
+     * exists, only the name is set
+     * @param activityId id to be used
+     * @param activityName name of the activity
+     */
+    void add(const QString & activityId,
+            const QString & activityName);
+
+    /**
+     * Remove the specified activity
+     * @param activityId id of the activity to delete
+     */
+    void remove(const QString & activityId);
+
+    /**
+     * @returns the name of the specified activity
+     * @param activityId id of the activity
+     */
+    QString name(const QString & activityId) const;
+
+    /**
+     * Sets the name of the specified activity
+     * @param activityId id of the activity
+     * @param name name to be set
+     */
+    void setName(const QString & activityId, const QString & name);
+
+    /**
+     * @returns the icon of the specified activity
+     * @param activityId id of the activity
+     */
+    QString icon(const QString & activityId) const;
+
+    /**
+     * Sets the icon of the specified activity.
+     * @param activityId id of the activity
+     * @param icon path or freedesktop.org icon name
+     */
+    void setIcon(const QString & activityId, const QString & icon);
+
+    /**
+     * @returns the Nepomuk URI of the specified activity
+     * @param activityId id of the activity
+     */
+    QString resourceUri(const QString & activityId) const;
+
+    /**
+     * @returns activity uri for the specified activity
+     * @param activityId id of the activity
+     */
+    QString uri(const QString & activityId) const;
+
+    /**
+     * Links the resource and the activity. (Adds 'is related to' link
+     * from the resource to the activity)
+     * @param activityID id of the activity
+     * @param resourceUri Nepomuk resource URI
+     * @param typeUri type to assign to the resource to be linked
+     */
+    void associateResource(const QString & activityID,
+        const QString & resourceUri, const QString & typeUri = QString());
+
+    /**
+     * Unlinks the resource and the activity. (Removes 'is related to' link
+     * from the resource to the activity)
+     * @param activityID id of the activity
+     * @param resourceUri Nepomuk resource URI
+     */
+    void disassociateResource(const QString & activityID,
+        const QString & resourceUri);
+
+    /**
+     * @returns the list of resources that are related to
+     * the specified activity
+     * @param activityId id of the activity
+     */
+    QStringList associatedResources(const QString & activityId, const QString & resourceType = QString()) const;
+
+    /**
+     * @returns the list of activities associated with the
+     * specified resource
+     */
+    QStringList forResource(const QString & uri) const;
+
+    /**
+     * This function is for debugging purposes only,
+     * and will be deleted
+     */
+    void _deleteAll();
+
+    /**
+     * This function is for debugging purposes only,
+     * and will be deleted
+     */
+    QString _serviceIteration() const;
+
+private:
+    Soprano::Model * m_model;
+
+    Nepomuk::Resource activityResource(const QString & activityId) const;
+    QString activityId(const Nepomuk::Resource & resource) const;
+
+    QString urlForResource(const Nepomuk::Resource & resource) const;
+
+};
+
+#endif // NEPOMUK_ACTIVITIES_SERVICE_H

Modification de propriétés sur nepomuk/services/activities/nepomukactivitiesservice.h
___________________________________________________________________
Ajouté : svn:eol-style
   + native

Index: nepomuk/services/activities/nepomukactivitiesservice.desktop
===================================================================
--- nepomuk/services/activities/nepomukactivitiesservice.desktop	(révision 0)
+++ nepomuk/services/activities/nepomukactivitiesservice.desktop	(révision 0)
@@ -0,0 +1,19 @@
+[Desktop Entry]
+Type=Service
+ServiceTypes=NepomukService
+X-KDE-Library=nepomukactivitiesservice
+X-KDE-Nepomuk-autostart=true
+X-KDE-Nepomuk-start-on-demand=false
+Name=Nepomuk Activities Service
+Name[en_GB]=Nepomuk Activities Service
+Name[ia]=Servicio de Activitate de Nepomuk
+Name[km]=សេវា​សកម្មភាព​របស់ Nepomuk
+Name[lt]=Nepomuk veiklų tarnyba
+Name[nds]=Nepomuk-Aktivitetendeenst
+Name[nl]=Nepomuk activiteitenservice
+Name[pt]=Serviço de Actividades do Nepomuk
+Name[pt_BR]=Serviço de Atividades do Nepomuk
+Name[sv]=Nepomuk aktivitetstjänst
+Name[uk]=Служба просторів дій Nepomuk
+Name[x-test]=xxNepomuk Activities Servicexx
+Comment=
Index: nepomuk/services/activities/CMakeLists.txt
===================================================================
--- nepomuk/services/activities/CMakeLists.txt	(révision 0)
+++ nepomuk/services/activities/CMakeLists.txt	(révision 0)
@@ -0,0 +1,48 @@
+include(SopranoAddOntology)
+
+set(nepomukactivitiesservice_SRCS
+   nepomukactivitiesservice.cpp
+   )
+
+qt4_add_dbus_adaptor(nepomukactivitiesservice_SRCS
+   org.kde.nepomuk.ActivitiesService.xml
+   nepomukactivitiesservice.h
+   NepomukActivitiesService
+   )
+
+soprano_add_ontology(
+   nepomukactivitiesservice_SRCS
+   "${SHAREDDESKTOPONTOLOGIES_ROOT_DIR}/nie/nie.trig"
+   "nie"
+   "Ontologies"
+   "trig"
+   )
+
+kde4_add_plugin(
+   nepomukactivitiesservice ${nepomukactivitiesservice_SRCS}
+   )
+
+target_link_libraries(nepomukactivitiesservice
+   ${SOPRANO_CLIENT_LIBRARIES}
+   ${SOPRANO_LIBRARIES}
+   ${QT_QTCORE_LIBRARY}
+   ${QT_QTDBUS_LIBRARY}
+   ${KDE4_KDECORE_LIBS}
+   ${NEPOMUK_LIBRARIES}
+   ${NEPOMUK_QUERY_LIBRARIES}
+   )
+
+install(
+   FILES nepomukactivitiesservice.desktop
+   DESTINATION ${SERVICES_INSTALL_DIR}
+   )
+
+install(
+   TARGETS nepomukactivitiesservice
+   DESTINATION ${PLUGIN_INSTALL_DIR}
+   )
+
+# install(FILES
+#    org.kde.nepomuk.ActivitiesService.xml
+#    DESTINATION ${DBUS_INTERFACES_INSTALL_DIR}
+#    )

Modification de propriétés sur nepomuk/services/activities/CMakeLists.txt
___________________________________________________________________
Ajouté : svn:eol-style
   + native

Index: nepomuk/services/filewatch/metadatamover.h
===================================================================
--- nepomuk/services/filewatch/metadatamover.h	(révision 1121160)
+++ nepomuk/services/filewatch/metadatamover.h	(copie de travail)
@@ -68,7 +68,7 @@
          * If old pre-KDE 4.4 file:/ resource URIs are used these are
          * updated to the new nepomuk:/res/<UUID> scheme
          */
-        void updateMetadata( const KUrl& from, const KUrl& to );
+        void updateMetadata( const KUrl& from, const KUrl& to, bool includeChildren = true );
 
         /**
          * Convert old pre-KDE 4.4 style file:/ resource URIs to the
Index: nepomuk/services/filewatch/kinotify.h
===================================================================
--- nepomuk/services/filewatch/kinotify.h	(révision 0)
+++ nepomuk/services/filewatch/kinotify.h	(révision 0)
@@ -0,0 +1,176 @@
+/* This file is part of the KDE libraries
+   Copyright (C) 2007-2010 Sebastian Trueg <trueg@kde.org>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public License
+   along with this library; see the file COPYING.LIB.  If not, write to
+   the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.
+*/
+
+#ifndef _KINOTIFY_H_
+#define _KINOTIFY_H_
+
+#include <QtCore/QObject>
+#include <QtCore/QFlags>
+
+/**
+ * A simple wrapper around inotify which only allows
+ * to add folders recursively.
+ */
+class KInotify : public QObject
+{
+    Q_OBJECT
+
+public:
+    KInotify( QObject* parent );
+    ~KInotify();
+
+    /**
+     * Inotify events that can occur. Use with addWatch
+     * to define the events that should be watched.
+     *
+     * These flags correspond to the native Linux inotify flags.
+     */
+    enum WatchEvent {
+        EventAccess = 0x00000001, /**< File was accessed (read, compare inotify's IN_ACCESS) */
+        EventAttributeChange = 0x00000004, /**< Metadata changed (permissions, timestamps, extended attributes, etc., compare inotify's IN_ATTRIB) */
+        EventCloseWrite = 0x00000008, /**< File opened for writing was closed (compare inotify's IN_CLOSE_WRITE) */
+        EventCloseRead = 0x00000010, /**< File not opened for writing was closed (compare inotify's IN_CLOSE_NOWRITE) */
+        EventCreate = 0x00000100, /** File/directory created in watched directory (compare inotify's IN_CREATE) */
+        EventDelete = 0x00000200, /**< File/directory deleted from watched directory (compare inotify's IN_DELETE) */
+        EventDeleteSelf = 0x00000400, /**< Watched file/directory was itself deleted (compare inotify's IN_DELETE_SELF) */
+        EventModify = 0x00000002, /**< File was modified (compare inotify's IN_MODIFY) */
+        EventMoveSelf = 0x00000800, /**< Watched file/directory was itself moved (compare inotify's IN_MOVE_SELF) */
+        EventMoveFrom = 0x00000040, /**< File moved out of watched directory (compare inotify's IN_MOVED_FROM) */
+        EventMoveTo = 0x00000080, /**< File moved into watched directory (compare inotify's IN_MOVED_TO) */
+        EventOpen = 0x00000020, /**< File was opened (compare inotify's IN_OPEN) */
+        EventUnmount = 0x00002000, /**< Backing fs was unmounted (compare inotify's IN_UNMOUNT) */
+        EventQueueOverflow = 0x00004000, /**< Event queued overflowed (compare inotify's IN_Q_OVERFLOW) */
+        EventIgnored = 0x00008000, /**< File was ignored (compare inotify's IN_IGNORED) */
+        EventMove = ( EventMoveFrom|EventMoveTo),
+        EventAll = ( EventAccess|
+                     EventAttributeChange|
+                     EventCloseWrite|
+                     EventCloseRead|
+                     EventCreate|
+                     EventDelete|
+                     EventDeleteSelf|
+                     EventModify|
+                     EventMoveSelf|
+                     EventMoveFrom|
+                     EventMoveTo|
+                     EventOpen )
+    };
+    Q_DECLARE_FLAGS(WatchEvents, WatchEvent)
+
+    /**
+     * Watch flags
+     *
+     * These flags correspond to the native Linux inotify flags.
+     */
+    enum WatchFlag {
+        FlagOnlyDir = 0x01000000, /**< Only watch the path if it is a directory (IN_ONLYDIR) */
+        FlagDoNotFollow = 0x02000000, /**< Don't follow a sym link (IN_DONT_FOLLOW) */
+        FlagOneShot = 0x80000000 /**< Only send event once (IN_ONESHOT) */
+    };
+    Q_DECLARE_FLAGS(WatchFlags, WatchFlag)
+
+    /**
+     * \return \p true if inotify is available and usable.
+     */
+    bool available() const;
+
+    bool watchingPath( const QString& path ) const;
+
+public Q_SLOTS:
+    bool addWatch( const QString& path, WatchEvents modes, WatchFlags flags = WatchFlags() );
+    bool removeWatch( const QString& path );
+
+Q_SIGNALS:
+    /**
+     * Emitted if a file is accessed (KInotify::EventAccess)
+     */
+    void accessed( const QString& file );
+
+    /**
+     * Emitted if file attributes are changed (KInotify::EventAttributeChange)
+     */
+    void attributeChanged( const QString& file );
+
+    /**
+     * Emitted if FIXME (KInotify::EventCloseWrite)
+     */
+    void closedWrite( const QString& file );
+
+    /**
+     * Emitted if FIXME (KInotify::EventCloseRead)
+     */
+    void closedRead( const QString& file );
+
+    /**
+     * Emitted if a new file has been created in one of the watched
+     * folders (KInotify::EventCreate)
+     */
+    void created( const QString& file );
+
+    /**
+     * Emitted if a watched file or folder has been deleted.
+     * This includes files in watched foldes (KInotify::EventDelete and KInotify::EventDeleteSelf)
+     */
+    void deleted( const QString& file );
+
+    /**
+     * Emitted if a watched file is modified (KInotify::EventModify)
+     */
+    void modified( const QString& file );
+
+    /**
+     * Emitted if a file or folder has been moved or renamed.
+     *
+     * \warning The moved signal will only be emitted if both the source and target folder
+     * are being watched.
+     */
+    void moved( const QString& oldName, const QString& newName );
+
+    /**
+     * Emitted if a file is opened (KInotify::EventOpen)
+     */
+    void opened( const QString& file );
+
+    /**
+     * Emitted if a watched path has been unmounted (KInotify::EventUnmount)
+     */
+    void unmounted( const QString& file );
+
+    /**
+     * Emitted if during updating the internal watch structures (recursive watches)
+     * the inotify user watch limit was reached.
+     *
+     * This means that not all requested paths can be watched until the user watch
+     * limit is increased.
+     *
+     * This signal will only be emitted once.
+     */
+    void watchUserLimitReached();
+
+private Q_SLOTS:
+    void slotEvent( int );
+
+private:
+    class Private;
+    Private* const d;
+
+    Q_PRIVATE_SLOT( d, void _k_addWatches() )
+};
+
+#endif

Modification de propriétés sur nepomuk/services/filewatch/kinotify.h
___________________________________________________________________
Ajouté : svn:eol-style
   + native

Index: nepomuk/services/filewatch/nepomukfilewatch.cpp
===================================================================
--- nepomuk/services/filewatch/nepomukfilewatch.cpp	(révision 1121160)
+++ nepomuk/services/filewatch/nepomukfilewatch.cpp	(copie de travail)
@@ -1,5 +1,5 @@
 /* This file is part of the KDE Project
-   Copyright (c) 2007-2008 Sebastian Trueg <trueg@kde.org>
+   Copyright (c) 2007-2010 Sebastian Trueg <trueg@kde.org>
 
    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Library General Public
@@ -18,33 +18,68 @@
 
 #include "nepomukfilewatch.h"
 #include "metadatamover.h"
+#include "strigiserviceinterface.h"
+#include "../strigi/priority.h"
+#include "nie.h"
 
+#ifdef BUILD_KINOTIFY
+#include "kinotify.h"
+#endif
+
 #include <QtCore/QDir>
+#include <QtCore/QThread>
 #include <QtDBus/QDBusConnection>
 
 #include <KDebug>
 #include <KUrl>
 #include <KPluginFactory>
 
+#include <Nepomuk/ResourceManager>
 
-// Restrictions and TODO:
-// ----------------------
-//
-// * KIO slaves that do change the local file system may emit stuff like
-//   file:///foo/bar -> xyz://foobar while the file actually ends up in
-//   the local file system again. This is not handled here. It is maybe
-//   necessary to use KFileItem::mostLocalUrl to determine local paths
-//   before deciding to call updateMetaDataForResource.
-//
-// * Only operations done through KIO are caught
-//
+#include <Soprano/Model>
+#include <Soprano/QueryResultIterator>
+#include <Soprano/Node>
 
+
 using namespace Soprano;
 
 
 NEPOMUK_EXPORT_SERVICE( Nepomuk::FileWatch, "nepomukfilewatch")
 
 
+namespace {
+    
+    class RemoveInvalidThread : public QThread {
+    public :
+        RemoveInvalidThread(QObject* parent = 0);
+        void run();
+    };
+
+    RemoveInvalidThread::RemoveInvalidThread(QObject* parent): QThread(parent)
+    {
+        connect( this, SIGNAL(finished()), this, SLOT(deleteLater()) );
+    }
+
+    void RemoveInvalidThread::run()
+    {
+        QString query = QString::fromLatin1( "select distinct ?g ?url where { ?r %1 ?url. FILTER( regex(str(?url), 'file://') ). graph ?g { ?r ?p ?o. } }" )
+                                        .arg( Soprano::Node::resourceToN3( Nepomuk::Vocabulary::NIE::url() ) );
+        Soprano::QueryResultIterator it = Nepomuk::ResourceManager::instance()->mainModel()->executeQuery( query, Soprano::Query::QueryLanguageSparql );
+
+        while( it.next() ) {
+            QUrl url( it["url"].uri() );
+            QString file = url.toLocalFile();
+            
+            if( !file.isEmpty() && !QFile::exists(file) ) {
+                kDebug() << "REMOVING " << file;
+                Nepomuk::ResourceManager::instance()->mainModel()->removeContext( it["g"] );
+            }
+        }
+    }
+
+}
+
+
 Nepomuk::FileWatch::FileWatch( QObject* parent, const QList<QVariant>& )
     : Service( parent )
 {
@@ -52,11 +87,40 @@
     m_metadataMover = new MetadataMover( mainModel(), this );
     m_metadataMover->start();
 
-    // monitor KIO for changes
-    QDBusConnection::sessionBus().connect( QString(), QString(), "org.kde.KDirNotify", "FileMoved",
-                                           this, SIGNAL( slotFileMoved( const QString&, const QString& ) ) );
-    QDBusConnection::sessionBus().connect( QString(), QString(), "org.kde.KDirNotify", "FilesRemoved",
-                                           this, SIGNAL( slotFilesDeleted( const QStringList& ) ) );
+#ifdef BUILD_KINOTIFY
+    // listing all folders in watchFolder below will be IO-intensive. Do not grab it all
+    if ( !lowerIOPriority() )
+        kDebug() << "Failed to lower io priority.";
+
+    // monitor the file system for changes (restricted by the inotify limit)
+    m_dirWatch = new KInotify( this );
+
+    // FIXME: force to only use maxUserWatches-500 or something or always leave 500 free watches
+
+    connect( m_dirWatch, SIGNAL( moved( const QString&, const QString& ) ),
+             this, SLOT( slotFileMoved( const QString&, const QString& ) ) );
+    connect( m_dirWatch, SIGNAL( deleted( const QString& ) ),
+             this, SLOT( slotFileDeleted( const QString& ) ) );
+    connect( m_dirWatch, SIGNAL( created( const QString& ) ),
+             this, SLOT( slotFileCreated( const QString& ) ) );
+    connect( m_dirWatch, SIGNAL( watchUserLimitReached() ),
+             this, SLOT( slotInotifyWatchUserLimitReached() ) );
+
+    // recursively watch the whole home dir
+
+    // FIXME: we cannot simply watch the folders that contain annotated files since moving
+    // one of these files out of the watched "area" would mean we "lose" it, i.e. we have no
+    // information about where it is moved.
+    // On the other hand only using the homedir means a lot of restrictions.
+    // One dummy solution would be a hybrid: watch the whole home dir plus all folders that
+    // contain annotated files outside of the home dir and hope for the best
+
+    watchFolder( QDir::homePath() );
+#else
+    connectToKDirWatch();
+#endif
+    
+    (new RemoveInvalidThread())->start();
 }
 
 
@@ -67,9 +131,15 @@
 }
 
 
-void Nepomuk::FileWatch::moveFileMetadata( const QString& from, const QString& to )
+void Nepomuk::FileWatch::watchFolder( const QString& path )
 {
-    slotFileMoved( from, to );
+    kDebug() << path;
+#ifdef BUILD_KINOTIFY
+    if ( m_dirWatch && !m_dirWatch->watchingPath( path ) )
+        m_dirWatch->addWatch( path,
+                              KInotify::WatchEvents( KInotify::EventMove|KInotify::EventDelete|KInotify::EventDeleteSelf|KInotify::EventCreate ),
+                              KInotify::WatchFlags() );
+#endif
 }
 
 
@@ -102,4 +172,34 @@
     slotFilesDeleted( QStringList( urlString ) );
 }
 
+
+void Nepomuk::FileWatch::slotFileCreated( const QString& path )
+{
+    // tell Strigi service (if running)
+    org::kde::nepomuk::Strigi strigi( "org.kde.nepomuk.services.nepomukstrigiservice", "/nepomukstrigiservice", QDBusConnection::sessionBus() );
+    if ( strigi.isValid() )
+        strigi.updateFolder( path, false /* no forced update */ );
+}
+
+
+void Nepomuk::FileWatch::connectToKDirWatch()
+{
+    // monitor KIO for changes
+    QDBusConnection::sessionBus().connect( QString(), QString(), "org.kde.KDirNotify", "FileMoved",
+                                           this, SIGNAL( slotFileMoved( const QString&, const QString& ) ) );
+    QDBusConnection::sessionBus().connect( QString(), QString(), "org.kde.KDirNotify", "FilesRemoved",
+                                           this, SIGNAL( slotFilesDeleted( const QStringList& ) ) );
+}
+
+
+#ifdef BUILD_KINOTIFY
+void Nepomuk::FileWatch::slotInotifyWatchUserLimitReached()
+{
+    // we do it the brutal way for now hoping with new kernels and defaults this will never happen
+    delete m_dirWatch;
+    m_dirWatch = 0;
+    connectToKDirWatch();
+}
+#endif
+
 #include "nepomukfilewatch.moc"
Index: nepomuk/services/filewatch/metadatamover.cpp
===================================================================
--- nepomuk/services/filewatch/metadatamover.cpp	(révision 1121160)
+++ nepomuk/services/filewatch/metadatamover.cpp	(copie de travail)
@@ -1,5 +1,5 @@
 /* This file is part of the KDE Project
-   Copyright (c) 2009 Sebastian Trueg <trueg@kde.org>
+   Copyright (c) 2009-2010 Sebastian Trueg <trueg@kde.org>
 
    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Library General Public
@@ -39,6 +39,7 @@
 #include <Nepomuk/Query/Query>
 #include <Nepomuk/Query/ComparisonTerm>
 #include <Nepomuk/Query/ResourceTerm>
+#include <Nepomuk/Query/LiteralTerm>
 
 #include <KDebug>
 
@@ -70,6 +71,7 @@
 
 void Nepomuk::MetadataMover::moveFileMetadata( const KUrl& from, const KUrl& to )
 {
+    kDebug() << from << to;
     m_queueMutex.lock();
     UpdateRequest req( from, to );
     if ( !m_updateQueue.contains( req ) &&
@@ -82,18 +84,13 @@
 
 void Nepomuk::MetadataMover::removeFileMetadata( const KUrl& file )
 {
-    m_queueMutex.lock();
-    UpdateRequest req( file );
-    if ( !m_updateQueue.contains( req ) &&
-         !m_recentlyFinishedRequests.contains( req ) )
-        m_updateQueue.enqueue( req );
-    m_queueMutex.unlock();
-    m_queueWaiter.wakeAll();
+    removeFileMetadata( KUrl::List() << file );
 }
 
 
 void Nepomuk::MetadataMover::removeFileMetadata( const KUrl::List& files )
 {
+    kDebug() << files;
     m_queueMutex.lock();
     foreach( const KUrl& file, files ) {
         UpdateRequest req( file );
@@ -189,7 +186,7 @@
 }
 
 
-void Nepomuk::MetadataMover::updateMetadata( const KUrl& from, const KUrl& to )
+void Nepomuk::MetadataMover::updateMetadata( const KUrl& from, const KUrl& to, bool includeChildren )
 {
     kDebug() << from << "->" << to;
 
@@ -226,19 +223,41 @@
         if ( newParent.exists() ) {
             newResource.setProperty( Nepomuk::Vocabulary::NIE::isPartOf(), newParent );
         }
+    }
 
+    if ( includeChildren && QFileInfo( to.toLocalFile() ).isDir() ) {
         //
         // Recursively update children
+        // We cannot use the nie:isPartOf relation since only children could have metadata. Thus, we do a regex
+        // match on all files and folders below the URL we got.
         //
-        Query::Query query( Query::ComparisonTerm( Nepomuk::Vocabulary::NIE::isPartOf(), Query::ResourceTerm( newResource ) ) );
-        query.addRequestProperty( Query::Query::RequestProperty( Nepomuk::Vocabulary::NIE::url() ) );
-        Soprano::QueryResultIterator it = m_model->executeQuery( query.toSparqlQuery(), Soprano::Query::QueryLanguageSparql );
+        // CAUTION: The trailing slash on the from URL is essential! Otherwise we might match the newly added
+        //          URLs, too (in case a rename only added chars to the name)
+        //
+        QString query = QString::fromLatin1( "select distinct ?r ?url where { "
+                                             "?r %1 ?url . "
+                                             "FILTER(REGEX(STR(?url),'^%2')) . "
+                                             "}" )
+                        .arg( Soprano::Node::resourceToN3( Nepomuk::Vocabulary::NIE::url() ),
+                              from.url(KUrl::AddTrailingSlash) );
+        kDebug() << query;
+        Soprano::QueryResultIterator it = m_model->executeQuery( query, Soprano::Query::QueryLanguageSparql );
         while ( it.next() ) {
-            QUrl uri = it[0].uri();
-            KUrl url = it[1].uri();
-            KUrl newUrl( to );
-            newUrl.addPath( url.fileName() );
-            updateMetadata( url, newUrl );
+
+            // the resource URI of the resource to update
+            const QUrl uri = it[0].uri();
+
+            // the old URL of the resource to update
+            const KUrl url = it[1].uri();
+
+            // now construct the new URL
+            const QString oldBasePath = from.path( KUrl::AddTrailingSlash );
+            const QString newBasePath = to.path( KUrl::AddTrailingSlash );
+            QString oldRelativePath = url.path().mid( oldBasePath.length() );
+            KUrl newUrl( newBasePath + oldRelativePath );
+
+            // finally update the metadata (excluding children since we already handle them all here)
+            updateMetadata( url, newUrl, false );
         }
     }
 }
Index: nepomuk/services/filewatch/nepomukfilewatch.h
===================================================================
--- nepomuk/services/filewatch/nepomukfilewatch.h	(révision 1121160)
+++ nepomuk/services/filewatch/nepomukfilewatch.h	(copie de travail)
@@ -1,5 +1,5 @@
 /* This file is part of the KDE Project
-   Copyright (c) 2007-2008 Sebastian Trueg <trueg@kde.org>
+   Copyright (c) 2007-2010 Sebastian Trueg <trueg@kde.org>
 
    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Library General Public
@@ -31,9 +31,7 @@
     }
 }
 
-namespace KInotify {
-    class DirWatch;
-}
+class KInotify;
 
 class KUrl;
 
@@ -51,18 +49,23 @@
         ~FileWatch();
 
     public Q_SLOTS:
-        Q_SCRIPTABLE void moveFileMetadata( const QString& from, const QString& to );
+        Q_SCRIPTABLE void watchFolder( const QString& path );
 
     private Q_SLOTS:
         void slotFileMoved( const QString& from, const QString& to );
         void slotFileDeleted( const QString& path );
         void slotFilesDeleted( const QStringList& path );
+        void slotFileCreated( const QString& );
+        void connectToKDirWatch();
+#ifdef BUILD_KINOTIFY
+        void slotInotifyWatchUserLimitReached();
+#endif
 
     private:
         MetadataMover* m_metadataMover;
 
-#ifndef Q_WS_WIN
-        KInotify::DirWatch* m_dirWatch;
+#ifdef BUILD_KINOTIFY
+        KInotify* m_dirWatch;
 #endif
     };
 }
Index: nepomuk/services/filewatch/CMakeLists.txt
===================================================================
--- nepomuk/services/filewatch/CMakeLists.txt	(révision 1121160)
+++ nepomuk/services/filewatch/CMakeLists.txt	(copie de travail)
@@ -16,8 +16,19 @@
   nepomukfilewatch.cpp
   metadatamover.cpp
   updaterequest.cpp
+  ../strigi/priority.cpp
   )
 
+qt4_add_dbus_interface(SRCS ../../interfaces/org.kde.nepomuk.Strigi.xml strigiserviceinterface)
+
+if(CMAKE_SYSTEM_NAME MATCHES "Linux")
+  set(SRCS
+    ${SRCS}
+    kinotify.cpp
+)
+add_definitions(-DBUILD_KINOTIFY)
+endif(CMAKE_SYSTEM_NAME MATCHES "Linux")
+
 soprano_add_ontology(SRCS
   ${SHAREDDESKTOPONTOLOGIES_ROOT_DIR}/nie/nie.trig
   "NIE"
Index: nepomuk/services/filewatch/nepomukfilewatch.desktop
===================================================================
--- nepomuk/services/filewatch/nepomukfilewatch.desktop	(révision 1121160)
+++ nepomuk/services/filewatch/nepomukfilewatch.desktop	(copie de travail)
@@ -34,6 +34,7 @@
 Name[hr]=Nepomuk nadgledanje datoteka
 Name[hsb]=NepomukFileWatch
 Name[hu]=NepomukFileWatch
+Name[ia]=NepomukFileWatch
 Name[id]=Pengawas Berkas Nepomuk
 Name[is]=Nepomuk skráavörður
 Name[it]=Sorveglianza dei file di Nepomuk
@@ -106,6 +107,7 @@
 Comment[hr]=Nepomukova usluga nadgledanja datoteka za otkrivanje promjena nad istima
 Comment[hsb]=Nepomukowe wobkedźbowanje datajow za zwěsćenje změnow
 Comment[hu]=Nepomuk fájlfigyelő szolgáltatás fájlváltozások követéséhez
+Comment[ia]=Servicio de guarda de archivo Nepomuk pro monitorar variationes de archivo
 Comment[id]=Layanan pengawas berkas Nepomuk untuk memonitor perubahan pada berkas
 Comment[is]=Nepomuk skráavarslan fylgist með breytingum á skrám
 Comment[it]=Il servizio di sorveglianza di Nepomuk per monitorare i cambiamenti dei file
@@ -140,7 +142,7 @@
 Comment[sv]=Nepomuks filövervakningstjänst för att bevaka filändringar
 Comment[ta]=The Nepomuk file watch service for monitoring file changes
 Comment[te]=ఫైల్ మార్పులను మానిటరింగ్ చేయుటకొరకు Nepomuk ఫైల్ వాచ్ సేవ
-Comment[tg]=Служба Nepomuk file watch контролирует изменения в файлах
+Comment[tg]=Системаи Nepomuk тағйиротҳоро дар файлҳо муайян мекунад
 Comment[th]=บริการของ Nepomuk สำหรับคอยตรวจจับความเปลี่ยนแปลงของแฟ้ม
 Comment[tr]=Dosya değişikliklerini izlemek için Nepomuk dosya izleme servisi
 Comment[uk]=Служба Nepomuk для спостереження за змінами в файлах
Index: nepomuk/services/filewatch/kinotify.cpp
===================================================================
--- nepomuk/services/filewatch/kinotify.cpp	(révision 0)
+++ nepomuk/services/filewatch/kinotify.cpp	(révision 0)
@@ -0,0 +1,403 @@
+/* This file is part of the KDE libraries
+   Copyright (C) 2007-2010 Sebastian Trueg <trueg@kde.org>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public License
+   along with this library; see the file COPYING.LIB.  If not, write to
+   the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.
+*/
+
+#include "kinotify.h"
+
+#include <QtCore/QSocketNotifier>
+#include <QtCore/QHash>
+#include <QtCore/QDirIterator>
+#include <QtCore/QFile>
+#include <QtCore/QQueue>
+
+#include <kdebug.h>
+
+#include <sys/inotify.h>
+#include <sys/utsname.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <dirent.h>
+
+
+namespace {
+    const int EVENT_STRUCT_SIZE = sizeof( struct inotify_event );
+
+    // we need one event to fit into the buffer, the problem is that the name
+    // is a variable length array
+    const int EVENT_BUFFER_SIZE = EVENT_STRUCT_SIZE + 1024*16;
+
+    QByteArray normalizePath( const QByteArray& path ) {
+        QByteArray p( path );
+        if ( p.endsWith( '/' ) )
+            p.truncate( p.length()-1 );
+        return p;
+    }
+}
+
+class KInotify::Private
+{
+public:
+    Private( KInotify* parent )
+        : watchHiddenFolders( true ),
+          m_inotifyFd( -1 ),
+          m_notifier( 0 ),
+          q( parent) {
+    }
+
+    ~Private() {
+        close();
+    }
+
+    QHash<int, QString> cookies;
+    QHash<int, QByteArray> pathHash;
+
+    /// queue of paths to install watches for
+    QQueue<QByteArray> pathsToWatch;
+
+    unsigned char eventBuffer[EVENT_BUFFER_SIZE];
+
+    // FIXME: only stored from the last addWatch call
+    WatchEvents mode;
+    WatchFlags flags;
+
+    bool watchHiddenFolders;
+
+    int inotify() {
+        if ( m_inotifyFd < 0 ) {
+            open();
+        }
+        return m_inotifyFd;
+    }
+
+    void close() {
+        kDebug();
+        delete m_notifier;
+        m_notifier = 0;
+
+        ::close( m_inotifyFd );
+        m_inotifyFd = -1;
+    }
+
+    bool addWatch( const QByteArray& path ) {
+        // we always need the unmount event to maintain our path hash
+        const int mask = mode|flags|EventUnmount;
+
+        int wd = inotify_add_watch( inotify(), path.data(), mask );
+        if ( wd > 0 ) {
+//            kDebug() << "Successfully added watch for" << path << pathHash.count();
+            pathHash.insert( wd, normalizePath( path ) );
+            return true;
+        }
+        else {
+            kDebug() << "Failed to create watch for" << path;
+            static bool userLimitReachedSignaled = false;
+            if ( !userLimitReachedSignaled && errno == ENOSPC ) {
+                kDebug() << "User limit reached. Please raise the inotify user watch limit.";
+                userLimitReachedSignaled = true;
+                emit q->watchUserLimitReached();
+            }
+            return false;
+        }
+    }
+
+    bool addWatchesRecursively( const QByteArray& path )
+    {
+        if ( !addWatch( path ) )
+            return false;
+
+        int len = offsetof(struct dirent, d_name) +
+                  pathconf(path.data(), _PC_NAME_MAX) + 1;
+        struct dirent* entry = ( struct dirent* )new char[len];
+
+        DIR* dir = opendir( path.data() );
+        if ( dir ) {
+            struct dirent *result = 0;
+            while ( !readdir_r( dir, entry, &result ) ) {
+
+                if ( !result ) {
+                    // end of folder
+                    break;
+                }
+
+                if ( ( entry->d_type == DT_UNKNOWN ||
+                       entry->d_type == DT_DIR ) &&
+                     ( watchHiddenFolders ||
+                       qstrncmp( entry->d_name, ".", 1 ) ) &&
+                     qstrcmp( entry->d_name, "." ) &&
+                     qstrcmp( entry->d_name, ".." ) ) {
+                    bool isDir = true;
+                    QByteArray subDir = path + '/' + QByteArray::fromRawData( entry->d_name, qstrlen( entry->d_name ) );
+                    if ( entry->d_type == DT_UNKNOWN ) {
+                        struct stat buf;
+                        lstat( subDir.data(), &buf );
+                        isDir = S_ISDIR( buf.st_mode );
+                    }
+
+                    if ( isDir ) {
+                        pathsToWatch.enqueue( subDir );
+                    }
+                }
+            }
+
+            closedir( dir );
+            delete [] entry;
+
+            return true;
+        }
+        else {
+            kDebug() << "Could not open dir" << path;
+            return false;
+        }
+    }
+
+    void removeWatch( int wd ) {
+        pathHash.remove( wd );
+        inotify_rm_watch( inotify(), wd );
+    }
+
+    void _k_addWatches() {
+        // add the next batch of paths
+        for ( int i = 0; i < 100; ++i ) {
+            if ( pathsToWatch.isEmpty() ||
+                 !addWatchesRecursively( pathsToWatch.dequeue() ) ) {
+                return;
+            }
+        }
+
+        // asyncroneously add the next batch
+        if ( !pathsToWatch.isEmpty() ) {
+            QMetaObject::invokeMethod( q, "_k_addWatches", Qt::QueuedConnection );
+        }
+    }
+
+private:
+    void open() {
+        kDebug();
+        m_inotifyFd = inotify_init();
+        delete m_notifier;
+        if ( m_inotifyFd > 0 ) {
+            fcntl( m_inotifyFd, F_SETFD, FD_CLOEXEC );
+            kDebug() << "Successfully opened connection to inotify:" << m_inotifyFd;
+            m_notifier = new QSocketNotifier( m_inotifyFd, QSocketNotifier::Read );
+            connect( m_notifier, SIGNAL( activated( int ) ), q, SLOT( slotEvent( int ) ) );
+        }
+    }
+
+    int m_inotifyFd;
+    QSocketNotifier* m_notifier;
+
+    KInotify* q;
+};
+
+
+KInotify::KInotify( QObject* parent )
+    : QObject( parent ),
+      d( new Private( this ) )
+{
+}
+
+
+KInotify::~KInotify()
+{
+    delete d;
+}
+
+
+bool KInotify::available() const
+{
+    if( d->inotify() > 0 ) {
+        // trueg: Copied from KDirWatch.
+        struct utsname uts;
+        int major, minor, patch;
+        if ( uname(&uts) < 0 ) {
+            return false; // *shrug*
+        }
+        else if ( sscanf( uts.release, "%d.%d.%d", &major, &minor, &patch) != 3 ) {
+            return false; // *shrug*
+        }
+        else if( major * 1000000 + minor * 1000 + patch < 2006014 ) { // <2.6.14
+            kDebug(7001) << "Can't use INotify, Linux kernel too old";
+            return false;
+        }
+
+        return true;
+    }
+    else {
+        return false;
+    }
+}
+
+
+bool KInotify::watchingPath( const QString& path ) const
+{
+    QByteArray p( normalizePath( QFile::encodeName( path ) ) );
+    QHash<int, QByteArray>::const_iterator end = d->pathHash.constEnd();
+    for ( QHash<int, QByteArray>::const_iterator it = d->pathHash.constBegin();
+          it != end; ++it ) {
+        if ( it.value() == p )
+            return true;
+    }
+    return false;
+}
+
+
+bool KInotify::addWatch( const QString& path, WatchEvents mode, WatchFlags flags )
+{
+    kDebug() << path;
+
+    d->mode = mode;
+    d->flags = flags;
+    d->pathsToWatch.append( QFile::encodeName( path ) );
+    d->_k_addWatches();
+    return true;
+}
+
+
+// TODO: do this more efficiently
+bool KInotify::removeWatch( const QString& path )
+{
+    QByteArray encodedPath = QFile::encodeName( path );
+    QHash<int, QByteArray>::iterator it = d->pathHash.begin();
+    while ( it != d->pathHash.end() ) {
+        if ( it.value().startsWith( encodedPath ) ) {
+            inotify_rm_watch( d->inotify(), it.key() );
+            it = d->pathHash.erase( it );
+        }
+        else {
+            ++it;
+        }
+    }
+    return true;
+}
+
+
+void KInotify::slotEvent( int socket )
+{
+    // read at least one event
+    int len = read( socket, d->eventBuffer, EVENT_BUFFER_SIZE );
+    int i = 0;
+    while ( i < len && len-i >= EVENT_STRUCT_SIZE  ) {
+        struct inotify_event* event = ( struct inotify_event* )&d->eventBuffer[i];
+
+        QByteArray encodedPath = QByteArray::fromRawData( event->name, event->len );
+
+        kDebug() << encodedPath;
+
+        if ( encodedPath[0] != '/' ) {
+            encodedPath = d->pathHash.value( event->wd ) + '/' + encodedPath;
+        }
+
+        QString path = QFile::decodeName( encodedPath );
+
+        kDebug() << path;
+
+
+        // now signal the event
+        if ( event->mask & EventAccess) {
+            kDebug() << path << "EventAccess";
+            emit accessed( path );
+        }
+        if ( event->mask & EventAttributeChange ) {
+            kDebug() << path << "EventAttributeChange";
+            emit attributeChanged( path );
+        }
+        if ( event->mask & EventCloseWrite ) {
+            kDebug() << path << "EventCloseWrite";
+            emit closedWrite( path );
+        }
+        if ( event->mask & EventCloseRead ) {
+            kDebug() << path << "EventCloseRead";
+            emit closedRead( path );
+        }
+        if ( event->mask & EventCreate ) {
+            kDebug() << path << "EventCreate";
+            if ( event->mask & IN_ISDIR ) {
+                // FIXME: store the mode and flags somewhere
+                addWatch( encodedPath, d->mode, d->flags );
+            }
+            emit created( path );
+        }
+        if ( event->mask & EventDelete ) {
+            kDebug() << path << "EventDelete";
+            if ( event->mask & IN_ISDIR ) {
+                d->removeWatch( event->wd );
+            }
+            emit deleted( path );
+        }
+        if ( event->mask & EventDeleteSelf ) {
+            kDebug() << path << "EventDeleteSelf";
+            if ( event->mask & IN_ISDIR ) {
+                d->removeWatch( event->wd );
+            }
+            emit deleted( path );
+        }
+        if ( event->mask & EventModify ) {
+            kDebug() << path << "EventModify";
+            emit modified( path );
+        }
+        if ( event->mask & EventMoveSelf ) {
+            kDebug() << path << "EventMoveSelf";
+        }
+        if ( event->mask & EventMoveFrom ) {
+            kDebug() << path << "EventMoveFrom";
+            d->cookies[event->cookie] = path;
+        }
+        if ( event->mask & EventMoveTo ) {
+            // check if we have a cookie for this one
+            if ( d->cookies.contains( event->cookie ) ) {
+                QString oldPath = d->cookies[event->cookie];
+                d->cookies.remove( event->cookie );
+                kDebug() << oldPath << "EventMoveTo" << path;
+                emit moved( oldPath, path );
+            }
+            else {
+                kDebug() << "No cookie for move information of" << path;
+            }
+        }
+        if ( event->mask & EventOpen ) {
+            kDebug() << path << "EventOpen";
+            emit opened( path );
+        }
+        if ( event->mask & EventUnmount ) {
+            kDebug() << path << "EventUnmount. removing from path hash";
+            if ( event->mask & IN_ISDIR ) {
+                d->removeWatch( event->wd );
+            }
+            emit unmounted( path );
+        }
+        if ( event->mask & EventQueueOverflow ) {
+            // This should not happen since we grab all events as soon as they arrive
+            kDebug() << path << "EventQueueOverflow";
+//            emit queueOverflow();
+        }
+        if ( event->mask & EventIgnored ) {
+            kDebug() << path << "EventIgnored";
+        }
+
+        i += EVENT_STRUCT_SIZE + event->len;
+    }
+
+    if ( len < 0 ) {
+        kDebug() << "Failed to read event.";
+    }
+}
+
+#include "kinotify.moc"

Modification de propriétés sur nepomuk/services/filewatch/kinotify.cpp
___________________________________________________________________
Ajouté : svn:eol-style
   + native

Index: nepomuk/services/queryservice/queryservice.cpp
===================================================================
--- nepomuk/services/queryservice/queryservice.cpp	(révision 1121160)
+++ nepomuk/services/queryservice/queryservice.cpp	(copie de travail)
@@ -26,6 +26,7 @@
 #include <QtDBus/QDBusConnectionInterface>
 #include <QtDBus/QDBusObjectPath>
 #include <QtDBus/QDBusMessage>
+#include <QtDBus/QDBusServiceWatcher>
 
 #include <KPluginFactory>
 #include <KUrl>
@@ -50,10 +51,12 @@
 
     s_instance = this;
 
-    connect( QDBusConnection::sessionBus().interface(),
-             SIGNAL( serviceOwnerChanged( const QString&, const QString&, const QString& ) ),
-             this,
-             SLOT( slotServiceOwnerChanged( const QString&, const QString&, const QString& ) ) );
+    m_serviceWatcher = new QDBusServiceWatcher( QString(),
+                                                QDBusConnection::sessionBus(),
+                                                QDBusServiceWatcher::WatchForUnregistration, this);
+
+    connect( m_serviceWatcher, SIGNAL( serviceUnregistered(const QString& ) ),
+             this, SLOT( slotServiceUnregistered( const QString& ) ) );
 }
 
 
@@ -102,6 +105,7 @@
     QString dbusClient = msg.service();
     m_openConnections.insert( dbusClient, conn );
     m_connectionDBusServiceHash.insert( conn, dbusClient );
+    m_serviceWatcher->addWatchedService( dbusClient );
 
     return QDBusObjectPath( dbusObjectPath );
 }
@@ -155,18 +159,15 @@
 }
 
 
-void Nepomuk::Query::QueryService::slotServiceOwnerChanged( const QString& serviceName,
-                                                            const QString&,
-                                                            const QString& newOwner )
+void Nepomuk::Query::QueryService::slotServiceUnregistered( const QString& serviceName )
 {
-    if ( newOwner.isEmpty() ) {
-        QList<FolderConnection*> conns = m_openConnections.values( serviceName );
-        if ( !conns.isEmpty() ) {
-            kDebug() << "Service" << serviceName << "went down. Removing connections";
-            // hash cleanup will be triggered automatically
-            qDeleteAll( conns );
-        }
+    QList<FolderConnection*> conns = m_openConnections.values( serviceName );
+    if ( !conns.isEmpty() ) {
+        kDebug() << "Service" << serviceName << "went down. Removing connections";
+        // hash cleanup will be triggered automatically
+        qDeleteAll( conns );
     }
+    m_serviceWatcher->removeWatchedService(serviceName);
 }
 
 #include "queryservice.moc"
Index: nepomuk/services/queryservice/queryservice.h
===================================================================
--- nepomuk/services/queryservice/queryservice.h	(révision 1121160)
+++ nepomuk/services/queryservice/queryservice.h	(copie de travail)
@@ -30,6 +30,7 @@
 
 class QDBusObjectPath;
 class QDBusMessage;
+class QDBusServiceWatcher;
 
 namespace Nepomuk {
     namespace Query {
@@ -62,9 +63,7 @@
             Q_SCRIPTABLE QDBusObjectPath sparqlQuery( const QString& query, const RequestPropertyMapDBus& requestProps, const QDBusMessage& msg );
 
         private Q_SLOTS:
-            void slotServiceOwnerChanged( const QString& serviceName,
-                                          const QString&,
-                                          const QString& newOwner );
+            void slotServiceUnregistered( const QString& serviceName );
             void slotFolderDestroyed( QObject* folder );
             void slotFolderConnectionDestroyed( QObject* conn );
 
@@ -82,6 +81,7 @@
             QHash<FolderConnection*, QString> m_connectionDBusServiceHash; // maps connections to their using dbus service
 
             int m_folderConnectionCnt; // only used for unique dbus object path generation
+            QDBusServiceWatcher *m_serviceWatcher;
         };
     }
 }
Index: nepomuk/services/queryservice/nepomukqueryservice.desktop
===================================================================
--- nepomuk/services/queryservice/nepomukqueryservice.desktop	(révision 1121160)
+++ nepomuk/services/queryservice/nepomukqueryservice.desktop	(copie de travail)
@@ -34,6 +34,7 @@
 Name[hr]=Nepomuk Upitna Usluga
 Name[hsb]=NepomukQueryService
 Name[hu]=Nepomuk-lekérdezés
+Name[ia]=NepomukQueryService
 Name[id]=NepomukQueryService
 Name[is]=Nepomuk fyrirspurnamiðlari
 Name[it]=Servizio di interrogazioni di Nepomuk
@@ -71,7 +72,7 @@
 Name[ta]=NepomukQueryService
 Name[tg]=Хидматҳои Nepomuk
 Name[th]=NepomukQueryService
-Name[tr]=Nepomuk Sorgulama Servisi
+Name[tr]=NepomukQueryService
 Name[uk]=NepomukQueryService
 Name[wa]=SierviceCweraedjeNepomuk
 Name[x-test]=xxNepomukQueryServicexx
@@ -101,6 +102,7 @@
 Comment[hr]=Nepomuk Upitna Usluga pruža sučelje za trajne upitne direktorije
 Comment[hsb]=Nepomukowa naprašowanska słužba staji intefejs za persistentne naprašowanske zapiski k dispoziciji.
 Comment[hu]=A Nepomuk lekérdező szolgáltatás keresőmappákhoz nyújt felületet
+Comment[ia]=Le Nepomuk Query Service forni un interface pro classificatores persistente de demanda
 Comment[id]=Layanan Tanya Nepomuk menyediakan antarmuka untuk folder pertanyaan yang kukuh
 Comment[is]=Nepomuk fyrirspurnamiðlarinn er viðmót fyrir viðvarandi fyrirspurnamöppur (persistent query folders)
 Comment[it]=Il servizio di interrogazione di Nepomuk fornisce un'interfaccia per cartelle di interrogazione persistenti
@@ -135,7 +137,7 @@
 Comment[ta]=The Nepomuk Query Service provides an interface for persistent query folders
 Comment[te]=నెపోమక్ క్వరీ సేవ అనునది ఎప్పుడూవుండే క్వరీ ఫోల్డర్సుకు ఇంటర్ఫేస్‌ను అందిస్తుంది
 Comment[th]=บริการสืบค้น Nepomuk เป็นส่วนติดต่อสำหรับโฟลเดอร์สืบค้นข้อมูลถาวร
-Comment[tr]=Nepomuk Sorgulama Servisi kalıcı sorgu dizinleri için bir arayüz sağlar
+Comment[tr]=Nepomuk Sorgulama Hizmeti kalıcı sorgu dizinleri için bir arayüz sağlar
 Comment[uk]=Служба запитів Nepomuk надає інтерфейс для постійних тек запитів
 Comment[wa]=Li siervice di cweraedje di Nepomuk dene èn eterface po des ridants d' cweraedje wårdés
 Comment[x-test]=xxThe Nepomuk Query Service provides an interface for persistent query foldersxx
Index: nepomuk/services/queryservice/searchthread.cpp
===================================================================
--- nepomuk/services/queryservice/searchthread.cpp	(révision 1121160)
+++ nepomuk/services/queryservice/searchthread.cpp	(copie de travail)
@@ -142,11 +142,21 @@
     kDebug() << it.binding( 0 ).uri();
     Result result( it.binding( 0 ).uri() );
 
+    // make sure we do not store values twice
+    QStringList names = it.bindingNames();
+    names.removeAll( QLatin1String( "r" ) );
+
     for ( RequestPropertyMap::const_iterator rpIt = m_requestProperties.constBegin();
           rpIt != m_requestProperties.constEnd(); ++rpIt ) {
         result.addRequestProperty( rpIt.value(), it.binding( rpIt.key() ) );
+        names.removeAll( rpIt.key() );
     }
 
+    Soprano::BindingSet set;
+    foreach( const QString& var, names )
+        set.insert( var, it[var] );
+    result.setAdditionalBindings( set );
+
     // score will be set above
     return result;
 }
Index: nepomuk/services/migration1/nepomukmigration1.desktop
===================================================================
--- nepomuk/services/migration1/nepomukmigration1.desktop	(révision 1121160)
+++ nepomuk/services/migration1/nepomukmigration1.desktop	(copie de travail)
@@ -32,6 +32,7 @@
 Comment[hr]=Nepomuk Seoba Podataka Razina 1
 Comment[hsb]=Nepomuk migracija datow runina 1
 Comment[hu]=Nepomuk adatmigráció 1. szint
+Comment[ia]=Migration de Datos de Nepomuk de Nivello 1
 Comment[id]=Migrasi Data Nepomuk Level 1
 Comment[is]=Nepomuk gagnaflutningur, stig 1
 Comment[it]=Migrazione dei dati di Nepomuk di livello 1
Index: nepomuk/services/CMakeLists.txt
===================================================================
--- nepomuk/services/CMakeLists.txt	(révision 1121160)
+++ nepomuk/services/CMakeLists.txt	(copie de travail)
@@ -5,3 +5,5 @@
 add_subdirectory(queryservice)
 add_subdirectory(strigi)
 add_subdirectory(removablestorage)
+
+add_subdirectory(activities)
Index: nepomuk/server/servicecontroller.cpp
===================================================================
--- nepomuk/server/servicecontroller.cpp	(révision 1121160)
+++ nepomuk/server/servicecontroller.cpp	(copie de travail)
@@ -24,13 +24,15 @@
 #include <QtCore/QEventLoop>
 #include <QtCore/QTimer>
 
+#include <QtDBus/QDBusServiceWatcher>
+
 #include <KStandardDirs>
 #include <KConfigGroup>
 #include <KDebug>
 
 
 namespace {
-    QString dbusServiceName( const QString& serviceName ) {
+    inline QString dbusServiceName( const QString& serviceName ) {
         return QString("org.kde.nepomuk.services.%1").arg(serviceName);
     }
 }
@@ -42,6 +44,7 @@
     Private()
         : processControl( 0 ),
           serviceControlInterface( 0 ),
+          dbusServiceWatcher( 0 ),
           attached( false ),
           initialized( false ),
           failedToInitialize( false ) {
@@ -54,6 +57,7 @@
 
     ProcessControl* processControl;
     OrgKdeNepomukServiceControlInterface* serviceControlInterface;
+    QDBusServiceWatcher* dbusServiceWatcher;
 
     // true if we attached to an already running instance instead of
     // starting our own (in that case processControl will be 0)
@@ -158,12 +162,25 @@
     d->initialized = false;
     d->failedToInitialize = false;
 
+    if ( !d->dbusServiceWatcher ) {
+        d->dbusServiceWatcher = new QDBusServiceWatcher( dbusServiceName(name()),
+                                                         QDBusConnection::sessionBus(),
+                                                         QDBusServiceWatcher::WatchForRegistration | QDBusServiceWatcher::WatchForUnregistration,
+                                                         this );
+    }
+    d->dbusServiceWatcher->disconnect( this );
+
     // check if the service is already running, ie. has been started by someone else or by a crashed instance of the server
     // we cannot rely on the auto-restart feature of ProcessControl here. So we handle that completely in slotServiceOwnerChanged
     if( QDBusConnection::sessionBus().interface()->isServiceRegistered( dbusServiceName( name() ) ) ) {
         kDebug() << "Attaching to already running service" << name();
         d->attached = true;
         createServiceControlInterface();
+
+        // we do not have ProcessControl to take care of restarting. Thus, we monitor the service via DBus
+        connect( d->dbusServiceWatcher, SIGNAL( serviceUnregistered( QString ) ),
+                 this, SLOT( slotServiceUnregistered( QString ) ) );
+
         return true;
     }
     else {
@@ -175,10 +192,9 @@
                      this, SLOT( slotProcessFinished( bool ) ) );
         }
 
-        connect( QDBusConnection::sessionBus().interface(),
-                 SIGNAL( serviceOwnerChanged( const QString&, const QString&, const QString& ) ),
-                 this,
-                 SLOT( slotServiceOwnerChanged( const QString&, const QString&, const QString& ) ) );
+        // wait for the service to be registered with DBus before creating the service interface
+        connect( d->dbusServiceWatcher, SIGNAL( serviceRegistered( QString ) ),
+                 this, SLOT( slotServiceRegistered( QString ) ) );
 
         d->processControl->setCrashPolicy( ProcessControl::RestartOnCrash );
         return d->processControl->start( KGlobal::dirs()->locate( "exe", "nepomukservicestub" ),
@@ -265,19 +281,19 @@
 }
 
 
-void Nepomuk::ServiceController::slotServiceOwnerChanged( const QString& serviceName,
-                                                          const QString& oldOwner,
-                                                          const QString& newOwner )
+void Nepomuk::ServiceController::slotServiceRegistered( const QString& serviceName )
 {
-    if( !newOwner.isEmpty() && serviceName == dbusServiceName( name() ) ) {
+    if( serviceName == dbusServiceName( name() ) ) {
         createServiceControlInterface();
     }
+}
 
+void Nepomuk::ServiceController::slotServiceUnregistered( const QString& serviceName )
+{
     // an attached service was not started through ProcessControl. Thus, we cannot rely
     // on its restart-on-crash feature and have to do it manually. Afterwards it is back
-    // to normals
-    else if( d->attached &&
-             oldOwner == dbusServiceName( name() ) ) {
+    // to normal
+    if( d->attached && serviceName == dbusServiceName( name() ) ) {
         kDebug() << "Attached service" << name() << "went down. Restarting ourselves.";
         d->attached = false;
         start();
Index: nepomuk/server/servicecontroller.h
===================================================================
--- nepomuk/server/servicecontroller.h	(révision 1121160)
+++ nepomuk/server/servicecontroller.h	(copie de travail)
@@ -80,9 +80,8 @@
         
     private Q_SLOTS:
         void slotProcessFinished( bool );
-        void slotServiceOwnerChanged( const QString& serviceName,
-                                      const QString&,
-                                      const QString& newOwner );
+        void slotServiceRegistered( const QString& serviceName );
+        void slotServiceUnregistered( const QString& serviceName );
         void slotServiceInitialized( bool success );
         
     private:
Index: nepomuk/server/processcontrol.cpp
===================================================================
--- nepomuk/server/processcontrol.cpp	(révision 1121160)
+++ nepomuk/server/processcontrol.cpp	(copie de travail)
@@ -90,27 +90,27 @@
         if ( mPolicy == RestartOnCrash ) {
              // don't try to start an unstartable application
             if ( !mFailedToStart && --mCrashCount >= 0 ) {
-                qDebug( "Application '%s' crashed! %d restarts left.", qPrintable( mApplication ), mCrashCount );
+                qDebug( "Application '%s' crashed! %d restarts left.", qPrintable( commandLine() ), mCrashCount );
                 start();
             } else {
                 if ( mFailedToStart ) {
-                    qDebug( "Application '%s' failed to start!", qPrintable( mApplication ) );
+                    qDebug( "Application '%s' failed to start!", qPrintable( commandLine() ) );
                 } else {
-                    qDebug( "Application '%s' crashed to often. Giving up!", qPrintable( mApplication ) );
+                    qDebug( "Application '%s' crashed to often. Giving up!", qPrintable( commandLine() ) );
                 }
                 emit finished(false);
             }
         } else {
-            qDebug( "Application '%s' crashed. No restart!", qPrintable( mApplication ) );
+            qDebug( "Application '%s' crashed. No restart!", qPrintable( commandLine() ) );
         }
     } else {
         if ( exitCode != 0 ) {
             qDebug( "ProcessControl: Application '%s' returned with exit code %d (%s)",
-                    qPrintable( mApplication ), exitCode, qPrintable( mProcess.errorString() ) );
+                    qPrintable( commandLine() ), exitCode, qPrintable( mProcess.errorString() ) );
             mFailedToStart = true;
             emit finished(false);
         } else {
-            qDebug( "Application '%s' exited normally...", qPrintable( mApplication ) );
+            qDebug( "Application '%s' exited normally...", qPrintable( commandLine() ) );
             emit finished(true);
         }
     }
@@ -145,4 +145,9 @@
     return mProcess.state() == QProcess::Running;
 }
 
+QString ProcessControl::commandLine() const
+{
+    return mApplication + QLatin1String(" ") + mArguments.join(QLatin1String(" "));
+}
+
 #include "processcontrol.moc"
Index: nepomuk/server/processcontrol.h
===================================================================
--- nepomuk/server/processcontrol.h	(révision 1121160)
+++ nepomuk/server/processcontrol.h	(copie de travail)
@@ -97,6 +97,8 @@
 private:
     bool start();
 
+    QString commandLine() const;
+
     QProcess mProcess;
     QString mApplication;
     QStringList mArguments;
Index: nepomuk/server/nepomukservice.desktop
===================================================================
--- nepomuk/server/nepomukservice.desktop	(révision 1121160)
+++ nepomuk/server/nepomukservice.desktop	(copie de travail)
@@ -32,6 +32,7 @@
 Comment[hr]=Usluga Nepomuk
 Comment[hsb]=Nepomuk-słužba
 Comment[hu]=Nepomuk szolgáltatás
+Comment[ia]=Servicio de Nepomuk
 Comment[id]=Layanan Nepomuk
 Comment[is]=Nepomuk þjónusta
 Comment[it]=Servizio Nepomuk
@@ -70,7 +71,7 @@
 Comment[te]=Nepomuk సేవ
 Comment[tg]=Хидматҳои Nepomuk
 Comment[th]=บริการ Neomuk
-Comment[tr]=Nepomuk Servisi
+Comment[tr]=Nepomuk Hizmeti
 Comment[uk]=Служба Nepomuk
 Comment[uz]=Nepomuk xizmati
 Comment[uz@cyrillic]=Nepomuk хизмати
Index: nepomuk/server/servicemanager.cpp
===================================================================
--- nepomuk/server/servicemanager.cpp	(révision 1121160)
+++ nepomuk/server/servicemanager.cpp	(copie de travail)
@@ -327,39 +327,8 @@
 bool Nepomuk::ServiceManager::startService( const QString& name )
 {
     if( ServiceController* sc = d->findService( name ) ) {
-        if( !sc->isRunning() ) {
-            // start dependencies if possible
-            foreach( const QString &dependency, d->dependencyTree[name] ) {
-                if ( ServiceController* depSc = d->findService( dependency ) ) {
-                    if( depSc->autostart() || depSc->startOnDemand() ) {
-                        if ( !startService( dependency ) ) {
-                            kDebug() << "Cannot start dependency" << dependency;
-                            return false;
-                        }
-                    }
-                    else {
-                        kDebug() << "Dependency" << dependency << "can not be started automatically. It is not an autostart or start on demand service";
-                        return false;
-                    }
-                }
-                else {
-                    kDebug() << "Invalid dependency:" << dependency;
-                    return false;
-                }
-            }
-
-            if ( sc->start() ) {
-                return sc->waitForInitialized();
-            }
-            else {
-                // failed to start service
-                return false;
-            }
-        }
-        else {
-            // service already running
-            return true;
-        }
+        d->startService( sc );
+        return sc->waitForInitialized();
     }
     else {
         // could not find service
Index: nepomuk/server/nepomukserver.desktop
===================================================================
--- nepomuk/server/nepomukserver.desktop	(révision 1121160)
+++ nepomuk/server/nepomukserver.desktop	(copie de travail)
@@ -35,6 +35,7 @@
 Name[hr]=Poslužitelj Nepomuk
 Name[hsb]=Nepomuk Serwer
 Name[hu]=Nepomuk szolgáltatás
+Name[ia]=Servitor de Nepomuk
 Name[id]=Server Nepomuk
 Name[is]=Nepomuk miðlari
 Name[it]=Server di Nepomuk
@@ -110,11 +111,12 @@
 Comment[hr]=Nepomuk poslužitelj koji pruža usluge pohrane i upravljanja Strigijem
 Comment[hsb]=Nepomuk-serwer staji składowanske słužby a strigi-kontrolu k dispoziciji.
 Comment[hu]=A Nepomuk szolgáltatás tárolási lehetőséget biztosít és a Strigi vezérlését végzi
+Comment[ia]=Le servitor Nepomuk forniente servicios de Storage e controlante de strigi
 Comment[id]=Server Nepomuk memberikan layanan Penyimpanan dan pengendalian strigi
 Comment[is]=Nepomuk miðlarinn heldur utanum geymsluþjónustur og Strigi stýringu
 Comment[it]=Il server Nepomuk fornisce servizi di memorizzazione e controllo di Strigi
 Comment[ja]=ストレージサービスを提供し Strigi を制御する Nepomuk サーバ
-Comment[kk]=Сақтау қызметі және strigi бақлауын атқаратын Nepomuk сервері
+Comment[kk]=Сақтау қызметі және strigi бақылауын атқаратын Nepomuk сервері
 Comment[km]=ម៉ាស៊ីន​បម្រើ Nepomuk ផ្ដល់​សេវា​ផ្ទុក និង​ការត្រួតពិនិត្យ strigi
 Comment[kn]=ಸ್ಟ್ರಿಗಿ ನಿಯಂತ್ರಣ ಮತ್ತು ಸಂಗ್ರಹ ಸೇವೆಗಳನ್ನು ಒದಗಿಸುವ ನೆಪೋಮುಕ್ ಪರಿಚಾರಕ (ಸರ್ವರ್)
 Comment[ko]=저장소 서비스를 제공하는 Nepomuk 서버와 Strigi 제어
@@ -146,7 +148,7 @@
 Comment[sv]=Nepomuk-server som tillhandahåller lagringstjänster och styrning av Strigi
 Comment[ta]=The Nepomuk Server providing Storage services and strigi controlling
 Comment[te]=Nepomuk సేవిక నిల్వ సేవలను మరియు strigi నింయత్రణను అందిస్తుంది
-Comment[tg]=Сервер Nepomuk предоставляет службы хранения данных и управление Strigi
+Comment[tg]=Хидматгоҳи Nepomuk хидматҳои захира ва идоракунии маълумот дастрас мекунад
 Comment[th]=บริการ Nepomuk จะให้บริการจัดเก็บข้อมูลและทำการควบคุม strigi
 Comment[tr]=Nepomuk Sunucusu Depolama servislerini ve Strigi uygulamasının kontrolünü sağlar
 Comment[uk]=Сервер Nepomuk надає служби збереження і керування strigi
Index: nepomuk/strigibackend/nepomukindexwriter.cpp
===================================================================
--- nepomuk/strigibackend/nepomukindexwriter.cpp	(révision 1121160)
+++ nepomuk/strigibackend/nepomukindexwriter.cpp	(copie de travail)
@@ -1,5 +1,5 @@
 /*
-  Copyright (C) 2007-2009 Sebastian Trueg <trueg@kde.org>
+  Copyright (C) 2007-2010 Sebastian Trueg <trueg@kde.org>
 
   This library is free software; you can redistribute it and/or
   modify it under the terms of the GNU General Public License as
@@ -21,6 +21,7 @@
 #include "util.h"
 #include "nfo.h"
 #include "nie.h"
+#include "nrl.h"
 
 #include <Soprano/Soprano>
 #include <Soprano/Vocabulary/RDF>
@@ -127,11 +128,14 @@
     class FileMetaData
     {
     public:
-        FileMetaData( const KUrl& url );
+        FileMetaData( const Strigi::AnalysisResult* idx );
 
         /// stores basic data including the nie:url and the nrl:GraphMetadata in \p model
         void storeBasicData( Soprano::Model* model );
 
+        /// map a blank node to a resource
+        QUrl mapNode( const std::string& s );
+
         /// The resource URI
         QUrl resourceUri;
 
@@ -147,8 +151,12 @@
         /// a buffer for all plain-text content generated by strigi
         std::string content;
 
+    private:
+        /// The Strigi result
+        const Strigi::AnalysisResult* m_analysisResult;
+
         /// mapping from blank nodes used in addTriplet to our urns
-        QMap<std::string, QUrl> blankNodeMap;
+        QMap<std::string, QUrl> m_blankNodeMap;
     };
 
     class RegisteredFieldData
@@ -170,10 +178,12 @@
         bool isRdfType;
     };
 
-    FileMetaData::FileMetaData( const KUrl& url )
-        : fileUrl( url ),
-          fileInfo( url.toLocalFile() )
+    FileMetaData::FileMetaData( const Strigi::AnalysisResult* idx )
+        : m_analysisResult( idx )
     {
+        fileUrl = createFileUrl( idx );
+        fileInfo = fileUrl.toLocalFile();
+
         // determine the resource URI by using Nepomuk::Resource's power
         // this will automatically find previous uses of the file in question
         // with backwards compatibility
@@ -183,6 +193,27 @@
         context = Nepomuk::ResourceManager::instance()->generateUniqueUri( "ctx" );
     }
 
+    QUrl FileMetaData::mapNode( const std::string& s )
+    {
+        if ( s[0] == ':' ) {
+            if( m_blankNodeMap.contains( s ) ) {
+                return m_blankNodeMap[s];
+            }
+            else {
+                QUrl urn = Nepomuk::ResourceManager::instance()->generateUniqueUri( QString() );
+                m_blankNodeMap.insert( s, urn );
+                return urn;
+            }
+        }
+        // special case to properly handle nie:isPartOf relations created for containers
+        else if ( s == m_analysisResult->path() ) {
+            return resourceUri;
+        }
+        else {
+            return QUrl::fromEncoded( s.c_str() );
+        }
+    }
+
     void FileMetaData::storeBasicData( Soprano::Model* model )
     {
         model->addStatement( resourceUri, Nepomuk::Vocabulary::NIE::url(), fileUrl, context );
@@ -206,7 +237,7 @@
         QUrl metaDataContext = Nepomuk::ResourceManager::instance()->generateUniqueUri( "ctx" );
         model->addStatement( context,
                              Vocabulary::RDF::type(),
-                             Vocabulary::NRL::InstanceBase(),
+                             Nepomuk::Vocabulary::NRL::DiscardableInstanceBase(),
                              metaDataContext );
         model->addStatement( context,
                              Vocabulary::NAO::created(),
@@ -218,10 +249,10 @@
                              metaDataContext );
         model->addStatement( metaDataContext,
                              Vocabulary::RDF::type(),
-                             Vocabulary::NRL::GraphMetadata(),
+                             Nepomuk::Vocabulary::NRL::GraphMetadata(),
                              metaDataContext );
         model->addStatement( metaDataContext,
-                             Vocabulary::NRL::coreGraphMetadataFor(),
+                             Nepomuk::Vocabulary::NRL::coreGraphMetadataFor(),
                              context,
                              metaDataContext );
     }
@@ -272,22 +303,6 @@
         }
     }
 
-    QUrl mapNode( FileMetaData* fmd, const std::string& s ) {
-        if ( s[0] == ':' ) {
-            if( fmd->blankNodeMap.contains( s ) ) {
-                return fmd->blankNodeMap[s];
-            }
-            else {
-                QUrl urn = Nepomuk::ResourceManager::instance()->generateUniqueUri( QString() );
-                fmd->blankNodeMap.insert( s, urn );
-                return urn;
-            }
-        }
-        else {
-            return QUrl::fromEncoded( s.c_str() );
-        }
-    }
-
     Soprano::Model* repository;
 
     //
@@ -355,7 +370,7 @@
     }
 
     // create the file data used during the analysis
-    FileMetaData* data = new FileMetaData( createFileUrl( idx ) );
+    FileMetaData* data = new FileMetaData( idx );
 
     // remove previously indexed data
     removeIndexedData( data->resourceUri, data->fileUrl );
@@ -449,7 +464,7 @@
             if ( value[0] == ':' ) {
                 Nepomuk::Types::Property property( rfd->property );
                 if ( property.range().isValid() ) {
-                    statement.setObject( d->mapNode( md, value ) );
+                    statement.setObject( md->mapNode( value ) );
                 }
             }
         }
@@ -545,11 +560,11 @@
 
     FileMetaData* md = fileDataForResult( d->currentResultStack.top() );
 
-    QUrl subject = d->mapNode( md, s );
-    Nepomuk::Types::Property property( d->mapNode( md, p ) );
+    QUrl subject = md->mapNode( s );
+    Nepomuk::Types::Property property( md->mapNode( p ) );
     Soprano::Node object;
     if ( property.range().isValid() )
-        object = d->mapNode( md, o );
+        object = md->mapNode( o );
     else
         object = Soprano::LiteralValue::fromString( QString::fromUtf8( o.c_str() ), property.literalRangeType().dataTypeUri() );
 
Index: nepomuk/strigibackend/CMakeLists.txt
===================================================================
--- nepomuk/strigibackend/CMakeLists.txt	(révision 1121160)
+++ nepomuk/strigibackend/CMakeLists.txt	(copie de travail)
@@ -15,6 +15,11 @@
 )
 
 soprano_add_ontology(strigi_nepomuk_indexer_SRCS
+  ${SHAREDDESKTOPONTOLOGIES_ROOT_DIR}/nepomuk/nrl.trig
+  "NRL"
+  "Nepomuk::Vocabulary"
+  "trig")
+soprano_add_ontology(strigi_nepomuk_indexer_SRCS
   ${SHAREDDESKTOPONTOLOGIES_ROOT_DIR}/nie/nfo.trig
   "NFO"
   "Nepomuk::Vocabulary"
Index: nepomuk/kcm/kcm_nepomuk.desktop
===================================================================
--- nepomuk/kcm/kcm_nepomuk.desktop	(révision 1121160)
+++ nepomuk/kcm/kcm_nepomuk.desktop	(copie de travail)
@@ -8,7 +8,7 @@
 X-KDE-ServiceTypes=KCModule
 X-KDE-Library=kcm_nepomuk
 X-KDE-ParentApp=kcontrol
-X-KDE-System-Settings-Parent-Category=advanced-user-settings
+X-KDE-System-Settings-Parent-Category=advanced-user-settings
 
 Name=Desktop Search
 Name[ar]=بحث سطح المكتب
@@ -40,6 +40,7 @@
 Name[hr]=Pretraživanje računala
 Name[hsb]=Pytanje za dźěłowy powjerch
 Name[hu]=Asztali keresés
+Name[ia]=Cerca de Scriptorio
 Name[id]=Pencarian Desktop
 Name[is]=Skjáborðsleit
 Name[it]=Ricerca desktop
@@ -115,6 +116,7 @@
 Comment[hr]=Konfiguracija Nepomuk/Strigi poslužitelja
 Comment[hsb]=Připrawjenje Nepomuk/Strigi-Serwera
 Comment[hu]=A Nepomuk/Strigi szolgáltatás beállítása
+Comment[ia]=Configuration de servitor Nepomuk/Strigi
 Comment[id]=Konfigurasi Server Nepomuk/Strigi
 Comment[is]=Nepomuk/Strigi miðlarastillingar
 Comment[it]=Configurazione dei server di Nepomuk/Strigi
Index: nepomuk/kcm/nepomukserverkcm.cpp
===================================================================
--- nepomuk/kcm/nepomukserverkcm.cpp	(révision 1121160)
+++ nepomuk/kcm/nepomukserverkcm.cpp	(copie de travail)
@@ -28,6 +28,7 @@
 #include <KMessageBox>
 
 #include <QtGui/QTreeView>
+#include <QtDBus/QDBusServiceWatcher>
 
 #include <Soprano/PluginManager>
 
@@ -117,10 +118,15 @@
     connect( m_checkShowHiddenFolders, SIGNAL( toggled( bool ) ),
              m_folderModel, SLOT( setHiddenFoldersShown( bool ) ) );
 
-    connect( QDBusConnection::sessionBus().interface(),
-             SIGNAL( serviceOwnerChanged( const QString&, const QString&, const QString& ) ),
-             this,
-             SLOT( slotUpdateStrigiStatus() ) );
+    QDBusServiceWatcher * watcher = new QDBusServiceWatcher( this );
+    watcher->addWatchedService( QLatin1String("org.kde.nepomuk.services.nepomukstrigiservice") );
+    watcher->setConnection( QDBusConnection::sessionBus() );
+    watcher->setWatchMode( QDBusServiceWatcher::WatchForRegistration | QDBusServiceWatcher::WatchForUnregistration );
+    
+    connect( watcher, SIGNAL( serviceRegistered(const QString&) ),
+             this, SLOT( slotUpdateStrigiStatus() ) );
+    connect( watcher, SIGNAL( serviceUnregistered(const QString&) ),
+             this, SLOT( slotUpdateStrigiStatus() ) );
 
     recreateStrigiInterface();
 }
Index: nepomuk/kcm/nepomukconfigwidget.ui
===================================================================
--- nepomuk/kcm/nepomukconfigwidget.ui	(révision 1121160)
+++ nepomuk/kcm/nepomukconfigwidget.ui	(copie de travail)
@@ -158,7 +158,7 @@
              <string>Index the files on removable media like USB sticks when they are mounted</string>
             </property>
             <property name="text">
-             <string>Index Files on Removable Media</string>
+             <string>Index files on removable media</string>
             </property>
            </widget>
           </item>
Index: nepomuk/servicestub/main.cpp
===================================================================
--- nepomuk/servicestub/main.cpp	(révision 1121160)
+++ nepomuk/servicestub/main.cpp	(copie de travail)
@@ -23,6 +23,7 @@
 #include <KService>
 #include <KServiceTypeTrader>
 #include <KDebug>
+#include <KApplication>
 
 #include <QtCore/QTextStream>
 #include <QtCore/QTimer>
@@ -80,10 +81,6 @@
 
     KCmdLineArgs::init( argc, argv, &aboutData );
 
-    QApplication app( argc, argv );
-    installSignalHandler();
-    QApplication::setQuitOnLastWindowClosed( false );
-
     // FIXME: set the proper KConfig rc name using the service name
 
     KCmdLineArgs* args = KCmdLineArgs::parsedArgs();
@@ -100,7 +97,10 @@
     args->clear();
 
     aboutData.setAppName( serviceName.toLocal8Bit() );
-    KComponentData compData( aboutData );
+    KApplication app( true /* The strigi service actually needs a GUI at the moment */ );
+    app.disableSessionManagement();
+    installSignalHandler();
+    QApplication::setQuitOnLastWindowClosed( false );
 
 
     // check if NepomukServer is running
@@ -142,12 +142,12 @@
 
     // register the service control
     // ====================================
-    Nepomuk::ServiceControl* control = new Nepomuk::ServiceControl( serviceName, service, &app );
+    Nepomuk::ServiceControl control( serviceName, service, 0 );
 
 
     // start the service (queued since we need an event loop)
     // ====================================
-    QTimer::singleShot( 0, control, SLOT( start() ) );
+    QTimer::singleShot( 0, &control, SLOT( start() ) );
 
     return app.exec();
 }
Index: nepomuk/services/strigi/nepomukstrigiservice.notifyrc
===================================================================
--- nepomuk/services/strigi/nepomukstrigiservice.notifyrc
+++ nepomuk/services/strigi/nepomukstrigiservice.notifyrc	2010-05-14 10:17:09.000000000 +0200
@@ -86,6 +57,7 @@
 Name[hr]=Prvotno indeksiranje je započelo
 Name[hsb]=Prěnje tworjenje indeksa startowane
 Name[hu]=A kezdeti index elkészítése folyik
+Name[ia]=Il initiava le indicisation initial
 Name[id]=Pengindeksan Awal dimulai
 Name[is]=Gerð upphafsyfirlits er hafin
 Name[it]=Indicizzazione iniziale avviata
@@ -109,7 +81,7 @@
 Name[pa]=ਸ਼ੁਰੂਆਤੀ ਇੰਡੈਕਸ ਸ਼ੁਰੂ ਕੀਤਾ
 Name[pl]=Rozpoczęto początkowe indeksowanie
 Name[pt]=Início da primeira indexação
-Name[pt_BR]=Iniciada a indexação inicial
+Name[pt_BR]=A indexação inicial foi iniciada
 Name[ro]=Indexarea inițială a început
 Name[ru]=Начато индексирование
 Name[si]=තනි සූචිකරණය ඇරඹිනි
@@ -148,7 +120,7 @@
 Comment[gl]=Comezouse a indexación dos ficheiros locais para facer procuras rápidas.
 Comment[he]=אינדוקס של קבצים מקומיים עבור חיפושים מהירים החל
 Comment[hr]=Započelo je indeksiranje lokalnih datoteka za brzu pretragu.
-Comment[hu]=A helyi fájlok indexelése elkezdődött a gyors keresések számára.
+Comment[ia]=Le indicisation de archivos local pro rapide cercas ha initiate
 Comment[id]=Pengindeksan berkas lokal untuk pencarian desktop secara cepat telah dimulai.
 Comment[is]=Gerð skráayfirlits til að styðja við hraðar skjáborðsleitir er hafin.
 Comment[it]=Indicizzazione dei file locali per le ricerche veloci avviata
@@ -165,7 +137,6 @@
 Comment[nds]=Dat Indizeren vun lokaal Dateien för gau Söken hett anfungen
 Comment[nl]=Indexering van lokale bestanden voor snelle zoekopdrachten is gestart.
 Comment[nn]=Starta førsteindekseringa av lokale filer for snøgge søk.
-Comment[pa]=ਤੇਜ਼ ਡੈਸਕਟਾਪ ਖੋਜ ਲਈ ਲੋਕਲ ਫਾਇਲਾਂ ਵਾਸਤੇ ਇੰਡੈਕਸ ਬਣਾਉਣਾ ਸ਼ੁਰੂ ਕੀਤਾ
 Comment[pl]=Nastąpiło rozpoczęcie indeksowania plików lokalnych w celu przyspieszenia wyszukiwania.
 Comment[pt]=A indexação dos ficheiros para pesquisas mais rápidas começou agora.
 Comment[pt_BR]=A indexação dos arquivos para pesquisas rápidas foi iniciada.
@@ -215,6 +186,7 @@
 Name[hr]=Prvotno indeksiranje je završilo
 Name[hsb]=Prěni indeks dotwarjeny
 Name[hu]=A kiindulási index elkészült
+Name[ia]=Le indicisation Initial finiva
 Name[id]=Pengindeksan Awal selesai
 Name[is]=Gerð upphafsyfirlits er lokið
 Name[it]=Indicizzazione iniziale terminata
@@ -238,7 +210,7 @@
 Name[pa]=ਸ਼ੁਰੂਆਤੀ ਇੰਡੈਕਸ ਮੁਕੰਮਲ
 Name[pl]=Początkowe indeksowanie zakończone
 Name[pt]=Fim da primeira indexação
-Name[pt_BR]=Concluída a indexação inicial
+Name[pt_BR]=A indexação inicial foi concluída
 Name[ro]=Indexarea inițială s-a încheiat
 Name[ru]=Индексирование закончено
 Name[si]=තනි සූචිකරණය නිමයි
@@ -251,7 +223,7 @@
 Name[sv]=Inledande indexering klar
 Name[ta]=Initial Indexing finished
 Name[te]=ప్రాధమిక విషయవర్గీకరణ పూర్తైనది.
-Name[tg]=Создание индекса завершено.
+Name[tg]=Эҷоди индекс ба итмом расид
 Name[th]=เตรียมการการทำดัชนีเสร็จแล้ว
 Name[tr]=Temel İndeksleme tamamlandı
 Name[uk]=Початкове індексування закінчено
@@ -276,7 +248,7 @@
 Comment[gl]=Completouse a indexación inicial dos ficheiros locais para facer procuras rápidas no escritorio.
 Comment[he]=אינדוקס ראשוני של קבצים מקומיים עבור חיפושי שולחן מהירים הסתיים
 Comment[hr]=Završilo je prvotno indeksiranje lokalnih datoteka za brzu pretragu računala.
-Comment[hu]=A helyi fájlok indexelése befejeződöttt a gyors asztali keresések számára.
+Comment[ia]=Le indicisation de archivos local pro rapide cercas de scriptorio ha completate.
 Comment[id]=Pengindeksan awal berkas lokal untuk pencarian desktop secara cepat telah selesai.
 Comment[is]=Gerð skráayfirlits til að styðja við hraðar skjáborðsleitir er lokið.
 Comment[it]=L'indicizzazione iniziale dei file locali per le ricerche desktop veloci è stata completata.
@@ -293,7 +265,6 @@
 Comment[nds]=Dat eerste Indizeren vun lokaal Dateien för gau Schriefdisch-Söken is afslaten.
 Comment[nl]=De eerste indexering van lokale bestanden voor snelle desktop-zoekopdrachten is gereed.
 Comment[nn]=Starta førsteindekseringa av lokale filer for snøgge søk.
-Comment[pa]=ਤੇਜ਼ ਡੈਸਕਟਾਪ ਖੋਜ ਲਈ ਲੋਕਲ ਫਾਇਲਾਂ ਵਾਸਤੇ ਇੰਡੈਕਸ ਬਣਾਉਣਾ ਪੂਰਾ ਹੋਇਆ।
 Comment[pl]=Nastąpiło zakończenie wstępnego indeksowania plików lokalnych w celu przyspieszenia wyszukiwania.
 Comment[pt]=A primeira indexação dos ficheiros para pesquisas mais rápidas terminou.
 Comment[pt_BR]=A indexação inicial de arquivos locais para pesquisas rápidas foi concluída.
@@ -343,6 +314,7 @@
 Name[hr]=Indeksiranje je pauzirano
 Name[hsb]=Tworjenje indeksa zastajene
 Name[hu]=Az indexelés felfüggesztve
+Name[ia]=Il suspendeva le indicisation
 Name[id]=Pengindeksan disuspensi
 Name[is]=Hætt við yfirlitsgerð
 Name[it]=Indicizzazione sospesa
@@ -401,11 +373,10 @@
 Comment[fi]=Hakupalvelu on keskeyttänyt tiedostoindeksoinnin.
 Comment[fr]=L'indexation de fichiers a été suspendue par le service de recherche.
 Comment[fy]=Triem yndeksearring is ûnderbrútsen troch de syk tsjinst
-Comment[ga]=Chuir an tseirbhís chuardaigh innéacsú comhad ar fionraí.
 Comment[gl]=O servizo de procuras suspendeu a indexación de ficheiros.
 Comment[he]=אינדוקס קובץ הושהה על-ידי שירות החיפוש
 Comment[hr]=Usluga pretrage je pauzirala indeksiranje datoteka.
-Comment[hu]=A fájl indexelést a kereső szolgáltatás felfüggesztette.
+Comment[ia]=Le indicisation del Archivo ha essite suspendite per le servicio de cerca
 Comment[id]=Pengindeksan berkas telah disuspensi oleh layanan pencarian.
 Comment[is]=Gerð skráayfirlits hefur verið frestað af leitartækinu.
 Comment[it]=L'indicizzazione dei file è stata sospesa dal servizio di ricerca.
@@ -422,7 +393,6 @@
 Comment[nds]=De Söökdeenst hett dat Indizeren vun Dateien utsett.
 Comment[nl]=Bestandenindexering is onderbroken door de zoekservice.
 Comment[nn]=Filindekseringa med vart stoppa av søkjetenesta.
-Comment[pa]=ਖੋਜ ਸਰਵਿਸ ਨੇ ਫਾਇਲ ਇੰਡੈਕਸ ਨੂੰ ਸਸਪੈਂਡ ਕੀਤਾ
 Comment[pl]=Indeksowanie plików zostało zawieszone przez usługę wyszukiwania.
 Comment[pt]=A indexação de ficheiros foi suspensa pelo serviço de pesquisa.
 Comment[pt_BR]=A indexação de arquivos foi suspensa pelo serviço de pesquisa.
@@ -472,6 +442,7 @@
 Name[hr]=Indeksiranje nastavljeno
 Name[hsb]=Indeks so dale twari
 Name[hu]=Az indexelés folytatódik
+Name[ia]=Il resumeva le indicisation
 Name[id]=Pengindeksan dilanjutkan
 Name[is]=Yfirlitsgerð er hafin aftur
 Name[it]=Indicizzazione ripresa
@@ -530,11 +501,10 @@
 Comment[fi]=Hakupalvelu on käynnistänyt tiedostoindeksoinnin uudelleen
 Comment[fr]=L'indexation des fichiers a été reprise par le service de recherche.
 Comment[fy]=Triem yndeksearring is ferfette troch de syk tsjinst
-Comment[ga]=D'atosaigh an tseirbhís chuardaigh innéacsú comhad.
 Comment[gl]=O servizo de procuras continuou a indexación de ficheiros.
 Comment[he]=אינדוקס קובץ נמשך על-ידי שירות החיפוש
 Comment[hr]=Usluga pretrage je nastavila indeksiranje datoteka.
-Comment[hu]=A fájl indexelést a kereső szolgáltatás folytatta.
+Comment[ia]=Le indicisation de archivo ha essite resumite per le servicio de cerca
 Comment[id]=Pengindeksan berkas telah dilanjutkan oleh layanan pencarian.
 Comment[is]=Gerð skráayfirlits hefur verið hafin aftur af leitartækinu.
 Comment[it]=L'indicizzazione dei file è stata ripresa dal servizio di ricerca.
@@ -551,7 +521,6 @@
 Comment[nds]=De Söökdeenst maakt mit dat Indizeren vun Dateien wieder.
 Comment[nl]=Bestandenindexering is hervat door de zoekservice.
 Comment[nn]=Filindekseringa vart starta opp att av søkjetenesta.
-Comment[pa]=ਖੋਜ ਸਰਵਿਸ ਵਲੋਂ ਫਾਇਲ ਇੰਡੈਕਸ ਮੁੜ-ਚਲਾਇਆ ਗਿਆ
 Comment[pl]=Wznowiono indeksowanie plików.
 Comment[pt]=A indexação de ficheiros foi retomada pelo serviço de pesquisa.
 Comment[pt_BR]=A indexação de arquivos foi retomada pelo serviço de pesquisa.
Index: nepomuk/services/storage/nepomukstorage.notifyrc
===================================================================
--- nepomuk/services/storage/nepomukstorage.notifyrc
+++ nepomuk/services/storage/nepomukstorage.notifyrc	2010-05-14 10:17:29.000000000 +0200
@@ -196,6 +101,7 @@
 Name[sr@ijekavianlatin]=Neuspjelo pokretanje Nepomuka
 Name[sr@latin]=Neuspelo pokretanje Nepomuka
 Name[sv]=Misslyckades starta Nepomuk
+Name[tg]=Оғози Nepomuk қатъ шуд
 Name[th]=ล้มเหลวในการเริ่มบริการ Nepomuk
 Name[tr]=Nepomuk başlatılamadı
 Name[uk]=Не вдалося запустити Nepomuk
@@ -216,10 +122,9 @@
 Comment[fi]=Nepomuk semanttista työpöytäjärjestelmää ei voitu käynnistää 
 Comment[fr]=Le système de bureau sémantique Nepomuk ne peut être démarré
 Comment[fy]=De Nepomuk semantic buroblêd systeem koe net úteinsetten wurde
-Comment[ga]=Níorbh fhéidir Deasc Shéimeantach Nepomuk a thosú
 Comment[he]=לא ניתן להפעיל את מערכת שולחן העבודה הסמנטית של Nepomuk 
 Comment[hr]=Sustav semantičke radne površine Nepomuk ne može biti pokrenut
-Comment[hu]=Nem sikerült elindítani a Nepomuk szemantikus asztali rendszert
+Comment[ia]=Le systema de Scriptorio Semantic de Nepomuk non poteva esser initiate
 Comment[id]=Sistem Desktop Semantik Nepomuk tak dapat dijalankan
 Comment[is]=Ekki var hægt að ræsa Merkingarlega Nemopuk (semantic) Skjáborðskerfið
 Comment[it]=Impossibile avviare il sistema del desktop semantico Nepomuk
@@ -284,6 +189,7 @@
 Name[hr]=Pretvaram Nepomukove podatke
 Name[hsb]=Konwertěruju Nepomukowe daty
 Name[hu]=Indexadatok konvertálása folyik
+Name[ia]=Il converte datos de Nepomuk
 Name[id]=Mengonversi data Nepomuk
 Name[is]=Umbreyti Nepomuk gögnum
 Name[it]=Conversione dei dati di Nepomuk
@@ -354,6 +260,7 @@
 Comment[hr]=Svi Nepomukovi podaci su pretvoreni u format novog načina pohrane
 Comment[hsb]=Wšě Nepomukowe daty buchu za nowy składowanski backend konwertěrowane
 Comment[hu]=Sikerült átkonvertálni minden adatot az új tárolómodul számára
+Comment[ia]=Tote le datos de Nepomuk es convertite a un nove backend de storage
 Comment[id]=Semua data Nepomuk dikonversi ke ujung belakang penyimpanan baru
 Comment[is]=Öllum Nepomuk er umbreytt fyrir nýja geymslubakendann
 Comment[it]=Tutti i dati di Nepomuk sono convertiti ad un nuovo motore di memorizzazione
@@ -427,6 +334,7 @@
 Name[hr]=Pretvaranje Nepomukovih podataka nije uspjelo.
 Name[hsb]=Konwertěrowanje Nepomukowych datow zwrěšćene
 Name[hu]=Adatkonvertálási hiba történt a Nepomukban
+Name[ia]=Il falleva le conversion de datos de Nepomuk
 Name[id]=Mengonversi data Nepomuk telah gagal
 Name[is]=Umbreyting Nepomuk gagna mistókst
 Name[it]=Conversione dei dati di Nepomuk non riuscita
@@ -497,6 +405,7 @@
 Comment[hr]=Pretvaranje Nepomukovih podataka u novi format nije uspjelo.
 Comment[hsb]=Konwertěrowanje Nepomukowych datow za nowy backend je zwrěšćiło.
 Comment[hu]=Ne sikerült átkonvertálni Nepomuk-adatokat egy új kezelőmodul számára
+Comment[ia]=Il falleva le conversion de datos de Nepomuk a un nove backend
 Comment[id]=Mengonversi data Nepomuk ke ujung belakang baru gagal
 Comment[is]=Umbreyting Nepomuk gagna fyrir nýjan bakenda mistókst
 Comment[it]=La conversione dei dati di Nepomuk ad un nuovo motore di memorizzazione non è riuscita
@@ -570,6 +479,7 @@
 Name[hr]=Pretvarane Nepomukovih podataka je završilo.
 Name[hsb]=Konwertěrowanje Nepomukowych datow zakónčene
 Name[hu]=Nepomuk adatkonverzió befejeződött
+Name[ia]=Facite la conversion de datos de Nepomuk 
 Name[id]=Mengonversi data Nepomuk telah selesai
 Name[is]=Umbreyting Nepomuk gagna er lokið
 Name[it]=Conversione dei dati di Nepomuk completata
@@ -640,6 +550,7 @@
 Comment[hr]=Nepomukovi podaci su uspješno pretvoreni u novi format.
 Comment[hsb]=Konwertěrowanje Nepomukowych datow za nowy backend wuspěšne.
 Comment[hu]=Sikerült átkonvertálni minden Nepomuk-adatot az új tárolómodulhoz 
+Comment[ia]=Il converteva con successo datos de Nepomuk a un nove backend
 Comment[id]=Sukses mengonversi data Nepomuk ke ujung belakang baru
 Comment[is]=Umbreyting Nepomuk gagna fyrir nýjan bakenda tókst
 Comment[it]=Conversione dei dati di Nepomuk ad un nuovo motore riuscita
Index: nepomuk/kioslaves/search/kdedmodule/nepomuksearchmodule.desktop
===================================================================
--- nepomuk/kioslaves/search/kdedmodule/nepomuksearchmodule.desktop
+++ nepomuk/kioslaves/search/kdedmodule/nepomuksearchmodule.desktop	2010-05-14 10:16:48.000000000 +0200
@@ -27,7 +27,6 @@
 Name[kk]=Nepomuk іздеу модулі
 Name[km]=ម៉ូឌុល​ស្វែងរក​របស់ Nepomuk
 Name[lt]=Nepomuk paieškos modulis
-Name[lv]=Nepomuk meklēšanas modulis
 Name[mk]=Модул на Непомук за пребарување
 Name[nb]=Nepomuk søkemodul
 Name[nds]=Nepomuk-Söökmoduul
@@ -44,7 +43,7 @@
 Name[sr@ijekavianlatin]=Pretraživački modul Nepomuka
 Name[sr@latin]=Pretraživački modul Nepomuka
 Name[sv]=Nepomuk-sökmodul
-Name[tg]=Хидматҳои Nepomuk
+Name[tg]=Хидматҳои ҷустуҷӯии Nepomuk
 Name[th]=มอดูลค้นหาของบริการ Neomuk
 Name[tr]=Nepomuk Arama Modülü
 Name[uk]=Модуль пошуку Nepomuk
@@ -63,7 +62,7 @@
 Comment[eu]=KIOrentzako modulu laguntzailea nepomuksearch zerrenden eguneraketa automatikoa ziurtatzeko.
 Comment[fr]=Module assistant pour KIO qui assure les mises à jours automatiques des listes de NepomukSearch 
 Comment[hr]=Pomoćni modul za KIO koji osigurava automatsko ažuriranje izlistavanja nepomuk pretraga.
-Comment[hu]=Súgó modul a KIO számára, hogy biztos legyen a nepomuk keresési listázások automatikus frissítése.
+Comment[ia]=Modulo de Adjuta pro KIO per assecurar actualisationes automatic de listas de nepomuksearch.
 Comment[id]=Modul penolong untuk KIO untuk memastikan pemutakhiran otomatis pengurutan nepomuksearch.
 Comment[it]=Modulo ausiliare per KIO per assicurare gli aggiornamenti automatici delle liste di ricerca di Nepomuk.
 Comment[kk]=nepomuksearch тізімдерін автоматты түрде жаңартуға арналған KIO-нің көмекші модулі
@@ -84,7 +83,7 @@
 Comment[sr@latin]=Pomoćni modul za K‑U/I koji obezbeđuje automatsko ažuriranje spiskova Nepomukove pretrage.
 Comment[sv]=Hjälpmodul för I/O-slavar för att försäkra att automatisk uppdatering görs av Nepomuk söklistningar.
 Comment[th]=มอดูลช่วยสำหรับ KIO เพื่อให้แน่ใจว่าจะมีการปรับปรุงการทำรายการของ nepomuksearch
-Comment[tr]=KIO'nun, nepomuksearch listelerinin otomatik güncellenmesini sağlaması için yardımcı modül.
+Comment[tr]=nepomuksearch listelemelerini otomatik güncellemek için KIO yardımcı modülü.
 Comment[uk]=Допоміжний модуль KIO для забезпечення автоматичного оновлення списків nepomuksearch.
 Comment[x-test]=xxHelper module for KIO to ensure automatic updates of nepomuksearch listings.xx
 Comment[zh_CN]=KIO 用于自动更新 Nepomuk 搜索列表的助手模块。
