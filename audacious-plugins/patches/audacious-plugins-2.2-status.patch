diff -Nur audacious-plugins-2.2-orig/src/statusicon/si_ui.c audacious-plugins-2.2/src/statusicon/si_ui.c
--- audacious-plugins-2.2-orig/src/statusicon/si_ui.c	2009-11-22 23:49:53.000000000 +0100
+++ audacious-plugins-2.2/src/statusicon/si_ui.c	2010-04-07 19:20:06.000000000 +0200
@@ -30,17 +30,17 @@
 #include <gdk/gdkx.h>
 #include <gtk/gtk.h>
 
-#ifndef MAX
-# define MAX(a,b) ((a) > (b) ? (a) : (b))
-#endif
-
 static void si_ui_statusicon_popup_timer_start ( GtkStatusIcon * );
 static void si_ui_statusicon_popup_timer_stop ( GtkStatusIcon * );
 static void si_ui_statusicon_smallmenu_show ( gint x, gint y, guint button, guint32 time , gpointer );
 static void si_ui_statusicon_smallmenu_recreate ( GtkStatusIcon * );
+static void si_ui_statusicon_popup_hide ( gpointer icon );
 
 extern si_cfg_t si_cfg;
 static gboolean recreate_smallmenu = FALSE;
+static gint last_x = -1;
+static gint last_y = -1;
+static gint popup_step = 0;
 
 
 /* this stuff required to make titlechange hook work properly */
@@ -93,6 +93,14 @@
 
     case 3:
     {
+      if (GPOINTER_TO_INT(g_object_get_data(G_OBJECT(icon), "popup_active" )) == 1)
+      {
+        popup_step = 1;
+        
+        si_ui_statusicon_popup_hide( icon );
+        si_ui_statusicon_popup_timer_start( icon );
+      }
+      
       if (event->state & GDK_SHIFT_MASK)
         audacious_drct_pl_prev();
       else{
@@ -161,30 +169,65 @@
 static gboolean
 si_ui_statusicon_popup_show ( gpointer icon )
 {
-  if ( GPOINTER_TO_INT(g_object_get_data( G_OBJECT(icon) , "timer_active" )) == 1 )
-  {
-    Tuple *tuple;
-    gint pl_active = aud_playlist_get_active();
-    gint pos = aud_playlist_get_position(pl_active);
-    GtkWidget *popup = g_object_get_data( G_OBJECT(icon) , "popup" );
-
-    tuple = (Tuple*) aud_playlist_entry_get_tuple( pl_active , pos );
-    if ( ( tuple == NULL ) || ( aud_tuple_get_int(tuple, FIELD_LENGTH, NULL) < 1 ) )
-    {
-      gchar *title = (gchar*) aud_playlist_entry_get_title( pl_active , pos );
-      audacious_fileinfopopup_show_from_title( popup , title );
-      g_free( title );
-    }
-    else
-    {
-      audacious_fileinfopopup_show_from_tuple( popup , tuple );
+    if ( GPOINTER_TO_INT(g_object_get_data( G_OBJECT(icon) , "timer_active" )) == 1 ) {
+        switch (popup_step) {
+        case 0:
+            {
+                Tuple *tuple;
+                gint pl_active = aud_playlist_get_active();
+                gint pos = aud_playlist_get_position(pl_active);
+                GtkWidget *popup = g_object_get_data( G_OBJECT(icon) , "popup" );
+                
+                GdkDisplay *display = gdk_display_get_default();
+                GdkScreen *screen = gdk_display_get_default_screen(display);
+                GdkRectangle area;
+                gint x, y;
+                gtk_status_icon_get_geometry(icon, &screen, &area, NULL);
+                gdk_display_get_pointer(display, &screen, &x, &y, NULL);
+
+                if (x < area.x || x > area.x + area.width || y < area.y || y > area.y + area.width)
+                {                    
+                    si_ui_statusicon_popup_timer_stop(icon);
+                    si_ui_statusicon_popup_hide(icon);
+                    
+                    return TRUE;    
+                }
+
+                tuple = (Tuple*) aud_playlist_entry_get_tuple( pl_active , pos );
+                if ( ( tuple == NULL ) || ( aud_tuple_get_int(tuple, FIELD_LENGTH, NULL) < 1 ) )  {
+                    gchar *title = (gchar*) aud_playlist_entry_get_title( pl_active , pos );
+                    audacious_fileinfopopup_show_from_title( popup , title );
+                }
+                else {
+                    audacious_fileinfopopup_show_from_tuple( popup , tuple );
+                }
+                g_object_set_data( G_OBJECT(icon) , "popup_active" , GINT_TO_POINTER(1) );
+                break;
+            }
+        case 2:
+            {
+                last_x = -1;
+                last_y = -1;
+                GdkDisplay *display = gdk_display_get_default();
+                gtk_tooltip_trigger_tooltip_query(display);
+                break;
+            }
+        default:
+            {
+                if (popup_step >= 3) {
+                    popup_step = 1;
+                    if (last_x<0 || last_y<0) {
+                        si_ui_statusicon_popup_hide(icon);
+                        si_ui_statusicon_popup_timer_stop(icon);
+                        return FALSE;
+                    }
+                }
+                break;
+            }
+        }
     }
-
-    g_object_set_data( G_OBJECT(icon) , "popup_active" , GINT_TO_POINTER(1) );
-  }
-
-  si_ui_statusicon_popup_timer_stop( icon );
-  return FALSE;
+    popup_step += 1;
+    return TRUE;
 }
 
 
@@ -204,6 +247,7 @@
 si_ui_statusicon_popup_timer_start ( GtkStatusIcon * icon )
 {
   gint timer_id = g_timeout_add( 500 , si_ui_statusicon_popup_show , icon );
+  popup_step = 0;
   g_object_set_data( G_OBJECT(icon) , "timer_id" , GINT_TO_POINTER(timer_id) );
   g_object_set_data( G_OBJECT(icon) , "timer_active" , GINT_TO_POINTER(1) );
   return;
@@ -222,6 +266,19 @@
 }
 
 
+static gboolean
+si_ui_statusicon_cb_tooltip(GtkStatusIcon *icon , gint x, gint y, gboolean keyboard_mode, GtkTooltip *tooltip, gpointer user_data) {
+    if ( GPOINTER_TO_INT(g_object_get_data( G_OBJECT(icon), "popup_active" )) == 0 ) {
+        if ( GPOINTER_TO_INT(g_object_get_data(G_OBJECT(icon),"timer_active")) == 0 ) {
+            si_ui_statusicon_popup_timer_start( icon );
+        }
+    }
+    last_x = x;
+    last_y = y;
+    return FALSE;
+}
+
+
 static void
 si_ui_statusicon_cb_aud_hook_pbstart ( gpointer plentry_gp , gpointer icon )
 {
@@ -238,8 +295,8 @@
 si_ui_statusicon_cb_aud_hook_tchange ( gpointer plentry_gp , gpointer prevs_gp )
 {
   si_aud_hook_tchange_prevs_t *prevs = prevs_gp;
-  gint pl_entry = GPOINTER_TO_INT(plentry_gp);
   gint playlist = aud_playlist_get_active();
+  gint pl_entry = aud_playlist_get_position(playlist);
   gboolean upd_pop = FALSE;
 
   if (pl_entry >= 0)
@@ -267,6 +324,7 @@
         /* if filename changes, reset title as well */
         g_free(prevs->title);
         prevs->title = g_strdup(pl_entry_title);
+        upd_pop = TRUE;
       }
     }
     else
@@ -409,7 +467,10 @@
                       G_CALLBACK(si_ui_statusicon_cb_btpress) , NULL );
     g_signal_connect( G_OBJECT(si_applet) , "scroll-event" ,
                       G_CALLBACK(si_ui_statusicon_cb_btscroll) , NULL );
+    g_signal_connect( G_OBJECT(si_applet) , "query-tooltip" ,
+                      G_CALLBACK(si_ui_statusicon_cb_tooltip) , NULL );
 
+    gtk_status_icon_set_has_tooltip( si_applet, TRUE );
     gtk_status_icon_set_visible(si_applet, TRUE);
 
     /* small menu that can be used in place of the audacious standard one */
@@ -421,7 +482,7 @@
     si_aud_hook_tchange_prevs->title = NULL;
     si_aud_hook_tchange_prevs->filename = NULL;
     si_aud_hook_tchange_prevs->applet = si_applet;
-    aud_hook_associate( "playlist set info" , si_ui_statusicon_cb_aud_hook_tchange , si_aud_hook_tchange_prevs );
+    aud_hook_associate( "title change" , si_ui_statusicon_cb_aud_hook_tchange , si_aud_hook_tchange_prevs );
 
     return;
   }
@@ -432,7 +493,7 @@
       GtkWidget *si_smenu = g_object_get_data( G_OBJECT(si_applet) , "smenu" );
       si_ui_statusicon_popup_timer_stop( si_applet ); /* just in case the timer is active */
       aud_hook_dissociate( "playback begin" , si_ui_statusicon_cb_aud_hook_pbstart );
-      aud_hook_dissociate( "playlist set info" , si_ui_statusicon_cb_aud_hook_tchange );
+      aud_hook_dissociate( "title change" , si_ui_statusicon_cb_aud_hook_tchange );
       if ( si_aud_hook_tchange_prevs->title != NULL ) g_free( si_aud_hook_tchange_prevs->title );
       if ( si_aud_hook_tchange_prevs->filename != NULL ) g_free( si_aud_hook_tchange_prevs->filename );
       g_free( si_aud_hook_tchange_prevs );
