diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
index 6e590e8..956b3da 100644
--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -284,6 +284,7 @@ set(libmetaimpl_SRCS
     core-impl/meta/multi/MultiTrack.cpp
     core-impl/meta/cue/CueFileSupport.cpp
     core-impl/meta/proxy/MetaProxy.cpp
+    core-impl/meta/proxy/MetaProxyWorker.cpp
     core-impl/meta/stream/Stream.cpp
     core-impl/playlists/types/file/PlaylistFile.cpp
     core-impl/statistics/providers/url/PermanentUrlStatisticsProvider.cpp
diff --git a/src/core-impl/collections/support/CollectionManager.cpp b/src/core-impl/collections/support/CollectionManager.cpp
index 37fe03a..9085b5a 100644
--- a/src/core-impl/collections/support/CollectionManager.cpp
+++ b/src/core-impl/collections/support/CollectionManager.cpp
@@ -463,6 +463,7 @@ CollectionManager::trackForUrl( const KUrl &url )
         }
     }
 
+    //TODO: create specific TrackProviders for these:
     if( url.protocol() == QLatin1String("http") || url.protocol() == QLatin1String("mms") ||
         url.protocol() == QLatin1String("smb") )
         return Meta::TrackPtr( new MetaStream::Track( url ) );
diff --git a/src/core-impl/meta/proxy/MetaProxy.h b/src/core-impl/meta/proxy/MetaProxy.h
index d8329be..060223f 100644
--- a/src/core-impl/meta/proxy/MetaProxy.h
+++ b/src/core-impl/meta/proxy/MetaProxy.h
@@ -17,6 +17,8 @@
 #ifndef AMAROK_METAPROXY_H
 #define AMAROK_METAPROXY_H
 
+#include "MetaProxyWorker.h"
+
 #include "core/meta/Meta.h"
 #include "core/capabilities/Capability.h"
 
@@ -82,6 +84,7 @@ namespace MetaProxy
             virtual void setDiscNumber( int discNumber );
 
             virtual qint64 length() const;
+            virtual void setLength( qint64 length );
             virtual int filesize() const;
             virtual int sampleRate() const;
             virtual int bitrate() const;
@@ -110,11 +113,12 @@ namespace MetaProxy
 		 * allows subclasses to create an instance of trackprovider which will only check the TrackProvider
 		 * passed to lookupTrack(TrackProvider*) for the real track.
 		 */
-		Track( const KUrl &url, bool awaitLookupNotification);
+        Track( const KUrl &url, bool awaitLookupNotification );
+
 		/**
 		 * MetaProxy will check the given trackprovider if it can provide the track for the proxy's url.
 		 */
-		void lookupTrack(Collections::TrackProvider *provider);
+        void lookupTrack( Collections::TrackProvider *provider );
 
         /**
          * MetaProxy will update the proxy with the track.
@@ -123,7 +127,7 @@ namespace MetaProxy
 
         private:
 			void init( const KUrl &url, bool awaitLookupNotification );
-            Private * const d;
+            Private *const d;
     };
 
 }
diff --git a/src/core-impl/meta/proxy/MetaProxy.cpp b/src/core-impl/meta/proxy/MetaProxy.cpp
index d1577a2..6a27f0e 100644
--- a/src/core-impl/meta/proxy/MetaProxy.cpp
+++ b/src/core-impl/meta/proxy/MetaProxy.cpp
@@ -17,6 +17,7 @@
 #include "core-impl/meta/proxy/MetaProxy.h"
 #include "core-impl/meta/proxy/MetaProxy_p.h"
 #include "core-impl/meta/proxy/MetaProxy_p.moc"
+#include "core-impl/meta/proxy/MetaProxyWorker.h"
 
 #include "core/capabilities/EditCapability.h"
 
@@ -27,6 +28,7 @@
 #include <QTimer>
 
 #include <KSharedPtr>
+#include <threadweaver/ThreadWeaver.h>
 
 using namespace MetaProxy;
 
@@ -83,18 +85,20 @@ MetaProxy::Track::init( const KUrl &url, bool awaitLookupNotification )
 	d->url = url;
     d->proxy = this;
     d->cachedLength = 0;
-
-	if( !awaitLookupNotification )
-    {
-        QObject::connect( CollectionManager::instance(), SIGNAL( trackProviderAdded( Collections::TrackProvider* ) ), d, SLOT( slotNewTrackProvider( Collections::TrackProvider* ) ) );
-        QObject::connect( CollectionManager::instance(), SIGNAL( collectionAdded( Collections::Collection* ) ), d, SLOT( slotNewCollection( Collections::Collection* ) ) );
-    }
-
     d->albumPtr = Meta::AlbumPtr( new ProxyAlbum( d ) );
     d->artistPtr = Meta::ArtistPtr( new ProxyArtist( d ) );
     d->genrePtr = Meta::GenrePtr( new ProxyGenre( d ) );
     d->composerPtr = Meta::ComposerPtr( new ProxyComposer( d ) );
     d->yearPtr = Meta::YearPtr( new ProxyYear( d ) );
+
+    if( !awaitLookupNotification )
+    {
+        Worker *worker = new Worker( d->url );
+        QObject::connect( worker, SIGNAL(finishedLookup( const Meta::TrackPtr & )),
+                d, SLOT(slotUpdateTrack(Meta::TrackPtr)) );
+
+        ThreadWeaver::Weaver::instance()->enqueue( worker );
+    }
 }
 
 MetaProxy::Track::~Track()
@@ -345,6 +349,12 @@ MetaProxy::Track::length() const
     return d->cachedLength;
 }
 
+void
+MetaProxy::Track::setLength( qint64 length )
+{
+    d->cachedLength = length;
+}
+
 int
 MetaProxy::Track::filesize() const
 {
@@ -424,7 +434,7 @@ MetaProxy::Track::inCollection() const
     return false;
 }
 
-Collections::Collection*
+Collections::Collection *
 MetaProxy::Track::collection() const
 {
     if( d->realTrack )
@@ -450,7 +460,11 @@ MetaProxy::Track::unsubscribe( Meta::Observer *observer )
 void
 MetaProxy::Track::lookupTrack( Collections::TrackProvider *provider )
 {
-	d->slotNewTrackProvider( provider );
+    if( provider->possiblyContainsTrack( d->url ) )
+    {
+        Meta::TrackPtr track = provider->trackForUrl( d->url );
+        d->slotUpdateTrack( track );
+    }
 }
 
 void
@@ -470,7 +484,7 @@ MetaProxy::Track::hasCapabilityInterface( Capabilities::Capability::Type type )
     return false;
 }
 
-Capabilities::Capability*
+Capabilities::Capability *
 MetaProxy::Track::createCapabilityInterface( Capabilities::Capability::Type type )
 {
     if( d->realTrack )
@@ -484,7 +498,7 @@ MetaProxy::Track::createCapabilityInterface( Capabilities::Capability::Type type
 bool
 MetaProxy::Track::operator==( const Meta::Track &track ) const
 {
-    const MetaProxy::Track *proxy = dynamic_cast<const MetaProxy::Track*>( &track );
+    const MetaProxy::Track *proxy = dynamic_cast<const MetaProxy::Track *>( &track );
     if( proxy && d->realTrack )
         return d->realTrack == proxy->d->realTrack;
     else if( proxy )
diff --git a/src/core-impl/meta/proxy/MetaProxyWorker.h b/src/core-impl/meta/proxy/MetaProxyWorker.h
new file mode 100644
index 0000000..557f29d
--- /dev/null
+++ b/src/core-impl/meta/proxy/MetaProxyWorker.h
@@ -0,0 +1,42 @@
+/****************************************************************************************
+ * Copyright (c) 2012 Bart Cerneels <bart.cerneels@kde.org>                             *
+ *                                                                                      *
+ * This program is free software; you can redistribute it and/or modify it under        *
+ * the terms of the GNU General Public License as published by the Free Software        *
+ * Foundation; either version 2 of the License, or (at your option) any later           *
+ * version.                                                                             *
+ *                                                                                      *
+ * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
+ * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
+ *                                                                                      *
+ * You should have received a copy of the GNU General Public License along with         *
+ * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
+ ****************************************************************************************/
+
+#ifndef METAPROXY_METAPROXYWORKER_H
+#define METAPROXY_METAPROXYWORKER_H
+
+#include <core/collections/support/TrackForUrlWorker.h>
+#include <core/collections/Collection.h>
+
+namespace MetaProxy {
+
+class Worker : public Amarok::TrackForUrlWorker
+{
+    Q_OBJECT
+    public:
+        explicit Worker( const KUrl &url );
+
+        //TrackForUrlWorker virtual methods
+        virtual void run();
+
+    private slots:
+        void slotNewTrackProvider( Collections::TrackProvider *newTrackProvider );
+        void slotNewCollection( Collections::Collection *newCollection );
+
+};
+
+} // namespace MetaProxy
+
+#endif // METAPROXY_METAPROXYWORKER_H
diff --git a/src/core-impl/meta/proxy/MetaProxyWorker.cpp b/src/core-impl/meta/proxy/MetaProxyWorker.cpp
new file mode 100644
index 0000000..0cde280
--- /dev/null
+++ b/src/core-impl/meta/proxy/MetaProxyWorker.cpp
@@ -0,0 +1,82 @@
+/****************************************************************************************
+ * Copyright (c) 2012 Bart Cerneels <bart.cerneels@kde.org>                             *
+ *                                                                                      *
+ * This program is free software; you can redistribute it and/or modify it under        *
+ * the terms of the GNU General Public License as published by the Free Software        *
+ * Foundation; either version 2 of the License, or (at your option) any later           *
+ * version.                                                                             *
+ *                                                                                      *
+ * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
+ * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
+ *                                                                                      *
+ * You should have received a copy of the GNU General Public License along with         *
+ * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
+ ****************************************************************************************/
+
+#include "MetaProxyWorker.h"
+
+#include "core-impl/collections/support/CollectionManager.h"
+
+namespace MetaProxy {
+
+Worker::Worker( const KUrl &url )
+    : Amarok::TrackForUrlWorker( url )
+{
+
+}
+
+void
+Worker::run()
+{
+    Meta::TrackPtr track = CollectionManager::instance()->trackForUrl( m_url );
+
+    //no TrackProvider has a track for us yet, query new ones that are added.
+    if( track.isNull() )
+    {
+        //TODO: should only have to connecto to TrackProvider signals.
+        //Each Collection contains a TrackProvider
+        connect( CollectionManager::instance(),
+                 SIGNAL(trackProviderAdded( Collections::TrackProvider * )),
+                 SLOT(slotNewTrackProvider( Collections::TrackProvider * )) );
+        connect( CollectionManager::instance(),
+                 SIGNAL(collectionAdded( Collections::Collection * )),
+                 SLOT(slotNewCollection( Collections::Collection * )) );
+
+        return;
+    }
+
+    emit( finishedLookup( track ) );
+}
+
+void
+Worker::slotNewTrackProvider( Collections::TrackProvider *newTrackProvider )
+{
+    if( !newTrackProvider )
+    {
+        return;
+    }
+
+    if( newTrackProvider->possiblyContainsTrack( m_url ) )
+    {
+        Meta::TrackPtr track = newTrackProvider->trackForUrl( m_url );
+        emit( finishedLookup( track ) );
+    }
+}
+
+void
+Worker::slotNewCollection( Collections::Collection *newCollection )
+{
+    if( !newCollection )
+    {
+        return;
+    }
+
+    if( newCollection->possiblyContainsTrack( m_url ) )
+    {
+        Meta::TrackPtr track = newCollection->trackForUrl( m_url );
+        emit( finishedLookup( track ) );
+    }
+}
+
+} // namespace MetaProxy
diff --git a/src/core-impl/meta/proxy/MetaProxy_p.h b/src/core-impl/meta/proxy/MetaProxy_p.h
index 792675d..360be21 100644
--- a/src/core-impl/meta/proxy/MetaProxy_p.h
+++ b/src/core-impl/meta/proxy/MetaProxy_p.h
@@ -43,7 +43,7 @@ class MetaProxy::Track::Private : public QObject, public Meta::Observer
 
         Meta::TrackPtr realTrack;
 
-        QList<Meta::Observer*> observers;
+        QList<Meta::Observer *> observers;
 
         QString cachedArtist;
         QString cachedAlbum;
@@ -82,34 +82,6 @@ class MetaProxy::Track::Private : public QObject, public Meta::Observer
         }
 
     public slots:
-        void slotNewTrackProvider( Collections::TrackProvider *newTrackProvider )
-        {
-            if ( !newTrackProvider )
-            {
-                return;
-            }
-
-            if( newTrackProvider->possiblyContainsTrack( url ) )
-            {
-                Meta::TrackPtr track = newTrackProvider->trackForUrl( url );
-                slotUpdateTrack( track );
-            }
-        }
-
-        void slotNewCollection( Collections::Collection *newCollection )
-        {
-            if ( !newCollection )
-            {
-                return;
-            }
-
-            if( newCollection->possiblyContainsTrack( url ) )
-            {
-                Meta::TrackPtr track = newCollection->trackForUrl( url );
-                slotUpdateTrack( track );
-            }
-        }
-
         void slotUpdateTrack( Meta::TrackPtr track )
         {
             if( track )
@@ -117,8 +89,6 @@ class MetaProxy::Track::Private : public QObject, public Meta::Observer
                 subscribeTo( track );
                 realTrack = track;
                 notifyObservers();
-                disconnect( CollectionManager::instance(), SIGNAL( trackProviderAdded( Collections::TrackProvider* ) ), this, SLOT( slotNewTrackProvider( Collections::TrackProvider* ) ) );
-                disconnect( CollectionManager::instance(), SIGNAL( collectionAdded( Collections::Collection* ) ), this, SLOT( slotNewCollection( Collections::Collection* ) ) );
             }
         }
 };
diff --git a/src/core-impl/playlists/types/file/m3u/M3UPlaylist.cpp b/src/core-impl/playlists/types/file/m3u/M3UPlaylist.cpp
index c64cb97..989e8d7 100644
--- a/src/core-impl/playlists/types/file/m3u/M3UPlaylist.cpp
+++ b/src/core-impl/playlists/types/file/m3u/M3UPlaylist.cpp
@@ -21,6 +21,7 @@
 #include "core/support/Amarok.h"
 #include "core/support/Debug.h"
 #include "core-impl/collections/support/CollectionManager.h"
+#include "core-impl/meta/proxy/MetaProxy.h"
 #include "core-impl/playlists/types/file/PlaylistFileSupport.h"
 #include "playlistmanager/file/PlaylistFileProvider.h"
 #include "PlaylistManager.h"
@@ -150,20 +151,25 @@ bool
 M3UPlaylist::loadM3u( QTextStream &stream )
 {
     const QString directory = m_url.directory();
-    bool hasTracks = false;
     m_tracksLoaded = false;
 
+    int length = -1;
+    QString extinfTitle;
     do
     {
         QString line = stream.readLine();
         if( line.startsWith( "#EXTINF" ) )
         {
-            //const QString extinf = line.section( ':', 1 );
-            //const int length = extinf.section( ',', 0, 0 ).toInt();
+            const QString extinf = line.section( ':', 1 );
+            bool ok;
+            length = extinf.section( ',', 0, 0 ).toInt( &ok );
+            if( !ok )
+                length = -1;
+            extinfTitle = extinf.section( ',', 1 );
         }
         else if( !line.startsWith( '#' ) && !line.isEmpty() )
         {
-            Meta::TrackPtr trackPtr;
+            MetaProxy::Track *proxyTrack;
             line = line.replace( "\\", "/" );
 
             // KUrl::isRelativeUrl() expects absolute URLs to start with a protocol, so prepend it if missing
@@ -180,22 +186,30 @@ M3UPlaylist::loadM3u( QTextStream &stream )
                 kurl.addPath( line ); // adds directory separator if required
                 kurl.cleanPath();
 
-                trackPtr = CollectionManager::instance()->trackForUrl( kurl );
+                url = kurl.url();
             }
-            else
+
+            proxyTrack = new MetaProxy::Track( KUrl( url ) );
+            QString artist = extinfTitle.section( " - ", 0, 0 );
+            QString title = extinfTitle.section( " - ", 1, 1 );
+            //if title and artist are saved such as in M3UPlaylist::save()
+            if( !title.isEmpty() && !artist.isEmpty() )
             {
-                trackPtr = CollectionManager::instance()->trackForUrl( KUrl( line ) );
+                proxyTrack->setName( title );
+                proxyTrack->setArtist( artist );
             }
-
-            if( trackPtr )
+            else
             {
-                m_tracks.append( trackPtr );
-                hasTracks = true;
-                m_tracksLoaded = true;
+                proxyTrack->setName( extinfTitle );
             }
+            proxyTrack->setLength( length );
+            m_tracks << Meta::TrackPtr( proxyTrack );
+            m_tracksLoaded = true;
         }
     } while( !stream.atEnd() );
-    return hasTracks;
+
+    //TODO: return false if stream is not readable, empty or has errors
+    return true;
 }
 
 bool
diff --git a/src/core-impl/playlists/types/file/pls/PLSPlaylist.cpp b/src/core-impl/playlists/types/file/pls/PLSPlaylist.cpp
index 67ed68e..386734a 100644
--- a/src/core-impl/playlists/types/file/pls/PLSPlaylist.cpp
+++ b/src/core-impl/playlists/types/file/pls/PLSPlaylist.cpp
@@ -21,6 +21,7 @@
 #include "core/capabilities/EditCapability.h"
 #include "core/meta/Meta.h"
 #include "PlaylistManager.h"
+#include "core-impl/meta/proxy/MetaProxy.h"
 #include "core-impl/playlists/types/file/PlaylistFileSupport.h"
 
 #include <KMimeType>
@@ -72,7 +73,7 @@ PLSPlaylist::trackCount() const
     if( m_tracksLoaded )
         return m_tracks.count();
 
-    //TODO: count the number of lines starting with #
+    //TODO: read NumberOfEntries from footer
     return -1;
 }
 
@@ -146,11 +147,9 @@ PLSPlaylist::removeTrack( int position )
 }
 
 bool
-PLSPlaylist::loadPls( QTextStream &stream )
+PLSPlaylist::loadPls( QTextStream &textStream )
 {
-    DEBUG_BLOCK
-
-    Meta::TrackPtr currentTrack;
+    MetaProxy::Track *proxyTrack;
 
     // Counted number of "File#=" lines.
     unsigned int entryCnt = 0;
@@ -172,27 +171,32 @@ PLSPlaylist::loadPls( QTextStream &stream )
     * Read the lines into a buffer; Cleanup the line strings;
     * Count the entries manually and read "NumberOfEntries".
     */
-    while (!stream.atEnd()) {
-        tmp = stream.readLine();
+    while( !textStream.atEnd() )
+    {
+        tmp = textStream.readLine();
         tmp = tmp.trimmed();
-        if (tmp.isEmpty())
+        if( tmp.isEmpty() )
             continue;
-        lines.append(tmp);
+        lines.append( tmp );
 
-        if (tmp.contains(regExp_File)) {
+        if( tmp.contains( regExp_File ) )
+        {
             entryCnt++;
             continue;
         }
-        if (tmp == section_playlist) {
+        if( tmp == section_playlist )
+        {
             havePlaylistSection = true;
             continue;
         }
-        if (tmp.contains(regExp_NumberOfEntries)) {
-            numberOfEntries = tmp.section('=', -1).trimmed().toUInt();
+        if( tmp.contains( regExp_NumberOfEntries ) )
+        {
+            numberOfEntries = tmp.section( '=', -1 ).trimmed().toUInt();
             continue;
         }
     }
-    if (numberOfEntries != entryCnt) {
+    if( numberOfEntries != entryCnt )
+    {
         warning() << ".pls playlist: Invalid \"NumberOfEntries\" value.  "
                 << "NumberOfEntries=" << numberOfEntries << "  counted="
                 << entryCnt << endl;
@@ -202,7 +206,7 @@ PLSPlaylist::loadPls( QTextStream &stream )
         */
         numberOfEntries = entryCnt;
     }
-    if (!numberOfEntries)
+    if( numberOfEntries == 0 )
         return true;
 
     unsigned int index;
@@ -213,67 +217,69 @@ PLSPlaylist::loadPls( QTextStream &stream )
     * and parse the playlist data.
     */
     QStringList::const_iterator i = lines.constBegin(), end = lines.constEnd();
-    for ( ; i != end; ++i) {
-        if (!inPlaylistSection && havePlaylistSection) {
+    for( ; i != end; ++i )
+    {
+        if( !inPlaylistSection && havePlaylistSection )
+        {
             /* The playlist begins with the "[playlist]" tag.
             * Skip everything before this.
             */
-            if ((*i) == section_playlist)
+            if( (*i) == section_playlist )
                 inPlaylistSection = true;
             continue;
         }
-        if ((*i).contains(regExp_File)) {
+        if( (*i).contains( regExp_File ) )
+        {
             // Have a "File#=XYZ" line.
-            index = loadPls_extractIndex(*i);
-            if (index > numberOfEntries || index == 0)
+            index = loadPls_extractIndex( *i );
+            if( index > numberOfEntries || index == 0 )
                 continue;
-            tmp = (*i).section('=', 1).trimmed();
-            currentTrack = CollectionManager::instance()->trackForUrl( tmp );
-            if( currentTrack.isNull() )
+            tmp = (*i).section( '=', 1 ).trimmed();
+            KUrl url( tmp );
+            if( url.isRelative() )
             {
-                debug() << "track could not be loaded: " << tmp;
-                continue;
+                url = m_url;
+                url.addPath( tmp );
             }
-            m_tracks.append( currentTrack );
+            proxyTrack = new MetaProxy::Track( url );
+            m_tracks << Meta::TrackPtr( proxyTrack );
             continue;
         }
-        if ((*i).contains(regExp_Title)) {
+        if( (*i).contains(regExp_Title) )
+        {
             // Have a "Title#=XYZ" line.
             index = loadPls_extractIndex(*i);
-            if (index > numberOfEntries || index == 0)
+            if( index > numberOfEntries || index == 0 )
                 continue;
-            tmp = (*i).section('=', 1).trimmed();
-
-            if ( currentTrack.data() != 0 && currentTrack->is<Capabilities::EditCapability>() )
-            {
-                Capabilities::EditCapability *ec = currentTrack->create<Capabilities::EditCapability>();
-                if( ec )
-                    ec->setTitle( tmp );
-                delete ec;
-            }
+            tmp = (*i).section( '=', 1 ).trimmed();
+            proxyTrack->setName( tmp );
             continue;
         }
-        if ((*i).contains(regExp_Length)) {
+        if( (*i).contains( regExp_Length ) )
+        {
             // Have a "Length#=XYZ" line.
             index = loadPls_extractIndex(*i);
-            if (index > numberOfEntries || index == 0)
+            if( index > numberOfEntries || index == 0 )
                 continue;
-            tmp = (*i).section('=', 1).trimmed();
-            //tracks.append( KUrl(tmp) );
-//             Q_ASSERT(ok);
+            tmp = (*i).section( '=', 1 ).trimmed();
+            bool ok = false;
+            int seconds = tmp.toInt( &ok );
+            if( ok )
+                proxyTrack->setLength( seconds * 1000 ); //length is in milliseconds
             continue;
         }
-        if ((*i).contains(regExp_NumberOfEntries)) {
+        if( (*i).contains( regExp_NumberOfEntries ) )
+        {
             // Have the "NumberOfEntries=#" line.
             continue;
         }
-        if ((*i).contains(regExp_Version)) {
+        if( (*i).contains( regExp_Version ) )
+        {
             // Have the "Version=#" line.
-            tmp = (*i).section('=', 1).trimmed();
+            tmp = (*i).section( '=', 1 ).trimmed();
             // We only support Version=2
-            if (tmp.toUInt(&ok) != 2)
+            if (tmp.toUInt( &ok ) != 2)
                 warning() << ".pls playlist: Unsupported version." << endl;
-//             Q_ASSERT(ok);
             continue;
         }
         warning() << ".pls playlist: Unrecognized line: \"" << *i << "\"" << endl;
@@ -300,14 +306,31 @@ PLSPlaylist::save( const KUrl &location, bool relative )
         return false;
     }
 
+    //Format: http://en.wikipedia.org/wiki/PLS_(file_format)
     QTextStream stream( &file );
+    //header
     stream << "[Playlist]\n";
-    stream << "NumberOfEntries=" << m_tracks.count() << endl;
+
+    //body
     int i = 1; //PLS starts at File1=
     foreach( Meta::TrackPtr track, m_tracks )
     {
-        stream << "File" << i << "=";
-        stream << KUrl( track->playableUrl() ).path();
+        KUrl playableUrl( track->playableUrl() );
+        QString file = playableUrl.url();
+
+        if( playableUrl.isLocalFile() )
+        {
+            if( relative )
+            {
+                file = KUrl::relativePath( savePath.toLocalFile(),
+                                           playableUrl.toLocalFile() );
+            }
+            else
+            {
+                file = playableUrl.toLocalFile();
+            }
+        }
+        stream << "File" << i << "=" << file;
         stream << "\nTitle" << i << "=";
         stream << track->name();
         stream << "\nLength" << i << "=";
@@ -316,6 +339,8 @@ PLSPlaylist::save( const KUrl &location, bool relative )
         i++;
     }
 
+    //footer
+    stream << "NumberOfEntries=" << m_tracks.count() << endl;
     stream << "Version=2\n";
     file.close();
     return true;
@@ -330,9 +355,9 @@ PLSPlaylist::loadPls_extractIndex( const QString &str ) const
     */
     bool ok = false;
     unsigned int ret;
-    QString tmp(str.section('=', 0, 0));
-    tmp.remove(QRegExp("^\\D*"));
-    ret = tmp.trimmed().toUInt(&ok);
+    QString tmp( str.section( '=', 0, 0 ) );
+    tmp.remove( QRegExp( "^\\D*" ) );
+    ret = tmp.trimmed().toUInt( &ok );
     Q_ASSERT(ok);
     return ret;
 }
diff --git a/src/core-impl/playlists/types/file/xspf/XSPFPlaylist.cpp b/src/core-impl/playlists/types/file/xspf/XSPFPlaylist.cpp
index 4cb49fb..01cf1e6 100644
--- a/src/core-impl/playlists/types/file/xspf/XSPFPlaylist.cpp
+++ b/src/core-impl/playlists/types/file/xspf/XSPFPlaylist.cpp
@@ -233,8 +233,7 @@ XSPFPlaylist::trackCount() const
 Meta::TrackList
 XSPFPlaylist::tracks()
 {
-    //If you do not load before, m_tracks
-    //can be empty before usage.
+    //If you do not load, m_tracks can be empty before usage.
     triggerTrackLoad();
 
     return m_tracks;
@@ -251,76 +250,14 @@ XSPFPlaylist::triggerTrackLoad()
 
     foreach( const XSPFTrack &track, xspfTracks )
     {
-        Meta::TrackPtr trackPtr;
-        if( !track.identifier.isEmpty() )
-            trackPtr = CollectionManager::instance()->trackForUrl( track.identifier );
-        else
-            trackPtr = CollectionManager::instance()->trackForUrl( track.location );
-        if( trackPtr )
-        {
-            /**
-             * NOTE: If this is a MetaProxy::Track, it probably isn't playable yet,
-             *       but that's okay. However, it's not a good idea to get another
-             *       one from the same provider, since the proxy probably means that
-             *       making one involves quite a bit of work.
-             *         - Andy Coder <andrew.coder@gmail.com>
-             */
-            if( !trackPtr->isPlayable() && ( typeid( * trackPtr.data() ) != typeid( MetaProxy::Track ) ) )
-                trackPtr = CollectionManager::instance()->trackForUrl( track.identifier );
-        }
-
-        if( trackPtr )
-        {
-            if( typeid( * trackPtr.data() ) == typeid( MetaStream::Track ) )
-            {
-                MetaStream::Track * streamTrack = dynamic_cast<MetaStream::Track *> ( trackPtr.data() );
-                if ( streamTrack )
-                {
-                    streamTrack->setTitle( track.title );
-                    streamTrack->setAlbum( track.album );
-                    streamTrack->setArtist( track.creator );
-                }
-            }
-            else if( typeid( * trackPtr.data() ) == typeid( Meta::TimecodeTrack ) )
-            {
-                Meta::TimecodeTrack * timecodeTrack =
-                        dynamic_cast<Meta::TimecodeTrack *>( trackPtr.data() );
-                if( timecodeTrack )
-                {
-                    timecodeTrack->beginMetaDataUpdate();
-                    timecodeTrack->setTitle( track.title );
-                    timecodeTrack->setAlbum( track.album );
-                    timecodeTrack->setArtist( track.creator );
-                    timecodeTrack->endMetaDataUpdate();
-                }
-            }
-
-            m_tracks << trackPtr;
-        }
-
-
-        // why do we need this? sqlplaylist is not doing this
-        // we don't want (probably) unplayable tracks
-        // and it causes problems for me (DanielW) as long
-        // amarok not respects Track::isPlayable()
-        /*else {
-
-            MetaProxy::Track *proxyTrack = new MetaProxy::Track( track.location );
-            {
-                //Fill in values from xspf..
-                QVariantMap map;
-                map.insert( Meta::Field::TITLE, track.title );
-                map.insert( Meta::Field::ALBUM, track.album );
-                map.insert( Meta::Field::ARTIST, track.creator );
-                map.insert( Meta::Field::LENGTH, track.duration );
-                map.insert( Meta::Field::TRACKNUMBER, track.trackNum );
-                map.insert( Meta::Field::URL, track.location );
-                Meta::Field::updateTrack( proxyTrack, map );
-            }
-            m_tracks << Meta::TrackPtr( proxyTrack );
-    //         m_tracks << CollectionManager::instance()->trackForUrl( track.location );
-        }*/
-
+       MetaProxy::Track *proxyTrack = new MetaProxy::Track( track.location );
+       //Fill in values from xspf..
+       proxyTrack->setName( track.title );
+       proxyTrack->setAlbum( track.album );
+       proxyTrack->setArtist( track.creator );
+       proxyTrack->setLength( track.duration );
+       proxyTrack->setTrackNumber( track.trackNum );
+       m_tracks << Meta::TrackPtr( proxyTrack );
     }
 
     m_tracksLoaded = true;
diff --git a/src/core/collections/support/TrackForUrlWorker.h b/src/core/collections/support/TrackForUrlWorker.h
index 64d23bd..16d764e 100644
--- a/src/core/collections/support/TrackForUrlWorker.h
+++ b/src/core/collections/support/TrackForUrlWorker.h
@@ -35,17 +35,17 @@ class AMAROK_CORE_EXPORT TrackForUrlWorker : public ThreadWeaver::Job
 {
     Q_OBJECT
 public:
-    TrackForUrlWorker ( const KUrl &url );
-    TrackForUrlWorker ( const QString &url );
+    TrackForUrlWorker( const KUrl &url );
+    TrackForUrlWorker( const QString &url );
     ~TrackForUrlWorker();
 
-    virtual void run () = 0;
+    virtual void run() = 0;
 signals:
-    void finishedLookup ( const Meta::TrackPtr  &track );
+    void finishedLookup( const Meta::TrackPtr &track );
 
 protected:
-    KUrl mUrl;
-    Meta::TrackPtr mTrack;
+    KUrl m_url;
+    Meta::TrackPtr m_track;
 
 private slots:
     void completeJob();
diff --git a/src/core/collections/support/TrackForUrlWorker.cpp b/src/core/collections/support/TrackForUrlWorker.cpp
index 7e8f289..28d92bb 100644
--- a/src/core/collections/support/TrackForUrlWorker.cpp
+++ b/src/core/collections/support/TrackForUrlWorker.cpp
@@ -16,14 +16,18 @@
 
 #include "TrackForUrlWorker.h"
 
-Amarok::TrackForUrlWorker::TrackForUrlWorker ( const KUrl &url ) : ThreadWeaver::Job(), mUrl ( url )
+Amarok::TrackForUrlWorker::TrackForUrlWorker( const KUrl &url )
+    : ThreadWeaver::Job()
+    , m_url( url )
 {
-    connect ( this, SIGNAL ( done ( ThreadWeaver::Job* ) ), SLOT ( completeJob() ) );
+    connect( this, SIGNAL(done( ThreadWeaver::Job * )), SLOT( completeJob()) );
 }
 
-Amarok::TrackForUrlWorker::TrackForUrlWorker( const QString &url ) : ThreadWeaver::Job(), mUrl ( KUrl ( url ) )
+Amarok::TrackForUrlWorker::TrackForUrlWorker( const QString &url )
+    : ThreadWeaver::Job()
+    , m_url( KUrl( url ) )
 {
-    connect ( this, SIGNAL ( done ( ThreadWeaver::Job* ) ), SLOT ( completeJob() ) );
+    connect( this, SIGNAL(done( ThreadWeaver::Job * )), SLOT( completeJob()) );
 }
 
 Amarok::TrackForUrlWorker::~TrackForUrlWorker()
@@ -32,6 +36,6 @@ Amarok::TrackForUrlWorker::~TrackForUrlWorker()
 void
 Amarok::TrackForUrlWorker::completeJob()
 {
-    emit ( finishedLookup ( mTrack ) );
+    emit( finishedLookup( m_track ) );
     deleteLater();
 }
diff --git a/src/playlistmanager/sql/SqlPlaylist.cpp b/src/playlistmanager/sql/SqlPlaylist.cpp
index 39ad759..3a22da4 100644
--- a/src/playlistmanager/sql/SqlPlaylist.cpp
+++ b/src/playlistmanager/sql/SqlPlaylist.cpp
@@ -16,10 +16,11 @@
 
 #include "SqlPlaylist.h"
 
-#include "core-impl/collections/support/CollectionManager.h"
+#include "core/collections/support/SqlStorage.h"
 #include "core/support/Debug.h"
+#include "core-impl/collections/support/CollectionManager.h"
+#include "core-impl/meta/proxy/MetaProxy.h"
 #include "core-impl/meta/stream/Stream.h"
-#include "core/collections/support/SqlStorage.h"
 #include "core-impl/meta/timecode/TimecodeMeta.h"
 #include "playlistmanager/PlaylistManager.h"
 #include "playlistmanager/sql/SqlPlaylistGroup.h"
@@ -278,6 +279,9 @@ SqlPlaylist::removeTrack( int position )
 void
 SqlPlaylist::metadataChanged( Meta::TrackPtr track )
 {
+    //TODO: do we really need to observe track changes? Metadata will be properly saved
+    //on exit and proxy tracks are loaded with uidUrl. So at worse the save metadata in
+    //playlist_tracks will be outdated until real track is loaded.
     if( !m_tracksLoaded )
         loadTracks();
 
@@ -308,43 +312,15 @@ SqlPlaylist::loadTracks()
         QStringList row = result.mid( i*7, 7 );
         KUrl url = KUrl( row[2] );
 
-        Meta::TrackPtr trackPtr = CollectionManager::instance()->trackForUrl( url );
+        MetaProxy::Track *proxyTrack = new MetaProxy::Track( url );
 
-        if( trackPtr )
-        {
-            if( typeid( * trackPtr.data() ) == typeid( MetaStream::Track ) )
-            {
-
-                debug() << "got stream from trackForUrl, setting album to " << row[4];
-
-                MetaStream::Track * streamTrack =
-                        dynamic_cast<MetaStream::Track *> ( trackPtr.data() );
-                
-                if( streamTrack )
-                {
-                    streamTrack->setTitle( row[3] );
-                    streamTrack->setAlbum( row[4] );
-                    streamTrack->setArtist( row[5] );
-                }
-            }
-            else if( typeid( * trackPtr.data() ) == typeid( Meta::TimecodeTrack ) )
-            {
-                Meta::TimecodeTrack * timecodeTrack =
-                        dynamic_cast<Meta::TimecodeTrack *> ( trackPtr.data() );
-
-                if( timecodeTrack )
-                {
-                    timecodeTrack->beginMetaDataUpdate();
-                    timecodeTrack->setTitle( row[3] );
-                    timecodeTrack->setAlbum( row[4] );
-                    timecodeTrack->setArtist( row[5] );
-                    timecodeTrack->endMetaDataUpdate();
-                }
-            }
-
-            subscribeTo( trackPtr );
-            m_tracks << trackPtr;
-        }
+        proxyTrack->setName( row[3] );
+        proxyTrack->setAlbum( row[4] );
+        proxyTrack->setArtist( row[5] );
+        Meta::TrackPtr trackPtr = Meta::TrackPtr( proxyTrack );
+        //subscribed to force a save to db on any change (such as AFT file move)
+        subscribeTo( trackPtr );
+        m_tracks << trackPtr;
     }
 
     m_tracksLoaded = true;
diff --git a/src/services/ampache/AmpacheServiceCollection.h b/src/services/ampache/AmpacheServiceCollection.h
index a48c8f2..cc49775 100644
--- a/src/services/ampache/AmpacheServiceCollection.h
+++ b/src/services/ampache/AmpacheServiceCollection.h
@@ -25,14 +25,16 @@ class AmpacheTrackForUrlWorker : public Amarok::TrackForUrlWorker
 {
     Q_OBJECT
     public:
-        AmpacheTrackForUrlWorker( const KUrl &url, MetaProxy::TrackPtr track, const QString &server, const QString &sessionId, ServiceBase* service);
+        AmpacheTrackForUrlWorker( const KUrl &url, MetaProxy::TrackPtr track,
+                                  const QString &server, const QString &sessionId,
+                                  ServiceBase *service);
         ~AmpacheTrackForUrlWorker();
-        virtual void run ();
+        virtual void run();
         void parseTrack( const QString &xml );
     signals:
         void authenticationNeeded();
     private:
-        MetaProxy::TrackPtr mProxy;
+        MetaProxy::TrackPtr m_proxy;
         int m_urlTrackId;
         int m_urlAlbumId;
         int m_urlArtistId;
@@ -44,7 +46,7 @@ class AmpacheTrackForUrlWorker : public Amarok::TrackForUrlWorker
         QString m_server;
         QString m_sessionId;
 
-        ServiceBase* m_service;
+        ServiceBase *m_service;
 };
 
 namespace Collections {
@@ -59,11 +61,12 @@ class AmpacheServiceCollection : public ServiceCollection
     Q_OBJECT
 
 public:
-    AmpacheServiceCollection( ServiceBase * service, const QString &server, const QString &sessionId );
+    AmpacheServiceCollection( ServiceBase *service, const QString &server,
+                              const QString &sessionId );
 
     virtual ~AmpacheServiceCollection();
 
-    virtual QueryMaker* queryMaker();
+    virtual QueryMaker *queryMaker();
 
     virtual QString collectionId() const;
     virtual QString prettyName() const;
@@ -76,16 +79,13 @@ signals:
 
 public slots:
     void slotAuthenticationNeeded();
-    void slotLookupComplete( const Meta::TrackPtr& );
+    void slotLookupComplete( const Meta::TrackPtr & );
 
 private:
-    /*void parseAlbum( const QString &xml );
-    void parseArtist( const QString &xml );*/
-
     QString m_server;
     QString m_sessionId;
 
-    AmpacheTrackForUrlWorker * m_trackForUrlWorker;
+    AmpacheTrackForUrlWorker *m_trackForUrlWorker;
 };
 
 } //namespace Collections
diff --git a/src/services/ampache/AmpacheServiceCollection.cpp b/src/services/ampache/AmpacheServiceCollection.cpp
index b684e34..c3b5115 100644
--- a/src/services/ampache/AmpacheServiceCollection.cpp
+++ b/src/services/ampache/AmpacheServiceCollection.cpp
@@ -27,7 +27,9 @@
 
 using namespace Collections;
 
-AmpacheServiceCollection::AmpacheServiceCollection( ServiceBase * service, const QString &server, const QString &sessionId )
+AmpacheServiceCollection::AmpacheServiceCollection( ServiceBase *service,
+                                                    const QString &server,
+                                                    const QString &sessionId )
     : ServiceCollection( service, "AmpacheCollection", "AmpacheCollection" )
     , m_server( server )
     , m_sessionId( sessionId )
@@ -58,7 +60,7 @@ AmpacheServiceCollection::prettyName() const
 }
 
 bool
-AmpacheServiceCollection::possiblyContainsTrack(const KUrl & url) const
+AmpacheServiceCollection::possiblyContainsTrack( const KUrl &url ) const
 {
     return url.url().contains( m_server );
 }
@@ -70,77 +72,82 @@ AmpacheServiceCollection::slotAuthenticationNeeded()
 }
 
 Meta::TrackPtr
-AmpacheServiceCollection::trackForUrl( const KUrl & url )
+AmpacheServiceCollection::trackForUrl( const KUrl &url )
 {
-    MetaProxy::Track* ptrack = new MetaProxy::Track( url.url(), true );
-    MetaProxy::TrackPtr trackptr(ptrack);
-    AmpacheTrackForUrlWorker * worker =  new AmpacheTrackForUrlWorker(url, trackptr, m_server, m_sessionId, service() );
-//     connect( worker, SIGNAL( finishedLookup ( const Meta::TrackPtr& ) ), this,
-//              SLOT( slotLookupComplete( const Meta::TrackPtr& ) ) );
-    connect( worker, SIGNAL( authenticationNeeded() ), this,
-             SLOT( slotAuthenticationNeeded() ) );
+    MetaProxy::Track *ptrack = new MetaProxy::Track( url.url(), true );
+    MetaProxy::TrackPtr trackptr( ptrack );
+    AmpacheTrackForUrlWorker *worker = new AmpacheTrackForUrlWorker( url, trackptr,
+                                                                     m_server,
+                                                                     m_sessionId,
+                                                                     service() );
+    connect( worker, SIGNAL(authenticationNeeded()), SLOT(slotAuthenticationNeeded()) );
     ThreadWeaver::Weaver::instance()->enqueue( worker );
 
     return Meta::TrackPtr::staticCast( trackptr );
 }
+
 void AmpacheServiceCollection::slotLookupComplete( const Meta::TrackPtr& )
 {
 }
 
 void AmpacheTrackForUrlWorker::parseTrack( const QString &xml )
 {
-//     DEBUG_BLOCK
-
-//      debug() << "Received track response: " << xml;
-
-     //so lets figure out what we got here:
+    //so lets figure out what we got here:
     QDomDocument doc( "reply" );
     doc.setContent( xml );
-    QDomElement root = doc.firstChildElement("root");
-    QDomElement song = root.firstChildElement("song");
+    QDomElement root = doc.firstChildElement( "root" );
+    QDomElement song = root.firstChildElement( "song" );
 
-    m_urlTrackId = song.attribute( "id", "0").toInt();
+    m_urlTrackId = song.attribute( "id", "0" ).toInt();
 
-    QDomElement element = song.firstChildElement("title");
+    QDomElement element = song.firstChildElement( "title" );
 
     QString title = element.text();
     if ( title.isEmpty() ) title = "Unknown";
 
-    element = song.firstChildElement("url");
+    element = song.firstChildElement( "url" );
 
     m_urlTrack = new Meta::AmpacheTrack( title, m_service );
     Meta::TrackPtr trackPtr( m_urlTrack );
 
-    //debug() << "Adding track: " <<  title;
     m_urlTrack->setUidUrl( element.text() );
     m_urlTrack->setId( m_urlTrackId );
 
-    element = song.firstChildElement("time");
+    element = song.firstChildElement( "time" );
     m_urlTrack->setLength( element.text().toInt() * 1000 );
 
-    element = song.firstChildElement("track");
+    element = song.firstChildElement( "track" );
     m_urlTrack->setTrackNumber( element.text().toInt() );
 
-    QDomElement albumElement = song.firstChildElement("album");
-    //m_urlAlbumId = albumElement.attribute( "id", "0").toInt();
+    QDomElement albumElement = song.firstChildElement( "album" );
+    m_urlAlbumId = albumElement.attribute( "id", "0" ).toInt();
 
-    Meta::AmpacheAlbum * album = new Meta::AmpacheAlbum( albumElement.text() );
+    Meta::AmpacheAlbum *album = new Meta::AmpacheAlbum( albumElement.text() );
 
-    QDomElement artElement = song.firstChildElement("art");
+    QDomElement artElement = song.firstChildElement( "art" );
     album->setCoverUrl( artElement.text() );
 
     album->addTrack( trackPtr );
     m_urlTrack->setAlbumPtr( Meta::AlbumPtr( album ) );
 
-    QDomElement artistElement = song.firstChildElement("artist");
-    Meta::ServiceArtist * artist = new Meta::ServiceArtist( artistElement.text() );
+    QDomElement artistElement = song.firstChildElement( "artist" );
+    Meta::ServiceArtist *artist = new Meta::ServiceArtist( artistElement.text() );
 
     Meta::ArtistPtr artistPtr( artist );
     m_urlTrack->setArtist( artistPtr );
     album->setAlbumArtist( artistPtr );
 }
 
-AmpacheTrackForUrlWorker::AmpacheTrackForUrlWorker(const KUrl &url, MetaProxy::TrackPtr track, const QString &server, const QString &sessionId, ServiceBase* service) : Amarok::TrackForUrlWorker(url), mProxy(track), m_server(server), m_sessionId(sessionId), m_service(service)
+AmpacheTrackForUrlWorker::AmpacheTrackForUrlWorker( const KUrl &url,
+                                                    MetaProxy::TrackPtr track,
+                                                    const QString &server,
+                                                    const QString &sessionId,
+                                                    ServiceBase *service )
+    : Amarok::TrackForUrlWorker( url )
+    , m_proxy( track )
+    , m_server( server )
+    , m_sessionId( sessionId )
+    , m_service( service )
 {
 }
 
@@ -150,8 +157,6 @@ AmpacheTrackForUrlWorker::~AmpacheTrackForUrlWorker()
 void
 AmpacheTrackForUrlWorker::run()
 {
-    // DEBUG_BLOCK;
-
     m_urlTrack = 0;
     m_urlAlbum = 0;
     m_urlArtist = 0;
@@ -162,9 +167,9 @@ AmpacheTrackForUrlWorker::run()
 
     //send url_to_song to Ampache
 
-    QString requestUrl = QString( "%1/server/xml.server.php?action=url_to_song&auth=%2&url=%3")
-    . arg(  m_server,  m_sessionId,  QUrl::toPercentEncoding( mUrl.url() ) );
-    //     debug() << "request url: " << requestUrl;
+    QString requestUrl =
+            QString( "%1/server/xml.server.php?action=url_to_song&auth=%2&url=%3" )
+                    .arg( m_server, m_sessionId, QUrl::toPercentEncoding( m_url.url() ) );
 
     QNetworkRequest req( requestUrl );
     QNetworkReply *reply = The::networkAccessManager()->get( req );
@@ -178,7 +183,7 @@ AmpacheTrackForUrlWorker::run()
         }
     }
     parseTrack( reply->readAll() );
-    mTrack = Meta::TrackPtr( m_urlTrack );
-    mProxy->updateTrack( mTrack );
+    m_track = Meta::TrackPtr( m_urlTrack );
+    m_proxy->updateTrack( m_track );
     reply->deleteLater();
 }
