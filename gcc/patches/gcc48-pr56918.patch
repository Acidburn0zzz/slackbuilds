From c2c5592fe70ed3ea0e958bebffaec35d674abe15 Mon Sep 17 00:00:00 2001
From: jakub <jakub@138bc75d-0d04-0410-961f-82ee72b054a4>
Date: Fri, 12 Apr 2013 08:38:29 +0000
Subject: [PATCH] 	PR tree-optimization/56918
 	PR tree-optimization/56920
 	* fold-const.c (int_const_binop_1): Use op1.mul_with_sign (op2, ...)
 	instead of op1 - op2.  Pass 2 * TYPE_PRECISION (type) as second
 	argument to rshift method.

	* gcc.dg/vect/pr56918.c: New test.
	* gcc.dg/vect/pr56920.c: New test.


git-svn-id: svn+ssh://gcc.gnu.org/svn/gcc/branches/gcc-4_8-branch@197847 138bc75d-0d04-0410-961f-82ee72b054a4
---
 gcc/ChangeLog                       |    8 ++++++++
 gcc/fold-const.c                    |   13 +++++++++----
 gcc/testsuite/ChangeLog             |    7 +++++++
 gcc/testsuite/gcc.dg/vect/pr56918.c |   31 +++++++++++++++++++++++++++++++
 gcc/testsuite/gcc.dg/vect/pr56920.c |   21 +++++++++++++++++++++
 5 files changed, 76 insertions(+), 4 deletions(-)
 create mode 100644 gcc/testsuite/gcc.dg/vect/pr56918.c
 create mode 100644 gcc/testsuite/gcc.dg/vect/pr56920.c

diff --git a/gcc/ChangeLog b/gcc/ChangeLog
index 6fbc1bb..111c0a0 100644
--- a/gcc/ChangeLog
+++ b/gcc/ChangeLog
@@ -1,3 +1,11 @@
+2013-04-12  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/56918
+	PR tree-optimization/56920
+	* fold-const.c (int_const_binop_1): Use op1.mul_with_sign (op2, ...)
+	instead of op1 - op2.  Pass 2 * TYPE_PRECISION (type) as second
+	argument to rshift method.
+
 2013-04-12  Andreas Krebbel  <Andreas.Krebbel@de.ibm.com>
 
 	* ifcvt.c (end_ifcvt_sequence): Mark a and b for unsharing as
diff --git a/gcc/fold-const.c b/gcc/fold-const.c
index 18ec9bb..055e9bb 100644
--- a/gcc/fold-const.c
+++ b/gcc/fold-const.c
@@ -984,12 +984,17 @@ int_const_binop_1 (enum tree_code code, const_tree arg1, const_tree arg2,
       break;
 
     case MULT_HIGHPART_EXPR:
-      /* ??? Need quad precision, or an additional shift operand
-	 to the multiply primitive, to handle very large highparts.  */
       if (TYPE_PRECISION (type) > HOST_BITS_PER_WIDE_INT)
 	return NULL_TREE;
-      tmp = op1 - op2;
-      res = tmp.rshift (TYPE_PRECISION (type), TYPE_PRECISION (type), !uns);
+      else
+	{
+	  bool dummy_overflow;
+	  /* MULT_HIGHPART_EXPR can't ever oveflow, as the multiplication
+	     is performed in twice the precision of arguments.  */
+	  tmp = op1.mul_with_sign (op2, false, &dummy_overflow);
+	  res = tmp.rshift (TYPE_PRECISION (type),
+			    2 * TYPE_PRECISION (type), !uns);
+	}
       break;
 
     case TRUNC_DIV_EXPR:
diff --git a/gcc/testsuite/ChangeLog b/gcc/testsuite/ChangeLog
index 1bbcdb8..11d8ef0 100644
--- a/gcc/testsuite/ChangeLog
+++ b/gcc/testsuite/ChangeLog
@@ -1,3 +1,10 @@
+2013-04-12  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/56918
+	PR tree-optimization/56920
+	* gcc.dg/vect/pr56918.c: New test.
+	* gcc.dg/vect/pr56920.c: New test.
+
 2013-04-11  Jakub Jelinek  <jakub@redhat.com>
 
 	PR c++/56895
diff --git a/gcc/testsuite/gcc.dg/vect/pr56918.c b/gcc/testsuite/gcc.dg/vect/pr56918.c
new file mode 100644
index 0000000..581faa0
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/vect/pr56918.c
@@ -0,0 +1,31 @@
+/* PR tree-optimization/56918 */
+/* { dg-additional-options "-O3" } */
+
+#include "tree-vect.h"
+
+extern void abort (void);
+double data[8];
+
+__attribute__((noinline, noclone)) void
+foo ()
+{
+  int i;
+  for (i = 0; i < 8; ++i)
+    data[i] = ((i + 2) % 3) + 1;
+}
+
+int
+main ()
+{
+  int i;
+  check_vect ();
+  foo ();
+  if (data[0] != 3 || data[7] != 1)
+    abort ();
+  for (i = 1; i < 4; ++i)
+    if (data[i] != i || data[i + 3] != i)
+      abort ();
+  return 0;
+}
+
+/* { dg-final { cleanup-tree-dump "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/pr56920.c b/gcc/testsuite/gcc.dg/vect/pr56920.c
new file mode 100644
index 0000000..c6c7cca
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/vect/pr56920.c
@@ -0,0 +1,21 @@
+/* PR tree-optimization/56920 */
+/* { dg-additional-options "-O3" } */
+
+#include "tree-vect.h"
+
+extern void abort (void);
+
+int
+main ()
+{
+  unsigned int a[15], i;
+  check_vect ();
+  for (i = 0; i < 15; ++i)
+    a[i] = (i * 2) % 15;
+  for (i = 0; i < 15; ++i)
+    if (a[i] != (i * 2) % 15)
+      abort ();
+  return 0;
+}
+
+/* { dg-final { cleanup-tree-dump "vect" } } */
-- 
1.7.1

