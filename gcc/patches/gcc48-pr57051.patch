From aa20a0b101bfe59490a51c8fa20cd5407a46e47f Mon Sep 17 00:00:00 2001
From: jakub <jakub@138bc75d-0d04-0410-961f-82ee72b054a4>
Date: Fri, 17 May 2013 08:52:36 +0000
Subject: [PATCH] 	PR tree-optimization/57051
 	* fold-const.c (const_binop) <case VEC_LSHIFT_EXPR,
 	case VEC_RSHIFT_EXPR>: Fix BYTES_BIG_ENDIAN handling.

git-svn-id: svn+ssh://gcc.gnu.org/svn/gcc/branches/gcc-4_8-branch@199004 138bc75d-0d04-0410-961f-82ee72b054a4
---
 gcc/ChangeLog    |    6 ++++++
 gcc/fold-const.c |    6 +++++-
 2 files changed, 11 insertions(+), 1 deletions(-)

diff --git a/gcc/ChangeLog b/gcc/ChangeLog
index 4612d9f..782f08e 100644
--- a/gcc/ChangeLog
+++ b/gcc/ChangeLog
@@ -1,3 +1,9 @@
+2013-05-17  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/57051
+	* fold-const.c (const_binop) <case VEC_LSHIFT_EXPR,
+	case VEC_RSHIFT_EXPR>: Fix BYTES_BIG_ENDIAN handling.
+
 2013-05-16  Jakub Jelinek  <jakub@redhat.com>
 
 	* omp-low.c (extract_omp_for_data): For collapsed loops,
diff --git a/gcc/fold-const.c b/gcc/fold-const.c
index a2e9632..5e34863 100644
--- a/gcc/fold-const.c
+++ b/gcc/fold-const.c
@@ -1388,7 +1388,11 @@ const_binop (enum tree_code code, tree arg1, tree arg2)
 	  if (shiftc >= outerc || (shiftc % innerc) != 0)
 	    return NULL_TREE;
 	  int offset = shiftc / innerc;
-	  if (code == VEC_LSHIFT_EXPR)
+	  /* The direction of VEC_[LR]SHIFT_EXPR is endian dependent.
+	     For reductions, compiler emits VEC_RSHIFT_EXPR always,
+	     for !BYTES_BIG_ENDIAN picks first vector element, but
+	     for BYTES_BIG_ENDIAN last element from the vector.  */
+	  if ((code == VEC_RSHIFT_EXPR) ^ (!BYTES_BIG_ENDIAN))
 	    offset = -offset;
 	  tree zero = build_zero_cst (TREE_TYPE (type));
 	  for (i = 0; i < count; i++)
-- 
1.7.1

