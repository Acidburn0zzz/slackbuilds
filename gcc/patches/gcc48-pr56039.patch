From bd72df95d43db15b505ae81b9e68f3815fd04148 Mon Sep 17 00:00:00 2001
From: jason <jason@138bc75d-0d04-0410-961f-82ee72b054a4>
Date: Sat, 23 Mar 2013 00:48:39 +0000
Subject: [PATCH] 	PR c++/56039
 	* tree.c (strip_typedefs_expr): Complain about lambda, don't abort.

git-svn-id: svn+ssh://gcc.gnu.org/svn/gcc/branches/gcc-4_8-branch@196991 138bc75d-0d04-0410-961f-82ee72b054a4
---
 gcc/cp/tree.c                                      |    3 +-
 gcc/testsuite/g++.dg/cpp0x/lambda/lambda-sfinae1.C |   55 ++++++++++++++++++++
 3 files changed, 60 insertions(+), 1 deletions(-)
 create mode 100644 gcc/testsuite/g++.dg/cpp0x/lambda/lambda-sfinae1.C

diff --git a/gcc/cp/tree.c b/gcc/cp/tree.c
index 1b484b1..af4729a 100644
--- a/gcc/cp/tree.c
+++ b/gcc/cp/tree.c
@@ -1418,7 +1418,8 @@ strip_typedefs_expr (tree t)
       }
 
     case LAMBDA_EXPR:
-      gcc_unreachable ();
+      error ("lambda-expression in a constant expression");
+      return error_mark_node;
 
     default:
       break;
diff --git a/gcc/testsuite/g++.dg/cpp0x/lambda/lambda-sfinae1.C b/gcc/testsuite/g++.dg/cpp0x/lambda/lambda-sfinae1.C
new file mode 100644
index 0000000..973f8a7
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/lambda/lambda-sfinae1.C
@@ -0,0 +1,55 @@
+// PR c++/56039
+// { dg-do compile { target c++11 } }
+
+template <bool> struct BoolSink { typedef void type; };
+
+template <typename T, typename U>
+struct AddRvalueReferenceImpl { typedef T type; };
+
+template <typename T>
+struct AddRvalueReferenceImpl<T, typename BoolSink<false &&
+      [] {
+         extern T &&tref;
+      }>::type> {		// { dg-error "lambda" }
+   typedef T &&type;
+};
+
+template <typename T>
+struct AddRvalueReference : AddRvalueReferenceImpl<T, void> { };
+
+namespace ImplHelpers {
+   template <typename T>
+   typename AddRvalueReference<T>::type create(void) { }
+}
+
+template <typename T, typename U, typename ...Args>
+struct IsConstructibleImpl { enum { value = 0 }; };
+
+template <typename T, typename ...Args>
+struct IsConstructibleImpl<T, typename BoolSink<false &&
+      [] {
+         T t( ::ImplHelpers::create<Args>() ...);
+      }>::type, Args ...> {	// { dg-error "lambda" }
+   enum { value = 1 };
+};
+
+template <typename T, typename ...Args>
+struct IsConstructible : IsConstructibleImpl<T, void, Args ...> { };
+
+struct DestroyMe {
+   ~DestroyMe() = delete;
+};
+
+static_assert(+IsConstructible<int>::value, "error");
+static_assert(!IsConstructible<void>::value, "error");
+static_assert(+IsConstructible<int [1]>::value, "error");
+static_assert(!IsConstructible<DestroyMe>::value, "error");
+static_assert(!IsConstructible<int *, char *>::value, "error");
+
+static_assert(+IsConstructible<int &&, int>::value, "error");
+static_assert(!IsConstructible<int &&, int &>::value, "error");
+static_assert(+IsConstructible<int &&, int &&>::value, "error");
+
+// { dg-prune-output "expected" }
+// { dg-prune-output "does not name a class" }
+// { dg-prune-output "static assertion" }
-- 
1.7.1

